From 322a45d7fe6eef0bbdc76e8bb77daab29b96e619 Mon Sep 17 00:00:00 2001
From: Broadcom Wiced <broadcom_wiced@broadcom.local>
Date: Mon, 25 Sep 2017 15:48:55 -0700
Subject: [PATCH 1/6] v0.10.0+dev

Merged from commit hash:
fa13b45eecd274dbd09e0c174b91dbf6cb5b26f9

upstream ref http://repo.or.cz/r/openocd.git
---
 .gitignore                                         |    3 +-
 Makefile.am                                        |   70 +-
 NEWS-0.10.0                                        |  155 +
 NEWTAPS                                            |    2 +-
 README                                             |   59 +-
 README.Windows                                     |    5 +-
 TODO                                               |    7 +-
 bootstrap                                          |    7 +
 common.mk                                          |   19 -
 configure.ac                                       | 1169 ++----
 contrib/60-openocd.rules                           |  145 +
 contrib/99-openocd.rules                           |  128 -
 contrib/loaders/Makefile                           |   34 +
 contrib/loaders/checksum/Makefile                  |   30 +
 contrib/loaders/checksum/armv4_5_crc.inc           |    7 +
 contrib/loaders/checksum/armv7m_crc.inc            |    5 +
 contrib/loaders/debug/xscale/Makefile              |   33 +
 .../loaders/debug}/xscale/debug_handler.S          |    4 +-
 contrib/loaders/debug/xscale/debug_handler.inc     |  101 +
 .../loaders/debug/xscale/debug_handler.ld          |    0
 .../loaders/debug}/xscale/protocol.h               |    4 +-
 contrib/loaders/erase_check/Makefile               |   30 +
 .../loaders/erase_check/armv4_5_erase_check.inc    |    3 +
 contrib/loaders/erase_check/armv4_5_erase_check.s  |    2 -
 .../loaders/erase_check/armv7m_0_erase_check.inc   |    2 +
 contrib/loaders/erase_check/armv7m_erase_check.inc |    2 +
 contrib/loaders/flash/cortex-m0.S                  |    4 +-
 contrib/loaders/flash/efm32.S                      |    4 -
 contrib/loaders/flash/fm4/Makefile                 |   32 +
 contrib/loaders/flash/fm4/erase.S                  |   77 +
 contrib/loaders/flash/fm4/erase.inc                |    7 +
 contrib/loaders/flash/fm4/fm4.h                    |   19 +
 contrib/loaders/flash/fm4/write.S                  |   85 +
 contrib/loaders/flash/fm4/write.inc                |    7 +
 contrib/loaders/flash/fpga/xilinx_bscan_spi.py     |  314 +-
 contrib/loaders/flash/kinetis/Makefile             |   19 +
 contrib/loaders/flash/kinetis/kinetis_flash.inc    |    6 +
 contrib/loaders/flash/kinetis/kinetis_flash.s      |  101 +
 contrib/loaders/flash/kinetis_ke/Makefile          |   21 +
 .../loaders/flash/kinetis_ke/kinetis_ke_flash.inc  |   15 +
 .../loaders/flash/kinetis_ke/kinetis_ke_flash.s    |  184 +
 .../flash/kinetis_ke/kinetis_ke_watchdog.inc       |    4 +
 .../loaders/flash/kinetis_ke/kinetis_ke_watchdog.s |   47 +
 contrib/loaders/flash/stm32l4x.S                   |   29 +-
 contrib/loaders/flash/stm32lx.S                    |   32 +-
 contrib/loaders/flash/xmc1xxx/Makefile             |   32 +
 contrib/loaders/flash/xmc1xxx/erase.S              |   53 +
 contrib/loaders/flash/xmc1xxx/erase.inc            |    4 +
 contrib/loaders/flash/xmc1xxx/erase_check.S        |   67 +
 contrib/loaders/flash/xmc1xxx/erase_check.inc      |    5 +
 contrib/loaders/flash/xmc1xxx/write.S              |   58 +
 contrib/loaders/flash/xmc1xxx/write.inc            |    4 +
 contrib/loaders/flash/xmc1xxx/xmc1xxx.S            |   46 +
 contrib/loaders/watchdog/Makefile                  |   21 +
 contrib/loaders/watchdog/armv7m_kinetis_wdog.inc   |    3 +
 contrib/loaders/watchdog/armv7m_kinetis_wdog.s     |   63 +
 contrib/loaders/watchdog/armv7m_kinetis_wdog32.inc |    5 +
 contrib/loaders/watchdog/armv7m_kinetis_wdog32.s   |   80 +
 contrib/rtos-helpers/FreeRTOS-openocd.c            |    2 +-
 contrib/rtos-helpers/uCOS-III-openocd.c            |   32 +
 doc/INSTALL.txt                                    |  204 -
 doc/Makefile.am                                    |   22 +-
 doc/manual/release.txt                             |    2 +-
 doc/manual/style.txt                               |   19 +
 doc/openocd.texi                                   |  763 +++-
 jimtcl                                             |    2 +-
 src/Makefile.am                                    |  131 +-
 src/flash/Makefile.am                              |   30 +-
 src/flash/common.c                                 |    4 +-
 src/flash/common.h                                 |   11 +-
 src/flash/mflash.c                                 |   36 +-
 src/flash/mflash.h                                 |   10 +-
 src/flash/nand/Makefile.am                         |   79 +-
 src/flash/nand/arm_io.c                            |    4 +-
 src/flash/nand/arm_io.h                            |   10 +-
 src/flash/nand/at91sam9.c                          |    4 +-
 src/flash/nand/core.c                              |    4 +-
 src/flash/nand/core.h                              |   12 +-
 src/flash/nand/davinci.c                           |    4 +-
 src/flash/nand/driver.c                            |    4 +-
 src/flash/nand/driver.h                            |   10 +-
 src/flash/nand/ecc.c                               |    5 +-
 src/flash/nand/ecc_kw.c                            |    3 +
 src/flash/nand/fileio.c                            |   14 +-
 src/flash/nand/fileio.h                            |   12 +-
 src/flash/nand/imp.h                               |   10 +-
 src/flash/nand/lpc3180.c                           |    4 +-
 src/flash/nand/lpc3180.h                           |   10 +-
 src/flash/nand/lpc32xx.c                           |    4 +-
 src/flash/nand/lpc32xx.h                           |   10 +-
 src/flash/nand/mx3.c                               |    5 +-
 src/flash/nand/mx3.h                               |    9 +-
 src/flash/nand/mxc.c                               |    4 +-
 src/flash/nand/mxc.h                               |   10 +-
 src/flash/nand/nonce.c                             |    4 +-
 src/flash/nand/nuc910.c                            |    4 +-
 src/flash/nand/nuc910.h                            |   11 +-
 src/flash/nand/orion.c                             |    4 +-
 src/flash/nand/s3c2410.c                           |    4 +-
 src/flash/nand/s3c2412.c                           |    4 +-
 src/flash/nand/s3c2440.c                           |    4 +-
 src/flash/nand/s3c2443.c                           |    4 +-
 src/flash/nand/s3c24xx.c                           |    4 +-
 src/flash/nand/s3c24xx.h                           |   10 +-
 src/flash/nand/s3c24xx_regs.h                      |   11 +-
 src/flash/nand/s3c6400.c                           |    4 +-
 src/flash/nand/tcl.c                               |   18 +-
 src/flash/nor/Makefile.am                          |  125 +-
 src/flash/nor/aduc702x.c                           |    6 +-
 src/flash/nor/aducm360.c                           |    4 +-
 src/flash/nor/ambiqmicro.c                         |  904 ++++
 src/flash/nor/at91sam3.c                           |   16 +-
 src/flash/nor/at91sam4.c                           |  862 +++-
 src/flash/nor/at91sam4l.c                          |   17 +-
 src/flash/nor/at91sam7.c                           |   34 +-
 src/flash/nor/at91samd.c                           |  232 +-
 src/flash/nor/ath79.c                              |  901 ++++
 src/flash/nor/atsamv.c                             |   15 +-
 src/flash/nor/avrf.c                               |    5 +-
 src/flash/nor/cfi.c                                |  161 +-
 src/flash/nor/cfi.h                                |   13 +-
 src/flash/nor/core.c                               |   74 +-
 src/flash/nor/core.h                               |   38 +-
 src/flash/nor/driver.h                             |   10 +-
 src/flash/nor/drivers.c                            |  128 +-
 src/flash/nor/dsp5680xx_flash.c                    |    4 +-
 src/flash/nor/efm32.c                              |  168 +-
 src/flash/nor/em357.c                              |   10 +-
 src/flash/nor/faux.c                               |    6 +-
 src/flash/nor/fm3.c                                |    4 +-
 src/flash/nor/fm4.c                                |  722 ++++
 src/flash/nor/imp.h                                |   10 +-
 src/flash/nor/jtagspi.c                            |   16 +-
 src/flash/nor/kinetis.c                            | 2913 +++++++++----
 src/flash/nor/kinetis_ke.c                         | 1314 ++++++
 src/flash/nor/lpc2000.c                            |   21 +-
 src/flash/nor/lpc288x.c                            |    4 +-
 src/flash/nor/lpc2900.c                            |   13 +-
 src/flash/nor/lpcspifi.c                           |   55 +-
 src/flash/nor/mdr.c                                |  114 +-
 src/flash/nor/mrvlqspi.c                           |    9 +-
 src/flash/nor/niietcm4.c                           |   81 +-
 src/flash/nor/non_cfi.c                            |    5 +-
 src/flash/nor/non_cfi.h                            |   10 +-
 src/flash/nor/{nrf51.c => nrf5.c}                  |  795 ++--
 src/flash/nor/numicro.c                            |    3 +
 src/flash/nor/ocl.c                                |    4 +-
 src/flash/nor/ocl.h                                |   10 +-
 src/flash/nor/pic32mx.c                            |  105 +-
 src/flash/nor/psoc4.c                              |    9 +-
 src/flash/nor/sim3x.c                              |    7 +-
 src/flash/nor/spi.c                                |   20 +-
 src/flash/nor/spi.h                                |    9 +-
 src/flash/nor/stellaris.c                          |   10 +-
 src/flash/nor/stm32f1x.c                           |    8 +-
 src/flash/nor/stm32f2x.c                           |  631 ++-
 src/flash/nor/stm32l4x.c                           |   81 +-
 src/flash/nor/stm32lx.c                            |  371 +-
 src/flash/nor/stmsmi.c                             |    8 +-
 src/flash/nor/str7x.c                              |    6 +-
 src/flash/nor/str9x.c                              |    6 +-
 src/flash/nor/str9xpec.c                           |    4 +-
 src/flash/nor/tcl.c                                |  257 +-
 src/flash/nor/tms470.c                             |    4 +-
 src/flash/nor/virtual.c                            |    5 +-
 src/flash/nor/xmc1xxx.c                            |  549 +++
 src/flash/nor/xmc4xxx.c                            |  143 +-
 src/hello.c                                        |    4 +-
 src/hello.h                                        |    6 +-
 src/helper/Makefile.am                             |   83 +-
 src/helper/binarybuffer.c                          |   80 +-
 src/helper/binarybuffer.h                          |   14 +-
 src/helper/command.c                               |   12 +-
 src/helper/command.h                               |   24 +-
 src/helper/configuration.c                         |    4 +-
 src/helper/configuration.h                         |   10 +-
 src/helper/fileio.c                                |  133 +-
 src/helper/fileio.h                                |   19 +-
 src/helper/ioutil.c                                |  115 +-
 src/helper/ioutil.h                                |   10 +-
 src/helper/ioutil_stubs.c                          |    4 +-
 src/helper/jep106.c                                |   44 +
 src/helper/jep106.h                                |   32 +
 src/helper/jep106.inc                              | 1156 ++++++
 src/helper/jim-nvp.c                               |    5 +-
 src/helper/jim-nvp.h                               |    8 +-
 src/helper/list.h                                  |    6 +-
 src/helper/log.c                                   |   83 +-
 src/helper/log.h                                   |   29 +-
 src/helper/options.c                               |  178 +-
 src/helper/replacements.c                          |    4 +-
 src/helper/replacements.h                          |   10 +-
 src/helper/system.h                                |   10 +-
 src/helper/time_support.c                          |    8 +-
 src/helper/time_support.h                          |   14 +-
 src/helper/time_support_common.c                   |    6 +-
 src/helper/types.h                                 |   41 +-
 src/helper/update_jep106.pl                        |   35 +
 src/helper/util.c                                  |    4 +-
 src/helper/util.h                                  |   10 +-
 src/jtag/Makefile.am                               |   96 +-
 src/jtag/adapter.c                                 |    4 +-
 src/jtag/aice/Makefile.am                          |   41 +-
 src/jtag/aice/aice_interface.c                     |    4 +-
 src/jtag/aice/aice_interface.h                     |   11 +-
 src/jtag/aice/aice_pipe.c                          |   10 +-
 src/jtag/aice/aice_pipe.h                          |   11 +-
 src/jtag/aice/aice_port.c                          |    4 +-
 src/jtag/aice/aice_port.h                          |   13 +-
 src/jtag/aice/aice_transport.c                     |   14 +-
 src/jtag/aice/aice_transport.h                     |   10 +-
 src/jtag/aice/aice_usb.c                           |   22 +-
 src/jtag/aice/aice_usb.h                           |   11 +-
 src/jtag/commands.c                                |    4 +-
 src/jtag/commands.h                                |   10 +-
 src/jtag/core.c                                    |   14 +-
 src/jtag/driver.h                                  |   10 +-
 src/jtag/drivers/Makefile.am                       |  211 +-
 src/jtag/drivers/Makefile.rlink                    |    4 +-
 src/jtag/drivers/OpenULINK/Makefile                |    4 +-
 src/jtag/drivers/OpenULINK/include/common.h        |    4 +-
 src/jtag/drivers/OpenULINK/include/delay.h         |    4 +-
 src/jtag/drivers/OpenULINK/include/io.h            |    4 +-
 src/jtag/drivers/OpenULINK/include/jtag.h          |    4 +-
 src/jtag/drivers/OpenULINK/include/main.h          |    4 +-
 src/jtag/drivers/OpenULINK/include/msgtypes.h      |    4 +-
 src/jtag/drivers/OpenULINK/include/protocol.h      |    4 +-
 src/jtag/drivers/OpenULINK/include/reg_ezusb.h     |    4 +-
 src/jtag/drivers/OpenULINK/include/usb.h           |    4 +-
 src/jtag/drivers/OpenULINK/src/USBJmpTb.a51        |    4 +-
 src/jtag/drivers/OpenULINK/src/delay.c             |    4 +-
 src/jtag/drivers/OpenULINK/src/jtag.c              |    4 +-
 src/jtag/drivers/OpenULINK/src/main.c              |    4 +-
 src/jtag/drivers/OpenULINK/src/protocol.c          |    4 +-
 src/jtag/drivers/OpenULINK/src/usb.c               |    4 +-
 src/jtag/drivers/amt_jtagaccel.c                   |    4 +-
 src/jtag/drivers/arm-jtag-ew.c                     |    4 +-
 src/jtag/drivers/at91rm9200.c                      |    4 +-
 src/jtag/drivers/bcm2835gpio.c                     |    8 +-
 src/jtag/drivers/bitbang.c                         |    4 +-
 src/jtag/drivers/bitbang.h                         |   10 +-
 src/jtag/drivers/bitq.c                            |    4 +-
 src/jtag/drivers/bitq.h                            |   10 +-
 src/jtag/drivers/buspirate.c                       |    4 +-
 src/jtag/drivers/cmsis_dap_usb.c                   |  589 ++-
 src/jtag/drivers/driver.c                          |    4 +-
 src/jtag/drivers/dummy.c                           |    4 +-
 src/jtag/drivers/ep93xx.c                          |    4 +-
 src/jtag/drivers/ft2232.c                          | 4378 --------------------
 src/jtag/drivers/ftd2xx_common.h                   |   57 -
 src/jtag/drivers/ftdi.c                            |  169 +-
 src/jtag/drivers/gw16012.c                         |    4 +-
 src/jtag/drivers/imx_gpio.c                        |  552 +++
 src/jtag/drivers/jlink.c                           |  751 ++--
 src/jtag/drivers/jtag_vpi.c                        |    2 +
 src/jtag/drivers/kitprog.c                         |  968 +++++
 src/jtag/drivers/libjaylink                        |    2 +-
 src/jtag/drivers/libusb0_common.c                  |    9 +-
 src/jtag/drivers/libusb0_common.h                  |   12 +-
 src/jtag/drivers/libusb1_common.c                  |    8 +-
 src/jtag/drivers/libusb1_common.h                  |   13 +-
 src/jtag/drivers/libusb_common.h                   |   13 +-
 src/jtag/drivers/minidriver_imp.h                  |   11 +-
 src/jtag/drivers/mpsse.c                           |  105 +-
 src/jtag/drivers/mpsse.h                           |   12 +-
 src/jtag/drivers/opendous.c                        |    4 +-
 src/jtag/drivers/openjtag.c                        |  428 +-
 src/jtag/drivers/osbdm.c                           |    4 +-
 src/jtag/drivers/parport.c                         |    4 +-
 src/jtag/drivers/presto.c                          |  223 +-
 src/jtag/drivers/remote_bitbang.c                  |    4 +-
 src/jtag/drivers/rlink.c                           |    4 +-
 src/jtag/drivers/rlink.h                           |    9 +-
 src/jtag/drivers/rlink_call.m4                     |    4 +-
 src/jtag/drivers/rlink_dtc_cmd.h                   |    9 +-
 src/jtag/drivers/rlink_ep1_cmd.h                   |    9 +-
 src/jtag/drivers/rlink_init.m4                     |    4 +-
 src/jtag/drivers/rlink_st7.h                       |    9 +-
 src/jtag/drivers/stlink_usb.c                      |   50 +-
 src/jtag/drivers/sysfsgpio.c                       |    4 +-
 src/jtag/drivers/ti_icdi_usb.c                     |   15 +-
 src/jtag/drivers/ulink.c                           |   12 +-
 src/jtag/drivers/usb_blaster/Makefile.am           |   25 +-
 .../drivers/usb_blaster/ublast2_access_libusb.c    |    3 +
 src/jtag/drivers/usb_blaster/ublast_access.h       |   16 +-
 .../drivers/usb_blaster/ublast_access_ftd2xx.c     |  177 -
 src/jtag/drivers/usb_blaster/ublast_access_ftdi.c  |    3 +
 src/jtag/drivers/usb_blaster/usb_blaster.c         |   12 +-
 src/jtag/drivers/usb_common.c                      |    4 +-
 src/jtag/drivers/usb_common.h                      |   10 +-
 src/jtag/drivers/usbprog.c                         |    4 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c    |    4 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c |    4 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c     |    4 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c     |    4 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c     |    4 +-
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h     |   10 +-
 .../drivers/versaloon/usbtoxxx/usbtoxxx_internal.h |   10 +-
 src/jtag/drivers/versaloon/versaloon.c             |    4 +-
 src/jtag/drivers/versaloon/versaloon.h             |   11 +-
 src/jtag/drivers/versaloon/versaloon_include.h     |    9 +-
 src/jtag/drivers/versaloon/versaloon_internal.h    |   10 +-
 src/jtag/drivers/vsllink.c                         |    4 +-
 src/jtag/hla/Makefile.am                           |   34 +-
 src/jtag/hla/hla_interface.c                       |    4 +-
 src/jtag/hla/hla_interface.h                       |   10 +-
 src/jtag/hla/hla_layout.c                          |    4 +-
 src/jtag/hla/hla_layout.h                          |   10 +-
 src/jtag/hla/hla_tcl.c                             |   14 +-
 src/jtag/hla/hla_tcl.h                             |   10 +-
 src/jtag/hla/hla_transport.c                       |    4 +-
 src/jtag/hla/hla_transport.h                       |   10 +-
 src/jtag/interface.c                               |    4 +-
 src/jtag/interface.h                               |    4 +-
 src/jtag/interfaces.c                              |   36 +-
 src/jtag/interfaces.h                              |    4 +-
 src/jtag/jtag.h                                    |   12 +-
 src/jtag/minidriver.h                              |   10 +-
 src/jtag/minidriver/minidriver_imp.h               |   10 +-
 src/jtag/minidummy/jtag_minidriver.h               |    4 +-
 src/jtag/minidummy/minidummy.c                     |    4 +-
 src/jtag/swd.h                                     |   10 +-
 src/jtag/tcl.c                                     |   16 +-
 src/jtag/tcl.h                                     |   10 +-
 src/jtag/zy1000/jtag_minidriver.h                  |    4 +-
 src/jtag/zy1000/zy1000.c                           |   10 +-
 src/main.c                                         |    4 +-
 src/openocd.c                                      |   13 +-
 src/openocd.h                                      |   10 +-
 src/pld/Makefile.am                                |   16 +-
 src/pld/pld.c                                      |    4 +-
 src/pld/pld.h                                      |   10 +-
 src/pld/virtex2.c                                  |    4 +-
 src/pld/virtex2.h                                  |   10 +-
 src/pld/xilinx_bit.c                               |    4 +-
 src/pld/xilinx_bit.h                               |   10 +-
 src/rtos/ChibiOS.c                                 |   27 +-
 src/rtos/FreeRTOS.c                                |   62 +-
 src/rtos/Makefile.am                               |   56 +-
 src/rtos/ThreadX.c                                 |   13 +-
 src/rtos/eCos.c                                    |   11 +-
 src/rtos/embKernel.c                               |   11 +-
 src/rtos/linux.c                                   |   17 +-
 src/rtos/linux_header.h                            |    5 +
 src/rtos/mqx.c                                     |   16 +-
 src/rtos/rtos.c                                    |   64 +-
 src/rtos/rtos.h                                    |   11 +-
 src/rtos/rtos_chibios_stackings.c                  |    4 +-
 src/rtos/rtos_chibios_stackings.h                  |   10 +-
 src/rtos/rtos_ecos_stackings.c                     |    4 +-
 src/rtos/rtos_ecos_stackings.h                     |   10 +-
 src/rtos/rtos_embkernel_stackings.c                |    4 +-
 src/rtos/rtos_embkernel_stackings.h                |   10 +-
 src/rtos/rtos_mqx_stackings.c                      |    3 +-
 src/rtos/rtos_mqx_stackings.h                      |   10 +-
 src/rtos/rtos_standard_stackings.c                 |  203 +-
 src/rtos/rtos_standard_stackings.h                 |   12 +-
 src/rtos/rtos_ucos_iii_stackings.c                 |   54 +
 src/rtos/rtos_ucos_iii_stackings.h                 |   30 +
 src/rtos/uCOS-III.c                                |  511 +++
 src/server/Makefile.am                             |   32 +-
 src/server/gdb_server.c                            |  227 +-
 src/server/gdb_server.h                            |   10 +-
 src/server/server.c                                |   99 +-
 src/server/server.h                                |   10 +-
 src/server/server_stubs.c                          |    4 +-
 src/server/tcl_server.c                            |    6 +-
 src/server/tcl_server.h                            |   10 +-
 src/server/telnet_server.c                         |   39 +-
 src/server/telnet_server.h                         |   17 +-
 src/svf/Makefile.am                                |   10 +-
 src/svf/svf.c                                      |   10 +-
 src/svf/svf.h                                      |   10 +-
 src/target/Makefile.am                             |  341 +-
 src/target/aarch64.c                               | 2452 +++++++++++
 src/target/aarch64.h                               |   69 +
 src/target/adi_v5_jtag.c                           |  620 ++-
 src/target/adi_v5_swd.c                            |   97 +-
 src/target/algorithm.c                             |    4 +-
 src/target/algorithm.h                             |   12 +-
 src/target/arm.h                                   |   49 +-
 src/target/arm11.c                                 |   97 +-
 src/target/arm11.h                                 |   10 +-
 src/target/arm11_dbgtap.c                          |   14 +-
 src/target/arm11_dbgtap.h                          |   10 +-
 src/target/arm720t.c                               |   14 +-
 src/target/arm720t.h                               |   10 +-
 src/target/arm7_9_common.c                         |   56 +-
 src/target/arm7_9_common.h                         |   26 +-
 src/target/arm7tdmi.c                              |    7 +-
 src/target/arm7tdmi.h                              |   10 +-
 src/target/arm920t.c                               |   18 +-
 src/target/arm920t.h                               |   14 +-
 src/target/arm926ejs.c                             |   20 +-
 src/target/arm926ejs.h                             |   12 +-
 src/target/arm946e.c                               |    8 +-
 src/target/arm946e.h                               |   10 +-
 src/target/arm966e.c                               |    4 +-
 src/target/arm966e.h                               |   10 +-
 src/target/arm9tdmi.c                              |    6 +-
 src/target/arm9tdmi.h                              |   10 +-
 src/target/arm_adi_v5.c                            |  913 ++--
 src/target/arm_adi_v5.h                            |   63 +-
 src/target/arm_cti.c                               |  148 +
 src/target/arm_cti.h                               |   73 +
 src/target/arm_disassembler.c                      |    7 +-
 src/target/arm_disassembler.h                      |   10 +-
 src/target/arm_dpm.c                               |   97 +-
 src/target/arm_dpm.h                               |   82 +-
 src/target/arm_jtag.c                              |    4 +-
 src/target/arm_jtag.h                              |   10 +-
 src/target/arm_opcodes.h                           |   11 +-
 src/target/arm_semihosting.c                       |  545 ++-
 src/target/arm_semihosting.h                       |   11 +-
 src/target/arm_simulator.c                         |    4 +-
 src/target/arm_simulator.h                         |   10 +-
 src/target/armv4_5.c                               |  220 +-
 src/target/armv4_5.h                               |   10 +-
 src/target/armv4_5_cache.c                         |    4 +-
 src/target/armv4_5_cache.h                         |   10 +-
 src/target/armv4_5_mmu.c                           |    4 +-
 src/target/armv4_5_mmu.h                           |   15 +-
 src/target/armv7a.c                                |   37 +-
 src/target/armv7a.h                                |   26 +-
 src/target/armv7a_cache.c                          |    3 +
 src/target/armv7a_cache.h                          |    9 +-
 src/target/armv7a_cache_l2x.c                      |   49 +-
 src/target/armv7a_cache_l2x.h                      |   11 +-
 src/target/armv7m.c                                |   98 +-
 src/target/armv7m.h                                |   22 +-
 src/target/armv7m_trace.c                          |    3 +
 src/target/armv7m_trace.h                          |    9 +-
 src/target/armv8.c                                 | 1308 ++++++
 src/target/armv8.h                                 |  282 ++
 src/target/armv8_cache.c                           |  423 ++
 src/target/armv8_cache.h                           |   26 +
 src/target/armv8_dpm.c                             | 1472 +++++++
 src/target/armv8_dpm.h                             |  122 +
 src/target/armv8_opcodes.c                         |   82 +
 src/target/armv8_opcodes.h                         |  189 +
 src/target/avr32_ap7k.c                            |   18 +-
 src/target/avr32_ap7k.h                            |   10 +-
 src/target/avr32_jtag.c                            |    4 +-
 src/target/avr32_jtag.h                            |   10 +-
 src/target/avr32_mem.c                             |    4 +-
 src/target/avr32_mem.h                             |   10 +-
 src/target/avr32_regs.c                            |    4 +-
 src/target/avr32_regs.h                            |   10 +-
 src/target/avrt.c                                  |   12 +-
 src/target/avrt.h                                  |   10 +-
 src/target/breakpoints.c                           |   49 +-
 src/target/breakpoints.h                           |   31 +-
 src/target/cortex_a.c                              |  430 +-
 src/target/cortex_a.h                              |   12 +-
 src/target/cortex_m.c                              |  165 +-
 src/target/cortex_m.h                              |   12 +-
 src/target/dsp563xx.c                              |   26 +-
 src/target/dsp563xx.h                              |   10 +-
 src/target/dsp563xx_once.c                         |    4 +-
 src/target/dsp563xx_once.h                         |   10 +-
 src/target/dsp5680xx.c                             |   22 +-
 src/target/dsp5680xx.h                             |   10 +-
 src/target/embeddedice.c                           |    4 +-
 src/target/embeddedice.h                           |   10 +-
 src/target/etb.c                                   |    4 +-
 src/target/etb.h                                   |   10 +-
 src/target/etm.c                                   |   44 +-
 src/target/etm.h                                   |   10 +-
 src/target/etm_dummy.c                             |    4 +-
 src/target/etm_dummy.h                             |   10 +-
 src/target/fa526.c                                 |    4 +-
 src/target/feroceon.c                              |   15 +-
 src/target/hla_target.c                            |   26 +-
 src/target/image.c                                 |   50 +-
 src/target/image.h                                 |   20 +-
 src/target/lakemont.c                              |   42 +-
 src/target/lakemont.h                              |   17 +-
 src/target/ls1_sap.c                               |  243 ++
 src/target/mips32.c                                |  186 +-
 src/target/mips32.h                                |  349 +-
 src/target/mips32_dmaacc.c                         |    4 +-
 src/target/mips32_dmaacc.h                         |   10 +-
 src/target/mips32_pracc.c                          |  681 ++-
 src/target/mips32_pracc.h                          |   40 +-
 src/target/mips_ejtag.c                            |  188 +-
 src/target/mips_ejtag.h                            |   25 +-
 src/target/mips_m4k.c                              |  229 +-
 src/target/mips_m4k.h                              |   21 +-
 src/target/nds32.c                                 |   31 +-
 src/target/nds32.h                                 |   24 +-
 src/target/nds32_aice.c                            |    8 +-
 src/target/nds32_aice.h                            |   15 +-
 src/target/nds32_cmd.c                             |   10 +-
 src/target/nds32_cmd.h                             |   11 +-
 src/target/nds32_disassembler.c                    |    4 +-
 src/target/nds32_disassembler.h                    |   10 +-
 src/target/nds32_edm.h                             |   11 +-
 src/target/nds32_insn.h                            |   11 +-
 src/target/nds32_reg.c                             |    4 +-
 src/target/nds32_reg.h                             |   11 +-
 src/target/nds32_tlb.c                             |   12 +-
 src/target/nds32_tlb.h                             |   19 +-
 src/target/nds32_v2.c                              |   30 +-
 src/target/nds32_v2.h                              |   12 +-
 src/target/nds32_v3.c                              |   12 +-
 src/target/nds32_v3.h                              |   11 +-
 src/target/nds32_v3_common.c                       |   26 +-
 src/target/nds32_v3_common.h                       |   25 +-
 src/target/nds32_v3m.c                             |   12 +-
 src/target/nds32_v3m.h                             |   12 +-
 src/target/oocd_trace.c                            |    4 +-
 src/target/oocd_trace.h                            |   10 +-
 src/target/openrisc/Makefile.am                    |   30 +-
 src/target/openrisc/jsp_server.c                   |    5 +-
 src/target/openrisc/jsp_server.h                   |    6 +-
 src/target/openrisc/or1k.c                         |   36 +-
 src/target/openrisc/or1k.h                         |    9 +-
 src/target/openrisc/or1k_du.h                      |   10 +-
 src/target/openrisc/or1k_du_adv.c                  |    3 +
 src/target/openrisc/or1k_tap.h                     |    9 +-
 src/target/openrisc/or1k_tap_mohor.c               |    3 +
 src/target/openrisc/or1k_tap_vjtag.c               |    3 +
 src/target/openrisc/or1k_tap_xilinx_bscan.c        |    3 +
 src/target/quark_d20xx.c                           |  115 +
 src/target/quark_x10xx.c                           |    6 +-
 src/target/register.c                              |    4 +-
 src/target/register.h                              |   25 +-
 src/target/smp.c                                   |    7 +-
 src/target/smp.h                                   |    8 +-
 src/target/startup.tcl                             |   14 +-
 src/target/target.c                                |  640 ++-
 src/target/target.h                                |   72 +-
 src/target/target_request.c                        |    4 +-
 src/target/target_request.h                        |   10 +-
 src/target/target_type.h                           |   46 +-
 src/target/testee.c                                |    4 +-
 src/target/trace.c                                 |    4 +-
 src/target/trace.h                                 |   10 +-
 src/target/x86_32_common.c                         |   98 +-
 src/target/x86_32_common.h                         |   27 +-
 src/target/xscale.c                                |   56 +-
 src/target/xscale.h                                |   10 +-
 src/target/xscale/build.sh                         |    7 -
 src/target/xscale/debug_handler.bin                |  Bin 1592 -> 0 bytes
 src/transport/Makefile.am                          |   15 +-
 src/transport/transport.c                          |    3 +-
 src/transport/transport.h                          |    9 +-
 src/xsvf/Makefile.am                               |   10 +-
 src/xsvf/xsvf.c                                    |    4 +-
 src/xsvf/xsvf.h                                    |   10 +-
 tcl/board/atmel_same70_xplained.cfg                |   12 +
 tcl/board/atmel_samg55_xplained_pro.cfg            |   11 +
 tcl/board/efm32.cfg                                |   10 +-
 tcl/board/fsl_imx6q_sabresd.cfg                    |  149 +
 tcl/board/lemaker_hikey.cfg                        |   26 +
 tcl/board/linksys-wag200g.cfg                      |   27 +
 tcl/board/marsohod.cfg                             |   13 +
 tcl/board/marsohod2.cfg                            |   13 +
 tcl/board/marsohod3.cfg                            |   13 +
 tcl/board/minispartan6.cfg                         |   24 +
 tcl/board/nordic_nrf51_dk.cfg                      |    9 +
 tcl/board/nordic_nrf52_dk.cfg                      |    9 +
 tcl/board/novena-internal-fpga.cfg                 |   24 +
 tcl/board/openrd.cfg                               |    2 +
 tcl/board/quark_d2000_refboard.cfg                 |   15 +
 tcl/board/spansion_sk-fm4-176l-s6e2cc.cfg          |    1 +
 tcl/board/spansion_sk-fm4-u120-9b560.cfg           |    1 +
 tcl/board/st_nucleo_f7.cfg                         |   10 +
 tcl/board/st_nucleo_l073rz.cfg                     |   12 +
 tcl/board/st_nucleo_l476rg.cfg                     |   11 +
 tcl/board/stm32f429disc1.cfg                       |   12 +
 tcl/board/stm32f429discovery.cfg                   |    3 +
 tcl/board/stm32f469discovery.cfg                   |    3 +
 tcl/board/stm32f4discovery.cfg                     |    3 +
 tcl/board/telo.cfg                                 |    3 -
 tcl/board/ti_am437x_idk.cfg                        |    6 +-
 tcl/board/ti_beaglebone-base.cfg                   |    4 +
 tcl/board/ti_beaglebone.cfg                        |    3 +-
 tcl/board/ti_beaglebone_black.cfg                  |    8 +
 tcl/board/tocoding_poplar.cfg                      |   28 +
 tcl/board/tp-link_tl-mr3020.cfg                    |    2 +
 tcl/board/tp-link_wdr4300.cfg                      |  160 +
 tcl/board/twr-vf65gs10.cfg                         |  201 +
 tcl/board/twr-vf65gs10_cmsisdap.cfg                |   15 +
 tcl/board/xmc-2go.cfg                              |    1 +
 tcl/board/xmc1100-boot-kit.cfg                     |    1 +
 tcl/board/xmc4300-relax.cfg                        |   12 +
 tcl/board/xmc4500-application-kit-sdram.cfg        |    2 -
 tcl/cpld/altera-5m570z-cpld.cfg                    |    6 +
 tcl/cpld/altera-epm240.cfg                         |    6 +
 tcl/cpld/xilinx-xc7.cfg                            |    2 +-
 tcl/fpga/altera-10m50.cfg                          |    6 +
 tcl/interface/axm0432.cfg                          |   11 -
 tcl/interface/busblaster.cfg                       |   14 -
 tcl/interface/calao-usb-a9260-c01.cfg              |   13 -
 tcl/interface/calao-usb-a9260-c02.cfg              |   13 -
 tcl/interface/cortino.cfg                          |   11 -
 tcl/interface/digilent-hs1.cfg                     |   15 -
 tcl/interface/dlp-usb1232h.cfg                     |   14 -
 tcl/interface/flossjtag-noeeprom.cfg               |   19 -
 tcl/interface/flossjtag.cfg                        |   20 -
 tcl/interface/flyswatter.cfg                       |   10 -
 tcl/interface/flyswatter2.cfg                      |   10 -
 tcl/interface/ftdi/digilent-hs2.cfg                |   10 +
 tcl/interface/ftdi/incircuit-icprog.cfg            |   14 +
 tcl/interface/ftdi/mbftdi.cfg                      |   16 +
 tcl/interface/ftdi/minimodule.cfg                  |   13 +-
 tcl/interface/ftdi/minispartan6.cfg                |   15 +
 tcl/interface/ftdi/openrd.cfg                      |    9 +-
 tcl/interface/ftdi/sheevaplug.cfg                  |    2 +-
 tcl/interface/ftdi/xds100v3.cfg                    |   11 +
 tcl/interface/hilscher_nxhx10_etm.cfg              |   11 -
 tcl/interface/hilscher_nxhx500_etm.cfg             |   11 -
 tcl/interface/hilscher_nxhx500_re.cfg              |   11 -
 tcl/interface/hilscher_nxhx50_etm.cfg              |   11 -
 tcl/interface/hilscher_nxhx50_re.cfg               |   11 -
 tcl/interface/hitex_str9-comstick.cfg              |   11 -
 tcl/interface/icebear.cfg                          |   11 -
 tcl/interface/imx-native.cfg                       |   35 +
 tcl/interface/jlink.cfg                            |   15 +-
 tcl/interface/jtag-lock-pick_tiny_2.cfg            |   10 -
 tcl/interface/jtagkey-tiny.cfg                     |    9 -
 tcl/interface/jtagkey.cfg                          |   11 -
 tcl/interface/jtagkey2.cfg                         |   11 -
 tcl/interface/jtagkey2p.cfg                        |   11 -
 tcl/interface/kitprog.cfg                          |   12 +
 tcl/interface/kt-link.cfg                          |   10 -
 tcl/interface/lisa-l.cfg                           |   11 -
 tcl/interface/luminary-icdi.cfg                    |   21 -
 tcl/interface/luminary-lm3s811.cfg                 |   18 -
 tcl/interface/luminary.cfg                         |   31 -
 tcl/interface/minimodule.cfg                       |   10 -
 tcl/interface/neodb.cfg                            |   10 -
 tcl/interface/ngxtech.cfg                          |   10 -
 tcl/interface/olimex-arm-usb-ocd-h.cfg             |   11 -
 tcl/interface/olimex-arm-usb-ocd.cfg               |   11 -
 tcl/interface/olimex-arm-usb-tiny-h.cfg            |   11 -
 tcl/interface/olimex-jtag-tiny.cfg                 |   11 -
 tcl/interface/oocdlink.cfg                         |   12 -
 tcl/interface/opendous_ftdi.cfg                    |   15 -
 tcl/interface/openocd-usb-hs.cfg                   |   11 -
 tcl/interface/openocd-usb.cfg                      |   11 -
 tcl/interface/openrd.cfg                           |   12 -
 tcl/interface/redbee-econotag.cfg                  |   13 -
 tcl/interface/redbee-usb.cfg                       |   13 -
 tcl/interface/sheevaplug.cfg                       |   12 -
 tcl/interface/signalyzer-h2.cfg                    |   11 -
 tcl/interface/signalyzer-h4.cfg                    |   11 -
 tcl/interface/signalyzer-lite.cfg                  |   11 -
 tcl/interface/signalyzer.cfg                       |   11 -
 tcl/interface/stm32-stick.cfg                      |   11 -
 tcl/interface/turtelizer2.cfg                      |   15 -
 tcl/interface/usb-jtag.cfg                         |    4 +-
 tcl/interface/vpaclink.cfg                         |   10 -
 tcl/interface/xds100v2.cfg                         |   10 -
 tcl/mem_helper.tcl                                 |    9 +
 tcl/memory.tcl                                     |   54 +
 tcl/target/adsp-sc58x.cfg                          |   44 +
 tcl/target/altera_fpgasoc.cfg                      |    4 +-
 tcl/target/am335x.cfg                              |   36 +-
 tcl/target/am437x.cfg                              |    6 +-
 tcl/target/amdm37x.cfg                             |    2 +-
 tcl/target/at91sam3XXX.cfg                         |    2 +-
 tcl/target/at91sam3ax_xx.cfg                       |    2 +-
 tcl/target/at91sam3sXX.cfg                         |    2 +-
 tcl/target/at91sam3uxx.cfg                         |    2 +-
 tcl/target/at91sam4XXX.cfg                         |    2 +-
 tcl/target/at91sam4c32x.cfg                        |    9 +
 tcl/target/at91sam4cXXX.cfg                        |    7 +
 tcl/target/at91sam4lXX.cfg                         |    2 +-
 tcl/target/at91sam4sXX.cfg                         |    2 +-
 tcl/target/at91sam4sd32x.cfg                       |    2 +-
 tcl/target/at91samdXX.cfg                          |    7 +-
 tcl/target/at91samg5x.cfg                          |    2 +-
 tcl/target/atheros_ar9344.cfg                      |   39 +
 tcl/target/atmega128rfa1.cfg                       |   22 +
 tcl/target/bcm281xx.cfg                            |    2 +-
 tcl/target/cc26xx.cfg                              |    2 +-
 tcl/target/cc32xx.cfg                              |    2 +-
 tcl/target/fm3.cfg                                 |    2 +-
 tcl/target/fm4_mb9bf.cfg                           |    3 +
 tcl/target/fm4_s6e2cc.cfg                          |    4 +
 tcl/target/hi3798.cfg                              |   49 +
 tcl/target/hi6220.cfg                              |   56 +
 tcl/target/imx51.cfg                               |    5 +-
 tcl/target/imx53.cfg                               |    5 +-
 tcl/target/imx6.cfg                                |    2 +-
 tcl/target/k1921vk01t.cfg                          |    2 +-
 tcl/target/ke0x.cfg                                |   54 +
 tcl/target/ke1xf.cfg                               |    7 +
 tcl/target/ke1xz.cfg                               |    7 +
 tcl/target/klx.cfg                                 |   30 +-
 tcl/target/kx.cfg                                  |   26 +-
 tcl/target/lpc1xxx.cfg                             |   10 +-
 tcl/target/nrf51.cfg                               |    2 +-
 tcl/target/nrf52.cfg                               |   15 +-
 tcl/target/omap3530.cfg                            |    2 +-
 tcl/target/psoc4.cfg                               |    2 +-
 tcl/target/psoc5lp.cfg                             |   32 +
 tcl/target/quark_d20xx.cfg                         |   50 +
 tcl/target/stm32f1x.cfg                            |   31 +-
 tcl/target/stm32f2x.cfg                            |   11 +-
 tcl/target/stm32f3x.cfg                            |   21 +-
 tcl/target/stm32f4x.cfg                            |   32 +-
 tcl/target/stm32f7x.cfg                            |   11 +-
 tcl/target/stm32l0.cfg                             |   10 +
 tcl/target/stm32l0_dual_bank.cfg                   |    5 +
 tcl/target/stm32l1.cfg                             |   22 +-
 tcl/target/stm32l4x.cfg                            |   34 +-
 tcl/target/stm32w108xx.cfg                         |    2 +-
 tcl/target/ti_msp432p4xx.cfg                       |   52 +
 tcl/target/ti_tms570.cfg                           |    2 +-
 tcl/target/xmc1xxx.cfg                             |   13 +
 tcl/target/zynq_7000.cfg                           |    3 +-
 tcl/tools/firmware-recovery.tcl                    |    1 +
 tools/scripts/checkpatch.pl                        |    8 +-
 716 files changed, 32725 insertions(+), 15759 deletions(-)
 create mode 100644 NEWS-0.10.0
 delete mode 100644 common.mk
 create mode 100644 contrib/60-openocd.rules
 delete mode 100644 contrib/99-openocd.rules
 create mode 100644 contrib/loaders/Makefile
 create mode 100644 contrib/loaders/checksum/Makefile
 create mode 100644 contrib/loaders/checksum/armv4_5_crc.inc
 create mode 100644 contrib/loaders/checksum/armv7m_crc.inc
 create mode 100644 contrib/loaders/debug/xscale/Makefile
 rename {src/target => contrib/loaders/debug}/xscale/debug_handler.S (98%)
 create mode 100644 contrib/loaders/debug/xscale/debug_handler.inc
 rename src/target/xscale/debug_handler.cmd => contrib/loaders/debug/xscale/debug_handler.ld (100%)
 rename {src/target => contrib/loaders/debug}/xscale/protocol.h (90%)
 create mode 100644 contrib/loaders/erase_check/Makefile
 create mode 100644 contrib/loaders/erase_check/armv4_5_erase_check.inc
 create mode 100644 contrib/loaders/erase_check/armv7m_0_erase_check.inc
 create mode 100644 contrib/loaders/erase_check/armv7m_erase_check.inc
 create mode 100644 contrib/loaders/flash/fm4/Makefile
 create mode 100644 contrib/loaders/flash/fm4/erase.S
 create mode 100644 contrib/loaders/flash/fm4/erase.inc
 create mode 100644 contrib/loaders/flash/fm4/fm4.h
 create mode 100644 contrib/loaders/flash/fm4/write.S
 create mode 100644 contrib/loaders/flash/fm4/write.inc
 create mode 100644 contrib/loaders/flash/kinetis/Makefile
 create mode 100644 contrib/loaders/flash/kinetis/kinetis_flash.inc
 create mode 100644 contrib/loaders/flash/kinetis/kinetis_flash.s
 create mode 100644 contrib/loaders/flash/kinetis_ke/Makefile
 create mode 100644 contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.inc
 create mode 100644 contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.s
 create mode 100644 contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.inc
 create mode 100644 contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.s
 create mode 100644 contrib/loaders/flash/xmc1xxx/Makefile
 create mode 100644 contrib/loaders/flash/xmc1xxx/erase.S
 create mode 100644 contrib/loaders/flash/xmc1xxx/erase.inc
 create mode 100644 contrib/loaders/flash/xmc1xxx/erase_check.S
 create mode 100644 contrib/loaders/flash/xmc1xxx/erase_check.inc
 create mode 100644 contrib/loaders/flash/xmc1xxx/write.S
 create mode 100644 contrib/loaders/flash/xmc1xxx/write.inc
 create mode 100644 contrib/loaders/flash/xmc1xxx/xmc1xxx.S
 create mode 100644 contrib/loaders/watchdog/Makefile
 create mode 100644 contrib/loaders/watchdog/armv7m_kinetis_wdog.inc
 create mode 100644 contrib/loaders/watchdog/armv7m_kinetis_wdog.s
 create mode 100644 contrib/loaders/watchdog/armv7m_kinetis_wdog32.inc
 create mode 100644 contrib/loaders/watchdog/armv7m_kinetis_wdog32.s
 create mode 100644 contrib/rtos-helpers/uCOS-III-openocd.c
 delete mode 100644 doc/INSTALL.txt
 create mode 100644 src/flash/nor/ambiqmicro.c
 create mode 100644 src/flash/nor/ath79.c
 create mode 100644 src/flash/nor/fm4.c
 create mode 100644 src/flash/nor/kinetis_ke.c
 rename src/flash/nor/{nrf51.c => nrf5.c} (57%)
 create mode 100644 src/flash/nor/xmc1xxx.c
 create mode 100644 src/helper/jep106.c
 create mode 100644 src/helper/jep106.h
 create mode 100644 src/helper/jep106.inc
 create mode 100755 src/helper/update_jep106.pl
 delete mode 100644 src/jtag/drivers/ft2232.c
 delete mode 100644 src/jtag/drivers/ftd2xx_common.h
 create mode 100644 src/jtag/drivers/imx_gpio.c
 create mode 100644 src/jtag/drivers/kitprog.c
 delete mode 100644 src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c
 create mode 100644 src/rtos/rtos_ucos_iii_stackings.c
 create mode 100644 src/rtos/rtos_ucos_iii_stackings.h
 create mode 100644 src/rtos/uCOS-III.c
 create mode 100644 src/target/aarch64.c
 create mode 100644 src/target/aarch64.h
 create mode 100644 src/target/arm_cti.c
 create mode 100644 src/target/arm_cti.h
 create mode 100644 src/target/armv8.c
 create mode 100644 src/target/armv8.h
 create mode 100644 src/target/armv8_cache.c
 create mode 100644 src/target/armv8_cache.h
 create mode 100644 src/target/armv8_dpm.c
 create mode 100644 src/target/armv8_dpm.h
 create mode 100644 src/target/armv8_opcodes.c
 create mode 100644 src/target/armv8_opcodes.h
 create mode 100644 src/target/ls1_sap.c
 create mode 100644 src/target/quark_d20xx.c
 delete mode 100755 src/target/xscale/build.sh
 delete mode 100755 src/target/xscale/debug_handler.bin
 create mode 100644 tcl/board/atmel_same70_xplained.cfg
 create mode 100644 tcl/board/atmel_samg55_xplained_pro.cfg
 create mode 100644 tcl/board/fsl_imx6q_sabresd.cfg
 create mode 100644 tcl/board/lemaker_hikey.cfg
 create mode 100644 tcl/board/linksys-wag200g.cfg
 create mode 100644 tcl/board/marsohod.cfg
 create mode 100644 tcl/board/marsohod2.cfg
 create mode 100644 tcl/board/marsohod3.cfg
 create mode 100644 tcl/board/minispartan6.cfg
 create mode 100644 tcl/board/nordic_nrf51_dk.cfg
 create mode 100644 tcl/board/nordic_nrf52_dk.cfg
 create mode 100644 tcl/board/novena-internal-fpga.cfg
 create mode 100644 tcl/board/quark_d2000_refboard.cfg
 create mode 100644 tcl/board/st_nucleo_f7.cfg
 create mode 100644 tcl/board/st_nucleo_l073rz.cfg
 create mode 100644 tcl/board/st_nucleo_l476rg.cfg
 create mode 100644 tcl/board/stm32f429disc1.cfg
 create mode 100644 tcl/board/ti_beaglebone-base.cfg
 create mode 100644 tcl/board/ti_beaglebone_black.cfg
 create mode 100644 tcl/board/tocoding_poplar.cfg
 create mode 100644 tcl/board/tp-link_wdr4300.cfg
 create mode 100644 tcl/board/twr-vf65gs10.cfg
 create mode 100644 tcl/board/twr-vf65gs10_cmsisdap.cfg
 create mode 100644 tcl/board/xmc4300-relax.cfg
 create mode 100644 tcl/cpld/altera-5m570z-cpld.cfg
 create mode 100644 tcl/cpld/altera-epm240.cfg
 create mode 100644 tcl/fpga/altera-10m50.cfg
 delete mode 100644 tcl/interface/axm0432.cfg
 delete mode 100644 tcl/interface/busblaster.cfg
 delete mode 100644 tcl/interface/calao-usb-a9260-c01.cfg
 delete mode 100644 tcl/interface/calao-usb-a9260-c02.cfg
 delete mode 100644 tcl/interface/cortino.cfg
 delete mode 100644 tcl/interface/digilent-hs1.cfg
 delete mode 100644 tcl/interface/dlp-usb1232h.cfg
 delete mode 100644 tcl/interface/flossjtag-noeeprom.cfg
 delete mode 100644 tcl/interface/flossjtag.cfg
 delete mode 100644 tcl/interface/flyswatter.cfg
 delete mode 100644 tcl/interface/flyswatter2.cfg
 create mode 100644 tcl/interface/ftdi/digilent-hs2.cfg
 create mode 100644 tcl/interface/ftdi/incircuit-icprog.cfg
 create mode 100644 tcl/interface/ftdi/mbftdi.cfg
 create mode 100644 tcl/interface/ftdi/minispartan6.cfg
 create mode 100644 tcl/interface/ftdi/xds100v3.cfg
 delete mode 100644 tcl/interface/hilscher_nxhx10_etm.cfg
 delete mode 100644 tcl/interface/hilscher_nxhx500_etm.cfg
 delete mode 100644 tcl/interface/hilscher_nxhx500_re.cfg
 delete mode 100644 tcl/interface/hilscher_nxhx50_etm.cfg
 delete mode 100644 tcl/interface/hilscher_nxhx50_re.cfg
 delete mode 100644 tcl/interface/hitex_str9-comstick.cfg
 delete mode 100644 tcl/interface/icebear.cfg
 create mode 100644 tcl/interface/imx-native.cfg
 delete mode 100644 tcl/interface/jtag-lock-pick_tiny_2.cfg
 delete mode 100644 tcl/interface/jtagkey-tiny.cfg
 delete mode 100644 tcl/interface/jtagkey.cfg
 delete mode 100644 tcl/interface/jtagkey2.cfg
 delete mode 100644 tcl/interface/jtagkey2p.cfg
 create mode 100644 tcl/interface/kitprog.cfg
 delete mode 100644 tcl/interface/kt-link.cfg
 delete mode 100644 tcl/interface/lisa-l.cfg
 delete mode 100644 tcl/interface/luminary-icdi.cfg
 delete mode 100644 tcl/interface/luminary-lm3s811.cfg
 delete mode 100644 tcl/interface/luminary.cfg
 delete mode 100644 tcl/interface/minimodule.cfg
 delete mode 100644 tcl/interface/neodb.cfg
 delete mode 100644 tcl/interface/ngxtech.cfg
 delete mode 100644 tcl/interface/olimex-arm-usb-ocd-h.cfg
 delete mode 100644 tcl/interface/olimex-arm-usb-ocd.cfg
 delete mode 100644 tcl/interface/olimex-arm-usb-tiny-h.cfg
 delete mode 100644 tcl/interface/olimex-jtag-tiny.cfg
 delete mode 100644 tcl/interface/oocdlink.cfg
 delete mode 100644 tcl/interface/opendous_ftdi.cfg
 delete mode 100644 tcl/interface/openocd-usb-hs.cfg
 delete mode 100644 tcl/interface/openocd-usb.cfg
 delete mode 100644 tcl/interface/openrd.cfg
 delete mode 100644 tcl/interface/redbee-econotag.cfg
 delete mode 100644 tcl/interface/redbee-usb.cfg
 delete mode 100644 tcl/interface/sheevaplug.cfg
 delete mode 100644 tcl/interface/signalyzer-h2.cfg
 delete mode 100644 tcl/interface/signalyzer-h4.cfg
 delete mode 100644 tcl/interface/signalyzer-lite.cfg
 delete mode 100644 tcl/interface/signalyzer.cfg
 delete mode 100644 tcl/interface/stm32-stick.cfg
 delete mode 100644 tcl/interface/turtelizer2.cfg
 delete mode 100644 tcl/interface/vpaclink.cfg
 delete mode 100644 tcl/interface/xds100v2.cfg
 create mode 100644 tcl/target/adsp-sc58x.cfg
 create mode 100644 tcl/target/at91sam4c32x.cfg
 create mode 100644 tcl/target/at91sam4cXXX.cfg
 create mode 100644 tcl/target/atheros_ar9344.cfg
 create mode 100644 tcl/target/atmega128rfa1.cfg
 create mode 100644 tcl/target/hi3798.cfg
 create mode 100644 tcl/target/hi6220.cfg
 create mode 100644 tcl/target/ke0x.cfg
 create mode 100644 tcl/target/ke1xf.cfg
 create mode 100644 tcl/target/ke1xz.cfg
 create mode 100644 tcl/target/psoc5lp.cfg
 create mode 100644 tcl/target/quark_d20xx.cfg
 create mode 100644 tcl/target/stm32l0_dual_bank.cfg
 create mode 100644 tcl/target/ti_msp432p4xx.cfg

diff --git a/.gitignore b/.gitignore
index 3e6e1e94..f1021b26 100644
--- a/.gitignore
+++ b/.gitignore
@@ -52,8 +52,8 @@ doc/openocd.pg
 doc/openocd.toc
 doc/openocd.tp
 doc/openocd.vr
-doc/texinfo.tex
 doc/version.texi
+texinfo.tex
 src/openocd
 src/openocd.exe
 
@@ -71,6 +71,7 @@ install-sh
 libtool
 ltmain.sh
 Makefile
+!contrib/loaders/**/Makefile
 mdate-sh
 missing
 stamp-h1
diff --git a/Makefile.am b/Makefile.am
index 2ddc96d3..930a3073 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -5,22 +5,45 @@ AUTOMAKE_OPTIONS = gnu 1.6
 # make sure we pass the correct jimtcl flags to distcheck
 DISTCHECK_CONFIGURE_FLAGS = --disable-install-jim
 
+# do not run Jim Tcl tests (esp. during distcheck)
+check-recursive:
+	@true
+
 nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \
 	contrib/libdcc/example.c \
 	contrib/libdcc/README \
-	contrib/99-openocd.rules
+	contrib/60-openocd.rules
 
-if INTERNAL_JIMTCL
-SUBDIRS = jimtcl
-else
 SUBDIRS =
+DIST_SUBDIRS =
+bin_PROGRAMS =
+noinst_LTLIBRARIES =
+info_TEXINFOS =
+dist_man_MANS =
+EXTRA_DIST =
+
+if INTERNAL_JIMTCL
+SUBDIRS += jimtcl
+DIST_SUBDIRS += jimtcl
 endif
 
-SUBDIRS += src doc
+# common flags used in openocd build
+AM_CFLAGS = $(GCC_WARNINGS)
+
+AM_CPPFLAGS = $(HOST_CPPFLAGS)\
+			  -I$(top_srcdir)/src \
+			  -I$(top_builddir)/src \
+			  -I$(top_srcdir)/src/helper \
+			  -DPKGDATADIR=\"$(pkgdatadir)\" \
+			  -DBINDIR=\"$(bindir)\"
 
-EXTRA_DIST = \
+if INTERNAL_JIMTCL
+AM_CPPFLAGS += -I$(top_srcdir)/jimtcl \
+			   -I$(top_builddir)/jimtcl
+endif
+EXTRA_DIST += \
 	BUGS \
 	HACKING \
 	NEWTAPS \
@@ -96,17 +119,26 @@ distclean-local:
 
 DISTCLEANFILES = doxygen.log
 
+METASOURCES = AUTO
+
+BUILT_SOURCES =
+CLEANFILES =
+
 MAINTAINERCLEANFILES = \
-	$(srcdir)/INSTALL \
-	$(srcdir)/configure \
-	$(srcdir)/Makefile.in \
-	$(srcdir)/depcomp \
-	$(srcdir)/config.guess \
-	$(srcdir)/config.sub \
-	$(srcdir)/config.h.in \
-	$(srcdir)/config.h.in~ \
-	$(srcdir)/compile \
-	$(srcdir)/ltmain.sh \
-	$(srcdir)/missing \
-	$(srcdir)/aclocal.m4 \
-	$(srcdir)/install-sh
+	%D%/INSTALL \
+	%D%/configure \
+	%D%/Makefile.in \
+	%D%/depcomp \
+	%D%/config.guess \
+	%D%/config.sub \
+	%D%/config.h.in \
+	%D%/config.h.in~ \
+	%D%/compile \
+	%D%/ltmain.sh \
+	%D%/missing \
+	%D%/aclocal.m4 \
+	%D%/install-sh \
+	%D%/texinfo.tex
+
+include src/Makefile.am
+include doc/Makefile.am
diff --git a/NEWS-0.10.0 b/NEWS-0.10.0
new file mode 100644
index 00000000..e3b1e256
--- /dev/null
+++ b/NEWS-0.10.0
@@ -0,0 +1,155 @@
+This file includes highlights of the changes made in the OpenOCD
+source archive release.
+
+JTAG Layer:
+	* New driver for J-Link adapters based on libjaylink
+          (including support for FPGA configuration, SWO and EMUCOM)
+	* FTDI improvements to work at 30MHz clock
+	* BCM2835 native driver SWD and Raspberry Pi2 support
+	* BCM2835 is set to 4ma drive, slow slew rate
+	* ixo-usb-jtag (emulation of an Altera Bus Blaster I on
+          Cypress FX2 IC) support
+	* JTAG pass-through mode for CMSIS-DAP (including support for
+          FPGA configuration)
+	* OpenJTAG support for Cypress CY7C65215
+	* connect_assert_srst support for SWD
+	* Xilinx Virtex-II Series7 bitstream loading support
+	* Use JEP106 data to decode IDs
+	* Deprecated "ft2232" driver removed (use "ftdi" instead)
+	* GPL-incompatible FTDI D2XX library support dropped (Presto,
+          OpenJTAG and USB-Blaster I are using libftdi only now)
+	* ZY1000 support dropped (unmaintained since long)
+	* oocd_trace support dropped
+
+Boundary Scan:
+
+Target Layer:
+	* ARMv7-A, Cortex-M, Cortex-A/R important fixes and
+          improvements (allowing e.g. simultaneous debugging of A8 and
+          M3 cores, JTAG WAIT support etc.)
+	* ARM Cortex-A,R allow interrupt disable during single-step
+          (maskisr command)
+	* Semihosting support for ARMv7-A
+	* ARM Cortex-M7 support
+	* Intel Quark mcu D2000 support
+	* Freescale LS102x SAP support
+	* ThreadX RTOS support on ARM926E-JS
+	* Cortex-M RTOS stack alignment fixes
+	* FreeRTOS FPU support
+	* uC/OS-III RTOS support
+	* bridging semihosting to GDB's File-I/O support
+	* -defer-examine option added to target create command
+	* verify_image_checksum command added
+
+Flash Layer:
+	* Atmel SAM4S, SAM4N, SAM4C support
+	* Atmel SAMV, SAMS, SAME (Cortex-M7) support
+	* Atmel AT91SAMD handle reset run/halt in DSU, other fixes
+	* Atmel AT91SAML21, SAML22, SAMC20/SAMC21, SAMD09 support
+	* ST STM32F4x support
+	* ST STM32F74x/76x/77x, STM32L4 support
+	* ST STM32L0 categories 1, 2 and 5 support
+	* Kinetis K02, K21, K22, K24, K26, K63, K64, K66 support
+	* Kinetis KE, KVx, K8x families support
+	* Kinetis FlexNVM handling
+	* Kinetis flash protection, security, mass_erase improvements
+	* Infineon XMC4xxx family support
+	* Infineon XMC1000 flash driver
+	* Energy Micro EFM32 Happy Gecko support
+	* Energy Micro EFM32 debug interface lock support
+	* Analog Devices ADuCM360 support
+	* Unified Nuvoton NuMicro flash driver
+	* NIIET K1921VK01T (Cortex-M4) support
+	* Nordic Semiconductor nRF51 improvements
+	* Spansion FM4 flash (including MB9BFx64/x65, S6E2DH) driver
+	* Ambiq Micro Apollo flash driver
+	* PIC32MX new device IDs, 17x/27x flash support
+	* read_bank() and verify_bank() NOR flash internal API to
+          allow reading (and verifying) non-memory-mapped devices
+	* JTAGSPI driver to access SPI NOR flashes via a trivial
+          FPGA proxy
+	* Milandr read/verify for Info memory support
+	* Various discrete SPI NOR flashes support
+	* CFI 16-bit flash reversed endianness support
+
+Board, Target, and Interface Configuration Scripts:
+	* Digilent JTAG-HS2, JTAG-HS3 interfaces configs
+	* FTDI UM232H module as JTAG interface config
+	* 100ask's OpenJTAG interface config
+	* MBFTDI interface config
+	* XDS100v3 interface config
+	* Freescale Vybrid VF6xx target config
+	* EmCraft VF6 SOM and baseboard configs
+	* Freescale SabreSD board config
+	* Freescale VF65GS10 tower board config
+	* Pipistrello Xilinx Spartan6 LX45 FPGA board config
+	* miniSpartan6+ board config
+	* Xilinx Kintex7 Development board config
+	* Parallella-I board config
+	* Digilent Atlys and Analog Discovery board configs
+	* Numato Opsis board config
+	* Xilinx Spartan 6 FPGA "Device DNA" reading support
+	* Altera 10M50 FPGA (MAX10 family) target config
+	* Altera EPM240 CPLD (MAXII family) target config
+	* Marsohod2, Marsohod3 FPGA, Marsohod CPLD boards configs
+	* Novena's integrated FPGA board config
+	* XMOS XS1-XAU8A-10's ARM core config
+	* XMOS xCORE-XA Core Module board config
+	* Exynos5250 target config
+	* Arndale board config
+	* FM4 MB9BFxxx family configs
+	* Spansion SK-FM4-U120-9B560 board config
+	* Diolan LPC4357-DB1 board config
+	* ST STM32F469 discovery board config
+	* ST STM32F7-DISCO, STM327[4|5]6G-EVAL boards configs
+	* ST STM32L4 discovery, NUCLEO L476RG, STM32F429I-DISC1 boards
+          configs
+	* Atheros AR2313, AR2315 targets config
+	* Netgear WP102 board config
+	* La Fonera FON2200 board config
+	* Linksys WAG200G board config
+	* LPC-Link2 board config
+	* NXP LPC4370 target config
+	* Atmel SAMV, SAMS, SAME target configs
+	* Atmel SAM E70 Xplained, SAM V71 Xplained Ultra boards
+          configs
+	* Nordic nRF52 target config
+	* Nordic nRF51-DK, nRF52-DK boards configs
+	* Infineon XMC4700 Relax Kit, XMC4800 Relax EtherCAT Kit,
+          XMC4300 Relax EtherCAT Kit boards configs
+	* Renesas S7G2 target config
+	* Renesas DK-S7G2 board config
+	* Altera EP3C10 FPGA (Cyclone III family) target config
+	* TI MSP432P4xx target config
+	* Cypress PSoC 5LP target config
+	* Analog Devices ADSP-SC58x target config (Cortex-A5 core only)
+
+Server Layer:
+	* tcl_trace command for async target trace output via Tcl RPC
+
+Documentation:
+
+Build and Release:
+	* Various fixes thanks to http://coccinellery.org/
+	* libftdi is now autodetected with pkgconfig
+	* Releases should now support reproducible builds
+	* Conversion to non-recursive make, requires automake >= 1.14
+	* Udev rules modified to add uaccess tag and moved to
+          60-openocd.rules
+	* Support searching for scripts relative to the openocd binary
+          for all major architectures
+
+
+This release also contains a number of other important functional and
+cosmetic bugfixes. For more details about what has changed since the
+last release, see the git repository history:
+
+http://sourceforge.net/p/openocd/code/ci/v0.10.0/log/?path=
+
+
+For older NEWS, see the NEWS files associated with each release
+(i.e. NEWS-<version>).
+
+For more information about contributing test reports, bug fixes, or new
+features and device support, please read the new Developer Manual (or
+the BUGS and PATCHES.txt files in the source archive).
diff --git a/NEWTAPS b/NEWTAPS
index 638fa005..10f30063 100644
--- a/NEWTAPS
+++ b/NEWTAPS
@@ -77,7 +77,7 @@ This is always a 32bit hex number.
 Examples:
     0x1f0f0f0f - is an old ARM7TDMI
     0x3f0f0f0f - is a newer ARM7TDMI
-    0x3ba00477 - is an ARM cortex M3
+    0x3ba00477 - is an ARM Cortex-M3
 
 Some chips have multiple JTAG taps - be sure to list
 each one individually - ORDER is important!
diff --git a/README b/README
index 8f98e7fa..f2d704b4 100644
--- a/README
+++ b/README
@@ -4,7 +4,7 @@ Welcome to OpenOCD!
 OpenOCD provides on-chip programming and debugging support with a
 layered architecture of JTAG interface and TAP support including:
 
-- (X)SVF playback to faciliate automated boundary scan and FPGA/CPLD
+- (X)SVF playback to facilitate automated boundary scan and FPGA/CPLD
   programming;
 - debug target support (e.g. ARM, MIPS): single-stepping,
   breakpoints/watchpoints, gprof profiling, etc;
@@ -45,9 +45,6 @@ e.g.:
   openocd -f interface/stlink-v2-1.cfg -c "transport select hla_swd" \
           -f target/stm32l0.cfg
 
-NB: when using an FTDI-based adapter you should prefer configs in the
-ftdi directory; the old configs for the ft2232 are deprecated.
-
 After OpenOCD startup, connect GDB with
 
   (gdb) target extended-remote localhost:3333
@@ -119,18 +116,18 @@ Wiggler, XDS100v2, Xverve.
 Debug targets
 -------------
 
-ARM11, ARM7, ARM9, AVR32, Cortex-A, Cortex-R, Cortex-M,
+ARM11, ARM7, ARM9, AVR32, Cortex-A, Cortex-R, Cortex-M, LS102x-SAP,
 Feroceon/Dragonite, DSP563xx, DSP5680xx, FA526, MIPS EJTAG, NDS32,
 XScale, Intel Quark.
 
 Flash drivers
 -------------
 
-ADUC702x, AT91SAM, AVR, CFI, DSP5680xx, EFM32, EM357, FM3, Kinetis,
+ADUC702x, AT91SAM, ATH79, AVR, CFI, DSP5680xx, EFM32, EM357, FM3, FM4, Kinetis,
 LPC8xx/LPC1xxx/LPC2xxx/LPC541xx, LPC2900, LPCSPIFI, Marvell QSPI,
 Milandr, NIIET, NuMicro, PIC32mx, PSoC4, SiM3x, Stellaris, STM32, STMSMI,
 STR7x, STR9x, nRF51; NAND controllers of AT91SAM9, LPC3180, LPC32xx,
-i.MX31, MXC, NUC910, Orion/Kirkwood, S3C24xx, S3C6400, XMC4xxx.
+i.MX31, MXC, NUC910, Orion/Kirkwood, S3C24xx, S3C6400, XMC1xxx, XMC4xxx.
 
 
 ==================
@@ -184,10 +181,6 @@ suggestions:
   particular hardware;
 - Use "ftdi" interface adapter driver for the FTDI-based devices.
 
-As a PACKAGER, never link against the FTD2XX library, as the resulting
-binaries can't be legally distributed, due to the restrictions of the
-GPL.
-
 
 ================
 Building OpenOCD
@@ -221,18 +214,16 @@ You'll also need:
 Additionally, for building from git:
 
 - autoconf >= 2.64
-- automake >= 1.9
+- automake >= 1.14
 - texinfo
 
 USB-based adapters depend on libusb-1.0 and some older drivers require
 libusb-0.1 or libusb-compat-0.1. A compatible implementation, such as
 FreeBSD's, additionally needs the corresponding .pc files.
 
-USB-Blaster, ASIX Presto, OpenJTAG and ft2232 interface adapter
-drivers need either one of:
+USB-Blaster, ASIX Presto and OpenJTAG interface adapter
+drivers need:
   - libftdi: http://www.intra2net.com/en/developer/libftdi/index.php
-  - ftd2xx: http://www.ftdichip.com/Drivers/D2XX.htm (proprietary,
-    GPL-incompatible)
 
 CMSIS-DAP support needs HIDAPI library.
 
@@ -242,7 +233,7 @@ Permissions delegation
 Running OpenOCD with root/administrative permissions is strongly
 discouraged for security reasons.
 
-For USB devices on GNU/Linux you should use the contrib/99-openocd.rules
+For USB devices on GNU/Linux you should use the contrib/60-openocd.rules
 file. It probably belongs somewhere in /etc/udev/rules.d, but
 consult your operating system documentation to be sure. Do not forget
 to add yourself to the "plugdev" group.
@@ -304,40 +295,6 @@ use both the --enable-parport AND the --enable-parport-giveio option
 if you want to use giveio instead of ioperm parallel port access
 method.
 
-Using FTDI's FTD2XX
--------------------
-
-The (closed source) FTDICHIP.COM solution is faster than libftdi on
-Windows. That is the motivation for supporting it even though its
-licensing restricts it to non-redistributable OpenOCD binaries, and it
-is not available for all operating systems used with OpenOCD. You may,
-however, build such copies for personal use.
-
-The FTDICHIP drivers come as either a (win32) ZIP file, or a (Linux)
-TAR.GZ file. You must unpack them ``some where'' convenient. As of this
-writing FTDICHIP does not supply means to install these files "in an
-appropriate place."
-
-You should use the following ./configure options to make use of
-FTD2XX:
-
-  --with-ftd2xx-win32-zipdir
-                          Where (CYGWIN/MINGW) the zip file from ftdichip.com
-                          was unpacked <default=search>
-  --with-ftd2xx-linux-tardir
-                          Where (Linux/Unix) the tar file from ftdichip.com
-                          was unpacked <default=search>
-  --with-ftd2xx-lib=(static|shared)
-                          Use static or shared ftd2xx libs (default is static)
-
-Remember, this library is binary-only, while OpenOCD is licenced
-according to GNU GPLv2 without any exceptions. That means that
-_distributing_ copies of OpenOCD built with the FTDI code would
-violate the OpenOCD licensing terms.
-
-Note that on Linux there is no good reason to use these FTDI binaries;
-they are no faster (on Linux) than libftdi, and cause licensing issues.
-
 
 ==========================
 Obtaining OpenOCD From GIT
diff --git a/README.Windows b/README.Windows
index 36929202..6c616f38 100644
--- a/README.Windows
+++ b/README.Windows
@@ -1,8 +1,9 @@
 Building OpenOCD for Windows
 ----------------------------
 
-You can build OpenOCD for Windows natively with either MinGW-w64/MSYS,
-Cygwin or MinGW.
+You can build OpenOCD for Windows natively with either MinGW-w64/MSYS
+or Cygwin (plain MinGW might work with --disable-werror but is not
+recommended as it doesn't provide enough C99 compatibility).
 Alternatively, one can cross-compile it using MinGW-w64 on a *nix
 host. See README for the generic instructions.
 
diff --git a/TODO b/TODO
index 8aac1575..aa43fddd 100644
--- a/TODO
+++ b/TODO
@@ -93,9 +93,6 @@ interface support:
   -# rewrite implementation to use non-blocking I/O
 - J-Link driver:
   - fix to work with long scan chains, such as R.Doss's svf test.
-- FT2232 (libftdi):
-  - make performance comparable to alternatives (on Win32, D2XX is faster)
-  - make usability comparable to alternatives
 - Autodetect USB based adapters; this should be easy on Linux.  If there's
   more than one, list the options; otherwise, just select that one.
 
@@ -170,9 +167,9 @@ https://lists.berlios.de/pipermail/openocd-development/2009-October/011506.html
   garabage.
   - implement missing functionality (grep FNC_INFO_NOTIMPLEMENTED ...)
 - Thumb2 single stepping: ARM1156T2 needs simulator support
-- Cortex A8 support (ML)
+- Cortex-A8 support (ML)
   - add target implementation (ML)
-- Cortex M3 support
+- Cortex-M3 support
   - when stepping, only write dirtied registers (be faster)
   - when connecting to halted core, fetch registers (startup is quirky)
 - Generic ARM run_algorithm() interface
diff --git a/bootstrap b/bootstrap
index aceccc9a..de7aa1c4 100755
--- a/bootstrap
+++ b/bootstrap
@@ -39,5 +39,12 @@ else
     git submodule update
 fi
 
+if [ -x src/jtag/drivers/libjaylink/autogen.sh ]; then
+    (
+    cd src/jtag/drivers/libjaylink
+    ./autogen.sh
+    )
+fi
+
 echo "Bootstrap complete. Quick build instructions:"
 echo "./configure ...."
diff --git a/common.mk b/common.mk
deleted file mode 100644
index a7a4b46b..00000000
--- a/common.mk
+++ /dev/null
@@ -1,19 +0,0 @@
-
-# common flags used in openocd build
-AM_CPPFLAGS = -I$(top_srcdir)/src \
-			  -I$(top_builddir)/src \
-			  -I$(top_srcdir)/src/helper \
-			  -DPKGDATADIR=\"$(pkgdatadir)\" \
-			  -DBINDIR=\"$(bindir)\"
-
-# MinGW by default uses MSVCRT printf format specifiers
-# This forces a compatibility header to be included at the start of every
-# source file to ensure the printf functions are fully C99 compliant
-if IS_MINGW
-AM_CPPFLAGS += -include helper/mingw_compat.h
-endif
-
-if INTERNAL_JIMTCL
-AM_CPPFLAGS += -I$(top_srcdir)/jimtcl \
-			   -I$(top_builddir)/jimtcl
-endif
diff --git a/configure.ac b/configure.ac
index 62f61dbc..e3914ec1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,5 +1,5 @@
 AC_PREREQ(2.64)
-AC_INIT([openocd], [0.10.0-dev],
+AC_INIT([openocd], [0.10.0+dev],
   [OpenOCD Mailing List <openocd-devel@lists.sourceforge.net>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 
@@ -7,10 +7,10 @@ m4_include([config_subdir.m4])dnl
 
 # check for makeinfo before calling AM_INIT_AUTOMAKE
 AC_CHECK_PROG([MAKEINFO], [makeinfo], [makeinfo])
-if test "x$MAKEINFO" = "x"; then
+AS_IF([test "x$MAKEINFO" = "x"], [
   MAKEINFO='echo makeinfo missing; true'
   AC_MSG_WARN([Info documentation will not be built.])
-fi
+])
 AC_SUBST([MAKEINFO])
 
 AM_INIT_AUTOMAKE([-Wall -Wno-portability dist-bzip2 dist-zip subdir-objects])
@@ -29,11 +29,6 @@ AM_PROG_CC_C_O
 AC_PROG_RANLIB
 PKG_PROG_PKG_CONFIG([0.23])
 
-dnl This is needed by MinGW for some reason
-m4_pattern_allow([^AC_MSG_NOTICE$])
-m4_pattern_allow([^AC_DEFINE$])
-m4_pattern_allow([^AC_MSG_WARN$])
-
 dnl disable checks for C++, Fortran and GNU Java Compiler
 m4_defun([_LT_AC_LANG_CXX_CONFIG], [:])
 m4_defun([_LT_AC_LANG_F77_CONFIG], [:])
@@ -50,67 +45,11 @@ AC_SEARCH_LIBS([ioperm], [ioperm])
 AC_SEARCH_LIBS([dlopen], [dl])
 
 AC_CHECK_HEADERS([sys/socket.h])
-AC_CHECK_HEADERS([arpa/inet.h], [], [], [dnl
-#include <stdio.h>
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-])
 AC_CHECK_HEADERS([elf.h])
 AC_CHECK_HEADERS([dirent.h])
 AC_CHECK_HEADERS([fcntl.h])
-AC_CHECK_HEADERS([ifaddrs.h], [], [], [dnl
-#include <stdio.h>
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-])
 AC_CHECK_HEADERS([malloc.h])
 AC_CHECK_HEADERS([netdb.h])
-AC_CHECK_HEADERS([netinet/in.h], [], [], [dnl
-#include <stdio.h>
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-])
-AC_CHECK_HEADERS([netinet/tcp.h], [], [], [dnl
-#include <stdio.h>
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-])
 AC_CHECK_HEADERS([poll.h])
 AC_CHECK_HEADERS([pthread.h])
 AC_CHECK_HEADERS([strings.h])
@@ -118,10 +57,11 @@ AC_CHECK_HEADERS([sys/ioctl.h])
 AC_CHECK_HEADERS([sys/param.h])
 AC_CHECK_HEADERS([sys/select.h])
 AC_CHECK_HEADERS([sys/stat.h])
+AC_CHECK_HEADERS([sys/sysctl.h])
 AC_CHECK_HEADERS([sys/time.h])
 AC_CHECK_HEADERS([sys/types.h])
 AC_CHECK_HEADERS([unistd.h])
-AC_CHECK_HEADERS([net/if.h], [], [], [dnl
+AC_CHECK_HEADERS([arpa/inet.h ifaddrs.h netinet/in.h netinet/tcp.h net/if.h], [], [], [dnl
 #include <stdio.h>
 #ifdef STDC_HEADERS
 # include <stdlib.h>
@@ -148,53 +88,17 @@ AC_CHECK_FUNCS([gettimeofday])
 AC_CHECK_FUNCS([usleep])
 AC_CHECK_FUNCS([nanosleep])
 AC_CHECK_FUNCS([vasprintf])
-
-build_bitbang=no
-build_bitq=no
-is_cygwin=no
-is_mingw=no
-is_win32=no
-is_darwin=no
+AC_CHECK_FUNCS([realpath])
 
 # guess-rev.sh only exists in the repository, not in the released archives
 AC_MSG_CHECKING([whether to build a release])
-if test -x $srcdir/guess-rev.sh ; then
+AS_IF([test -x "$srcdir/guess-rev.sh"], [
   build_release=no
-else
+], [
   build_release=yes
-fi
+])
 AC_MSG_RESULT([$build_release])
 
-AC_ARG_WITH(ftd2xx,
-   AS_HELP_STRING([--with-ftd2xx=<PATH>],[This option has been removed.]),
-  [
-# Option Given.
-cat << __EOF__
-
-The option: --with-ftd2xx=<PATH> has been removed.
-On Linux, the new option is:
-
-  --with-ftd2xx-linux-tardir=/path/to/files
-
-Where <path> is the path the the directory where the "tar.gz" file
-from FTDICHIP.COM was unpacked, for example:
-
-  --with-ftd2xx-linux-tardir=${HOME}/libftd2xx0.4.16
-
-On Cygwin/MingW32, the new option is:
-
-  --with-ftd2xx-win32-zipdir=/path/to/files
-
-Where <path> is the path to the directory where the "zip" file from
-FTDICHIP.COM was unpacked, for example:
-
-  --with-ftd2xx-win32-zipdir=${HOME}/ftd2xx.cdm.files
-
-__EOF__
-
-   AC_MSG_ERROR([Sorry Cannot continue])
-  ], [true])
-
 # Adapter drivers
 # 1st column -- configure option
 # 2nd column -- description
@@ -207,7 +111,6 @@ m4_define([ADAPTER_OPT], [m4_translit(ADAPTER_ARG($1), [_], [-])])
 
 m4_define([USB1_ADAPTERS],
 	[[[ftdi], [MPSSE mode of FTDI based devices], [FTDI]],
-	[[jlink], [Segger J-Link JTAG Programmer], [JLINK]],
 	[[stlink], [ST-Link JTAG Programmer], [HLADAPTER_STLINK]],
 	[[ti_icdi], [TI ICDI JTAG Programmer], [HLADAPTER_ICDI]],
 	[[ulink], [Keil ULINK JTAG Programmer], [ULINK]],
@@ -227,63 +130,17 @@ m4_define([USB0_ADAPTERS],
 m4_define([HIDAPI_ADAPTERS],
 	[[[cmsis_dap], [CMSIS-DAP Compliant Debugger], [CMSIS_DAP]]])
 
-#========================================
-# FTD2XXX support comes in 4 forms.
-#    (1) win32 - via a zip file
-#    (2) linux - via a tar file
-#    (3) linux/cygwin/mingw - via libftdi
-#    (4) darwin - installed under /usr/local
-#
-# In case (1) and (2) we need to know where the package was unpacked.
-
-AC_ARG_WITH(ftd2xx-win32-zipdir,
-  AS_HELP_STRING([--with-ftd2xx-win32-zipdir],[Where (CYGWIN/MINGW) the zip file from ftdichip.com was unpacked (default=search)]),
-  [
-  # option present
-  if test -d $with_ftd2xx_win32_zipdir
-  then
-    with_ftd2xx_win32_zipdir=`cd $with_ftd2xx_win32_zipdir && pwd`
-    AC_MSG_NOTICE([Using: ftdichip.com library: $with_ftd2xx_win32_zipdir])
-  else
-    AC_MSG_ERROR([Parameter to --with-ftd2xx-win32-zipdir is not a dir: $with_ftd2xx_win32_zipdir])
-  fi
-  ], [true])
-
-AC_ARG_WITH(ftd2xx-linux-tardir,
-  AS_HELP_STRING([--with-ftd2xx-linux-tardir], [Where (Linux/Unix) the tar file from ftdichip.com was unpacked (default=search)]),
-  [
-  # Option present
-  if test $is_win32 = yes ; then
-     AC_MSG_ERROR([The option: --with-ftd2xx-linux-tardir is only usable on linux])
-  fi
-  if test -d $with_ftd2xx_linux_tardir
-  then
-    with_ftd2xx_linux_tardir=`cd $with_ftd2xx_linux_tardir && pwd`
-    AC_MSG_NOTICE([Using: ftdichip.com library: $with_ftd2xx_linux_tardir])
-  else
-    AC_MSG_ERROR([Parameter to --with-ftd2xx-linux-tardir is not a dir: $with_ftd2xx_linux_tardir])
-  fi
-  ], [true])
-
-AC_ARG_WITH(ftd2xx-lib,
-  AS_HELP_STRING([--with-ftd2xx-lib],
-    [Use static or shared ftd2xx libs (default=static)]),
-  [
-  case "$withval" in
-  static)
-    with_ftd2xx_lib=$withval
-    ;;
-  shared)
-    with_ftd2xx_lib=$withval
-    ;;
-  *)
-    AC_MSG_ERROR([Option: --with-ftd2xx-lib=static or --with-ftd2xx-lib=shared not, $withval])
-    ;;
-  esac
-  ], [
-  # Default is static - it is simpler :-(
-  with_ftd2xx_lib=static
-  ])
+m4_define([HIDAPI_USB1_ADAPTERS],
+	[[[kitprog], [Cypress KitProg Programmer], [KITPROG]]])
+
+m4_define([LIBFTDI_ADAPTERS],
+	[[[usb_blaster], [Altera USB-Blaster Compatible], [USB_BLASTER]],
+	[[presto], [ASIX Presto Adapter], [PRESTO]],
+	[[openjtag], [OpenJTAG Adapter], [OPENJTAG]]])
+
+m4_define([LIBJAYLINK_ADAPTERS],
+	[[[jlink], [SEGGER J-Link Programmer], [JLINK]]])
+
 
 AC_ARG_ENABLE([doxygen-html],
   AS_HELP_STRING([--disable-doxygen-html],
@@ -313,10 +170,6 @@ AC_ARG_ENABLE([werror],
   AS_HELP_STRING([--disable-werror], [Do not treat warnings as errors]),
   [gcc_werror=$enableval], [gcc_werror=$gcc_warnings])
 
-AC_ARG_ENABLE([gbgcol],
-  AS_HELP_STRING([--disable-gbgcol], [Disable garbage collection of unused functions/variables]),
-  [gcc_gbgcol=$enableval], [gcc_gbgcol=yes])
-
 # set default verbose options, overridden by following options
 debug_jtag_io=no
 debug_usb_io=no
@@ -348,21 +201,21 @@ AC_ARG_ENABLE([verbose_usb_comms],
 
 AC_MSG_CHECKING([whether to enable verbose JTAG I/O messages]);
 AC_MSG_RESULT([$debug_jtag_io])
-if test $debug_jtag_io = yes; then
+AS_IF([test "x$debug_jtag_io" = "xyes"], [
   AC_DEFINE([_DEBUG_JTAG_IO_],[1], [Print verbose JTAG I/O messages])
-fi
+])
 
 AC_MSG_CHECKING([whether to enable verbose USB I/O messages]);
 AC_MSG_RESULT([$debug_usb_io])
-if test $debug_usb_io = yes; then
+AS_IF([test "x$debug_usb_io" = "xyes"], [
   AC_DEFINE([_DEBUG_USB_IO_],[1], [Print verbose USB I/O messages])
-fi
+])
 
 AC_MSG_CHECKING([whether to enable verbose USB communication messages]);
 AC_MSG_RESULT([$debug_usb_comms])
-if test $debug_usb_comms = yes; then
+AS_IF([test "x$debug_usb_comms" = "xyes"], [
   AC_DEFINE([_DEBUG_USB_COMMS_],[1], [Print verbose USB communication messages])
-fi
+])
 
 debug_malloc=no
 AC_ARG_ENABLE([malloc_logging],
@@ -372,9 +225,9 @@ AC_ARG_ENABLE([malloc_logging],
 
 AC_MSG_CHECKING([whether to enable malloc free space logging]);
 AC_MSG_RESULT([$debug_malloc])
-if test $debug_malloc = yes; then
+AS_IF([test "x$debug_malloc" = "xyes"], [
   AC_DEFINE([_DEBUG_FREE_SPACE_],[1], [Include malloc free space in logging])
-fi
+])
 
 AC_ARG_ENABLE([dummy],
   AS_HELP_STRING([--enable-dummy], [Enable building the dummy port driver]),
@@ -389,7 +242,15 @@ m4_define([AC_ARG_ADAPTERS], [
   ])
 ])
 
-AC_ARG_ADAPTERS([USB1_ADAPTERS, USB_ADAPTERS, USB0_ADAPTERS, HIDAPI_ADAPTERS], [auto])
+AC_ARG_ADAPTERS([
+  USB1_ADAPTERS,
+  USB_ADAPTERS,
+  USB0_ADAPTERS,
+  HIDAPI_ADAPTERS,
+  HIDAPI_USB1_ADAPTERS,
+  LIBFTDI_ADAPTERS,
+  LIBJAYLINK_ADAPTERS
+  ],[auto])
 
 AC_ARG_ENABLE([parport],
   AS_HELP_STRING([--enable-parport], [Enable building the pc parallel port driver]),
@@ -405,38 +266,10 @@ AC_ARG_ENABLE([parport_giveio],
       [Enable use of giveio for parport (for CygWin only)]),
     [parport_use_giveio=$enableval], [parport_use_giveio=])
 
-AC_ARG_ENABLE([ft2232_libftdi], [], [
-if test $enableval = yes; then
-  AC_MSG_ERROR([The ft2232 driver is deprecated, use --enable-ftdi to build its replacement, or force the old driver with --enable-legacy-ft2232_libftdi])
-fi
-])
-
-AC_ARG_ENABLE([ft2232_ftd2xx], [], [
-if test $enableval = yes; then
-  AC_MSG_ERROR([The ft2232 driver is deprecated, use --enable-ftdi to build its replacement, or force the old driver with --enable-legacy-ft2232_ftd2xx])
-fi
-])
-
-AC_ARG_ENABLE([legacy-ft2232_libftdi],
-  AS_HELP_STRING([--enable-legacy-ft2232_libftdi], [(DEPRECATED) Enable building support for FT2232 based devices using the libftdi library]),
-  [build_ft2232_libftdi=$enableval], [build_ft2232_libftdi=no])
-
-AC_ARG_ENABLE([legacy-ft2232_ftd2xx],
-  AS_HELP_STRING([--enable-legacy-ft2232_ftd2xx], [(DEPRECATED) Enable building support for FT2232 based devices using the D2XX library from ftdichip.com]),
-  [build_ft2232_ftd2xx=$enableval], [build_ft2232_ftd2xx=no])
-
 AC_ARG_ENABLE([jtag_vpi],
   AS_HELP_STRING([--enable-jtag_vpi], [Enable building support for JTAG VPI]),
   [build_jtag_vpi=$enableval], [build_jtag_vpi=no])
 
-AC_ARG_ENABLE([usb_blaster_libftdi],
-  AS_HELP_STRING([--enable-usb_blaster_libftdi], [Enable building support for the Altera USB-Blaster using the libftdi driver, opensource alternate of FTD2XX]),
-  [build_usb_blaster_libftdi=$enableval], [build_usb_blaster_libftdi=no])
-
-AC_ARG_ENABLE([usb_blaster_ftd2xx],
-  AS_HELP_STRING([--enable-usb_blaster_ftd2xx], [Enable building support for the Altera USB-Blaster using the FTD2XX driver from ftdichip.com]),
-  [build_usb_blaster_ftd2xx=$enableval], [build_usb_blaster_ftd2xx=no])
-
 AC_ARG_ENABLE([amtjtagaccel],
   AS_HELP_STRING([--enable-amtjtagaccel], [Enable building the Amontec JTAG-Accelerator driver]),
   [build_amtjtagaccel=$enableval], [build_amtjtagaccel=no])
@@ -453,8 +286,8 @@ AC_ARG_ENABLE([ioutil],
   AS_HELP_STRING([--enable-ioutil], [Enable ioutil functions - useful for standalone OpenOCD implementations]),
   [build_ioutil=$enableval], [build_ioutil=no])
 
-case "${host_cpu}" in
-  arm*)
+AS_CASE(["${host_cpu}"],
+  [arm*], [
     AC_ARG_ENABLE([ep93xx],
       AS_HELP_STRING([--enable-ep93xx], [Enable building support for EP93xx based SBCs]),
       [build_ep93xx=$enableval], [build_ep93xx=no])
@@ -466,35 +299,21 @@ case "${host_cpu}" in
     AC_ARG_ENABLE([bcm2835gpio],
       AS_HELP_STRING([--enable-bcm2835gpio], [Enable building support for bitbanging on BCM2835 (as found in Raspberry Pi)]),
       [build_bcm2835gpio=$enableval], [build_bcm2835gpio=no])
-    ;;
-
-  *)
+    AC_ARG_ENABLE([imx_gpio],
+      AS_HELP_STRING([--enable-imx_gpio], [Enable building support for bitbanging on NXP IMX processors]),
+      [build_imx_gpio=$enableval], [build_imx_gpio=no])
+  ],
+  [
     build_ep93xx=no
     build_at91rm9200=no
     build_bcm2835gpio=no
-    ;;
-esac
+    build_imx_gpio=no
+])
 
 AC_ARG_ENABLE([gw16012],
   AS_HELP_STRING([--enable-gw16012], [Enable building support for the Gateworks GW16012 JTAG Programmer]),
   [build_gw16012=$enableval], [build_gw16012=no])
 
-AC_ARG_ENABLE([presto_libftdi],
-  AS_HELP_STRING([--enable-presto_libftdi], [Enable building support for ASIX Presto Programmer using the libftdi driver]),
-  [build_presto_libftdi=$enableval], [build_presto_libftdi=no])
-
-AC_ARG_ENABLE([presto_ftd2xx],
-  AS_HELP_STRING([--enable-presto_ftd2xx], [Enable building support for ASIX Presto Programmer using the FTD2XX driver]),
-  [build_presto_ftd2xx=$enableval], [build_presto_ftd2xx=no])
-
-AC_ARG_ENABLE([openjtag_ftd2xx],
-  AS_HELP_STRING([--enable-openjtag_ftd2xx], [Enable building support for the OpenJTAG Programmer with ftd2xx driver]),
-  [build_openjtag_ftd2xx=$enableval], [build_openjtag_ftd2xx=no])
-
-AC_ARG_ENABLE([openjtag_ftdi],
-  AS_HELP_STRING([--enable-openjtag_ftdi], [Enable building support for the OpenJTAG Programmer with ftdi driver]),
-  [build_openjtag_ftdi=$enableval], [build_openjtag_ftdi=no])
-
 AC_ARG_ENABLE([oocd_trace],
   AS_HELP_STRING([--enable-oocd_trace],
   [Enable building support for some prototype OpenOCD+trace ETM capture hardware]),
@@ -508,6 +327,14 @@ AC_ARG_ENABLE([sysfsgpio],
   AS_HELP_STRING([--enable-sysfsgpio], [Enable building support for programming driven via sysfs gpios.]),
   [build_sysfsgpio=$enableval], [build_sysfsgpio=no])
 
+AS_CASE([$host_os],
+  [linux*], [],
+  [
+    AS_IF([test "x$build_sysfsgpio" = "xyes"], [
+      AC_MSG_ERROR([sysfsgpio is only available on linux])
+    ])
+])
+
 AC_ARG_ENABLE([minidriver_dummy],
   AS_HELP_STRING([--enable-minidriver-dummy], [Enable the dummy minidriver.]),
   [build_minidriver_dummy=$enableval], [build_minidriver_dummy=no])
@@ -521,16 +348,20 @@ AC_ARG_ENABLE([internal-libjaylink],
   [Disable building internal libjaylink]),
   [use_internal_libjaylink=$enableval], [use_internal_libjaylink=yes])
 
+AC_ARG_ENABLE([target64],
+  AS_HELP_STRING([--disable-target64], [Disable 64-bit target address]),
+    [build_target64=$enableval], [build_target64=yes])
+
 build_minidriver=no
 AC_MSG_CHECKING([whether to enable ZY1000 minidriver])
-if test $build_zy1000 = yes; then
-  if test $build_minidriver = yes; then
+AS_IF([test "x$build_zy1000" = "xyes"], [
+  AS_IF([test "x$build_minidriver" = "xyes"], [
     AC_MSG_ERROR([Multiple minidriver options have been enabled.])
-  fi
+  ])
   AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
       [Define to 1 if you have the <jtag_minidriver.h> header file.])
   build_minidriver=yes
-fi
+])
 AC_MSG_RESULT([$build_zy1000])
 
 AC_ARG_ENABLE([remote-bitbang],
@@ -538,613 +369,235 @@ AC_ARG_ENABLE([remote-bitbang],
   [build_remote_bitbang=$enableval], [build_remote_bitbang=no])
 
 AC_MSG_CHECKING([whether to enable dummy minidriver])
-if test $build_minidriver_dummy = yes; then
-  if test $build_minidriver = yes; then
+AS_IF([test "x$build_minidriver_dummy" = "xyes"], [
+  AS_IF([test "x$build_minidriver" = "xyes"], [
     AC_MSG_ERROR([Multiple minidriver options have been enabled.])
-  fi
+  ])
   build_minidriver=yes
   AC_DEFINE([BUILD_MINIDRIVER_DUMMY], [1], [Use the dummy minidriver.])
   AC_DEFINE([HAVE_JTAG_MINIDRIVER_H], [1],
       [Define to 1 if you have the <jtag_minidriver.h> header file.])
-fi
+])
 AC_MSG_RESULT([$build_minidriver_dummy])
 
 AC_MSG_CHECKING([whether standard drivers can be built])
-if test "$build_minidriver" = yes; then
+AS_IF([test "x$build_minidriver" = "xyes"], [
   AC_MSG_RESULT([no])
   AC_MSG_WARN([Using the minidriver disables all other drivers.])
   sleep 2
-else
+], [
   AC_MSG_RESULT([yes])
-fi
+])
 
-case "${host_cpu}" in
-  i?86|x86*)
-    ;;
-  *)
-    if test x$parport_use_ppdev = xno; then
+AS_CASE(["${host_cpu}"],
+  [i?86|x86*], [],
+  [
+    AS_IF([test "x$parport_use_ppdev" = "xno"], [
       AC_MSG_WARN([--disable-parport-ppdev is not supported by the host CPU])
-    fi
+    ])
     parport_use_ppdev=yes
-    ;;
-esac
+])
 
-case $host in
-  *-cygwin*)
+AS_CASE([$host],
+  [*-cygwin*], [
     is_win32=yes
     parport_use_ppdev=no
 
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [[return __MINGW32__;]])],
       [is_mingw=yes],[is_mingw=no])
-    if test $is_mingw = yes; then
-      AC_DEFINE([IS_MINGW], [1], [1 if building for MinGW.])
-      if test x$parport_use_giveio = xno; then
+    AS_IF([test "x$is_mingw" = "xyes"], [
+      AS_IF([test "x$parport_use_giveio" = "xno"], [
         AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
-      fi
+      ])
       parport_use_giveio=yes
       is_cygwin=no
-    else
+    ], [
       is_cygwin=yes
-      AC_DEFINE([IS_CYGWIN], [1], [1 if building for Cygwin.])
       # sys/io.h needed under cygwin for parport access
-      if test $build_parport = yes; then
+      AS_IF([test "x$build_parport" = "xyes"], [
         AC_CHECK_HEADERS([sys/io.h],[],AC_MSG_ERROR([Please install the cygwin ioperm package]))
-      fi
-    fi
-
-    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
-    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
-    ;;
-  *-mingw*)
+      ])
+    ])
+  ],
+  [*-mingw* | *-msys*], [
     is_mingw=yes
     is_win32=yes
     parport_use_ppdev=no
 
-    if test x$parport_use_giveio = xno; then
+    AS_IF([test "x$parport_use_giveio" = "xno"], [
       AC_MSG_WARN([--disable-parport-giveio is not supported by MinGW32 hosts])
-    fi
+    ])
     parport_use_giveio=yes
 
-    if test x$build_buspirate = xyes; then
+    AS_IF([test "x$build_buspirate" = "xyes"], [
       AC_MSG_ERROR([buspirate currently not supported by MinGW32 hosts])
-    fi
-
-    CFLAGS="$CFLAGS -D__USE_MINGW_ANSI_STDIO"
+    ])
 
-    AC_DEFINE([IS_MINGW], [1], [1 if building for MinGW.])
-    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
-    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
-    ;;
-  *darwin*)
+    AC_SUBST([HOST_CPPFLAGS], [-D__USE_MINGW_ANSI_STDIO])
+  ],
+  [*darwin*], [
     is_darwin=yes
 
-    if test x$parport_use_giveio = xyes; then
+    AS_IF([test "x$parport_use_giveio" = "xyes"], [
       AC_MSG_WARN([--enable-parport-giveio cannot be used by Darwin hosts])
-    fi
+    ])
     parport_use_giveio=no
-
-	gcc_gbgcol=no
-
-    AC_DEFINE([IS_CYGWIN], [0], [0 if not building for Cygwin.])
-    AC_DEFINE([IS_WIN32], [0], [0 if not building for Win32.])
-    AC_DEFINE([IS_DARWIN], [1], [1 if building for Darwin.])
-    ;;
-  *)
-    if test x$parport_use_giveio = xyes; then
+  ],
+  [
+    AS_IF([test "x$parport_use_giveio" = "xyes"], [
       AC_MSG_WARN([--enable-parport-giveio cannot be used by ]$host[ hosts])
-    fi
+    ])
     parport_use_giveio=no
+])
+
+AS_IF([test "x$is_cygwin" = "xyes"], [
+    AC_DEFINE([IS_CYGWIN], [1], [1 if building for Cygwin.])
+], [
     AC_DEFINE([IS_CYGWIN], [0], [0 if not building for Cygwin.])
+])
+
+AS_IF([test "x$is_mingw" = "xyes"], [
+    AC_DEFINE([IS_MINGW], [1], [1 if building for Mingw.])
+], [
+    AC_DEFINE([IS_MINGW], [0], [0 if not building for Mingw.])
+])
+
+AS_IF([test "x$is_win32" = "xyes"], [
+    AC_DEFINE([IS_WIN32], [1], [1 if building for Win32.])
+], [
     AC_DEFINE([IS_WIN32], [0], [0 if not building for Win32.])
-    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
-    ;;
-esac
+])
 
-if test $is_win32 = yes; then
-    AC_DEFINE([WIN32_LEAN_AND_MEAN], [1], [1 to exclude old conflicting definitions when building on Windows])
-fi
+AS_IF([test "x$is_darwin" = "xyes"], [
+    AC_DEFINE([IS_DARWIN], [1], [1 if building for Darwin.])
+], [
+    AC_DEFINE([IS_DARWIN], [0], [0 if not building for Darwin.])
+])
 
-if test $build_parport = yes; then
+AS_IF([test "x$build_parport" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_PARPORT], [1], [1 if you want parport.])
-else
+], [
   AC_DEFINE([BUILD_PARPORT], [0], [0 if you don't want parport.])
-fi
+])
 
-if test $build_dummy = yes; then
+AS_IF([test "x$build_dummy" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_DUMMY], [1], [1 if you want dummy driver.])
-else
+], [
   AC_DEFINE([BUILD_DUMMY], [0], [0 if you don't want dummy driver.])
-fi
+])
 
-if test $build_ep93xx = yes; then
+AS_IF([test "x$build_ep93xx" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_EP93XX], [1], [1 if you want ep93xx.])
-else
+], [
   AC_DEFINE([BUILD_EP93XX], [0], [0 if you don't want ep93xx.])
-fi
+])
 
-if test $build_zy1000 = yes; then
+AS_IF([test "x$build_zy1000" = "xyes"], [
   AC_DEFINE([BUILD_ZY1000], [1], [1 if you want ZY1000.])
-else
+], [
   AC_DEFINE([BUILD_ZY1000], [0], [0 if you don't want ZY1000.])
-fi
+])
 
-if test $build_zy1000_master = yes; then
+AS_IF([test "x$build_zy1000_master" = "xyes"], [
   AC_DEFINE([BUILD_ZY1000_MASTER], [1], [1 if you want ZY1000 JTAG master registers.])
-else
+], [
   AC_DEFINE([BUILD_ZY1000_MASTER], [0], [0 if you don't want ZY1000 JTAG master registers.])
-fi
+])
 
-if test $build_at91rm9200 = yes; then
+AS_IF([test "x$build_at91rm9200" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_AT91RM9200], [1], [1 if you want at91rm9200.])
-else
+], [
   AC_DEFINE([BUILD_AT91RM9200], [0], [0 if you don't want at91rm9200.])
-fi
+])
 
-if test $build_bcm2835gpio = yes; then
+AS_IF([test "x$build_bcm2835gpio" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_BCM2835GPIO], [1], [1 if you want bcm2835gpio.])
-else
+], [
   AC_DEFINE([BUILD_BCM2835GPIO], [0], [0 if you don't want bcm2835gpio.])
-fi
+])
+
+AS_IF([test "x$build_imx_gpio" = "xyes"], [
+  build_bitbang=yes
+  AC_DEFINE([BUILD_IMX_GPIO], [1], [1 if you want imx_gpio.])
+], [
+  AC_DEFINE([BUILD_IMX_GPIO], [0], [0 if you don't want imx_gpio.])
+])
 
-if test x$parport_use_ppdev = xyes; then
+AS_IF([test "x$parport_use_ppdev" = "xyes"], [
   AC_DEFINE([PARPORT_USE_PPDEV], [1], [1 if you want parport to use ppdev.])
-else
+], [
   AC_DEFINE([PARPORT_USE_PPDEV], [0], [0 if you don't want parport to use ppdev.])
-fi
+])
 
-if test x$parport_use_giveio = xyes; then
+AS_IF([test "x$parport_use_giveio" = "xyes"], [
   AC_DEFINE([PARPORT_USE_GIVEIO], [1], [1 if you want parport to use giveio.])
-else
+], [
   AC_DEFINE([PARPORT_USE_GIVEIO], [0], [0 if you don't want parport to use giveio.])
-fi
-
-if test $build_bitbang = yes; then
-  AC_DEFINE([BUILD_BITBANG], [1], [1 if you want a bitbang interface.])
-else
-  AC_DEFINE([BUILD_BITBANG], [0], [0 if you don't want a bitbang interface.])
-fi
-
-if test $build_ft2232_libftdi = yes; then
-  AC_DEFINE([BUILD_FT2232_LIBFTDI], [1], [1 if you want libftdi ft2232.])
-else
-  AC_DEFINE([BUILD_FT2232_LIBFTDI], [0], [0 if you don't want libftdi ft2232.])
-fi
-
-if test $build_ft2232_ftd2xx = yes; then
-  AC_DEFINE([BUILD_FT2232_FTD2XX], [1], [1 if you want ftd2xx ft2232.])
-else
-  AC_DEFINE([BUILD_FT2232_FTD2XX], [0], [0 if you don't want ftd2xx ft2232.])
-fi
-
-if test $build_usb_blaster_libftdi = yes; then
-  AC_DEFINE([BUILD_USB_BLASTER_LIBFTDI], [1], [1 if you want libftdi usb_blaster.])
-else
-  AC_DEFINE([BUILD_USB_BLASTER_LIBFTDI], [0], [0 if you don't want libftdi usb_blaster.])
-fi
-
-if test $build_jtag_vpi = yes; then
+])
+
+AS_IF([test "x$build_jtag_vpi" = "xyes"], [
   AC_DEFINE([BUILD_JTAG_VPI], [1], [1 if you want JTAG VPI.])
-else
+], [
   AC_DEFINE([BUILD_JTAG_VPI], [0], [0 if you don't want JTAG VPI.])
-fi
-
-if test $build_usb_blaster_ftd2xx = yes; then
-  AC_DEFINE([BUILD_USB_BLASTER_FTD2XX], [1], [1 if you want ftd2xx usb_blaster.])
-else
-  AC_DEFINE([BUILD_USB_BLASTER_FTD2XX], [0], [0 if you don't want ftd2xx usb_blaster.])
-fi
+])
 
-if test $build_amtjtagaccel = yes; then
+AS_IF([test "x$build_amtjtagaccel" = "xyes"], [
   AC_DEFINE([BUILD_AMTJTAGACCEL], [1], [1 if you want the Amontec JTAG-Accelerator driver.])
-else
+], [
   AC_DEFINE([BUILD_AMTJTAGACCEL], [0], [0 if you don't want the Amontec JTAG-Accelerator driver.])
-fi
+])
 
-if test $build_gw16012 = yes; then
+AS_IF([test "x$build_gw16012" = "xyes"], [
   AC_DEFINE([BUILD_GW16012], [1], [1 if you want the Gateworks GW16012 driver.])
-else
+], [
   AC_DEFINE([BUILD_GW16012], [0], [0 if you don't want the Gateworks GW16012 driver.])
-fi
-
-if test $build_presto_libftdi = yes; then
-  build_bitq=yes
-  AC_DEFINE([BUILD_PRESTO_LIBFTDI], [1], [1 if you want the ASIX PRESTO driver using libftdi.])
-else
-  AC_DEFINE([BUILD_PRESTO_LIBFTDI], [0], [0 if you don't want the ASIX PRESTO driver using libftdi.])
-fi
+])
 
-if test $build_presto_ftd2xx = yes; then
-  build_bitq=yes
-  AC_DEFINE([BUILD_PRESTO_FTD2XX], [1], [1 if you want the ASIX PRESTO driver using FTD2XX.])
-else
-  AC_DEFINE([BUILD_PRESTO_FTD2XX], [0], [0 if you don't want the ASIX PRESTO driver using FTD2XX.])
-fi
-
-if test $build_bitq = yes; then
-  AC_DEFINE([BUILD_BITQ], [1], [1 if you want a bitq interface.])
-else
-  AC_DEFINE([BUILD_BITQ], [0], [0 if you don't want a bitq interface.])
-fi
-
-AC_DEFINE([BUILD_OPENJTAG], [0], [0 if you don't want the OpenJTAG driver.])
-AC_DEFINE([BUILD_OPENJTAG_FTD2XX], [0], [0 if you don't want the OpenJTAG driver with FTD2XX driver.])
-AC_DEFINE([BUILD_OPENJTAG_LIBFTDI], [0], [0 if you don't want to build OpenJTAG driver with libftdi.])
-
-if test $build_openjtag_ftd2xx = yes; then
-  AC_DEFINE([BUILD_OPENJTAG], [1], [1 if you want the OpenJTAG driver.])
-  AC_DEFINE([BUILD_OPENJTAG_FTD2XX], [1], [1 if you want the OpenJTAG driver with FTD2XX driver.])
-fi
-if test $build_openjtag_ftdi = yes; then
-  AC_DEFINE([BUILD_OPENJTAG], [1], [1 if you want the OpenJTAG drvier.])
-  AC_DEFINE([BUILD_OPENJTAG_LIBFTDI], [1], [1 if you want to build OpenJTAG with FTDI driver.])
-fi
-
-if test $build_oocd_trace = yes; then
+AS_IF([test "x$build_oocd_trace" = "xyes"], [
   AC_DEFINE([BUILD_OOCD_TRACE], [1], [1 if you want the OpenOCD+trace ETM capture driver.])
-else
+], [
   AC_DEFINE([BUILD_OOCD_TRACE], [0], [0 if you don't want the OpenOCD+trace ETM capture driver.])
-fi
+])
 
-if test $build_buspirate = yes; then
+AS_IF([test "x$build_buspirate" = "xyes"], [
   AC_DEFINE([BUILD_BUSPIRATE], [1], [1 if you want the Buspirate JTAG driver.])
-else
+], [
   AC_DEFINE([BUILD_BUSPIRATE], [0], [0 if you don't want the Buspirate JTAG driver.])
-fi
+])
 
-if test $use_internal_jimtcl = yes; then
-  if test -f "$srcdir/jimtcl/configure.ac"; then
+AS_IF([test "x$use_internal_jimtcl" = "xyes"], [
+  AS_IF([test -f "$srcdir/jimtcl/configure.ac"], [
     AX_CONFIG_SUBDIR_OPTION([jimtcl], [--disable-install-jim])
-  else
+  ], [
     AC_MSG_ERROR([jimtcl not found, run git submodule init and git submodule update.])
-  fi
-fi
+  ])
+])
 
-if test $use_internal_libjaylink = yes; then
-  if test -f "$srcdir/src/jtag/drivers/libjaylink/configure.ac"; then
-    ( cd $srcdir/src/jtag/drivers/libjaylink/ && ./autogen.sh )
-    AX_CONFIG_SUBDIR_OPTION([src/jtag/drivers/libjaylink],
-		[--enable-subproject-build])
-  else
-    AC_MSG_ERROR([Internal libjaylink not found, run either 'git submodule init' and 'git submodule update' or disable internal libjaylink with --disable-internal-libjaylink.])
-  fi
-else
-  PKG_CHECK_MODULES([libjaylink], [libjaylink >= 0.1],
-	[CFLAGS="$CFLAGS $libjaylink_CFLAGS"; LIBS="$LIBS $libjaylink_LIBS"; HAVE_LIBJAYLINK=yes], [HAVE_LIBJAYLINK=no])
-fi
-
-if test $build_remote_bitbang = yes; then
+AS_IF([test "x$build_remote_bitbang" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_REMOTE_BITBANG], [1], [1 if you want the Remote Bitbang JTAG driver.])
-else
+], [
   AC_DEFINE([BUILD_REMOTE_BITBANG], [0], [0 if you don't want the Remote Bitbang JTAG driver.])
-fi
+])
 
-if test $build_sysfsgpio = yes; then
+AS_IF([test "x$build_sysfsgpio" = "xyes"], [
   build_bitbang=yes
   AC_DEFINE([BUILD_SYSFSGPIO], [1], [1 if you want the SysfsGPIO driver.])
-else
+], [
   AC_DEFINE([BUILD_SYSFSGPIO], [0], [0 if you don't want SysfsGPIO driver.])
-fi
-#-- Deal with MingW/Cygwin FTD2XX issues
-
-if test $is_win32 = yes; then
-if test "${with_ftd2xx_linux_tardir+set}" = set
-then
-  AC_MSG_ERROR([The option: with_ftd2xx_linux_tardir is for LINUX only.])
-fi
-
-if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes -o $build_openjtag_ftd2xx = yes; then
-  AC_MSG_CHECKING([for ftd2xx.lib exists (win32)])
-
-  # if we are given a zipdir...
-  if test "${with_ftd2xx_win32_zipdir+set}" = set
-  then
-    # Set the CFLAGS for "ftd2xx.h"
-    f=$with_ftd2xx_win32_zipdir/ftd2xx.h
-    if test ! -f $f ; then
-      AC_MSG_ERROR([File: $f cannot be found])
-    fi
-    CFLAGS="$CFLAGS -I$with_ftd2xx_win32_zipdir"
-
-    # And calculate the LDFLAGS for the machine
-    case "$host_cpu" in
-    i?86|x86_32)
-      LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/i386"
-      LIBS="$LIBS -lftd2xx"
-      f=$with_ftd2xx_win32_zipdir/i386/ftd2xx.lib
-      ;;
-    amd64|x86_64)
-      LDFLAGS="$LDFLAGS -L$with_ftd2xx_win32_zipdir/amd64"
-      LIBS="$LIBS -lftd2xx"
-      f=$with_ftd2xx_win32_zipdir/amd64/ftd2xx.lib
-      ;;
-    *)
-      AC_MSG_ERROR([Unknown Win32 host cpu: $host_cpu])
-      ;;
-    esac
-    if test ! -f $f ; then
-         AC_MSG_ERROR([Library: $f not found])
-    fi
-  else
-    LIBS="$LIBS -lftd2xx"
-    AC_MSG_WARN([ASSUMPTION: The (win32) FTDICHIP.COM files: ftd2xx.h and ftd2xx.lib are in a proper place])
-  fi
-fi
-fi # win32
-
-if test $is_darwin = yes ; then
-if test "${with_ftd2xx_win32_zipdir+set}" = set
-then
-   AC_MSG_ERROR([The option: --with-ftd2xx-win32-zipdir is for win32 only])
-fi
-if test "${with_ftd2xx_linux_tardir+set}" = set
-then
-   AC_MSG_ERROR([The option: with_ftd2xx_linux_tardir is for LINUX only.])
-fi
-
-if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
-   AC_MSG_CHECKING([for libftd2xx.a (darwin)])
-
-   if test ! -f /usr/local/include/ftd2xx.h ; then
-      AC_MSG_ERROR([ftd2xx library from FTDICHIP.com seems to be missing, cannot find: /usr/local/include/ftd2xx.h])
-   fi
-
-   CFLAGS="$CFLAGS -I/usr/local/include"
-   LDFLAGS="$LDFLAGS -L/usr/local/lib"
-   LIBS="$LIBS -lftd2xx"
-   AC_MSG_RESULT([-L/usr/local/lib -lftd2xx])
-fi
-fi # darwin
-
-if test $is_win32 = no && test $is_darwin = no ; then
-
-if test "${with_ftd2xx_win32_zipdir+set}" = set
-then
-   AC_MSG_ERROR([The option: --with-ftd2xx-win32-zipdir is for win32 only])
-fi
-
-if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes -o $build_openjtag_ftd2xx = yes; then
-   # Must be linux
-   if test $host_os != linux-gnu && test $host_os != linux ; then
-      AC_MSG_ERROR([The (linux) ftd2xx library from FTDICHIP.com is linux only. Try --enable-ft2232-libftdi instead])
-  fi
-  # Are we given a TAR directory?
-  if test "${with_ftd2xx_linux_tardir+set}" = set
-  then
-    AC_MSG_CHECKING([uninstalled ftd2xx distribution])
-    # The .H file is simple..
-    FTD2XX_H=$with_ftd2xx_linux_tardir/ftd2xx.h
-    if test ! -f "${FTD2XX_H}"; then
-    AC_MSG_ERROR([Option: --with-ftd2xx-linux-tardir appears wrong, cannot find: ${FTD2XX_H}])
-    fi
-    CFLAGS="$CFLAGS -I$with_ftd2xx_linux_tardir"
-    if test $with_ftd2xx_lib = shared; then
-       FTD2XX_LDFLAGS="-L$with_ftd2xx_linux_tardir"
-       FTD2XX_LIB="-lftd2xx"
-    else
-      # Test #1 - v1.0.x
-      case "$host_cpu" in
-      i?86|x86_32)
-              dir=build/i386;;
-      amd64|x86_64)
-              dir=build/x86_64;;
-      *)
-              dir=none;;
-      esac
-      if test -f "$with_ftd2xx_linux_tardir/$dir/libftd2xx.a"; then
-          FTD2XX_LDFLAGS="-L$with_ftd2xx_linux_tardir/$dir"
-          # Also needs -lrt
-          FTD2XX_LIB="-lftd2xx -lrt"
-      else
-        # Test Number2.
-        # Grr.. perhaps it exists as a version number?
-        FTD2XX_LIB="$with_ftd2xx_linux_tardir/static_lib/libftd2xx.a.*.*.*"
-        count=`ls ${FTD2XX_LIB} | wc -l`
-        if test $count -gt 1 ; then
-          AC_MSG_ERROR([Multiple libftd2xx.a files found in: $with_ftd2xx_linux_tardir/static_lib sorry cannot handle this yet])
-        fi
-        if test $count -ne 1 ; then
-          AC_MSG_ERROR([Not found: $f, option: --with-ftd2xx-linux-tardir appears to be wrong])
-        fi
-        # Because the "-l" rules do not understand version numbers...
-        # we will just stuff the absolute path onto the LIBS variable
-        FTD2XX_LIB="`ls ${FTD2XX_LIB}` -lpthread"
-        FTD2XX_LDFLAGS=""
-      fi
-    fi
-    LDFLAGS="${LDFLAGS} ${FTD2XX_LDFLAGS}"
-    LIBS="${FTD2XX_LIB} ${LIBS}"
-    AC_MSG_RESULT([${FTD2XX_LDFLAGS} ${FTD2XX_LIB}])
-  else
-    AC_CHECK_HEADER([ftd2xx.h],[],[
-        AC_MSG_ERROR([You seem to be missing the FTD2xx driver header file.])
-      ])
-    AC_SEARCH_LIBS([FT_GetLibraryVersion],[ftd2xx],,[
-        AC_MSG_ERROR([You appear to be missing the FTD2xx driver library.])
-      ],[-lrt -lusb-1.0])
-  fi
-fi
-fi # linux
-
-if test $build_ft2232_ftd2xx = yes -o $build_presto_ftd2xx = yes -o $build_usb_blaster_ftd2xx = yes ; then
-
-# Before we go any further - make sure we can *BUILD* and *RUN*
-# a simple app with the "ftd2xx.lib" file - in what ever form we where given
-# We should be able to compile, link and run this test program now
-AC_MSG_CHECKING([whether ftd2xx library works])
-
-#
-# Save the LDFLAGS for later..
-LDFLAGS_SAVE=$LDFLAGS
-CFLAGS_SAVE=$CFLAGS
-_LDFLAGS=`eval echo $LDFLAGS`
-_CFLAGS=`eval echo $CFLAGS`
-LDFLAGS=$_LDFLAGS
-CFLAGS=$_CFLAGS
-
-AC_RUN_IFELSE([AC_LANG_PROGRAM([[
-#include "confdefs.h"
-#if IS_WIN32
-#include "windows.h"
-#endif
-#include <stdio.h>
-#include <ftd2xx.h>
-  ]], [[
-  DWORD x;
-  FT_GetLibraryVersion( &x );
-  ]])], [
-    AC_MSG_RESULT([Success!])
-  ], [
-    AC_MSG_ERROR([Cannot build & run test program using ftd2xx.lib])
-  ], [
-    AC_MSG_RESULT([Skipping as we are cross-compiling])
-  ])
-
-AC_MSG_CHECKING([for ftd2xx highspeed device support])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include "confdefs.h"
-#if IS_WIN32
-#include "windows.h"
-#endif
-#include <stdio.h>
-#include <ftd2xx.h>
-
-DWORD x = FT_DEVICE_4232H;
-    ]], [])], [
-      AC_DEFINE([BUILD_FT2232_HIGHSPEED], [1],
-        [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
-      build_ft2232_highspeed=yes
-    ], [
-      build_ft2232_highspeed=no
-    ])
-  AC_MSG_RESULT([$build_ft2232_highspeed])
-
-  if test $build_ft2232_highspeed = no; then
-    AC_MSG_WARN([You need a newer FTD2XX driver (version 2.04.16 or later).])
-  fi
-
-AC_MSG_CHECKING([for ftd2xx FT232H device support])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include "confdefs.h"
-#if IS_WIN32
-#include "windows.h"
-#endif
-#include <stdio.h>
-#include <ftd2xx.h>
-
-DWORD x = FT_DEVICE_232H;
-    ]], [])], [
-      AC_DEFINE([HAS_ENUM_FT232H], [1],
-        [Support FT232H with FTD2XX or libftdi.])
-      has_enum_ft232h=yes
-    ], [
-      has_enum_ft232h=no
-    ])
-  AC_MSG_RESULT([$has_enum_ft232h])
-
-  if test $has_enum_ft232h = no; then
-    AC_MSG_WARN([You need a newer FTD2XX driver (version 2.08.12 or later).])
-  fi
-
-LDFLAGS=$LDFLAGS_SAVE
-CFLAGS=$CFLAGS_SAVE
-fi
-
-if test $build_ft2232_libftdi = yes -o $build_usb_blaster_libftdi = yes -o \
-  $build_openjtag_ftdi = yes -o $build_presto_libftdi = yes; then
-
-  # we can have libftdi or libftdi1, so check it and use the latest one
-  PKG_CHECK_MODULES([LIBFTDI], [libftdi1], [use_libftdi=yes], [use_libftdi=no])
-  if test $use_libftdi = no; then
-	PKG_CHECK_MODULES([LIBFTDI], [libftdi], [use_libftdi=yes], [use_libftdi=no])
-  fi
-  if test $use_libftdi = no; then
-	AC_MSG_ERROR([The libftdi driver is not present on your system.])
-  fi
-
-  #
-  # Try to build a small program.
-  AC_MSG_CHECKING([Build & Link with libftdi...])
-
-  LDFLAGS_SAVE=$LDFLAGS
-  CFLAGS_SAVE=$CFLAGS
-  LIBS_SAVE=$LIBS
-  _LDFLAGS=`eval echo $LDFLAGS`
-  _CFLAGS=`eval echo $CFLAGS`
-  _LIBS=`eval echo $LIBS`
-  LDFLAGS=$_LDFLAGS
-  CFLAGS="$_CFLAGS $LIBFTDI_CFLAGS"
-  LIBS="$_LIBS $LIBFTDI_LIBS"
-
-  AC_RUN_IFELSE([AC_LANG_PROGRAM([[
-#include <stdio.h>
-#include <ftdi.h>
-  ]], [[
-  struct ftdi_context *p;
-  p = ftdi_new();
-  if( p != NULL ){
-      return 0;
-  } else {
-      fprintf( stderr, "calling ftdi_new() failed\n");
-      return 1;
-        }
-    ]])], [
-      AC_MSG_RESULT([Success])
-    ], [
-      AC_MSG_ERROR([Cannot build & run test program using libftdi])
-    ], [
-      AC_MSG_RESULT([Skipping as we are cross-compiling, trying build only])
-      AC_SEARCH_LIBS([ftdi_new], [], [], [AC_MSG_ERROR([Cannot link with libftdi])])
-    ])
-
-AC_MSG_CHECKING([for libftdi highspeed device support])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <stdio.h>
-#include <ftdi.h>
-  ]], [[
-enum ftdi_chip_type x = TYPE_2232H;
-    ]])], [
-      AC_DEFINE([BUILD_FT2232_HIGHSPEED], [1],
-        [Support FT2232H/FT4232HS with FTD2XX or libftdi.])
-      build_ft2232_highspeed=yes
-    ], [
-      build_ft2232_highspeed=no
-    ])
-    AC_MSG_RESULT([$build_ft2232_highspeed])
-
-    if test $build_ft2232_highspeed = no; then
-      AC_MSG_WARN([You need a newer libftdi version (0.16 or later).])
-    fi
-
-AC_MSG_CHECKING([for libftdi FT232H device support])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#include <stdio.h>
-#include <ftdi.h>
-  ]], [[
-enum ftdi_chip_type x = TYPE_232H;
-    ]])], [
-      AC_DEFINE([HAS_ENUM_FT232H], [1],
-        [Support FT232H with FTD2XX or libftdi.])
-      has_enum_ft232h=yes
-    ], [
-      has_enum_ft232h=no
-    ])
-    AC_MSG_RESULT([$has_enum_ft232h])
+])
 
-    if test $has_enum_ft232h = no; then
-      AC_MSG_WARN([You need a newer libftdi version (0.20 or later).])
-    fi
+AS_IF([test "x$build_target64" = "xyes"], [
+  AC_DEFINE([BUILD_TARGET64], [1], [1 if you want 64-bit addresses.])
+], [
+  AC_DEFINE([BUILD_TARGET64], [0], [0 if you don't want 64-bit addresses.])
+])
 
-  # Restore the 'unexpanded ldflags'
-  LDFLAGS=$LDFLAGS_SAVE
-  CFLAGS=$CFLAGS_SAVE
-  LIBS=$LIBS_SAVE
-fi
 
 PKG_CHECK_MODULES([LIBUSB1], [libusb-1.0], [
 	use_libusb1=yes
@@ -1154,6 +607,8 @@ PKG_CHECK_MODULES([LIBUSB1], [libusb-1.0], [
 		[AC_MSG_WARN([libusb-1.x older than 1.0.9 detected, consider updating])])
 	LIBUSB1_CFLAGS=`echo $LIBUSB1_CFLAGS | sed 's/-I/-isystem /'`
 	AC_MSG_NOTICE([libusb-1.0 header bug workaround: LIBUSB1_CFLAGS changed to "$LIBUSB1_CFLAGS"])
+	PKG_CHECK_EXISTS([libusb-1.0 >= 1.0.16],
+		[AC_DEFINE([HAVE_LIBUSB_GET_PORT_NUMBERS], [1], [Define if your libusb has libusb_get_port_numbers()])])
   ], [
 	use_libusb1=no
 	AC_MSG_WARN([libusb-1.x not found, trying legacy libusb-0.1 as a fallback; consider installing libusb-1.x instead])
@@ -1170,84 +625,106 @@ for hidapi_lib in hidapi hidapi-hidraw hidapi-libusb; do
 	])
 done
 
+PKG_CHECK_MODULES([LIBFTDI], [libftdi1], [use_libftdi=yes], [
+	PKG_CHECK_MODULES([LIBFTDI], [libftdi], [use_libftdi=yes], [use_libftdi=no])
+])
+
+PKG_CHECK_MODULES([LIBJAYLINK], [libjaylink >= 0.2],
+	[use_libjaylink=yes], [use_libjaylink=no])
+
 m4_define([PROCESS_ADAPTERS], [
   m4_foreach([adapter], [$1], [
-	if test $2; then
-		if test $ADAPTER_VAR([adapter]) != no; then
+	AS_IF([test $2], [
+		AS_IF([test "x$ADAPTER_VAR([adapter])" != "xno"], [
 			AC_DEFINE([BUILD_]ADAPTER_SYM([adapter]), [1], [1 if you want the ]ADAPTER_DESC([adapter]).)
-		else
+		], [
 			AC_DEFINE([BUILD_]ADAPTER_SYM([adapter]), [0], [0 if you do not want the ]ADAPTER_DESC([adapter]).)
-		fi
-	else
-		if test $ADAPTER_VAR([adapter]) = yes; then
+		])
+	], [
+		AS_IF([test "x$ADAPTER_VAR([adapter])" = "xyes"], [
 			AC_MSG_ERROR([$3 is required for the ADAPTER_DESC([adapter])])
-		fi
+		])
 		ADAPTER_VAR([adapter])=no
-	fi
-	AM_CONDITIONAL(ADAPTER_SYM([adapter]), [test $ADAPTER_VAR([adapter]) != no])
+	])
+	AM_CONDITIONAL(ADAPTER_SYM([adapter]), [test "x$ADAPTER_VAR([adapter])" != "xno"])
   ])
 ])
 
-PROCESS_ADAPTERS([USB1_ADAPTERS], [$use_libusb1 = yes], [libusb-1.x])
-PROCESS_ADAPTERS([USB_ADAPTERS], [$use_libusb1 = yes -o $use_libusb0 = yes], [libusb-1.x or libusb-0.1])
-PROCESS_ADAPTERS([USB0_ADAPTERS], [$use_libusb0 = yes], [libusb-0.1])
-PROCESS_ADAPTERS([HIDAPI_ADAPTERS], [$use_hidapi = yes], [hidapi])
+PROCESS_ADAPTERS([USB1_ADAPTERS], ["x$use_libusb1" = "xyes"], [libusb-1.x])
+PROCESS_ADAPTERS([USB_ADAPTERS], ["x$use_libusb1" = "xyes" -o "x$use_libusb0" = "xyes"], [libusb-1.x or libusb-0.1])
+PROCESS_ADAPTERS([USB0_ADAPTERS], ["x$use_libusb0" = "xyes"], [libusb-0.1])
+PROCESS_ADAPTERS([HIDAPI_ADAPTERS], ["x$use_hidapi" = "xyes"], [hidapi])
+PROCESS_ADAPTERS([HIDAPI_USB1_ADAPTERS], ["x$use_hidapi" = "xyes" -a "x$use_libusb1" = "xyes"], [hidapi and libusb-1.x])
+PROCESS_ADAPTERS([LIBFTDI_ADAPTERS], ["x$use_libftdi" = "xyes"], [libftdi])
+PROCESS_ADAPTERS([LIBJAYLINK_ADAPTERS], ["x$use_internal_libjaylink" = "xyes" -o "x$use_libjaylink" = "xyes"], [libjaylink-0.1])
+
+AS_IF([test "x$build_openjtag" = "xyes"], [
+  AS_IF([test "x$use_libusb1" != "xyes" -a "x$use_libusb0" != "xyes"], [
+    AC_MSG_ERROR([libusb-1.x or libusb-0.1 is required for the OpenJTAG Programmer])
+    build_openjtag=no
+  ])
+])
 
-if test $enable_stlink != no -o $enable_ti_icdi != no; then
+AS_IF([test "x$enable_stlink" != "xno" -o "x$enable_ti_icdi" != "xno"], [
 	AC_DEFINE([BUILD_HLADAPTER], [1], [1 if you want the High Level JTAG driver.])
-else
+], [
 	AC_DEFINE([BUILD_HLADAPTER], [0], [0 if you want the High Level JTAG driver.])
-fi
-AM_CONDITIONAL([HLADAPTER], [test $enable_stlink != no -o $enable_ti_icdi != no])
-
-# Disable J-Link driver if internal libjaylink is disabled and libjaylink was
-# not found by pkg-config.
-if test $enable_jlink != no; then
-  if test $use_internal_libjaylink$HAVE_LIBJAYLINK = nono; then
-      enable_jlink=no
-  fi
-fi
-
-AM_CONDITIONAL([RELEASE], [test $build_release = yes])
-AM_CONDITIONAL([PARPORT], [test $build_parport = yes])
-AM_CONDITIONAL([DUMMY], [test $build_dummy = yes])
-AM_CONDITIONAL([GIVEIO], [test x$parport_use_giveio = xyes])
-AM_CONDITIONAL([EP93XX], [test $build_ep93xx = yes])
-AM_CONDITIONAL([ZY1000], [test $build_zy1000 = yes])
-AM_CONDITIONAL([ZY1000_MASTER], [test $build_zy1000_master = yes])
-AM_CONDITIONAL([IOUTIL], [test $build_ioutil = yes])
-AM_CONDITIONAL([AT91RM9200], [test $build_at91rm9200 = yes])
-AM_CONDITIONAL([BCM2835GPIO], [test $build_bcm2835gpio = yes])
-AM_CONDITIONAL([BITBANG], [test $build_bitbang = yes])
-AM_CONDITIONAL([FT2232_LIBFTDI], [test $build_ft2232_libftdi = yes])
-AM_CONDITIONAL([FT2232_DRIVER], [test $build_ft2232_ftd2xx = yes -o $build_ft2232_libftdi = yes])
-AM_CONDITIONAL([USB_BLASTER_LIBFTDI], [test $build_usb_blaster_libftdi = yes])
-AM_CONDITIONAL([USB_BLASTER_FTD2XX], [test $build_usb_blaster_ftd2xx = yes])
-AM_CONDITIONAL([JTAG_VPI], [test $build_jtag_vpi = yes -o $build_jtag_vpi = yes])
-AM_CONDITIONAL([USB_BLASTER_DRIVER], [test $build_usb_blaster_ftd2xx = yes -o $build_usb_blaster_libftdi = yes -o $enable_usb_blaster_2 != no])
-AM_CONDITIONAL([AMTJTAGACCEL], [test $build_amtjtagaccel = yes])
-AM_CONDITIONAL([GW16012], [test $build_gw16012 = yes])
-AM_CONDITIONAL([PRESTO_LIBFTDI], [test $build_presto_libftdi = yes])
-AM_CONDITIONAL([PRESTO_DRIVER], [test $build_presto_ftd2xx = yes -o $build_presto_libftdi = yes])
-AM_CONDITIONAL([OPENJTAG], [test $build_openjtag_ftd2xx = yes -o $build_openjtag_ftdi = yes])
-AM_CONDITIONAL([OOCD_TRACE], [test $build_oocd_trace = yes])
-AM_CONDITIONAL([REMOTE_BITBANG], [test $build_remote_bitbang = yes])
-AM_CONDITIONAL([BUSPIRATE], [test $build_buspirate = yes])
-AM_CONDITIONAL([SYSFSGPIO], [test $build_sysfsgpio = yes])
-AM_CONDITIONAL([USE_LIBUSB0], [test $use_libusb0 = yes])
-AM_CONDITIONAL([USE_LIBUSB1], [test $use_libusb1 = yes])
-AM_CONDITIONAL([IS_CYGWIN], [test $is_cygwin = yes])
-AM_CONDITIONAL([IS_MINGW], [test $is_mingw = yes])
-AM_CONDITIONAL([IS_WIN32], [test $is_win32 = yes])
-AM_CONDITIONAL([IS_DARWIN], [test $is_darwin = yes])
-AM_CONDITIONAL([BITQ], [test $build_bitq = yes])
-AM_CONDITIONAL([CMSIS_DAP], [test $use_hidapi = yes])
-
-AM_CONDITIONAL([MINIDRIVER], [test $build_minidriver = yes])
-AM_CONDITIONAL([MINIDRIVER_DUMMY], [test $build_minidriver_dummy = yes])
-
-AM_CONDITIONAL([INTERNAL_JIMTCL], [test $use_internal_jimtcl = yes])
-AM_CONDITIONAL([INTERNAL_LIBJAYLINK], [test $use_internal_libjaylink = yes])
+])
+AM_CONDITIONAL([HLADAPTER], [test "x$enable_stlink" != "xno" -o "x$enable_ti_icdi" != "xno"])
+
+AS_IF([test "x$enable_jlink" != "xno"], [
+  AS_IF([test "x$use_internal_libjaylink" = "xyes"], [
+    AS_IF([test -f "$srcdir/src/jtag/drivers/libjaylink/configure.ac"], [
+      AX_CONFIG_SUBDIR_OPTION([src/jtag/drivers/libjaylink],
+		[--enable-subproject-build])
+    ], [
+      AC_MSG_ERROR([Internal libjaylink not found, run either 'git submodule init' and 'git submodule update' or disable internal libjaylink with --disable-internal-libjaylink.])
+    ])
+  ])
+])
+
+# Presto needs the bitq module
+AS_IF([test "x$enable_presto" != "xno"], [
+  build_bitq=yes
+])
+
+AM_CONDITIONAL([RELEASE], [test "x$build_release" = "xyes"])
+AM_CONDITIONAL([PARPORT], [test "x$build_parport" = "xyes"])
+AM_CONDITIONAL([DUMMY], [test "x$build_dummy" = "xyes"])
+AM_CONDITIONAL([GIVEIO], [test "x$parport_use_giveio" = "xyes"])
+AM_CONDITIONAL([EP93XX], [test "x$build_ep93xx" = "xyes"])
+AM_CONDITIONAL([ZY1000], [test "x$build_zy1000" = "xyes"])
+AM_CONDITIONAL([ZY1000_MASTER], [test "x$build_zy1000_master" = "xyes"])
+AM_CONDITIONAL([IOUTIL], [test "x$build_ioutil" = "xyes"])
+AM_CONDITIONAL([AT91RM9200], [test "x$build_at91rm9200" = "xyes"])
+AM_CONDITIONAL([BCM2835GPIO], [test "x$build_bcm2835gpio" = "xyes"])
+AM_CONDITIONAL([IMX_GPIO], [test "x$build_imx_gpio" = "xyes"])
+AM_CONDITIONAL([BITBANG], [test "x$build_bitbang" = "xyes"])
+AM_CONDITIONAL([JTAG_VPI], [test "x$build_jtag_vpi" = "xyes" -o "x$build_jtag_vpi" = "xyes"])
+AM_CONDITIONAL([USB_BLASTER_DRIVER], [test "x$enable_usb_blaster" != "xno" -o "x$enable_usb_blaster_2" != "xno"])
+AM_CONDITIONAL([AMTJTAGACCEL], [test "x$build_amtjtagaccel" = "xyes"])
+AM_CONDITIONAL([GW16012], [test "x$build_gw16012" = "xyes"])
+AM_CONDITIONAL([OOCD_TRACE], [test "x$build_oocd_trace" = "xyes"])
+AM_CONDITIONAL([REMOTE_BITBANG], [test "x$build_remote_bitbang" = "xyes"])
+AM_CONDITIONAL([BUSPIRATE], [test "x$build_buspirate" = "xyes"])
+AM_CONDITIONAL([SYSFSGPIO], [test "x$build_sysfsgpio" = "xyes"])
+AM_CONDITIONAL([USE_LIBUSB0], [test "x$use_libusb0" = "xyes"])
+AM_CONDITIONAL([USE_LIBUSB1], [test "x$use_libusb1" = "xyes"])
+AM_CONDITIONAL([IS_CYGWIN], [test "x$is_cygwin" = "xyes"])
+AM_CONDITIONAL([IS_MINGW], [test "x$is_mingw" = "xyes"])
+AM_CONDITIONAL([IS_WIN32], [test "x$is_win32" = "xyes"])
+AM_CONDITIONAL([IS_DARWIN], [test "x$is_darwin" = "xyes"])
+AM_CONDITIONAL([BITQ], [test "x$build_bitq" = "xyes"])
+AM_CONDITIONAL([USE_LIBFTDI], [test "x$use_libftdi" = "xyes"])
+AM_CONDITIONAL([USE_HIDAPI], [test "x$use_hidapi" = "xyes"])
+AM_CONDITIONAL([USE_LIBJAYLINK], [test "x$use_libjaylink" = "xyes"])
+AM_CONDITIONAL([TARGET64], [test "x$build_target64" = "xyes"])
+
+AM_CONDITIONAL([MINIDRIVER], [test "x$build_minidriver" = "xyes"])
+AM_CONDITIONAL([MINIDRIVER_DUMMY], [test "x$build_minidriver_dummy" = "xyes"])
+
+AM_CONDITIONAL([INTERNAL_JIMTCL], [test "x$use_internal_jimtcl" = "xyes"])
+AM_CONDITIONAL([INTERNAL_LIBJAYLINK], [test "x$use_internal_libjaylink" = "xyes"])
 
 # Look for environ alternatives.  Possibility #1: is environ in unistd.h or stdlib.h?
 AC_MSG_CHECKING([for environ in unistd.h and stdlib.h])
@@ -1276,56 +753,31 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     AC_MSG_RESULT([${has_environ}])
   ])
 
-if test "${has_environ}" != "yes" ; then
+AS_IF([test "x${has_environ}" != "xyes" ], [
   AC_MSG_FAILURE([Could not find 'environ' in unistd.h or available libraries.])
-fi
+])
 
 AC_DEFINE([_GNU_SOURCE],[1],[Use GNU C library extensions (e.g. stdndup).])
 
 # set default gcc warnings
 GCC_WARNINGS="-Wall -Wstrict-prototypes -Wformat-security -Wshadow"
-if test "${gcc_wextra}" = yes; then
+AS_IF([test "x${gcc_wextra}" = "xyes"], [
   GCC_WARNINGS="${GCC_WARNINGS} -Wextra -Wno-unused-parameter"
   GCC_WARNINGS="${GCC_WARNINGS} -Wbad-function-cast"
   GCC_WARNINGS="${GCC_WARNINGS} -Wcast-align"
   GCC_WARNINGS="${GCC_WARNINGS} -Wredundant-decls"
-fi
-if test "${gcc_werror}" = yes; then
+])
+AS_IF([test "x${gcc_werror}" = "xyes"], [
   GCC_WARNINGS="${GCC_WARNINGS} -Werror"
-fi
-
-# garbage collection flags
-if test "${gcc_gbgcol}" = yes; then
-  CFLAGS="$CFLAGS -ffunction-sections -fdata-sections"
-  LDFLAGS="$LDFLAGS -Wl,--gc-sections"
-fi
+])
 
 # overide default gcc cflags
-if test $gcc_warnings = yes; then
-  CFLAGS="$CFLAGS $GCC_WARNINGS"
-fi
+AS_IF([test "x$gcc_warnings" = "xyes"], [
+  AC_SUBST([GCC_WARNINGS], [$GCC_WARNINGS])
+])
 
 AC_CONFIG_FILES([
   Makefile
-  src/Makefile
-  src/helper/Makefile
-  src/jtag/Makefile
-  src/jtag/drivers/Makefile
-  src/jtag/drivers/usb_blaster/Makefile
-  src/jtag/hla/Makefile
-  src/jtag/aice/Makefile
-  src/transport/Makefile
-  src/target/openrisc/Makefile
-  src/xsvf/Makefile
-  src/svf/Makefile
-  src/target/Makefile
-  src/rtos/Makefile
-  src/server/Makefile
-  src/flash/Makefile
-  src/flash/nor/Makefile
-  src/flash/nand/Makefile
-  src/pld/Makefile
-  doc/Makefile
 ])
 AC_OUTPUT
 
@@ -1333,27 +785,42 @@ echo
 echo
 echo OpenOCD configuration summary
 echo --------------------------------------------------
-m4_foreach([adapter], [USB1_ADAPTERS, USB_ADAPTERS, USB0_ADAPTERS, HIDAPI_ADAPTERS],
+m4_foreach([adapter], [USB1_ADAPTERS, USB_ADAPTERS, USB0_ADAPTERS,
+	HIDAPI_ADAPTERS, HIDAPI_USB1_ADAPTERS, LIBFTDI_ADAPTERS,
+	LIBJAYLINK_ADAPTERS],
 	[s=m4_format(["%-40s"], ADAPTER_DESC([adapter]))
-	case $ADAPTER_VAR([adapter]) in
-		auto)
+	AS_CASE([$ADAPTER_VAR([adapter])],
+		[auto], [
 			echo "$s"yes '(auto)'
-			;;
-		yes)
+		],
+		[yes], [
 			echo "$s"yes
-			;;
-		no)
+		],
+		[no], [
 			echo "$s"no
-			;;
-	esac
+	])
 ])
 echo
 
-if test $build_ft2232_libftdi = yes -o $build_ft2232_ftd2xx = yes; then
-	if test $enable_ftdi = no; then
-		AC_MSG_WARN([Building the deprecated 'ft2232' adapter driver but not its replacement!])
-		AC_MSG_WARN([Please consider using --enable-ftdi instead.])
-	else
-		AC_MSG_WARN([Building the deprecated 'ft2232' adapter driver.])
-	fi
-fi
+AS_IF([test "x$build_oocd_trace" = "xyes"], [
+  echo 'WARNING! Deprecated configure option (--enable-oocd_trace)'
+  echo 'The oocd_trace driver is deprecated and will be removed in the next release.'
+  echo 'If you regularly use this driver, please report to the OpenOCD Mailing List.'
+  echo
+])
+
+AS_IF([test "x$build_zy1000" = "xyes" -o "x$build_zy1000_master" = "xyes"], [
+  echo 'WARNING! Deprecated configure option (--enable-zy1000, --enable-zy1000-master)'
+  echo 'Support for the ZY1000 platform is deprecated and will be removed in the next'
+  echo 'release. If you regularly use this platform, please report to the OpenOCD'
+  echo 'Mailing List.'
+  echo
+])
+
+AS_IF([test "x$build_ioutil" = "xyes"], [
+  echo 'WARNING! Deprecated configure option (--enable-ioutil)'
+  echo 'Support for the ioutil functions is deprecated and will be removed in the next'
+  echo 'release. If you regularly depend on this functionality, please report to the'
+  echo 'OpenOCD Mailing List.'
+  echo
+])
diff --git a/contrib/60-openocd.rules b/contrib/60-openocd.rules
new file mode 100644
index 00000000..da760f88
--- /dev/null
+++ b/contrib/60-openocd.rules
@@ -0,0 +1,145 @@
+# Copy this file to /etc/udev/rules.d/
+
+ACTION!="add|change", GOTO="openocd_rules_end"
+SUBSYSTEM!="usb|tty|hidraw", GOTO="openocd_rules_end"
+
+# Please keep this list sorted by VID:PID
+
+# opendous and estick
+ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="204f", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Original FT232/FT245 VID:PID
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Original FT2232 VID:PID
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6010", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Original FT4232 VID:PID
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6011", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Original FT232H VID:PID
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6014", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# DISTORTEC JTAG-lock-pick Tiny 2
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="8220", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# TUMPA, TUMPA Lite
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="8a98", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="8a99", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# XDS100v2
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="a6d0", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Xverve Signalyzer Tool (DT-USB-ST), Signalyzer LITE (DT-USB-SLITE)
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bca0", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bca1", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# TI/Luminary Stellaris Evaluation Board FTDI (several)
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bcd9", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# TI/Luminary Stellaris In-Circuit Debug Interface FTDI (ICDI) Board
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bcda", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# egnite Turtelizer 2
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bdc8", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Section5 ICEbear
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="c140", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="c141", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Amontec JTAGkey and JTAGkey-tiny
+ATTRS{idVendor}=="0403", ATTRS{idProduct}=="cff8", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# TI ICDI
+ATTRS{idVendor}=="0451", ATTRS{idProduct}=="c32a", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# STLink v1
+ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3744", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# STLink v2
+ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3748", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# STLink v2-1
+ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Cypress KitProg in KitProg mode
+ATTRS{idVendor}=="04b4", ATTRS{idProduct}=="f139", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Cypress KitProg in CMSIS-DAP mode
+ATTRS{idVendor}=="04b4", ATTRS{idProduct}=="f138", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Hilscher NXHX Boards
+ATTRS{idVendor}=="0640", ATTRS{idProduct}=="0028", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Hitex STR9-comStick
+ATTRS{idVendor}=="0640", ATTRS{idProduct}=="002c", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Hitex STM32-PerformanceStick
+ATTRS{idVendor}=="0640", ATTRS{idProduct}=="002d", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Altera USB Blaster
+ATTRS{idVendor}=="09fb", ATTRS{idProduct}=="6001", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Amontec JTAGkey-HiSpeed
+ATTRS{idVendor}=="0fbb", ATTRS{idProduct}=="1000", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# SEGGER J-Link
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0101", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0102", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0103", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0104", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0105", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0107", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0108", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1010", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1011", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1012", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1013", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1014", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1015", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1016", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1017", MODE="660", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1018", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Raisonance RLink
+ATTRS{idVendor}=="138e", ATTRS{idProduct}=="9000", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Debug Board for Neo1973
+ATTRS{idVendor}=="1457", ATTRS{idProduct}=="5118", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Olimex ARM-USB-OCD
+ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="0003", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Olimex ARM-USB-OCD-TINY
+ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="0004", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Olimex ARM-JTAG-EW
+ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="001e", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Olimex ARM-USB-OCD-TINY-H
+ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="002a", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Olimex ARM-USB-OCD-H
+ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="002b", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# USBprog with OpenOCD firmware
+ATTRS{idVendor}=="1781", ATTRS{idProduct}=="0c63", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# TI/Luminary Stellaris In-Circuit Debug Interface (ICDI) Board
+ATTRS{idVendor}=="1cbe", ATTRS{idProduct}=="00fd", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Ambiq Micro EVK and Debug boards.
+ATTRS{idVendor}=="2aec", ATTRS{idProduct}=="6010", MODE="664", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="2aec", ATTRS{idProduct}=="6011", MODE="664", GROUP="plugdev", TAG+="uaccess"
+ATTRS{idVendor}=="2aec", ATTRS{idProduct}=="1106", MODE="664", GROUP="plugdev", TAG+="uaccess"
+
+# Marvell Sheevaplug
+ATTRS{idVendor}=="9e88", ATTRS{idProduct}=="9e8f", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# Keil Software, Inc. ULink
+ATTRS{idVendor}=="c251", ATTRS{idProduct}=="2710", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+# CMSIS-DAP compatible adapters
+ATTRS{product}=="*CMSIS-DAP*", MODE="660", GROUP="plugdev", TAG+="uaccess"
+
+LABEL="openocd_rules_end"
diff --git a/contrib/99-openocd.rules b/contrib/99-openocd.rules
deleted file mode 100644
index 344b933a..00000000
--- a/contrib/99-openocd.rules
+++ /dev/null
@@ -1,128 +0,0 @@
-# Copy this file to /etc/udev/rules.d/
-
-ACTION!="add|change", GOTO="openocd_rules_end"
-SUBSYSTEM!="usb|tty|hidraw", GOTO="openocd_rules_end"
-
-# Please keep this list sorted by VID:PID
-
-# opendous and estick
-ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="204f", MODE="664", GROUP="plugdev"
-
-# Original FT232/FT245 VID:PID
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", MODE="664", GROUP="plugdev"
-
-# Original FT2232 VID:PID
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6010", MODE="664", GROUP="plugdev"
-
-# Original FT4232 VID:PID
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6011", MODE="664", GROUP="plugdev"
-
-# Original FT232H VID:PID
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6014", MODE="664", GROUP="plugdev"
-
-# DISTORTEC JTAG-lock-pick Tiny 2
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="8220", MODE="664", GROUP="plugdev"
-
-# TUMPA, TUMPA Lite
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="8a98", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="8a99", MODE="664", GROUP="plugdev"
-
-# XDS100v2
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="a6d0", MODE="664", GROUP="plugdev"
-
-# Xverve Signalyzer Tool (DT-USB-ST), Signalyzer LITE (DT-USB-SLITE)
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bca0", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bca1", MODE="664", GROUP="plugdev"
-
-# TI/Luminary Stellaris Evaluation Board FTDI (several)
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bcd9", MODE="664", GROUP="plugdev"
-
-# TI/Luminary Stellaris In-Circuit Debug Interface FTDI (ICDI) Board
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bcda", MODE="664", GROUP="plugdev"
-
-# egnite Turtelizer 2
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="bdc8", MODE="664", GROUP="plugdev"
-
-# Section5 ICEbear
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="c140", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="c141", MODE="664", GROUP="plugdev"
-
-# Amontec JTAGkey and JTAGkey-tiny
-ATTRS{idVendor}=="0403", ATTRS{idProduct}=="cff8", MODE="664", GROUP="plugdev"
-
-# TI ICDI
-ATTRS{idVendor}=="0451", ATTRS{idProduct}=="c32a", MODE="664", GROUP="plugdev"
-
-# STLink v1
-ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3744", MODE="664", GROUP="plugdev"
-
-# STLink v2
-ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3748", MODE="664", GROUP="plugdev"
-
-# STLink v2-1
-ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", MODE="664", GROUP="plugdev"
-
-# Hilscher NXHX Boards
-ATTRS{idVendor}=="0640", ATTRS{idProduct}=="0028", MODE="664", GROUP="plugdev"
-
-# Hitex STR9-comStick
-ATTRS{idVendor}=="0640", ATTRS{idProduct}=="002c", MODE="664", GROUP="plugdev"
-
-# Hitex STM32-PerformanceStick
-ATTRS{idVendor}=="0640", ATTRS{idProduct}=="002d", MODE="664", GROUP="plugdev"
-
-# Amontec JTAGkey-HiSpeed
-ATTRS{idVendor}=="0fbb", ATTRS{idProduct}=="1000", MODE="664", GROUP="plugdev"
-
-# SEGGER J-Link
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0101", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0102", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0103", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0104", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0105", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0107", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="0108", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1010", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1011", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1012", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1013", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1014", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1015", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1016", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1017", MODE="664", GROUP="plugdev"
-ATTRS{idVendor}=="1366", ATTRS{idProduct}=="1018", MODE="664", GROUP="plugdev"
-
-# Raisonance RLink
-ATTRS{idVendor}=="138e", ATTRS{idProduct}=="9000", MODE="664", GROUP="plugdev"
-
-# Debug Board for Neo1973
-ATTRS{idVendor}=="1457", ATTRS{idProduct}=="5118", MODE="664", GROUP="plugdev"
-
-# Olimex ARM-USB-OCD
-ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="0003", MODE="664", GROUP="plugdev"
-
-# Olimex ARM-USB-OCD-TINY
-ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="0004", MODE="664", GROUP="plugdev"
-
-# Olimex ARM-JTAG-EW
-ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="001e", MODE="664", GROUP="plugdev"
-
-# Olimex ARM-USB-OCD-TINY-H
-ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="002a", MODE="664", GROUP="plugdev"
-
-# Olimex ARM-USB-OCD-H
-ATTRS{idVendor}=="15ba", ATTRS{idProduct}=="002b", MODE="664", GROUP="plugdev"
-
-# USBprog with OpenOCD firmware
-ATTRS{idVendor}=="1781", ATTRS{idProduct}=="0c63", MODE="664", GROUP="plugdev"
-
-# TI/Luminary Stellaris In-Circuit Debug Interface (ICDI) Board
-ATTRS{idVendor}=="1cbe", ATTRS{idProduct}=="00fd", MODE="664", GROUP="plugdev"
-
-# Marvell Sheevaplug
-ATTRS{idVendor}=="9e88", ATTRS{idProduct}=="9e8f", MODE="664", GROUP="plugdev"
-
-# CMSIS-DAP compatible adapters
-ATTRS{product}=="*CMSIS-DAP*", MODE="664", GROUP="plugdev"
-
-LABEL="openocd_rules_end"
diff --git a/contrib/loaders/Makefile b/contrib/loaders/Makefile
new file mode 100644
index 00000000..31cccb5f
--- /dev/null
+++ b/contrib/loaders/Makefile
@@ -0,0 +1,34 @@
+.PHONY: arm clean-arm
+
+all: arm
+
+common_dirs = \
+	checksum \
+	erase_check \
+	watchdog
+
+ARM_CROSS_COMPILE ?= arm-none-eabi-
+
+arm_dirs = \
+	flash/fm4 \
+	flash/kinetis_ke \
+	flash/xmc1xxx \
+	debug/xscale
+
+arm:
+	for d in $(common_dirs); do \
+		$(MAKE) -C $$d arm; \
+	done
+	for d in $(arm_dirs); do \
+		$(MAKE) -C $$d all CROSS_COMPILE=$(ARM_CROSS_COMPILE); \
+	done
+
+clean-arm:
+	for d in $(arm_dirs); do \
+		$(MAKE) -C $$d clean; \
+	done
+
+clean: clean-arm
+	for d in $(common_dirs); do \
+		$(MAKE) -C $$d clean; \
+	done
diff --git a/contrib/loaders/checksum/Makefile b/contrib/loaders/checksum/Makefile
new file mode 100644
index 00000000..b9f59b8d
--- /dev/null
+++ b/contrib/loaders/checksum/Makefile
@@ -0,0 +1,30 @@
+BIN2C = ../../../src/helper/bin2char.sh
+
+ARM_CROSS_COMPILE ?= arm-none-eabi-
+ARM_AS      ?= $(ARM_CROSS_COMPILE)as
+ARM_OBJCOPY ?= $(ARM_CROSS_COMPILE)objcopy
+
+ARM_AFLAGS = -EL
+
+arm: armv4_5_crc.inc armv7m_crc.inc
+
+armv4_5_%.elf: armv4_5_%.s
+	$(ARM_AS) $(ARM_AFLAGS) $< -o $@
+
+armv4_5_%.bin: armv4_5_%.elf
+	$(ARM_OBJCOPY) -Obinary $< $@
+
+armv4_5_%.inc: armv4_5_%.bin
+	$(BIN2C) < $< > $@
+
+armv7m_%.elf: armv7m_%.s
+	$(ARM_AS) $(ARM_AFLAGS) $< -o $@
+
+armv7m_%.bin: armv7m_%.elf
+	$(ARM_OBJCOPY) -Obinary $< $@
+
+armv7m_%.inc: armv7m_%.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.bin *.inc
diff --git a/contrib/loaders/checksum/armv4_5_crc.inc b/contrib/loaders/checksum/armv4_5_crc.inc
new file mode 100644
index 00000000..216f6028
--- /dev/null
+++ b/contrib/loaders/checksum/armv4_5_crc.inc
@@ -0,0 +1,7 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x00,0x20,0xa0,0xe1,0x00,0x00,0xe0,0xe3,0x01,0x30,0xa0,0xe1,0x00,0x40,0xa0,0xe3,
+0x0b,0x00,0x00,0xea,0x04,0x10,0xd2,0xe7,0x30,0x70,0x9f,0xe5,0x01,0x0c,0x20,0xe0,
+0x00,0x50,0xa0,0xe3,0x00,0x00,0x50,0xe3,0x80,0x60,0xa0,0xe1,0x01,0x50,0x85,0xe2,
+0x06,0x00,0xa0,0xe1,0x07,0x00,0x26,0xb0,0x08,0x00,0x55,0xe3,0xf8,0xff,0xff,0x1a,
+0x01,0x40,0x84,0xe2,0x03,0x00,0x54,0xe1,0xf1,0xff,0xff,0x1a,0x70,0x00,0x20,0xe1,
+0xb7,0x1d,0xc1,0x04,
diff --git a/contrib/loaders/checksum/armv7m_crc.inc b/contrib/loaders/checksum/armv7m_crc.inc
new file mode 100644
index 00000000..1b013fd9
--- /dev/null
+++ b/contrib/loaders/checksum/armv7m_crc.inc
@@ -0,0 +1,5 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x02,0x46,0x00,0x20,0xc0,0x43,0x0a,0x4e,0x0b,0x46,0x00,0x24,0x0d,0xe0,0x11,0x5d,
+0x09,0x06,0x48,0x40,0x00,0x25,0x00,0x28,0x02,0xda,0x40,0x00,0x70,0x40,0x00,0xe0,
+0x40,0x00,0x01,0x35,0x08,0x2d,0xf6,0xd1,0x01,0x34,0x9c,0x42,0xef,0xd1,0x00,0xbe,
+0xb7,0x1d,0xc1,0x04,
diff --git a/contrib/loaders/debug/xscale/Makefile b/contrib/loaders/debug/xscale/Makefile
new file mode 100644
index 00000000..a0455c73
--- /dev/null
+++ b/contrib/loaders/debug/xscale/Makefile
@@ -0,0 +1,33 @@
+BIN2C = ../../../../src/helper/bin2char.sh
+
+CROSS_COMPILE ?= arm-none-eabi-
+
+CC=$(CROSS_COMPILE)gcc
+OBJCOPY=$(CROSS_COMPILE)objcopy
+OBJDUMP=$(CROSS_COMPILE)objdump
+
+CFLAGS = -static -nostartfiles -mlittle-endian -Wa,-EL
+LDFLAGS = -Tdebug_handler.ld
+
+all: debug_handler.inc
+
+.PHONY: clean
+
+.INTERMEDIATE: debug_handler.elf
+
+debug_handler.elf: protocol.h
+
+%.elf: %.S
+	$(CC) $(CFLAGS) $(LDFLAGS) $< -o $@
+
+%.lst: %.elf
+	$(OBJDUMP) -S $< > $@
+
+%.bin: %.elf
+	$(OBJCOPY) -Obinary $< $@
+
+%.inc: %.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.lst *.bin *.inc
diff --git a/src/target/xscale/debug_handler.S b/contrib/loaders/debug/xscale/debug_handler.S
similarity index 98%
rename from src/target/xscale/debug_handler.S
rename to contrib/loaders/debug/xscale/debug_handler.S
index 915e92fd..66dfa889 100644
--- a/src/target/xscale/debug_handler.S
+++ b/contrib/loaders/debug/xscale/debug_handler.S
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #include "protocol.h"
 
diff --git a/contrib/loaders/debug/xscale/debug_handler.inc b/contrib/loaders/debug/xscale/debug_handler.inc
new file mode 100644
index 00000000..d7f54e76
--- /dev/null
+++ b/contrib/loaders/debug/xscale/debug_handler.inc
@@ -0,0 +1,101 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x10,0xde,0x1a,0xee,0x02,0xd1,0x1d,0xe2,0x01,0x00,0x00,0x1a,0x03,0xd1,0xa0,0xe3,
+0x10,0xde,0x0a,0xee,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,0x10,0x0e,0x08,0xee,
+0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,0x10,0xee,0x08,0xee,0x01,0x00,0xa0,0xe1,
+0x70,0x01,0x00,0xeb,0x02,0x00,0xa0,0xe1,0x6e,0x01,0x00,0xeb,0x03,0x00,0xa0,0xe1,
+0x6c,0x01,0x00,0xeb,0x04,0x00,0xa0,0xe1,0x6a,0x01,0x00,0xeb,0x05,0x00,0xa0,0xe1,
+0x68,0x01,0x00,0xeb,0x06,0x00,0xa0,0xe1,0x66,0x01,0x00,0xeb,0x07,0x00,0xa0,0xe1,
+0x64,0x01,0x00,0xeb,0x00,0x00,0x4f,0xe1,0x62,0x01,0x00,0xeb,0x00,0x00,0x4f,0xe1,
+0x20,0x00,0xc0,0xe3,0xc0,0x00,0x80,0xe3,0x1f,0x10,0x00,0xe2,0x10,0x00,0x51,0xe3,
+0x01,0x00,0x00,0x1a,0x1f,0x00,0xc0,0xe3,0x1f,0x00,0x80,0xe3,0x3d,0x00,0x00,0xea,
+0x5c,0x01,0x00,0xeb,0x00,0x00,0x50,0xe3,0x39,0x00,0x00,0x0a,0x01,0x00,0x50,0xe3,
+0x5a,0x00,0x00,0x0a,0x11,0x00,0x50,0xe3,0x7b,0x00,0x00,0x0a,0x12,0x00,0x50,0xe3,
+0x83,0x00,0x00,0x0a,0x14,0x00,0x50,0xe3,0x8b,0x00,0x00,0x0a,0x21,0x00,0x50,0xe3,
+0x93,0x00,0x00,0x0a,0x22,0x00,0x50,0xe3,0x9b,0x00,0x00,0x0a,0x24,0x00,0x50,0xe3,
+0xa3,0x00,0x00,0x0a,0x30,0x00,0x50,0xe3,0x14,0x00,0x00,0x0a,0x31,0x00,0x50,0xe3,
+0x2b,0x01,0x00,0x0a,0x40,0x00,0x50,0xe3,0xc4,0x00,0x00,0x0a,0x41,0x00,0x50,0xe3,
+0xed,0x00,0x00,0x0a,0x50,0x00,0x50,0xe3,0xa7,0x00,0x00,0x0a,0x51,0x00,0x50,0xe3,
+0xac,0x00,0x00,0x0a,0x52,0x00,0x50,0xe3,0xac,0x00,0x00,0x0a,0x53,0x00,0x50,0xe3,
+0xac,0x00,0x00,0x0a,0x60,0x00,0x50,0xe3,0x9b,0x00,0x00,0x0a,0x61,0x00,0x50,0xe3,
+0x0c,0x01,0x00,0x0a,0x62,0x00,0x50,0xe3,0x14,0x01,0x00,0x0a,0xd7,0xff,0xff,0xea,
+0x34,0x01,0x00,0xeb,0x00,0xf0,0x69,0xe1,0x32,0x01,0x00,0xeb,0x00,0x70,0xa0,0xe1,
+0x30,0x01,0x00,0xeb,0x00,0x60,0xa0,0xe1,0x2e,0x01,0x00,0xeb,0x00,0x50,0xa0,0xe1,
+0x2c,0x01,0x00,0xeb,0x00,0x40,0xa0,0xe1,0x2a,0x01,0x00,0xeb,0x00,0x30,0xa0,0xe1,
+0x28,0x01,0x00,0xeb,0x00,0x20,0xa0,0xe1,0x26,0x01,0x00,0xeb,0x00,0x10,0xa0,0xe1,
+0x24,0x01,0x00,0xeb,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,0x10,0xee,0x19,0xee,
+0x00,0xf0,0x5e,0xe2,0x1f,0x01,0x00,0xeb,0x00,0x70,0x0f,0xe1,0x00,0xf0,0x21,0xe1,
+0x00,0x00,0xa0,0xe1,0x1f,0x10,0x00,0xe2,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,
+0x10,0x8e,0x08,0xee,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,0x10,0x9e,0x08,0xee,
+0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,0x10,0xae,0x08,0xee,0x10,0xfe,0x1e,0xee,
+0xfd,0xff,0xff,0x6a,0x10,0xbe,0x08,0xee,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,
+0x10,0xce,0x08,0xee,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,0x10,0xde,0x08,0xee,
+0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,0x10,0xee,0x08,0xee,0x1f,0x00,0x51,0xe3,
+0x03,0x00,0x00,0x0a,0x00,0x00,0x4f,0xe1,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,
+0x10,0x0e,0x08,0xee,0x07,0xf0,0x21,0xe1,0x00,0x00,0xa0,0xe1,0x9f,0xff,0xff,0xea,
+0xfc,0x00,0x00,0xeb,0x00,0x70,0x0f,0xe1,0x00,0xf0,0x21,0xe1,0x00,0x00,0xa0,0xe1,
+0x1f,0x10,0x00,0xe2,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,0x10,0x8e,0x19,0xee,
+0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,0x10,0x9e,0x19,0xee,0x10,0xfe,0x1e,0xee,
+0xfd,0xff,0xff,0x5a,0x10,0xae,0x19,0xee,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,
+0x10,0xbe,0x19,0xee,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,0x10,0xce,0x19,0xee,
+0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,0x10,0xde,0x19,0xee,0x10,0xfe,0x1e,0xee,
+0xfd,0xff,0xff,0x5a,0x10,0xee,0x19,0xee,0x1f,0x00,0x51,0xe3,0x03,0x00,0x00,0x0a,
+0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,0x10,0x0e,0x19,0xee,0x00,0xf0,0x69,0xe1,
+0x07,0xf0,0x21,0xe1,0x00,0x00,0xa0,0xe1,0x7c,0xff,0xff,0xea,0xd9,0x00,0x00,0xeb,
+0x00,0x20,0xa0,0xe1,0xd7,0x00,0x00,0xeb,0x00,0x10,0xa0,0xe1,0x01,0x00,0xd2,0xe4,
+0x9a,0x8f,0x07,0xee,0xcf,0x00,0x00,0xeb,0x01,0x10,0x51,0xe2,0xfa,0xff,0xff,0x1a,
+0x72,0xff,0xff,0xea,0xcf,0x00,0x00,0xeb,0x00,0x20,0xa0,0xe1,0xcd,0x00,0x00,0xeb,
+0x00,0x10,0xa0,0xe1,0xb2,0x00,0xd2,0xe0,0x9a,0x8f,0x07,0xee,0xc5,0x00,0x00,0xeb,
+0x01,0x10,0x51,0xe2,0xfa,0xff,0xff,0x1a,0x68,0xff,0xff,0xea,0xc5,0x00,0x00,0xeb,
+0x00,0x20,0xa0,0xe1,0xc3,0x00,0x00,0xeb,0x00,0x10,0xa0,0xe1,0x04,0x00,0x92,0xe4,
+0x9a,0x8f,0x07,0xee,0xbb,0x00,0x00,0xeb,0x01,0x10,0x51,0xe2,0xfa,0xff,0xff,0x1a,
+0x5e,0xff,0xff,0xea,0xbb,0x00,0x00,0xeb,0x00,0x20,0xa0,0xe1,0xb9,0x00,0x00,0xeb,
+0x00,0x10,0xa0,0xe1,0xb7,0x00,0x00,0xeb,0x01,0x00,0xc2,0xe4,0x9a,0x8f,0x07,0xee,
+0x01,0x10,0x51,0xe2,0xfa,0xff,0xff,0x1a,0x54,0xff,0xff,0xea,0xb1,0x00,0x00,0xeb,
+0x00,0x20,0xa0,0xe1,0xaf,0x00,0x00,0xeb,0x00,0x10,0xa0,0xe1,0xad,0x00,0x00,0xeb,
+0xb2,0x00,0xc2,0xe0,0x9a,0x8f,0x07,0xee,0x01,0x10,0x51,0xe2,0xfa,0xff,0xff,0x1a,
+0x4a,0xff,0xff,0xea,0xa7,0x00,0x00,0xeb,0x00,0x20,0xa0,0xe1,0xa5,0x00,0x00,0xeb,
+0x00,0x10,0xa0,0xe1,0xa3,0x00,0x00,0xeb,0x04,0x00,0x82,0xe4,0x9a,0x8f,0x07,0xee,
+0x01,0x10,0x51,0xe2,0xfa,0xff,0xff,0x1a,0x40,0xff,0xff,0xea,0x10,0x0e,0x1a,0xee,
+0x20,0x00,0xc0,0xe3,0x10,0x0e,0x0a,0xee,0x3c,0xff,0xff,0xea,0x99,0x00,0x00,0xeb,
+0x01,0x1b,0xa0,0xe3,0xb2,0x0f,0x07,0xee,0x20,0x00,0x80,0xe2,0x01,0x10,0x51,0xe2,
+0xfb,0xff,0xff,0x1a,0x35,0xff,0xff,0xea,0x16,0x0f,0x07,0xee,0x33,0xff,0xff,0xea,
+0x15,0x0f,0x07,0xee,0x31,0xff,0xff,0xea,0x10,0x0f,0x12,0xee,0x00,0x00,0xa0,0xe1,
+0x04,0xf0,0x4f,0xe2,0x2d,0xff,0xff,0xea,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x80,0x00,0x00,0xeb,0x00,0x10,0x8f,0xe2,0x80,0xf1,0x81,0xe0,0x10,0x0f,0x10,0xee,
+0x23,0x00,0x00,0xea,0x30,0x0f,0x10,0xee,0x21,0x00,0x00,0xea,0x10,0x0f,0x11,0xee,
+0x1f,0x00,0x00,0xea,0x30,0x0f,0x11,0xee,0x1d,0x00,0x00,0xea,0x10,0x0f,0x12,0xee,
+0x1b,0x00,0x00,0xea,0x10,0x0f,0x13,0xee,0x19,0x00,0x00,0xea,0x10,0x0f,0x15,0xee,
+0x17,0x00,0x00,0xea,0x10,0x0f,0x16,0xee,0x15,0x00,0x00,0xea,0x10,0x0f,0x1d,0xee,
+0x13,0x00,0x00,0xea,0x10,0x0f,0x1f,0xee,0x11,0x00,0x00,0xea,0x18,0x0f,0x1e,0xee,
+0x0f,0x00,0x00,0xea,0x19,0x0f,0x1e,0xee,0x0d,0x00,0x00,0xea,0x10,0x0f,0x1e,0xee,
+0x0b,0x00,0x00,0xea,0x13,0x0f,0x1e,0xee,0x09,0x00,0x00,0xea,0x14,0x0f,0x1e,0xee,
+0x07,0x00,0x00,0xea,0x10,0x0e,0x1b,0xee,0x05,0x00,0x00,0xea,0x10,0x0e,0x1c,0xee,
+0x03,0x00,0x00,0xea,0x10,0x0e,0x1d,0xee,0x01,0x00,0x00,0xea,0x10,0x0e,0x1a,0xee,
+0xff,0xff,0xff,0xea,0x53,0x00,0x00,0xeb,0xf8,0xfe,0xff,0xea,0x55,0x00,0x00,0xeb,
+0x00,0x10,0xa0,0xe1,0x53,0x00,0x00,0xeb,0x00,0x20,0x8f,0xe2,0x81,0xf1,0x82,0xe0,
+0x10,0x0f,0x00,0xee,0xf1,0xfe,0xff,0xea,0x30,0x0f,0x00,0xee,0xef,0xfe,0xff,0xea,
+0x10,0x0f,0x01,0xee,0xed,0xfe,0xff,0xea,0x30,0x0f,0x01,0xee,0xeb,0xfe,0xff,0xea,
+0x10,0x0f,0x02,0xee,0xe9,0xfe,0xff,0xea,0x10,0x0f,0x03,0xee,0xe7,0xfe,0xff,0xea,
+0x10,0x0f,0x05,0xee,0xe5,0xfe,0xff,0xea,0x10,0x0f,0x06,0xee,0xe3,0xfe,0xff,0xea,
+0x10,0x0f,0x0d,0xee,0xe1,0xfe,0xff,0xea,0x10,0x0f,0x0f,0xee,0xdf,0xfe,0xff,0xea,
+0x18,0x0f,0x0e,0xee,0xdd,0xfe,0xff,0xea,0x19,0x0f,0x0e,0xee,0xdb,0xfe,0xff,0xea,
+0x10,0x0f,0x0e,0xee,0xd9,0xfe,0xff,0xea,0x13,0x0f,0x0e,0xee,0xd7,0xfe,0xff,0xea,
+0x14,0x0f,0x0e,0xee,0xd5,0xfe,0xff,0xea,0x10,0x0e,0x0b,0xee,0xd3,0xfe,0xff,0xea,
+0x10,0x0e,0x0c,0xee,0xd1,0xfe,0xff,0xea,0x10,0x0e,0x0d,0xee,0xcf,0xfe,0xff,0xea,
+0x10,0x0e,0x0a,0xee,0xcd,0xfe,0xff,0xea,0x01,0x1c,0xa0,0xe3,0x10,0x0e,0x1b,0xee,
+0x24,0x00,0x00,0xeb,0x01,0x10,0x51,0xe2,0xfb,0xff,0xff,0x1a,0x10,0x0e,0x1c,0xee,
+0x20,0x00,0x00,0xeb,0x10,0x0e,0x1d,0xee,0x1e,0x00,0x00,0xeb,0xc3,0xfe,0xff,0xea,
+0x01,0x1c,0xa0,0xe3,0x10,0x0e,0x1b,0xee,0x01,0x10,0x51,0xe2,0xfc,0xff,0xff,0x1a,
+0xbe,0xfe,0xff,0xea,0x1b,0x00,0x00,0xeb,0x00,0xf0,0x69,0xe1,0x19,0x00,0x00,0xeb,
+0x00,0x70,0xa0,0xe1,0x17,0x00,0x00,0xeb,0x00,0x60,0xa0,0xe1,0x15,0x00,0x00,0xeb,
+0x00,0x50,0xa0,0xe1,0x13,0x00,0x00,0xeb,0x00,0x40,0xa0,0xe1,0x11,0x00,0x00,0xeb,
+0x00,0x30,0xa0,0xe1,0x0f,0x00,0x00,0xeb,0x00,0x20,0xa0,0xe1,0x0d,0x00,0x00,0xeb,
+0x00,0x10,0xa0,0xe1,0x0b,0x00,0x00,0xeb,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,
+0x10,0xee,0x19,0xee,0x10,0xde,0x1a,0xee,0x01,0xd0,0x8d,0xe3,0x10,0xde,0x0a,0xee,
+0x00,0xf0,0x5e,0xe2,0xfe,0xff,0xff,0xea,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x6a,
+0x10,0x0e,0x08,0xee,0x0e,0xf0,0xa0,0xe1,0x10,0xfe,0x1e,0xee,0xfd,0xff,0xff,0x5a,
+0x10,0x0e,0x19,0xee,0x0e,0xf0,0xa0,0xe1,
diff --git a/src/target/xscale/debug_handler.cmd b/contrib/loaders/debug/xscale/debug_handler.ld
similarity index 100%
rename from src/target/xscale/debug_handler.cmd
rename to contrib/loaders/debug/xscale/debug_handler.ld
diff --git a/src/target/xscale/protocol.h b/contrib/loaders/debug/xscale/protocol.h
similarity index 90%
rename from src/target/xscale/protocol.h
rename to contrib/loaders/debug/xscale/protocol.h
index f25f8c08..cb01655e 100644
--- a/src/target/xscale/protocol.h
+++ b/contrib/loaders/debug/xscale/protocol.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #define REG_R0 0
diff --git a/contrib/loaders/erase_check/Makefile b/contrib/loaders/erase_check/Makefile
new file mode 100644
index 00000000..01e62dea
--- /dev/null
+++ b/contrib/loaders/erase_check/Makefile
@@ -0,0 +1,30 @@
+BIN2C = ../../../src/helper/bin2char.sh
+
+ARM_CROSS_COMPILE ?= arm-none-eabi-
+ARM_AS      ?= $(ARM_CROSS_COMPILE)as
+ARM_OBJCOPY ?= $(ARM_CROSS_COMPILE)objcopy
+
+ARM_AFLAGS = -EL
+
+arm: armv4_5_erase_check.inc armv7m_erase_check.inc armv7m_0_erase_check.inc
+
+armv4_5_%.elf: armv4_5_%.s
+	$(ARM_AS) $(ARM_AFLAGS) $< -o $@
+
+armv4_5_%.bin: armv4_5_%.elf
+	$(ARM_OBJCOPY) -Obinary $< $@
+
+armv4_5_%.inc: armv4_5_%.bin
+	$(BIN2C) < $< > $@
+
+armv7m_%.elf: armv7m_%.s
+	$(ARM_AS) $(ARM_AFLAGS) $< -o $@
+
+armv7m_%.bin: armv7m_%.elf
+	$(ARM_OBJCOPY) -Obinary $< $@
+
+armv7m_%.inc: armv7m_%.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.bin *.inc
diff --git a/contrib/loaders/erase_check/armv4_5_erase_check.inc b/contrib/loaders/erase_check/armv4_5_erase_check.inc
new file mode 100644
index 00000000..f7f8ddf1
--- /dev/null
+++ b/contrib/loaders/erase_check/armv4_5_erase_check.inc
@@ -0,0 +1,3 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x01,0x30,0xd0,0xe4,0x03,0x20,0x02,0xe0,0x01,0x10,0x51,0xe2,0xfb,0xff,0xff,0x1a,
+0x70,0x00,0x20,0xe1,
diff --git a/contrib/loaders/erase_check/armv4_5_erase_check.s b/contrib/loaders/erase_check/armv4_5_erase_check.s
index 6d075a91..6c7d27f0 100644
--- a/contrib/loaders/erase_check/armv4_5_erase_check.s
+++ b/contrib/loaders/erase_check/armv4_5_erase_check.s
@@ -36,6 +36,4 @@ loop:
 end:
 	bkpt	#0
 
-CRC32XOR:	.word	0x04c11db7
-
 	.end
diff --git a/contrib/loaders/erase_check/armv7m_0_erase_check.inc b/contrib/loaders/erase_check/armv7m_0_erase_check.inc
new file mode 100644
index 00000000..76115ec1
--- /dev/null
+++ b/contrib/loaders/erase_check/armv7m_0_erase_check.inc
@@ -0,0 +1,2 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x03,0x78,0x01,0x30,0x1a,0x43,0x01,0x39,0xfa,0xd1,0x00,0xbe,
diff --git a/contrib/loaders/erase_check/armv7m_erase_check.inc b/contrib/loaders/erase_check/armv7m_erase_check.inc
new file mode 100644
index 00000000..1fe25cd5
--- /dev/null
+++ b/contrib/loaders/erase_check/armv7m_erase_check.inc
@@ -0,0 +1,2 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x03,0x78,0x01,0x30,0x1a,0x40,0x01,0x39,0xfa,0xd1,0x00,0xbe,
diff --git a/contrib/loaders/flash/cortex-m0.S b/contrib/loaders/flash/cortex-m0.S
index a905a362..b4416e78 100644
--- a/contrib/loaders/flash/cortex-m0.S
+++ b/contrib/loaders/flash/cortex-m0.S
@@ -27,8 +27,8 @@
 
 /* Written for NRF51822 (src/flash/nor/nrf51.c) however the NRF NVMC is
  * very generic (CPU blocks during flash writes), so this is actually
- * just a generic word-oriented copy routine for cortex-m0 (also
- * suitable for cortex m0plus/m3/m4.)
+ * just a generic word-oriented copy routine for Cortex-M0 (also
+ * suitable for Cortex-M0+/M3/M4.)
  *
  * To assemble:
  * arm-none-eabi-gcc -c cortex-m0.S
diff --git a/contrib/loaders/flash/efm32.S b/contrib/loaders/flash/efm32.S
index 25d63010..c5de55c2 100644
--- a/contrib/loaders/flash/efm32.S
+++ b/contrib/loaders/flash/efm32.S
@@ -44,11 +44,7 @@
 #define EFM32_MSC_ADDRB_OFFSET          0x010
 #define EFM32_MSC_WDATA_OFFSET          0x018
 #define EFM32_MSC_STATUS_OFFSET         0x01c
-#define EFM32_MSC_LOCK_OFFSET           0x03c
 
-	/* unlock MSC */
-	ldr     r6, =#0x1b71
-	str     r6, [r0, #EFM32_MSC_LOCK_OFFSET]
 	/* set WREN to 1 */
 	movs    r6, #1
 	str     r6, [r0, #EFM32_MSC_WRITECTRL_OFFSET]
diff --git a/contrib/loaders/flash/fm4/Makefile b/contrib/loaders/flash/fm4/Makefile
new file mode 100644
index 00000000..207b9d0f
--- /dev/null
+++ b/contrib/loaders/flash/fm4/Makefile
@@ -0,0 +1,32 @@
+BIN2C = ../../../../src/helper/bin2char.sh
+
+CROSS_COMPILE ?= arm-none-eabi-
+
+CC=$(CROSS_COMPILE)gcc
+OBJCOPY=$(CROSS_COMPILE)objcopy
+OBJDUMP=$(CROSS_COMPILE)objdump
+
+CFLAGS = -static -nostartfiles -mlittle-endian -Wa,-EL
+
+all: erase.inc write.inc
+
+.PHONY: clean
+
+.INTERMEDIATE: erase.elf write.elf
+
+erase.elf write.elf: fm4.h
+
+%.elf: %.S
+	$(CC) $(CFLAGS) $< -o $@
+
+%.lst: %.elf
+	$(OBJDUMP) -S $< > $@
+
+%.bin: %.elf
+	$(OBJCOPY) -Obinary $< $@
+
+%.inc: %.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.lst *.bin *.inc
diff --git a/contrib/loaders/flash/fm4/erase.S b/contrib/loaders/flash/fm4/erase.S
new file mode 100644
index 00000000..6fdf81dc
--- /dev/null
+++ b/contrib/loaders/flash/fm4/erase.S
@@ -0,0 +1,77 @@
+/*
+ * Spansion FM4 flash sector erase algorithm
+ *
+ * Copyright (c) 2015 Andreas Färber
+ *
+ * Based on S6E2CC_MN709-00007 for S6E2CC/C5/C4/C3/C2/C1 series
+ */
+
+#include "fm4.h"
+
+#define RESULT_OKAY	0
+#define RESULT_NONE	1
+#define RESULT_TIMEOUT	2
+
+	.macro busy_wait, res, addr, tmp1, tmp2, tmp3
+
+	ldrb	\tmp1, [\addr] /* ignore */
+1001:
+	ldrb	\tmp1, [\addr]
+	ldrb	\tmp2, [\addr]
+
+	and	\tmp3, \tmp1, #FLASH_TOGG
+	and	\tmp2, \tmp2, #FLASH_TOGG
+	cmp	\tmp3, \tmp2
+	beq	1010f
+
+	and	\tmp2, \tmp1, #FLASH_TLOV
+	cmp	\tmp2, #0
+	beq	1001b
+
+	ldrb	\tmp1, [\addr]
+	ldrb	\tmp2, [\addr]
+
+	and	\tmp3, \tmp1, #FLASH_TOGG
+	and	\tmp2, \tmp2, #FLASH_TOGG
+	cmp	\tmp3, \tmp2
+	beq	1010f
+
+	mov	\res, #RESULT_TIMEOUT
+	bkpt	#0
+1010:
+	mov	\res, #RESULT_OKAY
+
+	.endm
+
+
+	.macro erase, cmdseqaddr1, cmdseqaddr2, sa, res, tmp1, tmp2, tmp3
+
+	mov	\res, #RESULT_NONE
+
+	mov	\tmp1, #0xAA
+	strh	\tmp1, [\cmdseqaddr1]
+	mov	\tmp2, #0x55
+	strh	\tmp2, [\cmdseqaddr2]
+	mov	\tmp3, #0x80
+	strh	\tmp3, [\cmdseqaddr1]
+	strh	\tmp1, [\cmdseqaddr1]
+	strh	\tmp2, [\cmdseqaddr2]
+	mov	\tmp3, #0x30
+	strh	\tmp3, [\sa]
+
+	busy_wait \res, \sa, \tmp1, \tmp2, \tmp3
+
+	.endm
+
+
+	/* r0 = 0xAA8
+	 * r1 = 0x554
+	 * r2 = SA
+	 * r3 = result
+	 */
+erase:
+	erase r0, r1, r2, r3, r4, r5, r6
+
+	bkpt	#0
+
+data:
diff --git a/contrib/loaders/flash/fm4/erase.inc b/contrib/loaders/flash/fm4/erase.inc
new file mode 100644
index 00000000..9f380674
--- /dev/null
+++ b/contrib/loaders/flash/fm4/erase.inc
@@ -0,0 +1,7 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x4f,0xf0,0x01,0x03,0x4f,0xf0,0xaa,0x04,0x04,0x80,0x4f,0xf0,0x55,0x05,0x0d,0x80,
+0x4f,0xf0,0x80,0x06,0x06,0x80,0x04,0x80,0x0d,0x80,0x4f,0xf0,0x30,0x06,0x16,0x80,
+0x14,0x78,0x14,0x78,0x15,0x78,0x04,0xf0,0x40,0x06,0x05,0xf0,0x40,0x05,0xae,0x42,
+0x0e,0xd0,0x04,0xf0,0x20,0x05,0x00,0x2d,0xf3,0xd0,0x14,0x78,0x15,0x78,0x04,0xf0,
+0x40,0x06,0x05,0xf0,0x40,0x05,0xae,0x42,0x02,0xd0,0x4f,0xf0,0x02,0x03,0x00,0xbe,
+0x4f,0xf0,0x00,0x03,0x00,0xbe,
diff --git a/contrib/loaders/flash/fm4/fm4.h b/contrib/loaders/flash/fm4/fm4.h
new file mode 100644
index 00000000..603aac87
--- /dev/null
+++ b/contrib/loaders/flash/fm4/fm4.h
@@ -0,0 +1,19 @@
+/*
+ * Spansion FM4 flash macros
+ *
+ * Copyright (c) 2015 Andreas Färber
+ *
+ * Based on S6E2CC_MN709-00007 for S6E2CC/C5/C4/C3/C2/C1 series
+ */
+
+	.text
+	.syntax unified
+	.cpu cortex-m4
+	.thumb
+	.thumb_func
+
+
+#define FLASH_DPOL	(1 << 7)
+#define FLASH_TOGG	(1 << 6)
+#define FLASH_TLOV	(1 << 5)
+#define FLASH_TOGG2	(1 << 2)
diff --git a/contrib/loaders/flash/fm4/write.S b/contrib/loaders/flash/fm4/write.S
new file mode 100644
index 00000000..a8d01cde
--- /dev/null
+++ b/contrib/loaders/flash/fm4/write.S
@@ -0,0 +1,85 @@
+/*
+ * Spansion FM4 flash write algorithm
+ *
+ * Copyright (c) 2015 Andreas Färber
+ *
+ * Based on S6E2CC_MN709-00007 for S6E2CC/C5/C4/C3/C2/C1 series
+ */
+
+#include "fm4.h"
+
+#define RESULT_OKAY	0
+#define RESULT_NONE	1
+#define RESULT_TIMEOUT	2
+
+	.macro busy_wait, res, addr, data, tmp1, tmp2, tmp3
+
+	ldrb	\tmp1, [\addr] /* ignore */
+	and	\tmp2, \data, #FLASH_DPOL
+1001:
+	ldrb	\tmp1, [\addr]
+	and	\tmp3, \tmp1, #FLASH_DPOL
+	cmp	\tmp3, \tmp2
+	beq	1010f
+
+	and	\tmp3, \tmp1, #FLASH_TLOV
+	cmp	\tmp3, #0
+	beq	1001b
+
+	ldrb	\tmp1, [\addr]
+	and	\tmp3, \tmp1, #FLASH_DPOL
+	cmp	\tmp3, \tmp2
+	beq	1010f
+
+	mov	\res, #RESULT_TIMEOUT
+	bkpt	#0
+1010:
+	.endm
+
+
+	.macro write_one, res, cmdseqaddr1, cmdseqaddr2, pa, pd, tmp1, tmp2, tmp3
+
+	mov	\tmp1, #0xAA
+	strh	\tmp1, [\cmdseqaddr1]
+	mov	\tmp1, #0x55
+	strh	\tmp1, [\cmdseqaddr2]
+	mov	\tmp1, #0xA0
+	strh	\tmp1, [\cmdseqaddr1]
+	strh	\pd, [\pa]
+
+	busy_wait \res, \pa, \pd, \tmp1, \tmp2, \tmp3
+
+	.endm
+
+
+	.macro write, cmdseqaddr1, cmdseqaddr2, dest, src, cnt, res, tmp1, tmp2, tmp3, tmp4
+
+	mov	\res, #RESULT_NONE
+2001:
+	cbz	\cnt, 2010f
+
+	ldrh	\tmp1, [\src]
+	write_one \res, \cmdseqaddr1, \cmdseqaddr2, \dest, \tmp1, \tmp2, \tmp3, \tmp4
+
+	sub	\cnt, \cnt, #1
+	add	\dest, \dest, #2
+	add	\src, \src, #2
+	b	2001b
+2010:
+	mov	\res, #RESULT_OKAY
+	.endm
+
+
+	/* r0 = 0xAA8
+	 * r1 = 0x554
+	 * r2 = dest
+	 * r3 = src
+	 * r4 = cnt
+	 * r5 = result
+	 */
+write:
+	write r0, r1, r2, r3, r4, r5, r6, r7, r8, r9
+
+	bkpt	#0
+
+data:
diff --git a/contrib/loaders/flash/fm4/write.inc b/contrib/loaders/flash/fm4/write.inc
new file mode 100644
index 00000000..3d8472ba
--- /dev/null
+++ b/contrib/loaders/flash/fm4/write.inc
@@ -0,0 +1,7 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x4f,0xf0,0x01,0x05,0x34,0xb3,0x1e,0x88,0x4f,0xf0,0xaa,0x07,0x07,0x80,0x4f,0xf0,
+0x55,0x07,0x0f,0x80,0x4f,0xf0,0xa0,0x07,0x07,0x80,0x16,0x80,0x17,0x78,0x06,0xf0,
+0x80,0x08,0x17,0x78,0x07,0xf0,0x80,0x09,0xc1,0x45,0x0c,0xd0,0x07,0xf0,0x20,0x09,
+0xb9,0xf1,0x00,0x0f,0xf5,0xd0,0x17,0x78,0x07,0xf0,0x80,0x09,0xc1,0x45,0x02,0xd0,
+0x4f,0xf0,0x02,0x05,0x00,0xbe,0xa4,0xf1,0x01,0x04,0x02,0xf1,0x02,0x02,0x03,0xf1,
+0x02,0x03,0xd7,0xe7,0x4f,0xf0,0x00,0x05,0x00,0xbe,
diff --git a/contrib/loaders/flash/fpga/xilinx_bscan_spi.py b/contrib/loaders/flash/fpga/xilinx_bscan_spi.py
index a107a6ac..fa4ec2ac 100755
--- a/contrib/loaders/flash/fpga/xilinx_bscan_spi.py
+++ b/contrib/loaders/flash/fpga/xilinx_bscan_spi.py
@@ -13,20 +13,21 @@
 #  GNU General Public License for more details.
 #
 
-from migen.fhdl.std import *
-from mibuild.generic_platform import *
-from mibuild.xilinx import XilinxPlatform
-from mibuild.xilinx.vivado import XilinxVivadoToolchain
-from mibuild.xilinx.ise import XilinxISEToolchain
+from migen import *
+from migen.build.generic_platform import *
+from migen.build import xilinx
 
 
 """
 This migen script produces proxy bitstreams to allow programming SPI flashes
-behind FPGAs. JTAG signalling is connected directly to SPI signalling. CS_N is
-asserted when the JTAG IR contains the USER1 instruction and the state is
-SHIFT-DR.
+behind FPGAs.
+
+Bitstream binaries built with this script are available at:
+https://github.com/jordens/bscan_spi_bitstreams
 
-Xilinx bscan cells sample TDO on falling TCK and forward it.
+JTAG signalling is connected directly to SPI signalling. CS_N is
+asserted when the JTAG IR contains the USER1 instruction and the state is
+SHIFT-DR. Xilinx bscan cells sample TDO on falling TCK and forward it.
 MISO requires sampling on rising CLK and leads to one cycle of latency.
 
 https://github.com/m-labs/migen
@@ -35,8 +36,10 @@ https://github.com/m-labs/migen
 
 class Spartan3(Module):
     macro = "BSCAN_SPARTAN3"
+    toolchain = "ise"
 
     def __init__(self, platform):
+        platform.toolchain.bitgen_opt += " -g compress -g UnusedPin:Pullup"
         self.clock_domains.cd_jtag = ClockDomain(reset_less=True)
         spi = platform.request("spiflash")
         shift = Signal()
@@ -58,7 +61,10 @@ class Spartan3A(Spartan3):
 
 
 class Spartan6(Module):
+    toolchain = "ise"
+
     def __init__(self, platform):
+        platform.toolchain.bitgen_opt += " -g compress -g UnusedPin:Pullup"
         self.clock_domains.cd_jtag = ClockDomain(reset_less=True)
         spi = platform.request("spiflash")
         shift = Signal()
@@ -72,7 +78,13 @@ class Spartan6(Module):
 
 
 class Series7(Module):
+    toolchain = "vivado"
+
     def __init__(self, platform):
+        platform.toolchain.bitstream_commands.extend([
+            "set_property BITSTREAM.GENERAL.COMPRESS True [current_design]",
+            "set_property BITSTREAM.CONFIG.UNUSEDPIN Pullnone [current_design]",
+        ])
         self.clock_domains.cd_jtag = ClockDomain(reset_less=True)
         spi = platform.request("spiflash")
         clk = Signal()
@@ -89,184 +101,105 @@ class Series7(Module):
                                   i_USRCCLKTS=0, i_USRDONEO=1, i_USRDONETS=1)
 
 
-class XilinxBscanSpi(XilinxPlatform):
+class XilinxBscanSpi(xilinx.XilinxPlatform):
+    packages = {
+        # (package-speedgrade, id): [cs_n, clk, mosi, miso, *pullups]
+        ("cp132", 1): ["M2", "N12", "N2", "N8"],
+        ("fg320", 1): ["U3", "U16", "T4", "N10"],
+        ("fg320", 2): ["V3", "U16", "T11", "V16"],
+        ("fg484", 1): ["Y4", "AA20", "AB14", "AB20"],
+        ("fgg484", 1): ["Y4", "AA20", "AB14", "AB20"],
+        ("fgg400", 1): ["Y2", "Y19", "W12", "W18"],
+        ("ftg256", 1): ["T2", "R14", "P10", "T14"],
+        ("ft256", 1): ["T2", "R14", "P10", "T14"],
+        ("fg400", 1): ["Y2", "Y19", "W12", "W18"],
+        ("cs484", 1): ["U7", "V17", "V13", "W17"],
+        ("qg144-2", 1): ["P38", "P70", "P64", "P65", "P62", "P61"],
+        ("cpg196-2", 1): ["P2", "N13", "P11", "N11", "N10", "P10"],
+        ("cpg236-1", 1): ["K19", None, "D18", "D19", "G18", "F18"],
+        ("csg484-2", 1): ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
+        ("csg324-2", 1): ["V3", "R15", "T13", "R13", "T14", "V14"],
+        ("csg324-1", 1): ["L13", None, "K17", "K18", "L14", "M14"],
+        ("fbg484-1", 1): ["T19", None, "P22", "R22", "P21", "R21"],
+        ("fbg484-1", 2): ["L16", None, "H18", "H19", "G18", "F19"],
+        ("fbg676-1", 1): ["C23", None, "B24", "A25", "B22", "A22"],
+        ("ffg901-1", 1): ["V26", None, "R30", "T30", "R28", "T28"],
+        ("ffg1156-1", 1): ["V30", None, "AA33", "AA34", "Y33", "Y34"],
+        ("ffg1157-1", 1): ["AL33", None, "AN33", "AN34", "AK34", "AL34"],
+        ("ffg1158-1", 1): ["C24", None, "A23", "A24", "B26", "A26"],
+        ("ffg1926-1", 1): ["AK33", None, "AN34", "AN35", "AJ34", "AK34"],
+        ("fhg1761-1", 1): ["AL36", None, "AM36", "AN36", "AJ36", "AJ37"],
+        ("flg1155-1", 1): ["AL28", None, "AE28", "AF28", "AJ29", "AJ30"],
+        ("flg1932-1", 1): ["V32", None, "T33", "R33", "U31", "T31"],
+        ("flg1926-1", 1): ["AK33", None, "AN34", "AN35", "AJ34", "AK34"],
+    }
+
     pinouts = {
         # bitstreams are named by die, package does not matter, speed grade
         # should not matter.
-        #                    cs_n, clk, mosi, miso, *pullups
-        "xc3s100e": ("cp132",
-            ["M2", "N12", "N2", "N8"],
-            "LVCMOS33", Spartan3),
-        "xc3s1200e": ("fg320",
-            ["U3", "U16", "T4", "N10"],
-            "LVCMOS33", Spartan3),
-        "xc3s1400a": ("fg484",
-            ["Y4", "AA20", "AB14", "AB20"],
-            "LVCMOS33", Spartan3A),
-        "xc3s1400an": ("fgg484",
-            ["Y4", "AA20", "AB14", "AB20"],
-            "LVCMOS33", Spartan3A),
-        "xc3s1600e": ("fg320",
-            ["U3", "U16", "T4", "N10"],
-            "LVCMOS33", Spartan3),
-        "xc3s200a": ("fg320",
-            ["V3", "U16", "T11", "V16"],
-            "LVCMOS33", Spartan3A),
-        "xc3s200an": ("ftg256",
-            ["T2", "R14", "P10", "T14"],
-            "LVCMOS33", Spartan3A),
-        "xc3s250e": ("cp132",
-            ["M2", "N12", "N2", "N8"],
-            "LVCMOS33", Spartan3),
-        "xc3s400a": ("fg320",
-            ["V3", "U16", "T11", "V16"],
-            "LVCMOS33", Spartan3A),
-        "xc3s400an": ("fgg400",
-            ["Y2", "Y19", "W12", "W18"],
-            "LVCMOS33", Spartan3A),
-        "xc3s500e": ("cp132",
-            ["M2", "N12", "N2", "N8"],
-            "LVCMOS33", Spartan3),
-        "xc3s50a": ("ft256",
-            ["T2", "R14", "P10", "T14"],
-            "LVCMOS33", Spartan3A),
-        "xc3s50an": ("ftg256",
-            ["T2", "R14", "P10", "T14"],
-            "LVCMOS33", Spartan3A),
-        "xc3s700a": ("fg400",
-            ["Y2", "Y19", "W12", "W18"],
-            "LVCMOS33", Spartan3A),
-        "xc3s700an": ("fgg484",
-            ["Y4", "AA20", "AB14", "AB20"],
-            "LVCMOS33", Spartan3A),
-        "xc3sd1800a": ("cs484",
-            ["U7", "V17", "V13", "W17"],
-            "LVCMOS33", Spartan3A),
-        "xc3sd3400a": ("cs484",
-            ["U7", "V17", "V13", "W17"],
-            "LVCMOS33", Spartan3A),
-
-        "xc6slx100": ("csg484-2",
-            ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
-            "LVCMOS33", Spartan6),
-        "xc6slx100t": ("csg484-2",
-            ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
-            "LVCMOS33", Spartan6),
-        "xc6slx150": ("csg484-2",
-            ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
-            "LVCMOS33", Spartan6),
-        "xc6slx150t": ("csg484-2",
-            ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
-            "LVCMOS33", Spartan6),
-        "xc6slx16": ("cpg196-2",
-            ["P2", "N13", "P11", "N11", "N10", "P10"],
-            "LVCMOS33", Spartan6),
-        "xc6slx25": ("csg324-2",
-            ["V3", "R15", "T13", "R13", "T14", "V14"],
-            "LVCMOS33", Spartan6),
-        "xc6slx25t": ("csg324-2",
-            ["V3", "R15", "T13", "R13", "T14", "V14"],
-            "LVCMOS33", Spartan6),
-        "xc6slx45": ("csg324-2",
-            ["V3", "R15", "T13", "R13", "T14", "V14"],
-            "LVCMOS33", Spartan6),
-        "xc6slx45t": ("csg324-2",
-            ["V3", "R15", "T13", "R13", "T14", "V14"],
-            "LVCMOS33", Spartan6),
-        "xc6slx4": ("cpg196-2",
-            ["P2", "N13", "P11", "N11", "N10", "P10"],
-            "LVCMOS33", Spartan6),
-        "xc6slx4t": ("qg144-2",
-            ["P38", "P70", "P64", "P65", "P62", "P61"],
-            "LVCMOS33", Spartan6),
-        "xc6slx75": ("csg484-2",
-            ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
-            "LVCMOS33", Spartan6),
-        "xc6slx75t": ("csg484-2",
-            ["AB5", "W17", "AB17", "Y17", "V13", "W13"],
-            "LVCMOS33", Spartan6),
-        "xc6slx9": ("cpg196-2",
-            ["P2", "N13", "P11", "N11", "N10", "P10"],
-            "LVCMOS33", Spartan6),
-        "xc6slx9t": ("qg144-2",
-            ["P38", "P70", "P64", "P65", "P62", "P61"],
-            "LVCMOS33", Spartan6),
-
-        "xc7a100t": ("csg324-1",
-            ["L13", None, "K17", "K18", "L14", "M14"],
-            "LVCMOS25", Series7),
-        "xc7a15t": ("cpg236-1",
-            ["K19", None, "D18", "D19", "G18", "F18"],
-            "LVCMOS25", Series7),
-        "xc7a200t": ("fbg484-1",
-            ["T19", None, "P22", "R22", "P21", "R21"],
-            "LVCMOS25", Series7),
-        "xc7a35t": ("cpg236-1",
-            ["K19", None, "D18", "D19", "G18", "F18"],
-            "LVCMOS25", Series7),
-        "xc7a50t": ("cpg236-1",
-            ["K19", None, "D18", "D19", "G18", "F18"],
-            "LVCMOS25", Series7),
-        "xc7a75t": ("csg324-1",
-            ["L13", None, "K17", "K18", "L14", "M14"],
-            "LVCMOS25", Series7),
-        "xc7k160t": ("fbg484-1",
-            ["L16", None, "H18", "H19", "G18", "F19"],
-            "LVCMOS25", Series7),
-        "xc7k325t": ("fbg676-1",
-            ["C23", None, "B24", "A25", "B22", "A22"],
-            "LVCMOS25", Series7),
-        "xc7k355t": ("ffg901-1",
-            ["V26", None, "R30", "T30", "R28", "T28"],
-            "LVCMOS25", Series7),
-        "xc7k410t": ("fbg676-1",
-            ["C23", None, "B24", "A25", "B22", "A22"],
-            "LVCMOS25", Series7),
-        "xc7k420t": ("ffg1156-1",
-            ["V30", None, "AA33", "AA34", "Y33", "Y34"],
-            "LVCMOS25", Series7),
-        "xc7k480t": ("ffg1156-1",
-            ["V30", None, "AA33", "AA34", "Y33", "Y34"],
-            "LVCMOS25", Series7),
-        "xc7k70t": ("fbg484-1",
-            ["L16", None, "H18", "H19", "G18", "F19"],
-            "LVCMOS25", Series7),
-        "xc7v2000t": ("fhg1761-1",
-            ["AL36", None, "AM36", "AN36", "AJ36", "AJ37"],
-            "LVCMOS18", Series7),
-        "xc7v585t": ("ffg1157-1",
-            ["AL33", None, "AN33", "AN34", "AK34", "AL34"],
-            "LVCMOS18", Series7),
-        "xc7vh580t": ("flg1155-1",
-            ["AL28", None, "AE28", "AF28", "AJ29", "AJ30"],
-            "LVCMOS18", Series7),
-        "xc7vh870t": ("flg1932-1",
-            ["V32", None, "T33", "R33", "U31", "T31"],
-            "LVCMOS18", Series7),
-        "xc7vx1140t": ("flg1926-1",
-            ["AK33", None, "AN34", "AN35", "AJ34", "AK34"],
-            "LVCMOS18", Series7),
-        "xc7vx330t": ("ffg1157-1",
-            ["AL33", None, "AN33", "AN34", "AK34", "AL34"],
-            "LVCMOS18", Series7),
-        "xc7vx415t": ("ffg1157-1",
-            ["AL33", None, "AN33", "AN34", "AK34", "AL34"],
-            "LVCMOS18", Series7),
-        "xc7vx485t": ("ffg1157-1",
-            ["AL33", None, "AN33", "AN34", "AK34", "AL34"],
-            "LVCMOS18", Series7),
-        "xc7vx550t": ("ffg1158-1",
-            ["C24", None, "A23", "A24", "B26", "A26"],
-            "LVCMOS18", Series7),
-        "xc7vx690t": ("ffg1157-1",
-            ["AL33", None, "AN33", "AN34", "AK34", "AL34"],
-            "LVCMOS18", Series7),
-        "xc7vx980t": ("ffg1926-1",
-            ["AK33", None, "AN34", "AN35", "AJ34", "AK34"],
-            "LVCMOS18", Series7),
+        #
+        # chip: (package, id, standard, class)
+        "xc3s100e": ("cp132", 1, "LVCMOS33", Spartan3),
+        "xc3s1200e": ("fg320", 1, "LVCMOS33", Spartan3),
+        "xc3s1400a": ("fg484", 1, "LVCMOS33", Spartan3A),
+        "xc3s1400an": ("fgg484", 1, "LVCMOS33", Spartan3A),
+        "xc3s1600e": ("fg320", 1, "LVCMOS33", Spartan3),
+        "xc3s200a": ("fg320", 2, "LVCMOS33", Spartan3A),
+        "xc3s200an": ("ftg256", 1, "LVCMOS33", Spartan3A),
+        "xc3s250e": ("cp132", 1, "LVCMOS33", Spartan3),
+        "xc3s400a": ("fg320", 2, "LVCMOS33", Spartan3A),
+        "xc3s400an": ("fgg400", 1, "LVCMOS33", Spartan3A),
+        "xc3s500e": ("cp132", 1, "LVCMOS33", Spartan3),
+        "xc3s50a": ("ft256", 1, "LVCMOS33", Spartan3A),
+        "xc3s50an": ("ftg256", 1, "LVCMOS33", Spartan3A),
+        "xc3s700a": ("fg400", 1, "LVCMOS33", Spartan3A),
+        "xc3s700an": ("fgg484", 1, "LVCMOS33", Spartan3A),
+        "xc3sd1800a": ("cs484", 1, "LVCMOS33", Spartan3A),
+        "xc3sd3400a": ("cs484", 1, "LVCMOS33", Spartan3A),
+
+        "xc6slx100": ("csg484-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx100t": ("csg484-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx150": ("csg484-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx150t": ("csg484-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx16": ("cpg196-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx25": ("csg324-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx25t": ("csg324-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx45": ("csg324-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx45t": ("csg324-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx4": ("cpg196-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx4t": ("qg144-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx75": ("csg484-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx75t": ("csg484-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx9": ("cpg196-2", 1, "LVCMOS33", Spartan6),
+        "xc6slx9t": ("qg144-2", 1, "LVCMOS33", Spartan6),
+
+        "xc7a100t": ("csg324-1", 1, "LVCMOS25", Series7),
+        "xc7a15t": ("cpg236-1", 1, "LVCMOS25", Series7),
+        "xc7a200t": ("fbg484-1", 1, "LVCMOS25", Series7),
+        "xc7a35t": ("cpg236-1", 1, "LVCMOS25", Series7),
+        "xc7a50t": ("cpg236-1", 1, "LVCMOS25", Series7),
+        "xc7a75t": ("csg324-1", 1, "LVCMOS25", Series7),
+        "xc7k160t": ("fbg484-1", 2, "LVCMOS25", Series7),
+        "xc7k325t": ("fbg676-1", 1, "LVCMOS25", Series7),
+        "xc7k355t": ("ffg901-1", 1, "LVCMOS25", Series7),
+        "xc7k410t": ("fbg676-1", 1, "LVCMOS25", Series7),
+        "xc7k420t": ("ffg1156-1", 1, "LVCMOS25", Series7),
+        "xc7k480t": ("ffg1156-1", 1, "LVCMOS25", Series7),
+        "xc7k70t": ("fbg484-1", 2, "LVCMOS25", Series7),
+        "xc7v2000t": ("fhg1761-1", 1, "LVCMOS18", Series7),
+        "xc7v585t": ("ffg1157-1", 1, "LVCMOS18", Series7),
+        "xc7vh580t": ("flg1155-1", 1, "LVCMOS18", Series7),
+        "xc7vh870t": ("flg1932-1", 1, "LVCMOS18", Series7),
+        "xc7vx1140t": ("flg1926-1", 1, "LVCMOS18", Series7),
+        "xc7vx330t": ("ffg1157-1", 1, "LVCMOS18", Series7),
+        "xc7vx415t": ("ffg1157-1", 1, "LVCMOS18", Series7),
+        "xc7vx485t": ("ffg1157-1", 1, "LVCMOS18", Series7),
+        "xc7vx550t": ("ffg1158-1", 1, "LVCMOS18", Series7),
+        "xc7vx690t": ("ffg1157-1", 1, "LVCMOS18", Series7),
+        "xc7vx980t": ("ffg1926-1", 1, "LVCMOS18", Series7),
     }
 
-    def __init__(self, device, pins, std):
+    def __init__(self, device, pins, std, toolchain="ise"):
         cs_n, clk, mosi, miso = pins[:4]
         io = ["spiflash", 0,
               Subsignal("cs_n", Pins(cs_n)),
@@ -278,26 +211,21 @@ class XilinxBscanSpi(XilinxPlatform):
             io.append(Subsignal("clk", Pins(clk)))
         for i, p in enumerate(pins[4:]):
             io.append(Subsignal("pullup{}".format(i), Pins(p), Misc("PULLUP")))
-
-        XilinxPlatform.__init__(self, device, [io])
-        if isinstance(self.toolchain, XilinxVivadoToolchain):
-            self.toolchain.bitstream_commands.append(
-                "set_property BITSTREAM.GENERAL.COMPRESS True [current_design]"
-            )
-        elif isinstance(self.toolchain, XilinxISEToolchain):
-            self.toolchain.bitgen_opt += " -g compress"
+        xilinx.XilinxPlatform.__init__(self, device, [io], toolchain=toolchain)
 
     @classmethod
     def make(cls, device, errors=False):
-        pkg, pins, std, Top = cls.pinouts[device]
-        platform = cls("{}-{}".format(device, pkg), pins, std)
+        pkg, id, std, Top = cls.pinouts[device]
+        pins = cls.packages[(pkg, id)]
+        platform = cls("{}-{}".format(device, pkg), pins, std, Top.toolchain)
         top = Top(platform)
         name = "bscan_spi_{}".format(device)
         dir = "build_{}".format(device)
         try:
             platform.build(top, build_name=name, build_dir=dir)
         except Exception as e:
-            print("ERROR: build failed for {}: {}".format(device, e))
+            print(("ERROR: xilinx_bscan_spi build failed "
+                  "for {}: {}").format(device, e))
             if errors:
                 raise
 
diff --git a/contrib/loaders/flash/kinetis/Makefile b/contrib/loaders/flash/kinetis/Makefile
new file mode 100644
index 00000000..b240f53d
--- /dev/null
+++ b/contrib/loaders/flash/kinetis/Makefile
@@ -0,0 +1,19 @@
+BIN2C = ../../../../src/helper/bin2char.sh
+
+CROSS_COMPILE ?= arm-none-eabi-
+AS      = $(CROSS_COMPILE)as
+OBJCOPY = $(CROSS_COMPILE)objcopy
+
+all: kinetis_flash.inc
+
+%.elf: %.s
+	$(AS) $< -o $@
+
+%.bin: %.elf
+	$(OBJCOPY) -Obinary $< $@
+
+%.inc: %.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.bin *.inc
diff --git a/contrib/loaders/flash/kinetis/kinetis_flash.inc b/contrib/loaders/flash/kinetis/kinetis_flash.inc
new file mode 100644
index 00000000..c93797b7
--- /dev/null
+++ b/contrib/loaders/flash/kinetis/kinetis_flash.inc
@@ -0,0 +1,6 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x16,0x68,0x00,0x2e,0x1f,0xd0,0x55,0x68,0xb5,0x42,0xf9,0xd0,0x60,0x60,0x06,0x27,
+0xe7,0x71,0x2f,0x68,0xa7,0x60,0x80,0x27,0x27,0x70,0x04,0x35,0x9d,0x42,0x01,0xd3,
+0x15,0x1c,0x08,0x35,0x55,0x60,0x16,0x68,0x00,0x2e,0x0c,0xd0,0x26,0x78,0x3e,0x42,
+0xf9,0xd0,0x70,0x27,0x3e,0x42,0x04,0xd1,0x04,0x30,0x01,0x39,0x00,0x29,0xdf,0xd1,
+0x01,0xe0,0x00,0x25,0x55,0x60,0x00,0xbe,
diff --git a/contrib/loaders/flash/kinetis/kinetis_flash.s b/contrib/loaders/flash/kinetis/kinetis_flash.s
new file mode 100644
index 00000000..c8e6e05a
--- /dev/null
+++ b/contrib/loaders/flash/kinetis/kinetis_flash.s
@@ -0,0 +1,101 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by Ivan Meleca                                     *
+ *   ivan@artekit.eu                                                       *
+ *                                                                         *
+ *   Copyright (C) 2016 by Tomas Vanek                                     *
+ *   vanekt@fbl.cz                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ ***************************************************************************/
+
+	/* Params:
+	 * r0 = flash destination address in/out
+	 * r1 = longword count
+	 * r2 = workarea start address
+	 * r3 = workarea end address
+	 * r4 = FTFx base
+	 */
+
+	.text
+	.cpu cortex-m0plus
+	.code 16
+	.thumb_func
+
+	.align	2
+
+	/* r5 = rp
+	 * r6 = wp, tmp
+	 * r7 = tmp
+	 */
+
+	/* old longword algo: 6.680 KiB/s @ adapter_khz 2000
+	 * this async algo: 19.808 KiB/s @ adapter_khz 2000
+	 */
+
+FTFx_FSTAT =	0
+FTFx_FCCOB3 =	4
+FTFx_FCCOB0 =	7
+FTFx_FCCOB7 =	8
+
+wait_fifo:
+	ldr 	r6, [r2, #0]	/* read wp */
+	cmp 	r6, #0		/* abort if wp == 0 */
+	beq 	exit
+
+	ldr 	r5, [r2, #4]	/* read rp */
+	cmp 	r5, r6		/* wait until rp != wp */
+	beq 	wait_fifo
+
+	str	r0, [r4, #FTFx_FCCOB3] /* set flash address */
+	mov	r7, #6
+	strb	r7, [r4, #FTFx_FCCOB0] /* flash command */
+
+	ldr	r7, [r5]	/* set longword data = *rp */
+	str	r7, [r4, #FTFx_FCCOB7]
+
+	mov	r7, #128
+	strb	r7, [r4, #FTFx_FSTAT]
+
+	add	r5, #4		/* rp += 4 */
+	cmp     r5, r3		/* Wrap? */
+	bcc     no_wrap
+	mov     r5, r2
+	add   	r5, #8
+
+no_wrap:
+	str     r5, [r2, #4]	/* Store rp */
+
+wait_ccif:
+	ldr     r6, [r2, #0]    /* read wp */
+	cmp     r6, #0          /* abort if wp == 0 */
+	beq     exit
+
+	ldrb	r6, [r4, #FTFx_FSTAT]
+	tst	r6, r7
+	beq	wait_ccif
+
+	mov	r7, #0x70
+	tst	r6, r7
+	bne	error
+
+	add	r0, #4		/* flash address += 4, do not increment before err check */
+
+	sub	r1, #1		/* word_count-- */
+	cmp	r1, #0
+	bne	wait_fifo
+	b	exit
+
+error:
+	mov	r5, #0
+	str     r5, [r2, #4]    /* set rp = 0 on error */
+
+exit:
+	bkpt    #0
diff --git a/contrib/loaders/flash/kinetis_ke/Makefile b/contrib/loaders/flash/kinetis_ke/Makefile
new file mode 100644
index 00000000..7d8dba8c
--- /dev/null
+++ b/contrib/loaders/flash/kinetis_ke/Makefile
@@ -0,0 +1,21 @@
+BIN2C = ../../../../src/helper/bin2char.sh
+
+CROSS_COMPILE ?= arm-none-eabi-
+AS      = $(CROSS_COMPILE)as
+OBJCOPY = $(CROSS_COMPILE)objcopy
+
+AFLAGS = -EL
+
+all: kinetis_ke_flash.inc kinetis_ke_watchdog.inc
+
+%.elf: %.s
+	$(AS) $(AFLAGS) $< -o $@
+
+%.bin: %.elf
+	$(OBJCOPY) -Obinary $< $@
+
+%.inc: %.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.bin *.inc
diff --git a/contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.inc b/contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.inc
new file mode 100644
index 00000000..9bb0fa89
--- /dev/null
+++ b/contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.inc
@@ -0,0 +1,15 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x16,0x68,0x00,0x2e,0xfe,0xd0,0x55,0x68,0xb5,0x42,0xf9,0xd0,0x2f,0x4e,0x30,0x27,
+0x37,0x70,0x2f,0x4e,0x00,0x27,0x37,0x70,0x2e,0x4e,0x06,0x27,0x37,0x70,0x07,0x0c,
+0x2d,0x4e,0x37,0x70,0x2a,0x4e,0x01,0x27,0x37,0x70,0xc7,0xb2,0x2a,0x4e,0x37,0x70,
+0x07,0x0a,0x28,0x4e,0x37,0x70,0x26,0x4e,0x02,0x27,0x37,0x70,0x6f,0x78,0x25,0x4e,
+0x37,0x70,0x2f,0x78,0x24,0x4e,0x37,0x70,0x21,0x4e,0x03,0x27,0x37,0x70,0xef,0x78,
+0x20,0x4e,0x37,0x70,0xaf,0x78,0x20,0x4e,0x37,0x70,0x01,0x39,0x04,0x30,0x04,0x35,
+0x9d,0x42,0x01,0xd3,0x15,0x1c,0x08,0x35,0x00,0x29,0x1b,0xd0,0x16,0x68,0xae,0x42,
+0x18,0xd0,0x17,0x4e,0x04,0x27,0x37,0x70,0x6f,0x78,0x16,0x4e,0x37,0x70,0x2f,0x78,
+0x15,0x4e,0x37,0x70,0x12,0x4e,0x05,0x27,0x37,0x70,0xef,0x78,0x11,0x4e,0x37,0x70,
+0xaf,0x78,0x11,0x4e,0x37,0x70,0x01,0x39,0x04,0x30,0x04,0x35,0x9d,0x42,0x01,0xd3,
+0x15,0x1c,0x08,0x35,0x09,0x4e,0x80,0x27,0x37,0x70,0x08,0x4e,0x36,0x78,0x3e,0x42,
+0xfb,0xd0,0x30,0x27,0x3e,0x42,0x04,0xd1,0x00,0x26,0x55,0x60,0x00,0x29,0x02,0xd0,
+0x9e,0xe7,0x00,0x20,0x50,0x60,0x30,0x1c,0x00,0xbe,0xc0,0x46,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
diff --git a/contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.s b/contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.s
new file mode 100644
index 00000000..1fa76133
--- /dev/null
+++ b/contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.s
@@ -0,0 +1,184 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by Ivan Meleca                                     *
+ *   ivan@artekit.eu                                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ ***************************************************************************/
+
+	/* Params:
+	 * r0 = flash destination address, status
+	 * r1 = longword count
+	 * r2 = workarea start address
+	 * r3 = workarea end address
+	 */
+
+	.text
+	.cpu cortex-m0plus
+	.code 16
+	.thumb_func
+
+	.align	2
+
+	/* r5 = rp
+	 * r6 = wp, tmp
+	 * r7 = tmp
+	 */
+
+wait_fifo:
+	ldr 	r6, [r2, #0]	/* read wp */
+	cmp 	r6, #0			/* abort if wp == 0 */
+	beq 	exit
+	ldr 	r5, [r2, #4]	/* read rp */
+	cmp 	r5, r6			/* wait until rp != wp */
+	beq 	wait_fifo
+
+	ldr		r6, fstat		/* Clear error flags */
+	mov		r7, #48
+	strb	r7, [r6]
+
+	ldr		r6, fccobix		/* FCCOBIX = 0 */
+	mov		r7, #0
+	strb	r7, [r6]
+
+	ldr 	r6, fccobhi		/* Program FLASH command */
+	mov		r7, #6			/* FCCOBHI = 6 */
+	strb	r7, [r6]
+
+	lsr		r7, r0, #16		/* FCCOBLO = flash destination address >> 16 */
+	ldr		r6, fccoblo
+	strb	r7, [r6]
+
+	ldr		r6, fccobix		/* Index for lower byte address bits[15:0] */
+	mov		r7, #1
+	strb	r7, [r6]		/* FCCOBIX = 1*/
+
+	uxtb	r7, r0			/* Memory address bits[15:0] */
+	ldr 	r6, fccoblo
+	strb	r7, [r6]		/* FCCOBLO = flash destination address */
+
+	lsr		r7, r0, #8
+	ldr		r6, fccobhi
+	strb	r7, [r6]		/* FCCOBHI = flash destination address >> 8 */
+
+	ldr		r6, fccobix		/* FCCOBIX = 2 */
+	mov		r7, #2
+	strb	r7, [r6]
+
+	ldrb	r7, [r5, #1]	/* FCCOBHI = rp >> 8 */
+	ldr		r6, fccobhi
+	strb	r7, [r6]
+
+	ldrb	r7, [r5]		/* FCCOBLO = rp */
+	ldr 	r6, fccoblo
+	strb	r7, [r6]
+
+	ldr		r6, fccobix		/* FCCOBIX = 3 */
+	mov		r7, #3
+	strb	r7, [r6]
+
+	ldrb	r7, [r5, #3]	/* FCCOBHI = rp >> 24 */
+	ldr		r6, fccobhi
+	strb	r7, [r6]
+
+	ldrb	r7, [r5, #2]	/* FCCOBLO = rp >> 16 */
+	ldr		r6, fccoblo
+	strb	r7, [r6]
+
+	sub		r1, r1, #1		/* Two words (4 bytes) queued, decrement counter */
+	add		r0, r0, #4		/* flash address += 4 */
+	add		r5, r5, #4		/* rp += 4 */
+
+	cmp     r5, r3			/* Wrap? */
+	bcc     no_wrap
+	mov     r5, r2
+	add   	r5, r5, #8
+
+no_wrap:
+	cmp		r1, #0			/* Done? */
+	beq		execute
+
+	ldr 	r6, [r2, #0]	/* read wp */
+	cmp 	r6, r5
+	beq		execute			/* execute if rp == wp */
+
+	ldr		r6, fccobix		/* FCCOBIX = 4 */
+	mov		r7, #4
+	strb	r7, [r6]
+
+	ldrb	r7, [r5, #1]	/* FCCOBHI = rp >> 8 */
+	ldr		r6, fccobhi
+	strb	r7, [r6]
+
+	ldrb	r7, [r5]		/* FCCOBLO = rp */
+	ldr 	r6, fccoblo
+	strb	r7, [r6]
+
+	ldr		r6, fccobix		/* FCCOBIX = 5 */
+	mov		r7, #5
+	strb	r7, [r6]
+
+	ldrb	r7, [r5, #3]	/* FCCOBHI = rp >> 24 */
+	ldr		r6, fccobhi
+	strb	r7, [r6]
+
+	ldrb	r7, [r5, #2]	/* FCCOBLO = rp >> 16 */
+	ldr		r6, fccoblo
+	strb	r7, [r6]
+
+	sub		r1, r1, #1		/* Two words (4 bytes) queued, decrement counter */
+	add		r0, r0, #4		/* flash address += 4 */
+	add		r5, r5, #4		/* rp += 4 */
+
+	cmp     r5, r3			/* Wrap? */
+	bcc     execute
+	mov     r5, r2
+	add   	r5, r5, #8
+
+execute:
+	ldr		r6, fstat		/* Launch the command */
+	mov		r7, #128
+	strb	r7, [r6]
+
+wait_busy:
+	ldr		r6, fstat
+	ldrb	r6, [r6]		/* Wait until finished */
+	tst		r6, r7
+	beq		wait_busy
+
+	mov		r7, #48			/* Check error */
+	tst		r6, r7
+	bne		error
+
+	mov		r6, #0			/* Clear error */
+
+	str     r5, [r2, #4]	/* Store rp */
+
+	cmp		r1, #0			/* Done? */
+	beq		done
+	b		wait_fifo
+
+error:
+	mov		r0, #0
+	str     r0, [r2, #4]    /* set rp = 0 on error */
+
+done:
+	mov		r0, r6			/* Set result code */
+	bkpt    #0
+
+	.align	2
+fstat:
+	.word	0
+fccobix:
+	.word	0
+fccobhi:
+	.word	0
+fccoblo:
+	.word	0
diff --git a/contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.inc b/contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.inc
new file mode 100644
index 00000000..44a9d5e5
--- /dev/null
+++ b/contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.inc
@@ -0,0 +1,4 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x07,0x4b,0x7f,0x22,0x1d,0x78,0x5c,0x78,0x2a,0x40,0x06,0x4d,0x98,0x88,0xd9,0x88,
+0x5d,0x80,0x05,0x4d,0x5d,0x80,0x5c,0x70,0x98,0x80,0xd9,0x80,0x1a,0x70,0x00,0xbe,
+0x00,0x20,0x05,0x40,0xc5,0x20,0x00,0x00,0xd9,0x28,0x00,0x00,
diff --git a/contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.s b/contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.s
new file mode 100644
index 00000000..289662d0
--- /dev/null
+++ b/contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.s
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by Ivan Meleca                                     *
+ *   ivan@artekit.eu                                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ ***************************************************************************/
+
+	.text
+	.cpu cortex-m0plus
+	.code 16
+	.thumb_func
+
+	.align	2
+
+	ldr		r3, wdog_cs1
+	mov		r2, #127
+	ldrb	r5, [r3]
+	ldrb	r4, [r3, #1]
+	and		r2, r5
+	ldr		r5, unlock1
+	ldrh	r0, [r3, #4]
+	ldrh	r1, [r3, #6]
+	strh	r5, [r3, #2]
+	ldr		r5, unlock2
+	strh	r5, [r3, #2]
+	strb	r4, [r3, #1]
+	strh	r0, [r3, #4]
+	strh	r1, [r3, #6]
+	strb	r2, [r3]
+	bkpt	#0
+
+	.align	2
+
+wdog_cs1:
+	.word	0x40052000	// Watchdog Control and Status Register 1
+unlock1:
+	.word	0x20C5		// 1st unlock word
+unlock2:
+	.word	0x28D9		// 2nd unlock word
diff --git a/contrib/loaders/flash/stm32l4x.S b/contrib/loaders/flash/stm32l4x.S
index f58e0989..799dec52 100644
--- a/contrib/loaders/flash/stm32l4x.S
+++ b/contrib/loaders/flash/stm32l4x.S
@@ -51,9 +51,9 @@
  * r4 = flash base
  *
  * Clobbered:
- * r6 - temp
- * r7 - rp
- * r8 - wp, tmp
+ * r5   - rp
+ * r6/7 - temp (64-bit)
+ * r8   - wp, tmp
  */
 
 #define STM32_FLASH_CR_OFFSET	0x14	/* offset of CR register in FLASH struct */
@@ -63,18 +63,19 @@ wait_fifo:
 	ldr 	r8, [r0, #0]	/* read wp */
 	cmp 	r8, #0		/* abort if wp == 0 */
 	beq 	exit
-	ldr 	r7, [r0, #4]	/* read rp */
-	subs	r6, r8, r7	/* number of bytes available for read in r6*/
-	cmp 	r6, #7		/* wait until 8 bytes are available */
+	ldr 	r5, [r0, #4]	/* read rp */
+	subs	r6, r8, r5	/* number of bytes available for read in r6*/
+	itt 	mi              /* if wrapped around*/
+	addmi	r6, r1          /* add size of buffer */
+	submi	r6, r0
+	cmp 	r6, #8		/* wait until 8 bytes are available */
 	bcc 	wait_fifo
 
 	ldr	r6, STM32_PROG
 	str	r6, [r4, #STM32_FLASH_CR_OFFSET]
-	ldr 	r6, [r7], #0x04	/* read one word from src, increment ptr */
-	str 	r6, [r2], #0x04	/* write one word to dst, increment ptr */
-	ldr 	r6, [r7], #0x04	/* read one word from src, increment ptr */
-	str 	r6, [r2], #0x04	/* write one word to dst, increment ptr */
-        dsb
+	ldrd 	r6, [r5], #0x08	/* read one word from src, increment ptr */
+	strd 	r6, [r2], #0x08	/* write one word to dst, increment ptr */
+	dsb
 busy:
 	ldr 	r6, [r4, #STM32_FLASH_SR_OFFSET]
 	tst 	r6, #0x10000	/* BSY (bit16) == 1 => operation in progress */
@@ -82,10 +83,10 @@ busy:
 	tst	r6, #0xfa	/* PGSERR | PGPERR | PGAERR | WRPERR | PROGERR*/
 	bne	error		/* fail... */
 
-	cmp 	r7, r1		/* wrap rp at end of buffer */
+	cmp 	r5, r1		/* wrap rp at end of buffer */
 	it  	cs
-	addcs	r7, r0, #8	/* skip loader args */
-	str 	r7, [r0, #4]	/* store rp */
+	addcs	r5, r0, #8	/* skip loader args */
+	str 	r5, [r0, #4]	/* store rp */
 	subs	r3, r3, #1	/* decrement dword count */
 	cbz 	r3, exit	/* loop if not done */
 	b	wait_fifo
diff --git a/contrib/loaders/flash/stm32lx.S b/contrib/loaders/flash/stm32lx.S
index 88deed32..8f9fd0b2 100644
--- a/contrib/loaders/flash/stm32lx.S
+++ b/contrib/loaders/flash/stm32lx.S
@@ -8,6 +8,9 @@
  *   Copyright (C) 2011 Clement Burin des Roziers                          *
  *   clement.burin-des-roziers@hikob.com                                   *
  *                                                                         *
+ *   Copyright (C) 2017 Armin van der Togt                                 *
+ *   armin@otheruse.nl                                                     *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -28,7 +31,7 @@
 // Build : arm-eabi-gcc -c stm32lx.S
 	.text
 	.syntax unified
-	.cpu cortex-m3
+	.cpu cortex-m0
 	.thumb
 	.thumb_func
 	.global write
@@ -39,24 +42,21 @@
 	r2 - count
 */
 
-	// Set 0 to r3
-	movs	r3, #0
+	// r2 = source + count * 4
+	lsls	r2, r2, #2
+	adds	r2, r1, r2
 	// Go to compare
-	b.n test_done
-
+	b	test_done
 write_word:
-	// Load one word from address in r0, increment by 4
-	ldr.w	ip, [r1], #4
-	// Store the word to address in r1, increment by 4
-	str.w	ip, [r0], #4
-	// Increment r3
-	adds	r3, #1
-
+	// load word from address in r1 and increase r1 by 4
+	ldmia r1!, {r3}
+	// store word to address in r0 and increase r0 by 4
+	stmia r0!, {r3}
 test_done:
-	// Compare r3 and r2
-	cmp 	r3, r2
-	// Loop if not zero
-	bcc.n	write_word
+	// compare r1 and r2
+	cmp	r1, r2
+	// loop if not equal
+	bne	write_word
 
 	// Set breakpoint to exit
 	bkpt	#0x00
diff --git a/contrib/loaders/flash/xmc1xxx/Makefile b/contrib/loaders/flash/xmc1xxx/Makefile
new file mode 100644
index 00000000..b97c602d
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/Makefile
@@ -0,0 +1,32 @@
+BIN2C = ../../../../src/helper/bin2char.sh
+
+CROSS_COMPILE ?= arm-none-eabi-
+
+CC=$(CROSS_COMPILE)gcc
+OBJCOPY=$(CROSS_COMPILE)objcopy
+OBJDUMP=$(CROSS_COMPILE)objdump
+
+CFLAGS = -static -nostartfiles -mlittle-endian -Wa,-EL
+
+all: erase.inc erase_check.inc write.inc
+
+.PHONY: clean
+
+.INTERMEDIATE: erase.elf erase_check.elf write.elf
+
+erase.elf erase_check.elf write.elf: xmc1xxx.S
+
+%.elf: %.S
+	$(CC) $(CFLAGS) $< -o $@
+
+%.lst: %.elf
+	$(OBJDUMP) -S $< > $@
+
+%.bin: %.elf
+	$(OBJCOPY) -Obinary $< $@
+
+%.inc: %.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.lst *.bin *.inc
diff --git a/contrib/loaders/flash/xmc1xxx/erase.S b/contrib/loaders/flash/xmc1xxx/erase.S
new file mode 100644
index 00000000..e5a4808f
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/erase.S
@@ -0,0 +1,53 @@
+/*
+ * Infineon XMC1000 flash sectors erase
+ *
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * Based on XMC1100 AA-Step Reference Manual
+ *
+ * License: GPL-2.0+
+ */
+
+#include "xmc1xxx.S"
+
+#define DUMMY_VALUE 0x42
+
+	.macro erase_page, nvmbase, addr, tmp, tmp2
+
+	movs	\tmp, #DUMMY_VALUE
+	str	\tmp, [\addr]
+
+	busy_wait \nvmbase, \tmp, \tmp2
+
+	.endm
+
+
+	.macro erase, nvmbase, addr, end, tmp, tmp2
+
+	movs	\tmp, #NVMPROG_ACTION_PAGE_ERASE_CONTINUOUS
+	strh	\tmp, [\nvmbase, #NVMPROG]
+2001:
+	erase_page \nvmbase, \addr, \tmp, \tmp2
+
+	movs	\tmp, #(NVM_PAGE_SIZE - 1)
+	adds	\tmp, \tmp, #1
+	add	\addr, \addr, \tmp
+	cmp	\addr, \end
+	blt	2001b
+
+	movs	\tmp, #NVMPROG_ACTION_IDLE
+	strh	\tmp, [\nvmbase, #NVMPROG]
+
+	.endm
+
+
+	/*
+	 * r0 = 0x40050000
+	 * r1 = e.g. 0x10001000
+	 * r2 = e.g. 0x10011000
+	 * NVMPROG.ACTION = 0x00
+	 */
+erase:
+	erase r0, r1, r2, r3, r4
+
+	bkpt	#0
diff --git a/contrib/loaders/flash/xmc1xxx/erase.inc b/contrib/loaders/flash/xmc1xxx/erase.inc
new file mode 100644
index 00000000..b33e57d1
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/erase.inc
@@ -0,0 +1,4 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0xa2,0x23,0x83,0x80,0x42,0x23,0x0b,0x60,0x03,0x88,0x01,0x24,0x23,0x40,0xa3,0x42,
+0xfa,0xd0,0xff,0x23,0x01,0x33,0x19,0x44,0x91,0x42,0xf3,0xdb,0x00,0x23,0x83,0x80,
+0x00,0xbe,
diff --git a/contrib/loaders/flash/xmc1xxx/erase_check.S b/contrib/loaders/flash/xmc1xxx/erase_check.S
new file mode 100644
index 00000000..6c993443
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/erase_check.S
@@ -0,0 +1,67 @@
+/*
+ * Infineon XMC1000 flash sector erase check
+ *
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * Based on XMC1100 AA-Step Reference Manual
+ *
+ * License: GPL-2.0+
+ */
+
+#include "xmc1xxx.S"
+
+	.macro verify_block, nvmbase, addr, tmp, tmp2
+
+	movs	\tmp, #0x00
+	mvns	\tmp, \tmp
+	str	\tmp, [\addr, #0x0]
+	str	\tmp, [\addr, #0x4]
+	str	\tmp, [\addr, #0x8]
+	str	\tmp, [\addr, #0xC]
+
+	busy_wait \nvmbase, \tmp, \tmp2
+
+	.endm
+
+
+	.macro erase_check, nvmbase, addr, end, tmp, tmp2
+
+	ldrh	\tmp, [\nvmbase, #NVMCONF]
+	movs	\tmp2, #NVMCONF_HRLEV_MASK
+	mvns	\tmp2, \tmp2
+	ands	\tmp, \tmp, \tmp2
+	movs	\tmp2, #NVMCONF_HRLEV_HRE
+	orrs	\tmp, \tmp, \tmp2
+	strh	\tmp, [\nvmbase, #NVMCONF]
+
+	movs	\tmp, #NVMPROG_ACTION_VERIFY_CONTINUOUS
+	strh	\tmp, [\nvmbase, #NVMPROG]
+2001:
+	verify_block \nvmbase, \addr, \tmp, \tmp2
+
+	ldrh	\tmp, [\nvmbase, #NVMSTATUS]
+	movs	\tmp2, #NVMSTATUS_VERR_MASK
+	ands	\tmp, \tmp, \tmp2
+	cmp	\tmp, #NVMSTATUS_VERR_NOFAIL
+	bne	2010f
+
+	adds	\addr, \addr, #NVM_BLOCK_SIZE
+	cmp	\addr, \end
+	blt	2001b
+2010:
+	movs	\tmp, #NVMPROG_ACTION_IDLE
+	strh	\tmp, [\nvmbase, #NVMPROG]
+
+	.endm
+
+
+	/*
+	 * r0 = 0x40050000
+	 * r1 = e.g. 0x10001000
+	 * r2 = e.g. 0x10002000
+	 * NVMPROG.ACTION = 0x00
+	 */
+erase_check:
+	erase_check r0, r1, r2, r3, r4
+
+	bkpt	#0
diff --git a/contrib/loaders/flash/xmc1xxx/erase_check.inc b/contrib/loaders/flash/xmc1xxx/erase_check.inc
new file mode 100644
index 00000000..8fc8e0b5
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/erase_check.inc
@@ -0,0 +1,5 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0x03,0x89,0x06,0x24,0xe4,0x43,0x23,0x40,0x04,0x24,0x23,0x43,0x03,0x81,0xe0,0x23,
+0x83,0x80,0x00,0x23,0xdb,0x43,0x0b,0x60,0x4b,0x60,0x8b,0x60,0xcb,0x60,0x03,0x88,
+0x01,0x24,0x23,0x40,0xa3,0x42,0xfa,0xd0,0x03,0x88,0x0c,0x24,0x23,0x40,0x00,0x2b,
+0x02,0xd1,0x10,0x31,0x91,0x42,0xec,0xdb,0x00,0x23,0x83,0x80,0x00,0xbe,
diff --git a/contrib/loaders/flash/xmc1xxx/write.S b/contrib/loaders/flash/xmc1xxx/write.S
new file mode 100644
index 00000000..640f6ca9
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/write.S
@@ -0,0 +1,58 @@
+/*
+ * Infineon XMC1000 flash write
+ *
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * Based on XMC1100 AA-Step Reference Manual
+ *
+ * License: GPL-2.0+
+ */
+
+#include "xmc1xxx.S"
+
+	.macro write_block, nvmbase, dest, src, tmp, tmp2
+
+	ldr	\tmp, [\src,  #0x0]
+	str	\tmp, [\dest, #0x0]
+	ldr	\tmp, [\src,  #0x4]
+	str	\tmp, [\dest, #0x4]
+	ldr	\tmp, [\src,  #0x8]
+	str	\tmp, [\dest, #0x8]
+	ldr	\tmp, [\src,  #0xc]
+	str	\tmp, [\dest, #0xc]
+
+	busy_wait \nvmbase, \tmp, \tmp2
+
+	.endm
+
+
+	.macro write, nvmbase, dest, src, count, tmp, tmp2
+
+	movs	\tmp, #NVMPROG_ACTION_WRITE_CONTINUOUS
+	strh	\tmp, [\nvmbase, #NVMPROG]
+1001:
+	write_block \nvmbase, \dest, \src, \tmp, \tmp2
+
+	adds	\dest, \dest, #NVM_BLOCK_SIZE
+	adds	\src, \src, #NVM_BLOCK_SIZE
+	subs	\count, \count, #1
+	cmp	\count, #0
+	bgt	1001b
+
+	movs	\tmp, #NVMPROG_ACTION_IDLE
+	strh	\tmp, [\nvmbase, #NVMPROG]
+
+	.endm
+
+
+	/*
+	 * r0 = 0x40050000
+	 * r1 = e.g. 0x10001000
+	 * r2 = e.g. 0x20000000
+	 * r3 = e.g. 1
+	 * NVMPROG.ACTION = 0x00
+	 */
+write:
+	write r0, r1, r2, r3, r4, r5
+
+	bkpt	#0
diff --git a/contrib/loaders/flash/xmc1xxx/write.inc b/contrib/loaders/flash/xmc1xxx/write.inc
new file mode 100644
index 00000000..8272bb7e
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/write.inc
@@ -0,0 +1,4 @@
+/* Autogenerated with ../../../../src/helper/bin2char.sh */
+0xa1,0x24,0x84,0x80,0x14,0x68,0x0c,0x60,0x54,0x68,0x4c,0x60,0x94,0x68,0x8c,0x60,
+0xd4,0x68,0xcc,0x60,0x04,0x88,0x01,0x25,0x2c,0x40,0xac,0x42,0xfa,0xd0,0x10,0x31,
+0x10,0x32,0x01,0x3b,0x00,0x2b,0xed,0xdc,0x00,0x24,0x84,0x80,0x00,0xbe,
diff --git a/contrib/loaders/flash/xmc1xxx/xmc1xxx.S b/contrib/loaders/flash/xmc1xxx/xmc1xxx.S
new file mode 100644
index 00000000..dfe7d3f4
--- /dev/null
+++ b/contrib/loaders/flash/xmc1xxx/xmc1xxx.S
@@ -0,0 +1,46 @@
+/*
+ * Infineon XMC1000 flash
+ *
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * Based on XMC1100 AA-Step Reference Manual
+ *
+ * License: GPL-2.0+
+ */
+
+	.text
+	.syntax unified
+	.cpu cortex-m0
+	.thumb
+	.thumb_func
+
+#define NVMSTATUS	0x00
+#define NVMPROG		0x04
+#define NVMCONF		0x08
+
+#define NVMSTATUS_BUSY		(1 << 0)
+#define NVMSTATUS_VERR_NOFAIL	(0x0 << 2)
+#define NVMSTATUS_VERR_MASK	(0x3 << 2)
+
+#define NVMPROG_ACTION_IDLE			0x00
+#define NVMPROG_ACTION_WRITE_CONTINUOUS		0xA1
+#define NVMPROG_ACTION_PAGE_ERASE_CONTINUOUS	0xA2
+#define NVMPROG_ACTION_VERIFY_CONTINUOUS	0xE0
+
+#define NVMCONF_HRLEV_NR	(0x0 << 1)
+#define NVMCONF_HRLEV_HRE	(0x2 << 1)
+#define NVMCONF_HRLEV_MASK	(0x3 << 1)
+
+#define NVM_WORD_SIZE	4
+#define NVM_BLOCK_SIZE	(4 * NVM_WORD_SIZE)
+#define NVM_PAGE_SIZE	(16 * NVM_BLOCK_SIZE)
+
+	.macro busy_wait, nvmbase, tmp, tmp2
+1:
+	ldrh	\tmp, [\nvmbase, #NVMSTATUS]
+	movs	\tmp2, #NVMSTATUS_BUSY
+	ands	\tmp, \tmp, \tmp2
+	cmp	\tmp, \tmp2
+	beq	1b
+
+	.endm
diff --git a/contrib/loaders/watchdog/Makefile b/contrib/loaders/watchdog/Makefile
new file mode 100644
index 00000000..ed6d8f4e
--- /dev/null
+++ b/contrib/loaders/watchdog/Makefile
@@ -0,0 +1,21 @@
+BIN2C = ../../../src/helper/bin2char.sh
+
+ARM_CROSS_COMPILE ?= arm-none-eabi-
+ARM_AS      ?= $(ARM_CROSS_COMPILE)as
+ARM_OBJCOPY ?= $(ARM_CROSS_COMPILE)objcopy
+
+ARM_AFLAGS = -EL -mthumb
+
+arm: armv7m_kinetis_wdog.inc armv7m_kinetis_wdog32.inc
+
+armv7m_%.elf: armv7m_%.s
+	$(ARM_AS) $(ARM_AFLAGS) $< -o $@
+
+armv7m_%.bin: armv7m_%.elf
+	$(ARM_OBJCOPY) -Obinary $< $@
+
+armv7m_%.inc: armv7m_%.bin
+	$(BIN2C) < $< > $@
+
+clean:
+	-rm -f *.elf *.bin *.inc
diff --git a/contrib/loaders/watchdog/armv7m_kinetis_wdog.inc b/contrib/loaders/watchdog/armv7m_kinetis_wdog.inc
new file mode 100644
index 00000000..317d084d
--- /dev/null
+++ b/contrib/loaders/watchdog/armv7m_kinetis_wdog.inc
@@ -0,0 +1,3 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x04,0x4a,0xc2,0x81,0x04,0x4a,0xc2,0x81,0x01,0x24,0x02,0x88,0xa2,0x43,0x02,0x80,
+0x05,0xe0,0x00,0x00,0x20,0xc5,0x00,0x00,0x28,0xd9,0x00,0x00,0x00,0x00,0x00,0xbe,
diff --git a/contrib/loaders/watchdog/armv7m_kinetis_wdog.s b/contrib/loaders/watchdog/armv7m_kinetis_wdog.s
new file mode 100644
index 00000000..2a7eb898
--- /dev/null
+++ b/contrib/loaders/watchdog/armv7m_kinetis_wdog.s
@@ -0,0 +1,63 @@
+/***************************************************************************
+ *   Copyright (C) 2015 Tomas Vanek                                        *
+ *   vanekt@fbl.cz                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.                                        *
+ ***************************************************************************/
+
+/*
+	Disable watchdog for Kinetis Kx and KVx
+	Parameters:
+		r0 ... WDOG base (in)
+
+	Used instruction set should work on both Cortex-M4 and M0+
+*/
+
+	.text
+	.syntax unified
+        .cpu cortex-m0
+	.thumb
+
+/* WDOG registers offsets */
+WDOG_STCTRLH	= 0
+WDOG_UNLOCK	= 0x0e
+
+WDOG_KEY1	= 0xc520
+WDOG_KEY2	= 0xd928
+
+	.thumb_func
+start:
+/* WDOG_UNLOCK = 0xC520 */
+	ldr     r2, =WDOG_KEY1
+	strh    r2, [r0, WDOG_UNLOCK]
+/* WDOG_UNLOCK = 0xD928 */
+	ldr     r2, =WDOG_KEY2
+	strh    r2, [r0, WDOG_UNLOCK]
+/* WDOG_STCTRLH clear bit 0 */
+	movs	r4, #1
+	ldrh    r2, [r0, WDOG_STCTRLH]
+	bics	r2, r4
+	strh    r2, [r0, WDOG_STCTRLH]
+/* OpenOCD checks exit point address. Jump to the very end. */
+	b	done
+
+	.pool
+
+/* Avoid padding at .text segment end. Otherwise exit point check fails. */
+	.skip	( . - start + 2) & 2, 0
+done:
+	bkpt    #0
+
+	.end
diff --git a/contrib/loaders/watchdog/armv7m_kinetis_wdog32.inc b/contrib/loaders/watchdog/armv7m_kinetis_wdog32.inc
new file mode 100644
index 00000000..4ee06ed1
--- /dev/null
+++ b/contrib/loaders/watchdog/armv7m_kinetis_wdog32.inc
@@ -0,0 +1,5 @@
+/* Autogenerated with ../../../src/helper/bin2char.sh */
+0x02,0x68,0x08,0x4b,0x1a,0x42,0x08,0x4b,0x01,0xd0,0x43,0x60,0x02,0xe0,0x83,0x80,
+0x1b,0x0c,0x83,0x80,0x80,0x24,0xa2,0x43,0x20,0x24,0x22,0x43,0x02,0x60,0x03,0x4b,
+0x83,0x60,0x06,0xe0,0x00,0x20,0x00,0x00,0x20,0xc5,0x28,0xd9,0x00,0x04,0x00,0x00,
+0x00,0x00,0x00,0xbe,
diff --git a/contrib/loaders/watchdog/armv7m_kinetis_wdog32.s b/contrib/loaders/watchdog/armv7m_kinetis_wdog32.s
new file mode 100644
index 00000000..1284ab0a
--- /dev/null
+++ b/contrib/loaders/watchdog/armv7m_kinetis_wdog32.s
@@ -0,0 +1,80 @@
+/***************************************************************************
+ *   Copyright (C) 2017 Tomas Vanek                                        *
+ *   vanekt@fbl.cz                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.                                        *
+ ***************************************************************************/
+
+/*
+	Disable watchdog, 32-bit version for newer Kinetis
+	Parameters:
+		r0 ... WDOG32 base (in)
+
+	Used instruction set should work on both Cortex-M4 and M0+
+*/
+
+	.text
+	.syntax unified
+        .cpu cortex-m0
+	.thumb
+
+/* WDOG registers offsets */
+WDOG_CS		= 0
+WDOG_CNT	= 4
+WDOG_TOVAL	= 8
+
+WDOG_KEY 	= 0xd928c520
+
+	.thumb_func
+start:
+/* test WDOG_CS bit CMD32EN */
+	ldr     r2, [r0, WDOG_CS]
+	ldr     r3, =0x2000
+	tst     r2, r3
+	ldr     r3, =WDOG_KEY
+	beq     cmd16
+
+/* WDOG_CNT = key */
+	str     r3, [r0, WDOG_CNT]
+	b       unlocked
+
+cmd16:
+/* WDOG_CNT = key, halfword by halfword */
+	strh    r3, [r0, WDOG_CNT]
+	lsrs    r3, r3, #16
+	strh    r3, [r0, WDOG_CNT]
+
+/* WDOG_CS: clear EN bit 7, set UPDATE bit 5 */
+unlocked:
+	movs    r4, #0x80
+	bics    r2, r4
+	movs    r4, #0x20
+	orrs    r2, r4
+	str     r2, [r0, WDOG_CS]
+/* All active WDOG registers have to be updated, set dummy timeout */
+/* WDOG_TOVAL = 0x400 */
+	ldr     r3, =0x400
+	str     r3, [r0, WDOG_TOVAL]
+/* OpenOCD checks exit point address. Jump to the very end. */
+	b       done
+
+	.pool
+
+/* Avoid padding at .text segment end. Otherwise exit point check fails. */
+	.skip	( . - start + 2) & 2, 0
+done:
+	bkpt    #0
+
+	.end
diff --git a/contrib/rtos-helpers/FreeRTOS-openocd.c b/contrib/rtos-helpers/FreeRTOS-openocd.c
index 567e710b..81a3ab77 100644
--- a/contrib/rtos-helpers/FreeRTOS-openocd.c
+++ b/contrib/rtos-helpers/FreeRTOS-openocd.c
@@ -17,4 +17,4 @@
 #define USED
 #endif
 
-const int USED uxTopUsedPriority = configMAX_PRIORITIES;
+const int USED uxTopUsedPriority = configMAX_PRIORITIES - 1;
diff --git a/contrib/rtos-helpers/uCOS-III-openocd.c b/contrib/rtos-helpers/uCOS-III-openocd.c
new file mode 100644
index 00000000..9037334f
--- /dev/null
+++ b/contrib/rtos-helpers/uCOS-III-openocd.c
@@ -0,0 +1,32 @@
+/*
+ * uC/OS-III does not provide a fixed layout for OS_TCB, which makes it
+ * impossible to determine the appropriate offsets within the structure
+ * unaided. A priori knowledge of offsets based on os_dbg.c is tied to a
+ * specific release and thusly, brittle. The constants defined below
+ * provide the neccessary information OpenOCD needs to provide support
+ * in the most robust manner possible.
+ *
+ * This file should be linked along with the project to enable RTOS
+ * support for uC/OS-III.
+ */
+
+#include <os.h>
+
+#if OS_CFG_DBG_EN == 0
+#error "OS_CFG_DBG_EN is required to enable RTOS support for OpenOCD"
+#endif
+
+#define OFFSET_OF(type, member) ((CPU_SIZE_T)&(((type *)0)->member))
+
+#ifdef __GNUC__
+#define USED __attribute__((used))
+#else
+#define USED
+#endif
+
+const CPU_SIZE_T USED openocd_OS_TCB_StkPtr_offset = OFFSET_OF(OS_TCB, StkPtr);
+const CPU_SIZE_T USED openocd_OS_TCB_NamePtr_offset = OFFSET_OF(OS_TCB, NamePtr);
+const CPU_SIZE_T USED openocd_OS_TCB_TaskState_offset = OFFSET_OF(OS_TCB, TaskState);
+const CPU_SIZE_T USED openocd_OS_TCB_Prio_offset = OFFSET_OF(OS_TCB, Prio);
+const CPU_SIZE_T USED openocd_OS_TCB_DbgPrevPtr_offset = OFFSET_OF(OS_TCB, DbgPrevPtr);
+const CPU_SIZE_T USED openocd_OS_TCB_DbgNextPtr_offset = OFFSET_OF(OS_TCB, DbgNextPtr);
diff --git a/doc/INSTALL.txt b/doc/INSTALL.txt
deleted file mode 100644
index c329be2c..00000000
--- a/doc/INSTALL.txt
+++ /dev/null
@@ -1,204 +0,0 @@
-TODO!!! this should be merged into openocd.texi!!!
-
-
-Prerequisites
-=============
-
-When building with support for FTDI FT2232 based devices, you need at least
-one of the following libraries:
-
-- libftdi (http://www.intra2net.com/opensource/ftdi/)
-- libftd2xx (http://www.ftdichip.com/Drivers/D2XX.htm)
-
-On Windows, you need either Cygwin or MinGW, but compilation for MinGW is also
-possible using a Cygwin host.
-
-Basic Installation
-==================
-
-   OpenOCD is distributed without autotools generated files, i.e. without a
-configure script. Run ./bootstrap in the openocd directory to have all
-necessary files generated.
-
-   You have to explicitly enable desired JTAG interfaces during configure:
-
-./configure --enable-parport --enable-ft2232-libftdi (OR  --enable-ft2232-ftd2xx) \
-            --enable-amtjtagaccel
-
-   Under Windows/Cygwin, only the ftd2xx driver is supported for FT2232 based
-devices. You have to specify the location of the FTDI driver package with the
---with-ftd2xx=/full/path/name option.
-
-Under Linux you can choose to build the parport driver with support for
-/dev/parportN instead of the default access with direct port I/O using
---enable-parport_ppdev. This has the advantage of running OpenOCD without root
-privileges at the expense of a slight performance decrease. This is also
-available on FreeBSD using PPI, but the naming of the devices is different.
-
-Generic installation instructions
-=================================
-
-   These are generic installation instructions.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, a file
-`config.cache' that saves the results of its tests to speed up
-reconfiguring, and a file `config.log' containing compiler output
-(useful mainly for debugging `configure').
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If at some point `config.cache'
-contains results you don't want to keep, you may remove or edit it.
-
-   The file `configure.in' is used to create `configure' by a program
-called `autoconf'.  You only need `configure.in' if you want to change
-it or regenerate `configure' using a newer version of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.  If you're
-     using `csh' on an old version of System V, you might need to type
-     `sh ./configure' instead to prevent `csh' from trying to execute
-     `configure' itself.
-
-     Running `configure' takes a while.  While running, it prints some
-     messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Type `make install' to install the programs and any data files and
-     documentation.
-
-  4. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.
-
-Compilers and Options
-=====================
-
-   Some systems require unusual options for compilation or linking that
-the `configure' script does not know about.  You can give `configure'
-initial values for variables by setting them in the environment.  Using
-a Bourne-compatible shell, you can do that on the command line like
-this:
-     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
-
-Or on systems that have the `env' program, you can do it like this:
-     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
-
-Compiling For Multiple Architectures
-====================================
-
-   You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you must use a version of `make' that
-supports the `VPATH' variable, such as GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   If you have to use a `make' that does not supports the `VPATH'
-variable, you have to compile the package for one architecture at a time
-in the source code directory.  After you have installed the package for
-one architecture, use `make distclean' before reconfiguring for another
-architecture.
-
-Installation Names
-==================
-
-   By default, `make install' will install the package's files in
-`/usr/local/bin', `/usr/local/man', etc.  You can specify an
-installation prefix other than `/usr/local' by giving `configure' the
-option `--prefix=PATH'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-give `configure' the option `--exec-prefix=PATH', the package will use
-PATH as the prefix for installing programs and libraries.
-Documentation and other data files will still use the regular prefix.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-   Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-   There may be some features `configure' can not figure out
-automatically, but needs to determine by the type of host the package
-will run on.  Usually `configure' can figure that out, but if it prints
-a message saying it can not guess the host type, give it the
-`--host=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name with three fields:
-     CPU-COMPANY-SYSTEM
-
-See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the host type.
-
-   If you are building compiler tools for cross-compiling, you can also
-use the `--target=TYPE' option to select the type of system they will
-produce code for and the `--build=TYPE' option to select the type of
-system on which you are compiling the package.
-
-Sharing Defaults
-================
-
-   If you want to set default values for `configure' scripts to share,
-you can create a site shell script called `config.site' that gives
-default values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Operation Controls
-==================
-
-   `configure' recognizes the following options to control how it
-operates.
-
-`--cache-file=FILE'
-     Use and save the results of the tests in FILE instead of
-     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
-     debugging `configure'.
-
-`--help'
-     Print a summary of the options to `configure', and exit.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`--version'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`configure' also accepts some other, not widely useful, options.
-
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 935c8f9d..67592038 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,13 +1,11 @@
-info_TEXINFOS = openocd.texi
-openocd_TEXINFOS = fdl.texi
-man_MANS = openocd.1
-EXTRA_DIST = openocd.1 \
-	manual \
-	INSTALL.txt
+info_TEXINFOS += %D%/openocd.texi
+%C%_openocd_TEXINFOS = %D%/fdl.texi
 
-MAINTAINERCLEANFILES = \
-	$(srcdir)/Makefile.in \
-	$(srcdir)/mdate-sh \
-	$(srcdir)/stamp-vti \
-	$(srcdir)/version.texi \
-	$(srcdir)/texinfo.tex
+dist_man_MANS += %D%/openocd.1
+
+EXTRA_DIST += %D%/manual
+
+MAINTAINERCLEANFILES += \
+	%D%/mdate-sh \
+	%D%/stamp-vti \
+	%D%/version.texi
diff --git a/doc/manual/release.txt b/doc/manual/release.txt
index d1447569..83f668f5 100644
--- a/doc/manual/release.txt
+++ b/doc/manual/release.txt
@@ -334,7 +334,7 @@ git tag -m "The openocd-${PACKAGE_VERSION} release." "${PACKAGE_TAG}"
      configuring its contents, using them to build a copy of OpenOCD,
      and verifying that the result prints the correct release version
      in its startup banner.  (For example,
-     "configure --enable-ft2232_libftdi --enable-parport"
+     "configure --enable-parport"
      then "make" and run "src/openocd -v" as a sanity check.)
   -# Run <code>make docs</code> to create the
      documentation which will be published.
diff --git a/doc/manual/style.txt b/doc/manual/style.txt
index 54c1342e..2ff2a29e 100644
--- a/doc/manual/style.txt
+++ b/doc/manual/style.txt
@@ -72,6 +72,25 @@ Finally, try to avoid lines of code that are longer than than 72-80 columns:
 - use underline characters between consecutive words in identifiers
   (e.g. @c more_than_one_word).
 
+@section style_include_guards Include Guards
+
+Every header file should have a unique include guard to prevent multiple
+inclusion.
+To guarantee uniqueness, an include guard should be based on the filename and
+the full path in the project source tree.
+
+For the header file src/helper/jim-nvp.h, the include guard would look like
+this:
+
+@code
+#ifndef OPENOCD_HELPER_JIM_NVP_H
+#define OPENOCD_HELPER_JIM_NVP_H
+
+/* Your code here. */
+
+#endif /* OPENOCD_HELPER_JIM_NVP_H */
+@endcode
+
 @section stylec99 C99 Rules
 
 - inline functions
diff --git a/doc/openocd.texi b/doc/openocd.texi
index a8f652fc..4116be62 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -66,7 +66,7 @@ Free Documentation License''.
 * Running::                          Running OpenOCD
 * OpenOCD Project Setup::            OpenOCD Project Setup
 * Config File Guidelines::           Config File Guidelines
-* Daemon Configuration::             Daemon Configuration
+* Server Configuration::             Server Configuration
 * Debug Adapter Configuration::      Debug Adapter Configuration
 * Reset Configuration::              Reset Configuration
 * TAP Declaration::                  TAP Declaration
@@ -595,6 +595,9 @@ produced, PDF schematics are easily found and it is easy to make.
 @item @b{bcm2835gpio}
 @* A BCM2835-based board (e.g. Raspberry Pi) using the GPIO pins of the expansion header.
 
+@item @b{imx_gpio}
+@* A NXP i.MX-based board (e.g. Wandboard) using the GPIO pins (should work on any i.MX processor).
+
 @item @b{jtag_vpi}
 @* A JTAG driver acting as a client for the JTAG VPI server interface.
 @* Link: @url{http://github.com/fjullien/jtag_vpi}
@@ -679,7 +682,8 @@ bash$ openocd --help
 --version    | -v       display OpenOCD version
 --file       | -f       use configuration file <name>
 --search     | -s       dir to search for config files and scripts
---debug      | -d       set debug level <0-3>
+--debug      | -d       set debug level to 3
+             | -d<n>    set debug level to <level>
 --log_output | -l       redirect log output to file <name>
 --command    | -c       run <command>
 @end verbatim
@@ -752,13 +756,13 @@ on the command line or, if there were no @option{-c command} or
 At the end of the configuration stage it verifies the JTAG scan
 chain defined using those commands; your configuration should
 ensure that this always succeeds.
-Normally, OpenOCD then starts running as a daemon.
+Normally, OpenOCD then starts running as a server.
 Alternatively, commands may be used to terminate the configuration
 stage early, perform work (such as updating some flash memory),
-and then shut down without acting as a daemon.
+and then shut down without acting as a server.
 
-Once OpenOCD starts running as a daemon, it waits for connections from
-clients (Telnet, GDB, Other) and processes the commands issued through
+Once OpenOCD starts running as a server, it waits for connections from
+clients (Telnet, GDB, RPC) and processes the commands issued through
 those channels.
 
 If you are having problems, you can enable internal debug messages via
@@ -775,7 +779,7 @@ informational messages, warnings and errors. You can also change this
 setting from within a telnet or gdb session using @command{debug_level<n>}
 (@pxref{debuglevel,,debug_level}).
 
-You can redirect all output from the daemon to a file using the
+You can redirect all output from the server to a file using the
 @option{-l <logfile>} switch.
 
 Note! OpenOCD will launch the GDB & telnet server even if it can not
@@ -898,7 +902,7 @@ using a Signalyzer FT2232-based JTAG adapter to talk to
 a board with an Atmel AT91SAM7X256 microcontroller:
 
 @example
-source [find interface/signalyzer.cfg]
+source [find interface/ftdi/signalyzer.cfg]
 
 # GDB can also flash my flash!
 gdb_memory_map enable
@@ -910,7 +914,7 @@ source [find target/sam7x256.cfg]
 Here is the command line equivalent of that configuration:
 
 @example
-openocd -f interface/signalyzer.cfg \
+openocd -f interface/ftdi/signalyzer.cfg \
         -c "gdb_memory_map enable" \
         -c "gdb_flash_program enable" \
         -f target/sam7x256.cfg
@@ -995,7 +999,7 @@ For example, there may be configuration files for your JTAG adapter
 and target chip, but you need a new board-specific config file
 giving access to your particular flash chips.
 Or you might need to write another target chip configuration file
-for a new chip built around the Cortex M3 core.
+for a new chip built around the Cortex-M3 core.
 
 @quotation Note
 When you write new configuration files, please submit
@@ -1994,8 +1998,8 @@ proc setc15 @{regs value@} @{
 
 
 
-@node Daemon Configuration
-@chapter Daemon Configuration
+@node Server Configuration
+@chapter Server Configuration
 @cindex initialization
 The commands here are commonly found in the openocd.cfg file and are
 used to specify what TCP/IP ports are used, and how GDB should be
@@ -2097,7 +2101,7 @@ only during configuration (before those ports are opened).
 
 For reasons including security, you may wish to prevent remote
 access using one or more of these ports.
-In such cases, just specify the relevant port number as zero.
+In such cases, just specify the relevant port number as "disabled".
 If you disable all access through TCP/IP, you will need to
 use the command line @option{-pipe} option.
 
@@ -2109,7 +2113,7 @@ communicate via pipes(stdin/out or named pipes). The name
 the normal use cases.
 
 No arguments reports GDB port. "pipe" means listen to stdin
-output to stdout, an integer is base port number, "disable"
+output to stdout, an integer is base port number, "disabled"
 disables the gdb server.
 
 When using "pipe", also use log_output to redirect the log
@@ -2140,7 +2144,7 @@ output from the Tcl engine.
 Intended as a machine interface.
 When not specified during the configuration stage,
 the port @var{number} defaults to 6666.
-
+When specified as "disabled", this service is not activated.
 @end deffn
 
 @deffn {Command} telnet_port [number]
@@ -2149,7 +2153,7 @@ port on which to listen for incoming telnet connections.
 This port is intended for interaction with one human through TCL commands.
 When not specified during the configuration stage,
 the port @var{number} defaults to 4444.
-When specified as zero, this port is not activated.
+When specified as "disabled", this service is not activated.
 @end deffn
 
 @anchor{gdbconfiguration}
@@ -2403,119 +2407,28 @@ A dummy software-only driver for debugging.
 Cirrus Logic EP93xx based single-board computer bit-banging (in development)
 @end deffn
 
-@deffn {Interface Driver} {ft2232}
-FTDI FT2232 (USB) based devices over one of the userspace libraries.
-
-Note that this driver has several flaws and the @command{ftdi} driver is
-recommended as its replacement.
-
-These interfaces have several commands, used to configure the driver
-before initializing the JTAG scan chain:
-
-@deffn {Config Command} {ft2232_device_desc} description
-Provides the USB device description (the @emph{iProduct string})
-of the FTDI FT2232 device. If not
-specified, the FTDI default value is used. This setting is only valid
-if compiled with FTD2XX support.
-@end deffn
-
-@deffn {Config Command} {ft2232_serial} serial-number
-Specifies the @var{serial-number} of the FTDI FT2232 device to use,
-in case the vendor provides unique IDs and more than one FT2232 device
-is connected to the host.
-If not specified, serial numbers are not considered.
-(Note that USB serial numbers can be arbitrary Unicode strings,
-and are not restricted to containing only decimal digits.)
-@end deffn
-
-@deffn {Config Command} {ft2232_layout} name
-Each vendor's FT2232 device can use different GPIO signals
-to control output-enables, reset signals, and LEDs.
-Currently valid layout @var{name} values include:
-@itemize @minus
-@item @b{axm0432_jtag} Axiom AXM-0432
-@item @b{comstick} Hitex STR9 comstick
-@item @b{cortino} Hitex Cortino JTAG interface
-@item @b{evb_lm3s811} TI/Luminary Micro EVB_LM3S811 as a JTAG interface,
-either for the local Cortex-M3 (SRST only)
-or in a passthrough mode (neither SRST nor TRST)
-This layout can not support the SWO trace mechanism, and should be
-used only for older boards (before rev C).
-@item @b{luminary_icdi} This layout should be used with most TI/Luminary
-eval boards, including Rev C LM3S811 eval boards and the eponymous
-ICDI boards, to debug either the local Cortex-M3 or in passthrough mode
-to debug some other target. It can support the SWO trace mechanism.
-@item @b{flyswatter} Tin Can Tools Flyswatter
-@item @b{icebear} ICEbear JTAG adapter from Section 5
-@item @b{jtagkey} Amontec JTAGkey and JTAGkey-Tiny (and compatibles)
-@item @b{jtagkey2} Amontec JTAGkey2 (and compatibles)
-@item @b{m5960} American Microsystems M5960
-@item @b{olimex-jtag} Olimex ARM-USB-OCD and ARM-USB-Tiny
-@item @b{oocdlink} OOCDLink
-@c oocdlink ~= jtagkey_prototype_v1
-@item @b{redbee-econotag} Integrated with a Redbee development board.
-@item @b{redbee-usb} Integrated with a Redbee USB-stick development board.
-@item @b{sheevaplug} Marvell Sheevaplug development kit
-@item @b{signalyzer} Xverve Signalyzer
-@item @b{stm32stick} Hitex STM32 Performance Stick
-@item @b{turtelizer2} egnite Software turtelizer2
-@item @b{usbjtag} "USBJTAG-1" layout described in the OpenOCD diploma thesis
-@end itemize
-@end deffn
-
-@deffn {Config Command} {ft2232_vid_pid} [vid pid]+
-The vendor ID and product ID of the FTDI FT2232 device. If not specified, the FTDI
-default values are used.
-Currently, up to eight [@var{vid}, @var{pid}] pairs may be given, e.g.
-@example
-ft2232_vid_pid 0x0403 0xcff8 0x15ba 0x0003
-@end example
-@end deffn
-
-@deffn {Config Command} {ft2232_latency} ms
-On some systems using FT2232 based JTAG interfaces the FT_Read function call in
-ft2232_read() fails to return the expected number of bytes. This can be caused by
-USB communication delays and has proved hard to reproduce and debug. Setting the
-FT2232 latency timer to a larger value increases delays for short USB packets but it
-also reduces the risk of timeouts before receiving the expected number of bytes.
-The OpenOCD default value is 2 and for some systems a value of 10 has proved useful.
-@end deffn
-
-@deffn {Config Command} {ft2232_channel} channel
-Used to select the channel of the ft2232 chip to use (between 1 and 4).
-The default value is 1.
-@end deffn
-
-For example, the interface config file for a
-Turtelizer JTAG Adapter looks something like this:
-
-@example
-interface ft2232
-ft2232_device_desc "Turtelizer JTAG/RS232 Adapter"
-ft2232_layout turtelizer2
-ft2232_vid_pid 0x0403 0xbdc8
-@end example
-@end deffn
-
 @deffn {Interface Driver} {ftdi}
 This driver is for adapters using the MPSSE (Multi-Protocol Synchronous Serial
 Engine) mode built into many FTDI chips, such as the FT2232, FT4232 and FT232H.
-It is a complete rewrite to address a large number of problems with the ft2232
-interface driver.
 
 The driver is using libusb-1.0 in asynchronous mode to talk to the FTDI device,
-bypassing intermediate libraries like libftdi of D2XX. Performance-wise it is
-consistently faster than the ft2232 driver, sometimes several times faster.
+bypassing intermediate libraries like libftdi or D2XX.
 
-A major improvement of this driver is that support for new FTDI based adapters
-can be added competely through configuration files, without the need to patch
-and rebuild OpenOCD.
+Support for new FTDI based adapters can be added competely through
+configuration files, without the need to patch and rebuild OpenOCD.
 
 The driver uses a signal abstraction to enable Tcl configuration files to
 define outputs for one or several FTDI GPIO. These outputs can then be
 controlled using the @command{ftdi_set_signal} command. Special signal names
 are reserved for nTRST, nSRST and LED (for blink) so that they, if defined,
-will be used for their customary purpose.
+will be used for their customary purpose. Inputs can be read using the
+@command{ftdi_get_signal} command.
+
+To support SWD, a signal named SWD_EN must be defined. It is set to 1 when the
+SWD protocol is selected. When set, the adapter should route the SWDIO pin to
+the data input. An SWDIO_OE signal, if defined, will be set to 1 or 0 as
+required by the protocol, to tell the adapter to drive the data output onto
+the SWDIO pin or keep the SWDIO pin Hi-Z, respectively.
 
 Depending on the type of buffer attached to the FTDI GPIO, the outputs have to
 be controlled differently. In order to support tristateable signals such as
@@ -2535,9 +2448,8 @@ These interfaces have several commands, used to configure the driver
 before initializing the JTAG scan chain:
 
 @deffn {Config Command} {ftdi_vid_pid} [vid pid]+
-The vendor ID and product ID of the adapter. If not specified, the FTDI
-default values are used.
-Currently, up to eight [@var{vid}, @var{pid}] pairs may be given, e.g.
+The vendor ID and product ID of the adapter. Up to eight
+[@var{vid}, @var{pid}] pairs may be given, e.g.
 @example
 ftdi_vid_pid 0x0403 0xcff8 0x15ba 0x0003
 @end example
@@ -2558,6 +2470,16 @@ If not specified, serial numbers are not considered.
 and are not restricted to containing only decimal digits.)
 @end deffn
 
+@deffn {Config Command} {ftdi_location} <bus>:<port>[,<port>]...
+Specifies the physical USB port of the adapter to use. The path
+roots at @var{bus} and walks down the physical ports, with each
+@var{port} option specifying a deeper level in the bus topology, the last
+@var{port} denoting where the target adapter is actually plugged.
+The USB bus topology can be queried with the command @emph{lsusb -t}.
+
+This command is only available if your libusb1 is at least version 1.0.16.
+@end deffn
+
 @deffn {Config Command} {ftdi_channel} channel
 Selects the channel of the FTDI device to use for MPSSE operations. Most
 adapters use the default, channel 0, but there are exceptions.
@@ -2572,7 +2494,7 @@ minimal impact on the target system. Avoid floating inputs, conflicting outputs
 and initially asserted reset signals.
 @end deffn
 
-@deffn {Config Command} {ftdi_layout_signal} name [@option{-data}|@option{-ndata} data_mask] [@option{-oe}|@option{-noe} oe_mask] [@option{-alias}|@option{-nalias} name]
+@deffn {Config Command} {ftdi_layout_signal} name [@option{-data}|@option{-ndata} data_mask] [@option{-input}|@option{-ninput} input_mask] [@option{-oe}|@option{-noe} oe_mask] [@option{-alias}|@option{-nalias} name]
 Creates a signal with the specified @var{name}, controlled by one or more FTDI
 GPIO pins via a range of possible buffer connections. The masks are FTDI GPIO
 register bitmasks to tell the driver the connection and type of the output
@@ -2580,7 +2502,9 @@ buffer driving the respective signal. @var{data_mask} is the bitmask for the
 pin(s) connected to the data input of the output buffer. @option{-ndata} is
 used with inverting data inputs and @option{-data} with non-inverting inputs.
 The @option{-oe} (or @option{-noe}) option tells where the output-enable (or
-not-output-enable) input to the output buffer is connected.
+not-output-enable) input to the output buffer is connected. The options
+@option{-input} and @option{-ninput} specify the bitmask for pins to be read
+with the method @command{ftdi_get_signal}.
 
 Both @var{data_mask} and @var{oe_mask} need not be specified. For example, a
 simple open-collector transistor driver would be specified with @option{-oe}
@@ -2610,8 +2534,26 @@ Set a previously defined signal to the specified level.
 @end itemize
 @end deffn
 
+@deffn {Command} {ftdi_get_signal} name
+Get the value of a previously defined signal.
+@end deffn
+
+@deffn {Command} {ftdi_tdo_sample_edge} @option{rising}|@option{falling}
+Configure TCK edge at which the adapter samples the value of the TDO signal
+
+Due to signal propagation delays, sampling TDO on rising TCK can become quite
+peculiar at high JTAG clock speeds. However, FTDI chips offer a possiblity to sample
+TDO on falling edge of TCK. With some board/adapter configurations, this may increase
+stability at higher JTAG clocks.
+@itemize @minus
+@item @option{rising}, sample TDO on rising edge of TCK - this is the default
+@item @option{falling}, sample TDO on falling edge of TCK
+@end itemize
+@end deffn
+
 For example adapter definitions, see the configuration files shipped in the
 @file{interface/ftdi} directory.
+
 @end deffn
 
 @deffn {Interface Driver} {remote_bitbang}
@@ -2690,7 +2632,7 @@ reset_config srst_only
 @end example
 @end deffn
 
-@deffn {Command} {usb_blaster_lowlevel_driver} (@option{ftdi}|@option{ftd2xx}|@option{ublast2})
+@deffn {Command} {usb_blaster_lowlevel_driver} (@option{ftdi}|@option{ublast2})
 Chooses the low level access method for the adapter. If not specified,
 @option{ftdi} is selected unless it wasn't enabled during the
 configure stage. USB-Blaster II needs @option{ublast2}.
@@ -2768,6 +2710,26 @@ Reset the current configuration.
 @deffn {Command} {jlink config write}
 Write the current configuration to the internal persistent storage.
 @end deffn
+@deffn {Command} {jlink emucom write <channel> <data>}
+Write data to an EMUCOM channel. The data needs to be encoded as hexadecimal
+pairs.
+
+The following example shows how to write the three bytes 0xaa, 0x0b and 0x23 to
+the EMUCOM channel 0x10:
+@example
+> jlink emucom write 0x10 aa0b23
+@end example
+@end deffn
+@deffn {Command} {jlink emucom read <channel> <length>}
+Read data from an EMUCOM channel. The read data is encoded as hexadecimal
+pairs.
+
+The following example shows how to read 4 bytes from the EMUCOM channel 0x0:
+@example
+> jlink emucom read 0x0 4
+77a90000
+@end example
+@end deffn
 @deffn {Config} {jlink usb} <@option{0} to @option{3}>
 Set the USB address of the interface, in case more than one adapter is connected
 to the host. If not specified, USB addresses are not considered. Device
@@ -2784,6 +2746,62 @@ As a configuration command, it can be used only before 'init'.
 @end deffn
 @end deffn
 
+@deffn {Interface Driver} {kitprog}
+This driver is for Cypress Semiconductor's KitProg adapters. The KitProg is an
+SWD-only adapter that is designed to be used with Cypress's PSoC and PRoC device
+families, but it is possible to use it with some other devices. If you are using
+this adapter with a PSoC or a PRoC, you may need to add
+@command{kitprog_init_acquire_psoc} or @command{kitprog acquire_psoc} to your
+configuration script.
+
+Note that this driver is for the proprietary KitProg protocol, not the CMSIS-DAP
+mode introduced in firmware 2.14. If the KitProg is in CMSIS-DAP mode, it cannot
+be used with this driver, and must either be used with the cmsis-dap driver or
+switched back to KitProg mode. See the Cypress KitProg User Guide for
+instructions on how to switch KitProg modes.
+
+Known limitations:
+@itemize @bullet
+@item The frequency of SWCLK cannot be configured, and varies between 1.6 MHz
+and 2.7 MHz.
+@item For firmware versions below 2.14, "JTAG to SWD" sequences are replaced by
+"SWD line reset" in the driver. This is for two reasons. First, the KitProg does
+not support sending arbitrary SWD sequences, and only firmware 2.14 and later
+implement both "JTAG to SWD" and "SWD line reset" in firmware. Earlier firmware
+versions only implement "SWD line reset". Second, due to a firmware quirk, an
+SWD sequence must be sent after every target reset in order to re-establish
+communications with the target.
+@item Due in part to the limitation above, KitProg devices with firmware below
+version 2.14 will need to use @command{kitprog_init_acquire_psoc} in order to
+communicate with PSoC 5LP devices. This is because, assuming debug is not
+disabled on the PSoC, the PSoC 5LP needs its JTAG interface switched to SWD
+mode before communication can begin, but prior to firmware 2.14, "JTAG to SWD"
+could only be sent with an acquisition sequence.
+@end itemize
+
+@deffn {Config Command} {kitprog_init_acquire_psoc}
+Indicate that a PSoC acquisition sequence needs to be run during adapter init.
+Please be aware that the acquisition sequence hard-resets the target.
+@end deffn
+
+@deffn {Config Command} {kitprog_serial} serial
+Select a KitProg device by its @var{serial}. If left unspecified, the first
+device detected by OpenOCD will be used.
+@end deffn
+
+@deffn {Command} {kitprog acquire_psoc}
+Run a PSoC acquisition sequence immediately. Typically, this should not be used
+outside of the target-specific configuration scripts since it hard-resets the
+target as a side-effect.
+This is necessary for "reset halt" on some PSoC 4 series devices.
+@end deffn
+
+@deffn {Command} {kitprog info}
+Display various adapter information, such as the hardware version, firmware
+version, and target voltage.
+@end deffn
+@end deffn
+
 @deffn {Interface Driver} {parport}
 Supports PC parallel port bit-banging cables:
 Wigglers, PLD download cable, and more.
@@ -2978,6 +2996,39 @@ pinout.
 
 @end deffn
 
+@deffn {Interface Driver} {imx_gpio}
+i.MX SoC is present in many community boards. Wandboard is an example
+of the one which is most popular.
+
+This driver is mostly the same as bcm2835gpio.
+
+See @file{interface/imx-native.cfg} for a sample config and
+pinout.
+
+@end deffn
+
+
+@deffn {Interface Driver} {openjtag}
+OpenJTAG compatible USB adapter.
+This defines some driver-specific commands:
+
+@deffn {Config Command} {openjtag_variant} variant
+Specifies the variant of the OpenJTAG adapter (see @uref{http://www.openjtag.org/}).
+Currently valid @var{variant} values include:
+
+@itemize @minus
+@item @b{standard} Standard variant (default).
+@item @b{cy7c65215} Cypress CY7C65215 Dual Channel USB-Serial Bridge Controller
+(see @uref{http://www.cypress.com/?rID=82870}).
+@end itemize
+@end deffn
+
+@deffn {Config Command} {openjtag_device_desc} string
+The USB device description string of the adapter.
+This value is only used with the standard variant.
+@end deffn
+@end deffn
+
 @section Transport Configuration
 @cindex Transport
 As noted earlier, depending on the version of OpenOCD you use,
@@ -4025,6 +4076,7 @@ At this writing, the supported CPU types are:
 @item @code{cortex_a} -- this is an ARMv7 core with an MMU
 @item @code{cortex_m} -- this is an ARMv7 core, supporting only the
 compact Thumb2 instruction set.
+@item @code{aarch64} -- this is an ARMv8-A core with an MMU
 @item @code{dragonite} -- resembles arm966e
 @item @code{dsp563xx} -- implements Freescale's 24-bit DSP.
 (Support for this is still incomplete.)
@@ -4035,6 +4087,8 @@ compact Thumb2 instruction set.
 not a CPU type. It is based on the ARMv5 architecture.
 @item @code{openrisc} -- this is an OpenRISC 1000 core.
 The current implementation supports three JTAG TAP cores:
+@item @code{ls1_sap} -- this is the SAP on NXP LS102x CPUs,
+allowing access to physical memory addresses independently of CPU cores.
 @itemize @minus
 @item @code{OpenCores TAP} (See: @url{http://opencores.org/project,jtag})
 @item @code{Altera Virtual JTAG TAP} (See: @url{http://www.altera.com/literature/ug/ug_virtualjtag.pdf})
@@ -4055,7 +4109,7 @@ The CPU name used by OpenOCD will reflect the CPU design that was
 licenced, not a vendor brand which incorporates that design.
 Name prefixes like arm7, arm9, arm11, and cortex
 reflect design generations;
-while names like ARMv4, ARMv5, ARMv6, and ARMv7
+while names like ARMv4, ARMv5, ARMv6, ARMv7 and ARMv8
 reflect an architecture version implemented by a CPU design.
 
 @anchor{targetconfiguration}
@@ -4186,15 +4240,11 @@ The value should normally correspond to a static mapping for the
 
 @anchor{rtostype}
 @item @code{-rtos} @var{rtos_type} -- enable rtos support for target,
-@var{rtos_type} can be one of @option{auto}|@option{eCos}|@option{ThreadX}|
-@option{FreeRTOS}|@option{linux}|@option{ChibiOS}|@option{embKernel}|@option{mqx}
+@var{rtos_type} can be one of @option{auto}, @option{eCos},
+@option{ThreadX}, @option{FreeRTOS}, @option{linux}, @option{ChibiOS},
+@option{embKernel}, @option{mqx}, @option{uCOS-III}
 @xref{gdbrtossupport,,RTOS Support}.
 
-@item @code{-memorymap} (@option{RO}|@option{WO}|@option{RW}) @var{start_address} @var{size} [@var{short_name}] [@var{long_name}] -- Add a memory map region.
-If any memory map regions are specified, then memory reads & writes are limited to only those areas - preventing accesses to invalid regions.
-Currently this does @emph{not} yet use the "qXfer:memory-map:read" packet to inform GDB of the valid regions.
-
-
 @item @code{-rtos-wipe} -- wipe rtos variables before usage.
 OpenOCD reads global variables implemented by the RTOS - In some situations,
 these global variables may contain invalid data, which could cause RTOS
@@ -4211,6 +4261,23 @@ target that is already running, OR, if you are resetting but not halting
 immediately.
 @xref{gdbrtossupport,,RTOS Support}.
 
+@item @code{-defer-examine} -- skip target examination at initial JTAG chain
+scan and after a reset. A manual call to arp_examine is required to
+access the target for debugging.
+
+@item @code{-ap-num} @var{ap_number} -- set DAP access port for target,
+@var{ap_number} is the numeric index of the DAP AP the target is connected to.
+Use this option with systems where multiple, independent cores are connected
+to separate access ports of the same DAP.
+
+@item @code{-ctibase} @var{address} -- set base address of Cross-Trigger interface (CTI) connected
+to the target. Currently, only the @code{aarch64} target makes use of this option, where it is
+a mandatory configuration for the target run control.
+
+@item @code{-memorymap} (@option{RO}|@option{WO}|@option{RW}) @var{start_address} @var{size} [@var{short_name}] [@var{long_name}] -- Add a memory map region.
+If any memory map regions are specified, then memory reads & writes are limited to only those areas - preventing accesses to invalid regions.
+Currently this does @emph{not} yet use the "qXfer:memory-map:read" packet to inform GDB of the valid regions.
+
 @end itemize
 @end deffn
 
@@ -4247,7 +4314,7 @@ omap3530.cpu  mww 0x5555 123
 
 The commands supported by OpenOCD target objects are:
 
-@deffn Command {$target_name arp_examine}
+@deffn Command {$target_name arp_examine} @option{allow-defer}
 @deffnx Command {$target_name arp_halt}
 @deffnx Command {$target_name arp_poll}
 @deffnx Command {$target_name arp_reset}
@@ -4670,21 +4737,25 @@ each block, and the specified length must stay within that bank.
 @end deffn
 @comment no current checks for errors if fill blocks touch multiple banks!
 
-@deffn Command {flash write_bank} num filename offset
+@deffn Command {flash write_bank} num filename [offset]
 Write the binary @file{filename} to flash bank @var{num},
-starting at @var{offset} bytes from the beginning of the bank.
+starting at @var{offset} bytes from the beginning of the bank. If @var{offset}
+is omitted, start at the beginning of the flash bank.
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
-@deffn Command {flash read_bank} num filename offset length
+@deffn Command {flash read_bank} num filename [offset [length]]
 Read @var{length} bytes from the flash bank @var{num} starting at @var{offset}
-and write the contents to the binary @file{filename}.
+and write the contents to the binary @file{filename}. If @var{offset} is
+omitted, start at the beginning of the flash bank. If @var{length} is omitted,
+read the remaining bytes from the flash bank.
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
-@deffn Command {flash verify_bank} num filename offset
+@deffn Command {flash verify_bank} num filename [offset]
 Compare the contents of the binary file @var{filename} with the contents of the
-flash @var{num} starting at @var{offset}. Fails if the contents do not match.
+flash bank @var{num} starting at @var{offset}. If @var{offset} is omitted,
+start at the beginning of the flash bank. Fail if the contents do not match.
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
@@ -4734,8 +4805,10 @@ and display that status.
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
-@deffn Command {flash info} num
-Print info about flash bank @var{num}
+@deffn Command {flash info} num [sectors]
+Print info about flash bank @var{num}, a list of protection blocks
+and their status. Use @option{sectors} to show a list of sectors instead.
+
 The @var{num} parameter is a value shown by @command{flash banks}.
 This command will first query the hardware, it does not print cached
 and possibly stale information.
@@ -4743,12 +4816,15 @@ and possibly stale information.
 
 @anchor{flashprotect}
 @deffn Command {flash protect} num first last (@option{on}|@option{off})
-Enable (@option{on}) or disable (@option{off}) protection of flash sectors
-in flash bank @var{num}, starting at sector @var{first}
+Enable (@option{on}) or disable (@option{off}) protection of flash blocks
+in flash bank @var{num}, starting at protection block @var{first}
 and continuing up to and including @var{last}.
-Providing a @var{last} sector of @option{last}
+Providing a @var{last} block of @option{last}
 specifies "to the end of the flash bank".
 The @var{num} parameter is a value shown by @command{flash banks}.
+The protection block is usually identical to a flash sector.
+Some devices may utilize a protection block distinct from flash sector.
+See @command{flash info} for a list of protection blocks.
 @end deffn
 
 @deffn Command {flash padded_value} num value
@@ -4785,8 +4861,10 @@ the flash bank defined at address 0x1fc00000. Any cmds executed on
 the virtual banks are actually performed on the physical banks.
 @example
 flash bank $_FLASHNAME pic32mx 0x1fc00000 0 0 0 $_TARGETNAME
-flash bank vbank0 virtual 0xbfc00000 0 0 0 $_TARGETNAME $_FLASHNAME
-flash bank vbank1 virtual 0x9fc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank0 virtual 0xbfc00000 0 0 0 \
+           $_TARGETNAME $_FLASHNAME
+flash bank vbank1 virtual 0x9fc00000 0 0 0 \
+           $_TARGETNAME $_FLASHNAME
 @end example
 @end deffn
 
@@ -4813,6 +4891,9 @@ The CFI driver can accept the following optional parameters, in any order:
 @item @var{jedec_probe} ... is used to detect certain non-CFI flash ROMs,
 like AM29LV010 and similar types.
 @item @var{x16_as_x8} ... when a 16-bit flash is hooked up to an 8-bit bus.
+@item @var{bus_swap} ... when data bytes in a 16-bit flash needs to be swapped.
+@item @var{data_swap} ... when data bytes in a 16-bit flash needs to be
+swapped when writing data values (ie. not CFI commands).
 @end itemize
 
 To configure two adjacent banks of 16 MBytes each, both sixteen bits (two bytes)
@@ -4849,8 +4930,8 @@ Since signaling between JTAG and SPI is compatible, all that is required for
 a proxy bitstream is to connect TDI-MOSI, TDO-MISO, TCK-CLK and activate
 the flash chip select when the JTAG state machine is in SHIFT-DR. Such
 a bitstream for several Xilinx FPGAs can be found in
-@file{contrib/loaders/flash/fpga/xilinx_bscan_spi.py}. It requires migen
-(@url{http://github.com/m-labs/migen}) and a Xilinx toolchain to build.
+@file{contrib/loaders/flash/fpga/xilinx_bscan_spi.py}. It requires
+@uref{https://github.com/m-labs/migen, migen} and a Xilinx toolchain to build.
 
 This flash bank driver requires a target on a JTAG tap and will access that
 tap directly. Since no support from the target is needed, the target can be a
@@ -4873,7 +4954,8 @@ For the bitstreams generated from @file{xilinx_bscan_spi.py} this is the
 target create $_TARGETNAME testee -chain-position $_CHIPNAME.fpga
 set _XILINX_USER1 0x02
 set _DR_LENGTH 1
-flash bank $_FLASHNAME spi 0x0 0 0 0 $_TARGETNAME $_XILINX_USER1 $_DR_LENGTH
+flash bank $_FLASHNAME spi 0x0 0 0 0 \
+           $_TARGETNAME $_XILINX_USER1 $_DR_LENGTH
 @end example
 @end deffn
 
@@ -4942,6 +5024,45 @@ flash bank $_FLASHNAME mrvlqspi 0x0 0 0 0 $_TARGETNAME 0x46010000
 
 @end deffn
 
+@deffn {Flash Driver} ath79
+@cindex Atheros ath79 SPI driver
+@cindex ath79
+Members of ATH79 SoC family from Atheros include a SPI interface with 3
+chip selects.
+On reset a SPI flash connected to the first chip select (CS0) is made
+directly read-accessible in the CPU address space (up to 16MBytes)
+and is usually used to store the bootloader and operating system.
+Normal OpenOCD commands like @command{mdw} can be used to display
+the flash content while it is in memory-mapped mode (only the first
+4MBytes are accessible without additional configuration on reset).
+
+The setup command only requires the @var{base} parameter in order
+to identify the memory bank. The actual value for the base address
+is not otherwise used by the driver. However the mapping is passed
+to gdb. Thus for the memory mapped flash (chipselect CS0) the base
+address should be the actual memory mapped base address. For unmapped
+chipselects (CS1 and CS2) care should be taken to use a base address
+that does not overlap with real memory regions.
+Additional information, like flash size, are detected automatically.
+An optional additional parameter sets the chipselect for the bank,
+with the default CS0.
+CS1 and CS2 require additional GPIO setup before they can be used
+since the alternate function must be enabled on the GPIO pin
+CS1/CS2 is routed to on the given SoC.
+
+@example
+flash bank $_FLASHNAME ath79 0 0 0 0 $_TARGETNAME
+
+# When using multiple chipselects the base should be different for each,
+# otherwise the write_image command is not able to distinguish the
+# banks.
+flash bank flash0 ath79 0x00000000 0 0 0 $_TARGETNAME cs0
+flash bank flash1 ath79 0x10000000 0 0 0 $_TARGETNAME cs1
+flash bank flash2 ath79 0x20000000 0 0 0 $_TARGETNAME cs2
+@end example
+
+@end deffn
+
 @subsection Internal Flash (Microcontrollers)
 
 @deffn {Flash Driver} aduc702x
@@ -4956,6 +5077,53 @@ flash bank $_FLASHNAME aduc702x 0 0 0 0 $_TARGETNAME
 @end example
 @end deffn
 
+@deffn {Flash Driver} ambiqmicro
+@cindex ambiqmicro
+@cindex apollo
+All members of the Apollo microcontroller family from
+Ambiq Micro include internal flash and use ARM's Cortex-M4 core.
+The host connects over USB to an FTDI interface that communicates
+with the target using SWD.
+
+The @var{ambiqmicro} driver reads the Chip Information Register detect
+the device class of the MCU.
+The Flash and Sram sizes directly follow device class, and are used
+to set up the flash banks.
+If this fails, the driver will use default values set to the minimum
+sizes of an Apollo chip.
+
+All Apollo chips have two flash banks of the same size.
+In all cases the first flash bank starts at location 0,
+and the second bank starts after the first.
+
+@example
+# Flash bank 0
+flash bank $_FLASHNAME ambiqmicro 0 0x00040000 0 0 $_TARGETNAME
+# Flash bank 1 - same size as bank0, starts after bank 0.
+flash bank $_FLASHNAME ambiqmicro 0x00040000 0x00040000 0 0 \
+           $_TARGETNAME
+@end example
+
+Flash is programmed using custom entry points into the bootloader.
+This is the only way to program the flash as no flash control registers
+are available to the user.
+
+The @var{ambiqmicro} driver adds some additional commands:
+
+@deffn Command {ambiqmicro mass_erase} <bank>
+Erase entire bank.
+@end deffn
+@deffn Command {ambiqmicro page_erase} <bank> <first> <last>
+Erase device pages.
+@end deffn
+@deffn Command {ambiqmicro program_otp} <bank> <offset> <count>
+Program OTP is a one time operation to create write protected flash.
+The user writes sectors to sram starting at 0x10000010.
+Program OTP will write these sectors from sram to flash, and write protect
+the flash.
+@end deffn
+@end deffn
+
 @anchor{at91samd}
 @deffn {Flash Driver} at91samd
 @cindex at91samd
@@ -5165,19 +5333,27 @@ The AVR 8-bit microcontrollers from Atmel integrate flash memory.
 
 @deffn {Flash Driver} efm32
 All members of the EFM32 microcontroller family from Energy Micro include
-internal flash and use ARM Cortex M3 cores. The driver automatically recognizes
+internal flash and use ARM Cortex-M3 cores. The driver automatically recognizes
 a number of these chips using the chip identification register, and
 autoconfigures itself.
 @example
 flash bank $_FLASHNAME efm32 0 0 0 0 $_TARGETNAME
 @end example
+A special feature of efm32 controllers is that it is possible to completely disable the
+debug interface by writing the correct values to the 'Debug Lock Word'. OpenOCD supports
+this via the following command:
+@example
+efm32 debuglock num
+@end example
+The @var{num} parameter is a value shown by @command{flash banks}.
+Note that in order for this command to take effect, the target needs to be reset.
 @emph{The current implementation is incomplete. Unprotecting flash pages is not
 supported.}
 @end deffn
 
 @deffn {Flash Driver} fm3
 All members of the FM3 microcontroller family from Fujitsu
-include internal flash and use ARM Cortex M3 cores.
+include internal flash and use ARM Cortex-M3 cores.
 The @var{fm3} driver uses the @var{target} parameter to select the
 correct bank config, it can currently be one of the following:
 @code{mb9bfxx1.cpu}, @code{mb9bfxx2.cpu}, @code{mb9bfxx3.cpu},
@@ -5188,6 +5364,152 @@ flash bank $_FLASHNAME fm3 0 0 0 0 $_TARGETNAME
 @end example
 @end deffn
 
+@deffn {Flash Driver} fm4
+All members of the FM4 microcontroller family from Spansion (formerly Fujitsu)
+include internal flash and use ARM Cortex-M4 cores.
+The @var{fm4} driver uses a @var{family} parameter to select the
+correct bank config, it can currently be one of the following:
+@code{MB9BFx64}, @code{MB9BFx65}, @code{MB9BFx66}, @code{MB9BFx67}, @code{MB9BFx68},
+@code{S6E2Cx8}, @code{S6E2Cx9}, @code{S6E2CxA} or @code{S6E2Dx},
+with @code{x} treated as wildcard and otherwise case (and any trailing
+characters) ignored.
+
+@example
+flash bank $@{_FLASHNAME@}0 fm4 0x00000000 0 0 0 \
+           $_TARGETNAME S6E2CCAJ0A
+flash bank $@{_FLASHNAME@}1 fm4 0x00100000 0 0 0 \
+           $_TARGETNAME S6E2CCAJ0A
+@end example
+@emph{The current implementation is incomplete. Protection is not supported,
+nor is Chip Erase (only Sector Erase is implemented).}
+@end deffn
+
+@deffn {Flash Driver} kinetis
+@cindex kinetis
+Kx, KLx, KVx and KE1x members of the Kinetis microcontroller family
+from NXP (former Freescale) include
+internal flash and use ARM Cortex-M0+ or M4 cores. The driver automatically
+recognizes flash size and a number of flash banks (1-4) using the chip
+identification register, and autoconfigures itself.
+Use kinetis_ke driver for KE0x devices.
+
+The @var{kinetis} driver defines option:
+@itemize
+@item -sim-base @var{addr} ... base of System Integration Module where chip identification resides. Driver tries two known locations if option is omitted.
+@end itemize
+
+@example
+flash bank $_FLASHNAME kinetis 0 0 0 0 $_TARGETNAME
+@end example
+
+@deffn Command {kinetis create_banks}
+Configuration command enables automatic creation of additional flash banks
+based on real flash layout of device. Banks are created during device probe.
+Use 'flash probe 0' to force probe.
+@end deffn
+
+@deffn Command {kinetis fcf_source} [protection|write]
+Select what source is used when writing to a Flash Configuration Field.
+@option{protection} mode builds FCF content from protection bits previously
+set by 'flash protect' command.
+This mode is default. MCU is protected from unwanted locking by immediate
+writing FCF after erase of relevant sector.
+@option{write} mode enables direct write to FCF.
+Protection cannot be set by 'flash protect' command. FCF is written along
+with the rest of a flash image.
+@emph{BEWARE: Incorrect flash configuration may permanently lock the device!}
+@end deffn
+
+@deffn Command {kinetis fopt} [num]
+Set value to write to FOPT byte of Flash Configuration Field.
+Used in kinetis 'fcf_source protection' mode only.
+@end deffn
+
+@deffn Command {kinetis mdm check_security}
+Checks status of device security lock. Used internally in examine-end event.
+@end deffn
+
+@deffn Command {kinetis mdm halt}
+Issues a halt via the MDM-AP. This command can be used to break a watchdog reset
+loop when connecting to an unsecured target.
+@end deffn
+
+@deffn Command {kinetis mdm mass_erase}
+Issues a complete flash erase via the MDM-AP. This can be used to erase a chip
+back to its factory state, removing security. It does not require the processor
+to be halted, however the target will remain in a halted state after this
+command completes.
+@end deffn
+
+@deffn Command {kinetis nvm_partition}
+For FlexNVM devices only (KxxDX and KxxFX).
+Command shows or sets data flash or EEPROM backup size in kilobytes,
+sets two EEPROM blocks sizes in bytes and enables/disables loading
+of EEPROM contents to FlexRAM during reset.
+
+For details see device reference manual, Flash Memory Module,
+Program Partition command.
+
+Setting is possible only once after mass_erase.
+Reset the device after partition setting.
+
+Show partition size:
+@example
+kinetis nvm_partition info
+@end example
+
+Set 32 KB data flash, rest of FlexNVM is EEPROM backup. EEPROM has two blocks
+of 512 and 1536 bytes and its contents is loaded to FlexRAM during reset:
+@example
+kinetis nvm_partition dataflash 32 512 1536 on
+@end example
+
+Set 16 KB EEPROM backup, rest of FlexNVM is a data flash. EEPROM has two blocks
+of 1024 bytes and its contents is not loaded to FlexRAM during reset:
+@example
+kinetis nvm_partition eebkp 16 1024 1024 off
+@end example
+@end deffn
+
+@deffn Command {kinetis mdm reset}
+Issues a reset via the MDM-AP. This causes the MCU to output a low pulse on the
+RESET pin, which can be used to reset other hardware on board.
+@end deffn
+
+@deffn Command {kinetis disable_wdog}
+For Kx devices only (KLx has different COP watchdog, it is not supported).
+Command disables watchdog timer.
+@end deffn
+@end deffn
+
+@deffn {Flash Driver} kinetis_ke
+@cindex kinetis_ke
+KE0x members of the Kinetis microcontroller family from Freescale include
+internal flash and use ARM Cortex-M0+. The driver automatically recognizes
+the KE0x sub-family using the chip identification register, and
+autoconfigures itself.
+Use kinetis (not kinetis_ke) driver for KE1x devices.
+
+@example
+flash bank $_FLASHNAME kinetis_ke 0 0 0 0 $_TARGETNAME
+@end example
+
+@deffn Command {kinetis_ke mdm check_security}
+Checks status of device security lock. Used internally in examine-end event.
+@end deffn
+
+@deffn Command {kinetis_ke mdm mass_erase}
+Issues a complete Flash erase via the MDM-AP.
+This can be used to erase a chip back to its factory state.
+Command removes security lock from a device (use of SRST highly recommended).
+It does not require the processor to be halted.
+@end deffn
+
+@deffn Command {kinetis_ke disable_wdog}
+Command disables watchdog timer.
+@end deffn
+@end deffn
+
 @deffn {Flash Driver} lpc2000
 This is the driver to support internal flash of all members of the
 LPC11(x)00 and LPC1300 microcontroller families and most members of
@@ -5466,17 +5788,19 @@ Show information about flash driver.
 
 @end deffn
 
-@deffn {Flash Driver} nrf51
+@deffn {Flash Driver} nrf5
 All members of the nRF51 microcontroller families from Nordic Semiconductor
 include internal flash and use ARM Cortex-M0 core.
+Also, the nRF52832 microcontroller from Nordic Semiconductor, which include
+internal flash and use an ARM Cortex-M4F core.
 
 @example
-flash bank $_FLASHNAME nrf51 0 0x00000000 0 0 $_TARGETNAME
+flash bank $_FLASHNAME nrf5 0 0x00000000 0 0 $_TARGETNAME
 @end example
 
-Some nrf51-specific commands are defined:
+Some nrf5-specific commands are defined:
 
-@deffn Command {nrf51 mass_erase}
+@deffn Command {nrf5 mass_erase}
 Erases the contents of the code memory and user information
 configuration registers as well. It must be noted that this command
 works only for chips that do not have factory pre-programmed region 0
@@ -5525,7 +5849,7 @@ This will remove any Code Protection.
 
 @deffn {Flash Driver} psoc4
 All members of the PSoC 41xx/42xx microcontroller family from Cypress
-include internal flash and use ARM Cortex M0 cores.
+include internal flash and use ARM Cortex-M0 cores.
 The driver automatically recognizes a number of these chips using
 the chip identification register, and autoconfigures itself.
 
@@ -5559,7 +5883,7 @@ The @var{num} parameter is a value shown by @command{flash banks}.
 
 @deffn {Flash Driver} sim3x
 All members of the SiM3 microcontroller family from Silicon Laboratories
-include internal flash and use ARM Cortex M3 cores. It supports both JTAG
+include internal flash and use ARM Cortex-M3 cores. It supports both JTAG
 and SWD interface.
 The @var{sim3x} driver tries to probe the device to auto detect the MCU.
 If this failes, it will use the @var{size} parameter as the size of flash bank.
@@ -5662,8 +5986,8 @@ The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
 @deffn {Flash Driver} stm32f2x
-All members of the STM32F2 and STM32F4 microcontroller families from ST Microelectronics
-include internal flash and use ARM Cortex-M3/M4 cores.
+All members of the STM32F2, STM32F4 and STM32F7 microcontroller families from ST Microelectronics
+include internal flash and use ARM Cortex-M3/M4/M7 cores.
 The driver automatically recognizes a number of these chips using
 the chip identification register, and autoconfigures itself.
 
@@ -5686,6 +6010,24 @@ The @var{num} parameter is a value shown by @command{flash banks}.
 Unlocks the entire stm32 device.
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
+
+@deffn Command {stm32f2x options_read} num
+Reads and displays user options and (where implemented) boot_addr0, boot_addr1, optcr2.
+The @var{num} parameter is a value shown by @command{flash banks}.
+@end deffn
+
+@deffn Command {stm32f2x options_write} num user_options boot_addr0 boot_addr1
+Writes user options and (where implemented) boot_addr0 and boot_addr1 in raw format.
+Warning: The meaning of the various bits depends on the device, always check datasheet!
+The @var{num} parameter is a value shown by @command{flash banks}, @var{user_options} a
+12 bit value, consisting of bits 31-28 and 7-0 of FLASH_OPTCR, @var{boot_addr0} and
+@var{boot_addr1} two halfwords (of FLASH_OPTCR1).
+@end deffn
+
+@deffn Command {stm32f2x optcr2_write} num optcr2
+Writes FLASH_OPTCR2 options. Warning: Clearing PCROPi bits requires a full mass erase!
+The @var{num} parameter is a value shown by @command{flash banks}, @var{optcr2} a 32-bit word.
+@end deffn
 @end deffn
 
 @deffn {Flash Driver} stm32lx
@@ -5872,6 +6214,11 @@ the flash clock.
 @end deffn
 @end deffn
 
+@deffn {Flash Driver} xmc1xxx
+All members of the XMC1xxx microcontroller family from Infineon.
+This driver does not require the chip and bus width to be specified.
+@end deffn
+
 @deffn {Flash Driver} xmc4xxx
 All members of the XMC4xxx microcontroller family from Infineon.
 This driver does not require the chip and bus width to be specified.
@@ -6496,7 +6843,7 @@ port is 5555.
 @end itemize
 
 
-@section Daemon Commands
+@section Server Commands
 
 @deffn {Command} exit
 Exits the current telnet session.
@@ -6522,7 +6869,7 @@ Useful in connection with script files
 @end deffn
 
 @deffn Command shutdown [@option{error}]
-Close the OpenOCD daemon, disconnecting all clients (GDB, telnet,
+Close the OpenOCD server, disconnecting all clients (GDB, telnet,
 other). If option @option{error} is used, OpenOCD will return a
 non-zero exit code to the parent process.
 @end deffn
@@ -6531,12 +6878,13 @@ non-zero exit code to the parent process.
 @deffn Command debug_level [n]
 @cindex message level
 Display debug level.
-If @var{n} (from 0..3) is provided, then set it to that level.
+If @var{n} (from 0..4) is provided, then set it to that level.
 This affects the kind of messages sent to the server log.
 Level 0 is error messages only;
 level 1 adds warnings;
 level 2 adds informational messages;
-and level 3 adds debugging messages.
+level 3 adds debugging messages;
+and level 4 adds verbose low-level debug messages.
 The default is level 2, but that can be overridden on
 the command line along with the location of that log
 file (which is normally the server's standard output).
@@ -6561,6 +6909,11 @@ the initial log output channel is stderr.
 Add @var{directory} to the file/script search path.
 @end deffn
 
+@deffn Command bindto [name]
+Specify address by name on which to listen for incoming TCP/IP connections.
+By default, OpenOCD will listen on all available interfaces.
+@end deffn
+
 @anchor{targetstatehandling}
 @section Target State handling
 @cindex reset
@@ -7272,6 +7625,31 @@ requests by using a special SVC instruction that is trapped at the
 Supervisor Call vector by OpenOCD.
 @end deffn
 
+@deffn Command {arm semihosting_cmdline} [@option{enable}|@option{disable}]
+@cindex ARM semihosting
+Set the command line to be passed to the debuggee.
+
+@example
+arm semihosting_cmdline argv0 argv1 argv2 ...
+@end example
+
+This option lets one set the command line arguments to be passed to
+the program. The first argument (argv0) is the program name in a
+standard C environment (argv[0]). Depending on the program (not much
+programs look at argv[0]), argv0 is ignored and can be any string.
+@end deffn
+
+@deffn Command {arm semihosting_fileio} [@option{enable}|@option{disable}]
+@cindex ARM semihosting
+Display status of semihosting fileio, after optionally changing that
+status.
+
+Enabling this option forwards semihosting I/O to GDB process using the
+File-I/O remote protocol extension. This is especially useful for
+interacting with remote files or displaying console messages in the
+debugger.
+@end deffn
+
 @section ARMv4 and ARMv5 Architecture
 @cindex ARMv4
 @cindex ARMv5
@@ -7653,13 +8031,14 @@ coprocessor 14 register 7 itself) but all current ARM11
 cores @emph{except the ARM1176} use the same six bits.
 @end deffn
 
-@section ARMv7 Architecture
+@section ARMv7 and ARMv8 Architecture
 @cindex ARMv7
+@cindex ARMv8
 
-@subsection ARMv7 Debug Access Port (DAP) specific commands
+@subsection ARMv7 and ARMv8 Debug Access Port (DAP) specific commands
 @cindex Debug Access Port
 @cindex DAP
-These commands are specific to ARM architecture v7 Debug Access Port (DAP),
+These commands are specific to ARM architecture v7 and v8 Debug Access Port (DAP),
 included on Cortex-M and Cortex-A systems.
 They are available in addition to other core-specific commands that may be available.
 
@@ -7668,6 +8047,12 @@ Displays ID register from AP @var{num},
 defaulting to the currently selected AP.
 @end deffn
 
+@deffn Command {dap apreg} ap_num reg [value]
+Displays content of a register @var{reg} from AP @var{ap_num}
+or set a new value @var{value}.
+@var{reg} is byte address of a word register, 0, 4, 8 ... 0xfc.
+@end deffn
+
 @deffn Command {dap apsel} [num]
 Select AP @var{num}, defaulting to 0.
 @end deffn
@@ -7907,6 +8292,29 @@ the peripherals.
 @xref{targetevents,,Target Events}.
 @end deffn
 
+@subsection ARMv8-A specific commands
+@cindex ARMv8-A
+@cindex aarch64
+
+@deffn Command {aarch64 cache_info}
+Display information about target caches
+@end deffn
+
+@deffn Command {aarch64 dbginit}
+This command enables debugging by clearing the OS Lock and sticky power-down and reset
+indications. It also establishes the expected, basic cross-trigger configuration the aarch64
+target code relies on. In a configuration file, the command would typically be called from a
+@code{reset-end} or @code{reset-deassert-post} handler, to re-enable debugging after a system reset.
+However, normally it is not necessary to use the command at all.
+@end deffn
+
+@deffn Command {aarch64 smp_on|smp_off}
+Enable and disable SMP handling. The state of SMP handling influences the way targets in an SMP group
+are handled by the run control. With SMP handling enabled, issuing halt or resume to one core will trigger
+halting or resuming of all cores in the group. The command @code{target smp} defines which targets are in the SMP
+group. With SMP handling disabled, all targets need to be treated individually.
+@end deffn
+
 @section Intel Architecture
 
 Intel Quark X10xx is the first product in the Quark family of SoCs. It is an IA-32
@@ -8683,7 +9091,11 @@ end
 @anchor{gdbrtossupport}
 
 OpenOCD includes RTOS support, this will however need enabling as it defaults to disabled.
-It can be enabled by passing @option{-rtos} arg to the target @xref{rtostype,,RTOS Type}.
+It can be enabled by passing @option{-rtos} arg to the target. @xref{rtostype,,RTOS Type}.
+
+@xref{Threads, Debugging Programs with Multiple Threads,
+Debugging Programs with Multiple Threads, gdb, GDB manual}, for details about relevant
+GDB commands.
 
 @* An example setup is below:
 
@@ -8702,6 +9114,7 @@ Currently supported rtos's include:
 @item @option{ChibiOS}
 @item @option{embKernel}
 @item @option{mqx}
+@item @option{uCOS-III}
 @end itemize
 
 @quotation Note
@@ -8735,10 +9148,12 @@ Rtos::sCurrentTask, Rtos::sListReady, Rtos::sListSleep,
 Rtos::sListSuspended, Rtos::sMaxPriorities, Rtos::sCurrentTaskCount.
 @item mqx symbols
 _mqx_kernel_data, MQX_init_struct.
+@item uC/OS-III symbols
+OSRunning, OSTCBCurPtr, OSTaskDbgListPtr, OSTaskQty
 @end table
 
 For most RTOS supported the above symbols will be exported by default. However for
-some, eg. FreeRTOS, extra steps must be taken.
+some, eg. FreeRTOS and uC/OS-III, extra steps must be taken.
 
 These RTOSes may require additional OpenOCD-specific file to be linked
 along with the project:
@@ -8746,6 +9161,8 @@ along with the project:
 @table @code
 @item FreeRTOS
 contrib/rtos-helpers/FreeRTOS-openocd.c
+@item uC/OS-III
+contrib/rtos-helpers/uCOS-III-openocd.c
 @end table
 
 @node Tcl Scripting API
@@ -9127,16 +9544,6 @@ supply stable enough for the Amontec JTAGkey to be operated.
 
 @b{Laptops running on battery have this problem too...}
 
-@item @b{USB Power} When using the Amontec JTAGkey, sometimes OpenOCD crashes with the
-following error messages: "Error: ft2232.c:201 ft2232_read(): FT_Read returned:
-4" and "Error: ft2232.c:365 ft2232_send_and_recv(): couldn't read from FT2232".
-What does that mean and what might be the reason for this?
-
-First of all, the reason might be the USB power supply. Try using a self-powered
-hub instead of a direct connection to your computer. Secondly, the error code 4
-corresponds to an FT_IO_ERROR, which means that the driver for the FTDI USB
-chip ran into some sort of error - this points us to a USB problem.
-
 @item @b{GDB Disconnects} When using the Amontec JTAGkey, sometimes OpenOCD crashes with the following
 error message: "Error: gdb_server.c:101 gdb_get_char(): read: 10054".
 What does that mean and what might be the reason for this?
diff --git a/jimtcl b/jimtcl
index 51f65c6d..a9bf5975 160000
--- a/jimtcl
+++ b/jimtcl
@@ -1 +1 @@
-Subproject commit 51f65c6d38fbf86e1f0b036ad336761fd2ab7fa0
+Subproject commit a9bf5975fd0f89974d689a2d9ebd0873c8d64787
diff --git a/src/Makefile.am b/src/Makefile.am
index 26e02d08..07981aa6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,60 +1,41 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libopenocd.la
+bin_PROGRAMS += %D%/openocd
 
-SUBDIRS = \
-	jtag \
-	helper \
-	target \
-	transport \
-	flash \
-	svf \
-	xsvf \
-	pld \
-	server \
-	rtos
+%C%_openocd_SOURCES = \
+	%D%/main.c
 
-noinst_LTLIBRARIES = libopenocd.la
-bin_PROGRAMS = openocd
+%C%_libopenocd_la_SOURCES = \
+	%D%/hello.c %D%/hello.h \
+	%D%/openocd.c %D%/openocd.h
 
-MAINFILE = main.c
+%C%_openocd_LDADD = %D%/libopenocd.la
 
-openocd_SOURCES = $(MAINFILE)
-openocd_LDADD = libopenocd.la
+%C%_openocd_LDADD += $(MINGWLDADD)
 
 if INTERNAL_JIMTCL
-openocd_LDADD += $(top_builddir)/jimtcl/libjim.a
+%C%_openocd_LDADD += $(top_builddir)/jimtcl/libjim.a
 else
-openocd_LDADD += -ljim
+%C%_openocd_LDADD += -ljim
 endif
 
-if ULINK
-openocd_LDADD += -lm
-endif
-
-libopenocd_la_SOURCES = \
-	hello.c \
-	openocd.c
-
-noinst_HEADERS = \
-	hello.h \
-	openocd.h
-
-libopenocd_la_CPPFLAGS = -DPKGBLDDATE=\"`date +%F-%R`\"
+%C%_libopenocd_la_CPPFLAGS =
 
 # banner output includes RELSTR appended to $VERSION from the configure script
 # guess-rev.sh returns either a repository version ID or "-snapshot"
 if RELEASE
-libopenocd_la_CPPFLAGS += -DRELSTR=\"\"
-libopenocd_la_CPPFLAGS += -DGITVERSION=\"\"
+%C%_libopenocd_la_CPPFLAGS += -DRELSTR=\"\"
+%C%_libopenocd_la_CPPFLAGS += -DGITVERSION=\"\"
 else
-libopenocd_la_CPPFLAGS += -DRELSTR=\"`$(top_srcdir)/guess-rev.sh $(top_srcdir)`\"
-libopenocd_la_CPPFLAGS += -DGITVERSION=\"`cd $(top_srcdir) && git describe`\"
+%C%_libopenocd_la_CPPFLAGS += -DRELSTR=\"`$(top_srcdir)/guess-rev.sh $(top_srcdir)`\"
+%C%_libopenocd_la_CPPFLAGS += -DGITVERSION=\"`cd $(top_srcdir) && git describe`\"
+%C%_libopenocd_la_CPPFLAGS += -DPKGBLDDATE=\"`date +%F-%R`\"
 endif
 
 # add default CPPFLAGS
-libopenocd_la_CPPFLAGS += $(AM_CPPFLAGS) $(CPPFLAGS)
+%C%_libopenocd_la_CPPFLAGS += $(AM_CPPFLAGS) $(CPPFLAGS)
 
 # the library search path.
-libopenocd_la_LDFLAGS = $(all_libraries)
+%C%_libopenocd_la_LDFLAGS = $(all_libraries)
 
 if IS_MINGW
 MINGWLDADD = -lws2_32
@@ -62,55 +43,43 @@ else
 MINGWLDADD =
 endif
 
-libopenocd_la_LIBADD = \
-	$(top_builddir)/src/xsvf/libxsvf.la \
-	$(top_builddir)/src/svf/libsvf.la \
-	$(top_builddir)/src/pld/libpld.la \
-	$(top_builddir)/src/jtag/libjtag.la \
-	$(top_builddir)/src/transport/libtransport.la \
-	$(top_builddir)/src/flash/libflash.la \
-	$(top_builddir)/src/target/libtarget.la \
-	$(top_builddir)/src/server/libserver.la \
-	$(top_builddir)/src/rtos/librtos.la \
-	$(top_builddir)/src/helper/libhelper.la \
-	$(LIBFTDI_LIBS) $(MINGWLDADD) \
-	$(HIDAPI_LIBS) $(LIBUSB0_LIBS) $(LIBUSB1_LIBS)
-
-STARTUP_TCL_SRCS = \
-	$(srcdir)/helper/startup.tcl \
-	$(srcdir)/jtag/startup.tcl \
-	$(srcdir)/target/startup.tcl \
-	$(srcdir)/flash/startup.tcl \
-	$(srcdir)/server/startup.tcl
+%C%_libopenocd_la_LIBADD = \
+	%D%/xsvf/libxsvf.la \
+	%D%/svf/libsvf.la \
+	%D%/pld/libpld.la \
+	%D%/jtag/libjtag.la \
+	%D%/transport/libtransport.la \
+	%D%/flash/libflash.la \
+	%D%/target/libtarget.la \
+	%D%/server/libserver.la \
+	%D%/rtos/librtos.la \
+	%D%/helper/libhelper.la
 
-EXTRA_DIST = $(STARTUP_TCL_SRCS)
+BIN2C = $(srcdir)/%D%/helper/bin2char.sh
 
-BUILT_SOURCES = startup_tcl.inc
+STARTUP_TCL_SRCS =
+EXTRA_DIST += $(STARTUP_TCL_SRCS)
 
-startup.tcl: $(STARTUP_TCL_SRCS)
-	cat $^ > $@
-
-BIN2C = $(top_srcdir)/src/helper/bin2char.sh
+BUILT_SOURCES += %D%/startup_tcl.inc
 
 # Convert .tcl to c-array
-startup_tcl.inc: startup.tcl $(BIN2C)
-	$(BIN2C) < $< > $@ || { rm -f $@; false; }
+%D%/startup_tcl.inc: $(STARTUP_TCL_SRCS)
+	cat $^ | $(BIN2C) > $@ || { rm -f $@; false; }
 
 # add generated files to make clean list
-CLEANFILES = startup.tcl startup_tcl.inc
+CLEANFILES += %D%/startup_tcl.inc
 
 # we do not want generated file in the dist
-dist-hook:
-	rm -f $(distdir)/startup_tcl.inc
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
-
-# The "quick" target builds executables & reinstalls the executables
-# Primary use: developer types to quicken the edit/compile/debug
-# cycle.  by not requiring a "full build and full install". Note the
-# assumption is: You are only rebuilding the EXE.... and everything
-# else is/was previously installed.
-#
-# use at your own risk
-quick: all install-binPROGRAMS
-
+#dist-hook:
+#	rm -f $(distdir)/%D%/startup_tcl.inc
+
+include %D%/helper/Makefile.am
+include %D%/jtag/Makefile.am
+include %D%/transport/Makefile.am
+include %D%/xsvf/Makefile.am
+include %D%/svf/Makefile.am
+include %D%/target/Makefile.am
+include %D%/rtos/Makefile.am
+include %D%/server/Makefile.am
+include %D%/flash/Makefile.am
+include %D%/pld/Makefile.am
diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index ece40183..a1b46f85 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -1,23 +1,13 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libflash.la
+%C%_libflash_la_SOURCES = \
+	%D%/common.c %D%/common.h \
+	%D%/mflash.c %D%/mflash.h
 
-SUBDIRS = \
-	nor \
-	nand
+%C%_libflash_la_LIBADD = \
+	%D%/nor/libocdflashnor.la \
+	%D%/nand/libocdflashnand.la
 
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libflash.la
-libflash_la_SOURCES = \
-	common.c \
-	mflash.c
+STARTUP_TCL_SRCS += %D%/startup.tcl
 
-libflash_la_LIBADD = \
-	$(top_builddir)/src/flash/nor/libocdflashnor.la \
-	$(top_builddir)/src/flash/nand/libocdflashnand.la
-
-noinst_HEADERS = \
-	common.h \
-	mflash.h
-
-EXTRA_DIST = startup.tcl
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+include %D%/nor/Makefile.am
+include %D%/nand/Makefile.am
diff --git a/src/flash/common.c b/src/flash/common.c
index 878667b8..3e255119 100644
--- a/src/flash/common.c
+++ b/src/flash/common.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/common.h b/src/flash/common.h
index 6e32c552..4244f136 100644
--- a/src/flash/common.h
+++ b/src/flash/common.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_COMMON_H
-#define FLASH_COMMON_H
+#ifndef OPENOCD_FLASH_COMMON_H
+#define OPENOCD_FLASH_COMMON_H
 
 #include <helper/log.h>
 
@@ -46,5 +44,6 @@ bool flash_driver_name_matches(const char *name, const char *expected);
 #define ERROR_FLASH_SECTOR_NOT_ERASED		(-906)
 #define ERROR_FLASH_BANK_NOT_PROBED			(-907)
 #define ERROR_FLASH_OPER_UNSUPPORTED		(-908)
+#define ERROR_FLASH_PROTECTED			(-909)
 
-#endif	/* FLASH_COMMON_H */
+#endif /* OPENOCD_FLASH_COMMON_H */
diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 6f4a988e..4c95d216 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -261,11 +259,11 @@ static int mg_dsk_wait(mg_io_type_wait wait_local, uint32_t time_var)
 				case mg_io_wait_rdy:
 					if (status & mg_io_rbit_status_ready)
 						return ERROR_OK;
-
+					/* fallthrough */
 				case mg_io_wait_drq:
 					if (status & mg_io_rbit_status_data_req)
 						return ERROR_OK;
-
+					/* fallthrough */
 				default:
 					break;
 			}
@@ -749,7 +747,7 @@ COMMAND_HANDLER(mg_write_cmd)
 {
 	uint32_t address, cnt, res, i;
 	uint8_t *buffer;
-	struct fileio fileio;
+	struct fileio *fileio;
 	int ret;
 
 	if (CMD_ARGC != 3)
@@ -764,12 +762,12 @@ COMMAND_HANDLER(mg_write_cmd)
 	size_t filesize;
 	buffer = malloc(MG_FILEIO_CHUNK);
 	if (!buffer) {
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		return ERROR_FAIL;
 	}
-	int retval = fileio_size(&fileio, &filesize);
+	int retval = fileio_size(fileio, &filesize);
 	if (retval != ERROR_OK) {
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		free(buffer);
 		return retval;
 	}
@@ -782,7 +780,7 @@ COMMAND_HANDLER(mg_write_cmd)
 
 	size_t buf_cnt;
 	for (i = 0; i < cnt; i++) {
-		ret = fileio_read(&fileio, MG_FILEIO_CHUNK, buffer, &buf_cnt);
+		ret = fileio_read(fileio, MG_FILEIO_CHUNK, buffer, &buf_cnt);
 		if (ret != ERROR_OK)
 			goto mg_write_cmd_err;
 		ret = mg_mflash_write(address, buffer, MG_FILEIO_CHUNK);
@@ -792,7 +790,7 @@ COMMAND_HANDLER(mg_write_cmd)
 	}
 
 	if (res) {
-		ret = fileio_read(&fileio, res, buffer, &buf_cnt);
+		ret = fileio_read(fileio, res, buffer, &buf_cnt);
 		if (ret != ERROR_OK)
 			goto mg_write_cmd_err;
 		ret = mg_mflash_write(address, buffer, res);
@@ -807,13 +805,13 @@ COMMAND_HANDLER(mg_write_cmd)
 	}
 
 	free(buffer);
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	return ERROR_OK;
 
 mg_write_cmd_err:
 	free(buffer);
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	return ret;
 }
@@ -822,7 +820,7 @@ COMMAND_HANDLER(mg_dump_cmd)
 {
 	uint32_t address, size, cnt, res, i;
 	uint8_t *buffer;
-	struct fileio fileio;
+	struct fileio *fileio;
 	int ret;
 
 	if (CMD_ARGC != 4)
@@ -837,7 +835,7 @@ COMMAND_HANDLER(mg_dump_cmd)
 
 	buffer = malloc(MG_FILEIO_CHUNK);
 	if (!buffer) {
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		return ERROR_FAIL;
 	}
 
@@ -852,7 +850,7 @@ COMMAND_HANDLER(mg_dump_cmd)
 		ret = mg_mflash_read(address, buffer, MG_FILEIO_CHUNK);
 		if (ret != ERROR_OK)
 			goto mg_dump_cmd_err;
-		ret = fileio_write(&fileio, MG_FILEIO_CHUNK, buffer, &size_written);
+		ret = fileio_write(fileio, MG_FILEIO_CHUNK, buffer, &size_written);
 		if (ret != ERROR_OK)
 			goto mg_dump_cmd_err;
 		address += MG_FILEIO_CHUNK;
@@ -862,7 +860,7 @@ COMMAND_HANDLER(mg_dump_cmd)
 		ret = mg_mflash_read(address, buffer, res);
 		if (ret != ERROR_OK)
 			goto mg_dump_cmd_err;
-		ret = fileio_write(&fileio, res, buffer, &size_written);
+		ret = fileio_write(fileio, res, buffer, &size_written);
 		if (ret != ERROR_OK)
 			goto mg_dump_cmd_err;
 	}
@@ -875,13 +873,13 @@ COMMAND_HANDLER(mg_dump_cmd)
 	}
 
 	free(buffer);
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	return ERROR_OK;
 
 mg_dump_cmd_err:
 	free(buffer);
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	return ret;
 }
diff --git a/src/flash/mflash.h b/src/flash/mflash.h
index 6f46c7bd..18da4036 100644
--- a/src/flash/mflash.h
+++ b/src/flash/mflash.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _MFLASH_H
-#define _MFLASH_H
+#ifndef OPENOCD_FLASH_MFLASH_H
+#define OPENOCD_FLASH_MFLASH_H
 
 struct command_context;
 
@@ -288,4 +286,4 @@ typedef enum _mg_opmode {
 	mg_op_mode_stg = 0	/* Only Storage */
 } mg_opmode;
 
-#endif
+#endif /* OPENOCD_FLASH_MFLASH_H */
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 2ddd096a..abe90f8b 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -1,46 +1,43 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libocdflashnand.la
 
-noinst_LTLIBRARIES = libocdflashnand.la
-
-libocdflashnand_la_SOURCES = \
-	ecc.c \
-	ecc_kw.c \
-	core.c \
-	fileio.c \
-	tcl.c \
-	arm_io.c \
+%C%_libocdflashnand_la_SOURCES = \
+	%D%/ecc.c \
+	%D%/ecc_kw.c \
+	%D%/core.c \
+	%D%/fileio.c \
+	%D%/tcl.c \
+	%D%/arm_io.c \
 	$(NAND_DRIVERS) \
-	driver.c
+	%D%/driver.c \
+	$(NANDHEADERS)
 
 NAND_DRIVERS = \
-	nonce.c \
-	davinci.c \
-	lpc3180.c \
-	lpc32xx.c \
-	mxc.c \
-	mx3.c \
-	orion.c \
-	s3c24xx.c \
-	s3c2410.c \
-	s3c2412.c \
-	s3c2440.c \
-	s3c2443.c \
-	s3c6400.c \
-	at91sam9.c \
-	nuc910.c
-
-noinst_HEADERS = \
-	arm_io.h \
-	core.h \
-	driver.h \
-	fileio.h \
-	imp.h \
-	lpc3180.h \
-	lpc32xx.h \
-	mxc.h \
-	mx3.h \
-	s3c24xx.h \
-	s3c24xx_regs.h \
-	nuc910.h
+	%D%/nonce.c \
+	%D%/davinci.c \
+	%D%/lpc3180.c \
+	%D%/lpc32xx.c \
+	%D%/mxc.c \
+	%D%/mx3.c \
+	%D%/orion.c \
+	%D%/s3c24xx.c \
+	%D%/s3c2410.c \
+	%D%/s3c2412.c \
+	%D%/s3c2440.c \
+	%D%/s3c2443.c \
+	%D%/s3c6400.c \
+	%D%/at91sam9.c \
+	%D%/nuc910.c
 
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+NANDHEADERS = \
+	%D%/arm_io.h \
+	%D%/core.h \
+	%D%/driver.h \
+	%D%/fileio.h \
+	%D%/imp.h \
+	%D%/lpc3180.h \
+	%D%/lpc32xx.h \
+	%D%/mxc.h \
+	%D%/mx3.h \
+	%D%/s3c24xx.h \
+	%D%/s3c24xx_regs.h \
+	%D%/nuc910.h
diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
index d54958ad..e319f958 100644
--- a/src/flash/nand/arm_io.c
+++ b/src/flash/nand/arm_io.c
@@ -15,9 +15,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/arm_io.h b/src/flash/nand/arm_io.h
index 0ee79a79..8bb31145 100644
--- a/src/flash/nand/arm_io.h
+++ b/src/flash/nand/arm_io.h
@@ -12,12 +12,10 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-#ifndef __ARM_NANDIO_H
-#define __ARM_NANDIO_H
+#ifndef OPENOCD_FLASH_NAND_ARM_IO_H
+#define OPENOCD_FLASH_NAND_ARM_IO_H
 
 /**
  * Available operational states the arm_nand_data struct can be in.
@@ -54,4 +52,4 @@ struct arm_nand_data {
 int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size);
 int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size);
 
-#endif	/* __ARM_NANDIO_H */
+#endif /* OPENOCD_FLASH_NAND_ARM_IO_H */
diff --git a/src/flash/nand/at91sam9.c b/src/flash/nand/at91sam9.c
index 3f4e5e27..0af12b20 100644
--- a/src/flash/nand/at91sam9.c
+++ b/src/flash/nand/at91sam9.c
@@ -13,9 +13,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 815c7661..7428d225 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
index 308859bd..5bf9fb3d 100644
--- a/src/flash/nand/core.h
+++ b/src/flash/nand/core.h
@@ -18,13 +18,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NAND_CORE_H
-#define FLASH_NAND_CORE_H
+#ifndef OPENOCD_FLASH_NAND_CORE_H
+#define OPENOCD_FLASH_NAND_CORE_H
 
 #include <flash/common.h>
 
@@ -68,7 +66,7 @@ struct nand_device {
 	int address_cycles;
 	int page_size;
 	int erase_size;
-	int use_raw;
+	bool use_raw;
 	int num_blocks;
 	struct nand_block *blocks;
 	struct nand_device *next;
@@ -231,4 +229,4 @@ COMMAND_HELPER(nand_command_get_device, unsigned name_index,
 #define         ERROR_NAND_ERROR_CORRECTION_FAILED      (-1105)
 #define         ERROR_NAND_NO_BUFFER                    (-1106)
 
-#endif	/* FLASH_NAND_CORE_H */
+#endif /* OPENOCD_FLASH_NAND_CORE_H */
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index c88046d6..17e6f680 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 49e13c00..f7665603 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
index 62bae06e..2182a772 100644
--- a/src/flash/nand/driver.h
+++ b/src/flash/nand/driver.h
@@ -15,13 +15,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NAND_DRIVER_H
-#define FLASH_NAND_DRIVER_H
+#ifndef OPENOCD_FLASH_NAND_DRIVER_H
+#define OPENOCD_FLASH_NAND_DRIVER_H
 
 struct nand_device;
 
@@ -102,4 +100,4 @@ typedef int (*nand_driver_walker_t)(struct nand_flash_controller *c, void *);
  */
 int nand_driver_walk(nand_driver_walker_t f, void *x);
 
-#endif	/* FLASH_NAND_DRIVER_H */
+#endif /* OPENOCD_FLASH_NAND_DRIVER_H */
diff --git a/src/flash/nand/ecc.c b/src/flash/nand/ecc.c
index fba7b1c6..25b2eb10 100644
--- a/src/flash/nand/ecc.c
+++ b/src/flash/nand/ecc.c
@@ -21,9 +21,8 @@
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this file; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * As a special exception, if other files instantiate templates or use
  * macros or inline functions from these files, or you compile these
diff --git a/src/flash/nand/ecc_kw.c b/src/flash/nand/ecc_kw.c
index 1c3cc70a..fb3481d0 100644
--- a/src/flash/nand/ecc_kw.c
+++ b/src/flash/nand/ecc_kw.c
@@ -14,6 +14,9 @@
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/fileio.c b/src/flash/nand/fileio.c
index d84ef4f9..64c32c0a 100644
--- a/src/flash/nand/fileio.c
+++ b/src/flash/nand/fileio.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -99,7 +97,7 @@ int nand_fileio_start(struct command_context *cmd_ctx,
 int nand_fileio_cleanup(struct nand_fileio_state *state)
 {
 	if (state->file_opened)
-		fileio_close(&state->fileio);
+		fileio_close(state->fileio);
 
 	if (state->oob) {
 		free(state->oob);
@@ -134,7 +132,7 @@ COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
 
 	if (NULL == nand->device) {
 		command_print(CMD_CTX, "#%s: not probed", CMD_ARGV[0]);
-		return ERROR_OK;
+		return ERROR_NAND_DEVICE_NOT_PROBED;
 	}
 
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], state->address);
@@ -169,7 +167,7 @@ COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
 
 	if (!need_size) {
 		size_t filesize;
-		retval = fileio_size(&state->fileio, &filesize);
+		retval = fileio_size(state->fileio, &filesize);
 		if (retval != ERROR_OK)
 			return retval;
 		state->size = filesize;
@@ -190,7 +188,7 @@ int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s)
 	size_t one_read;
 
 	if (NULL != s->page) {
-		fileio_read(&s->fileio, s->page_size, s->page, &one_read);
+		fileio_read(s->fileio, s->page_size, s->page, &one_read);
 		if (one_read < s->page_size)
 			memset(s->page + one_read, 0xff, s->page_size - one_read);
 		total_read += one_read;
@@ -219,7 +217,7 @@ int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s)
 			ecc += 10;
 		}
 	} else if (NULL != s->oob)   {
-		fileio_read(&s->fileio, s->oob_size, s->oob, &one_read);
+		fileio_read(s->fileio, s->oob_size, s->oob, &one_read);
 		if (one_read < s->oob_size)
 			memset(s->oob + one_read, 0xff, s->oob_size - one_read);
 		total_read += one_read;
diff --git a/src/flash/nand/fileio.h b/src/flash/nand/fileio.h
index c92c644f..af6c7666 100644
--- a/src/flash/nand/fileio.h
+++ b/src/flash/nand/fileio.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NAND_FILEIO_H
-#define FLASH_NAND_FILEIO_H
+#ifndef OPENOCD_FLASH_NAND_FILEIO_H
+#define OPENOCD_FLASH_NAND_FILEIO_H
 
 #include <helper/time_support.h>
 #include <helper/fileio.h>
@@ -37,7 +35,7 @@ struct nand_fileio_state {
 	const int *eccpos;
 
 	bool file_opened;
-	struct fileio fileio;
+	struct fileio *fileio;
 
 	struct duration bench;
 };
@@ -55,4 +53,4 @@ COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
 
 int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s);
 
-#endif	/* FLASH_NAND_FILEIO_H */
+#endif /* OPENOCD_FLASH_NAND_FILEIO_H */
diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
index dde17cb8..c8a4ed9c 100644
--- a/src/flash/nand/imp.h
+++ b/src/flash/nand/imp.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NAND_IMP_H
-#define FLASH_NAND_IMP_H
+#ifndef OPENOCD_FLASH_NAND_IMP_H
+#define OPENOCD_FLASH_NAND_IMP_H
 
 #include "core.h"
 #include "driver.h"
@@ -37,4 +35,4 @@ int nand_probe(struct nand_device *nand);
 int nand_erase(struct nand_device *nand, int first_block, int last_block);
 int nand_build_bbt(struct nand_device *nand, int first, int last);
 
-#endif	/* FLASH_NAND_IMP_H */
+#endif /* OPENOCD_FLASH_NAND_IMP_H */
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index ff02ffaa..d15fdce3 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/lpc3180.h b/src/flash/nand/lpc3180.h
index 4d162fc8..c02ee5b2 100644
--- a/src/flash/nand/lpc3180.h
+++ b/src/flash/nand/lpc3180.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef LPC3180_NAND_CONTROLLER_H
-#define LPC3180_NAND_CONTROLLER_H
+#ifndef OPENOCD_FLASH_NAND_LPC3180_H
+#define OPENOCD_FLASH_NAND_LPC3180_H
 
 enum lpc3180_selected_controller {
 	LPC3180_NO_CONTROLLER,
@@ -36,4 +34,4 @@ struct lpc3180_nand_controller {
 	uint32_t sw_wp_upper_bound;
 };
 
-#endif	/*LPC3180_NAND_CONTROLLER_H */
+#endif /* OPENOCD_FLASH_NAND_LPC3180_H */
diff --git a/src/flash/nand/lpc32xx.c b/src/flash/nand/lpc32xx.c
index c310f904..1ed16dfd 100644
--- a/src/flash/nand/lpc32xx.c
+++ b/src/flash/nand/lpc32xx.c
@@ -21,9 +21,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/lpc32xx.h b/src/flash/nand/lpc32xx.h
index 2b1c1a89..90b20b24 100644
--- a/src/flash/nand/lpc32xx.h
+++ b/src/flash/nand/lpc32xx.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef LPC32xx_NAND_CONTROLLER_H
-#define LPC32xx_NAND_CONTROLLER_H
+#ifndef OPENOCD_FLASH_NAND_LPC32XX_H
+#define OPENOCD_FLASH_NAND_LPC32XX_H
 
 enum lpc32xx_selected_controller {
 	LPC32xx_NO_CONTROLLER,
@@ -35,4 +33,4 @@ struct lpc32xx_nand_controller {
 	uint32_t sw_wp_upper_bound;
 };
 
-#endif	/*LPC32xx_NAND_CONTROLLER_H */
+#endif /* OPENOCD_FLASH_NAND_LPC32XX_H */
diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
index dac654cd..92b4619b 100644
--- a/src/flash/nand/mx3.c
+++ b/src/flash/nand/mx3.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
@@ -283,6 +281,7 @@ static int imx31_command(struct nand_device *nand, uint8_t command)
 			 * offset == one half of page size
 			 */
 			in_sram_address = MX3_NF_MAIN_BUFFER0 + (nand->page_size >> 1);
+			break;
 		default:
 			in_sram_address = MX3_NF_MAIN_BUFFER0;
 	}
diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
index 60ec2938..00664d86 100644
--- a/src/flash/nand/mx3.h
+++ b/src/flash/nand/mx3.h
@@ -14,11 +14,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_FLASH_NAND_MX3_H
+#define OPENOCD_FLASH_NAND_MX3_H
+
 /*
  * Freescale iMX3* OpenOCD NAND Flash controller support.
  *
@@ -107,3 +108,5 @@ struct mx3_nf_controller {
 	enum mx_nf_finalize_action fin;
 	struct mx3_nf_flags flags;
 };
+
+#endif /* OPENOCD_FLASH_NAND_MX3_H */
diff --git a/src/flash/nand/mxc.c b/src/flash/nand/mxc.c
index b91460ef..5e59b9a6 100644
--- a/src/flash/nand/mxc.c
+++ b/src/flash/nand/mxc.c
@@ -20,9 +20,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/mxc.h b/src/flash/nand/mxc.h
index 866e0e32..a1887288 100644
--- a/src/flash/nand/mxc.h
+++ b/src/flash/nand/mxc.h
@@ -1,4 +1,3 @@
-
 /***************************************************************************
  *   Copyright (C) 2009 by Alexei Babich                                   *
  *   Rezonans plc., Chelyabinsk, Russia                                    *
@@ -18,11 +17,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_FLASH_NAND_MXC_H
+#define OPENOCD_FLASH_NAND_MXC_H
+
 /*
  * Freescale iMX OpenOCD NAND Flash controller support.
  * based on Freescale iMX2* and iMX3* OpenOCD NAND Flash controller support.
@@ -164,3 +164,5 @@ struct mxc_nf_controller {
 	enum mxc_nf_finalize_action fin;
 	struct mxc_nf_flags flags;
 };
+
+#endif /* OPENOCD_FLASH_NAND_MXC_H */
diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
index 6b3dbad8..6fda2618 100644
--- a/src/flash/nand/nonce.c
+++ b/src/flash/nand/nonce.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/nuc910.c b/src/flash/nand/nuc910.c
index 832eeae4..1a2dd596 100644
--- a/src/flash/nand/nuc910.c
+++ b/src/flash/nand/nuc910.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/nuc910.h b/src/flash/nand/nuc910.h
index e0e458f3..8877cf63 100644
--- a/src/flash/nand/nuc910.h
+++ b/src/flash/nand/nuc910.h
@@ -13,17 +13,15 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
  * NAND controller interface for Nuvoton NUC910
  */
 
-#ifndef NUC910_H
-#define NUC910_H
+#ifndef OPENOCD_FLASH_NAND_NUC910_H
+#define OPENOCD_FLASH_NAND_NUC910_H
 
 #define NUC910_FMICSR	0xB000D000
 #define NUC910_SMCSR	0xB000D0A0
@@ -56,5 +54,4 @@
 
 /* ECC4 Correction Status (ECC4ST) */
 
-#endif /* NUC910_H */
-
+#endif /* OPENOCD_FLASH_NAND_NUC910_H */
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 71f847bf..69814eca 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/s3c2410.c b/src/flash/nand/s3c2410.c
index 2aff7a89..57b51b48 100644
--- a/src/flash/nand/s3c2410.c
+++ b/src/flash/nand/s3c2410.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/s3c2412.c b/src/flash/nand/s3c2412.c
index 6cbdc6c0..002378a1 100644
--- a/src/flash/nand/s3c2412.c
+++ b/src/flash/nand/s3c2412.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/s3c2440.c b/src/flash/nand/s3c2440.c
index b794faba..44670e6f 100644
--- a/src/flash/nand/s3c2440.c
+++ b/src/flash/nand/s3c2440.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/s3c2443.c b/src/flash/nand/s3c2443.c
index 8cd3213f..ffd3864b 100644
--- a/src/flash/nand/s3c2443.c
+++ b/src/flash/nand/s3c2443.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/s3c24xx.c b/src/flash/nand/s3c24xx.c
index b4c15ce4..ae3f1373 100644
--- a/src/flash/nand/s3c24xx.c
+++ b/src/flash/nand/s3c24xx.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index c69de2ee..5c7782da 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef S3C24xx_NAND_H
-#define S3C24xx_NAND_H
+#ifndef OPENOCD_FLASH_NAND_S3C24XX_H
+#define OPENOCD_FLASH_NAND_S3C24XX_H
 
 /*
  * S3C24XX Series OpenOCD NAND Flash controller support.
@@ -77,4 +75,4 @@ int s3c2440_read_block_data(struct nand_device *nand,
 int s3c2440_write_block_data(struct nand_device *nand,
 		uint8_t *data, int data_size);
 
-#endif /* S3C24xx_NAND_H */
+#endif /* OPENOCD_FLASH_NAND_S3C24XX_H */
diff --git a/src/flash/nand/s3c24xx_regs.h b/src/flash/nand/s3c24xx_regs.h
index fc0f96f5..88bc6656 100644
--- a/src/flash/nand/s3c24xx_regs.h
+++ b/src/flash/nand/s3c24xx_regs.h
@@ -13,17 +13,15 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
  * S3C2410 NAND register definitions
  */
 
-#ifndef __ASM_ARM_REGS_NAND
-#define __ASM_ARM_REGS_NAND
+#ifndef OPENOCD_FLASH_NAND_S3C24XX_REGS_H
+#define OPENOCD_FLASH_NAND_S3C24XX_REGS_H
 
 #define S3C2410_NFREG(x) (x)
 
@@ -128,5 +126,4 @@
 #define S3C2412_NFECCERR_MULTIBIT	(2)
 #define S3C2412_NFECCERR_ECCAREA	(3)
 
-#endif /* __ASM_ARM_REGS_NAND */
-
+#endif /* OPENOCD_FLASH_NAND_S3C24XX_REGS_H */
diff --git a/src/flash/nand/s3c6400.c b/src/flash/nand/s3c6400.c
index abbfb251..7058133b 100644
--- a/src/flash/nand/s3c6400.c
+++ b/src/flash/nand/s3c6400.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 750c1f00..d9738c55 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -256,7 +254,8 @@ COMMAND_HANDLER(handle_nand_write_command)
 		int bytes_read = nand_fileio_read(nand, &s);
 		if (bytes_read <= 0) {
 			command_print(CMD_CTX, "error while reading file");
-			return nand_fileio_cleanup(&s);
+			nand_fileio_cleanup(&s);
+			return ERROR_FAIL;
 		}
 		s.size -= bytes_read;
 
@@ -266,7 +265,8 @@ COMMAND_HANDLER(handle_nand_write_command)
 			command_print(CMD_CTX, "failed writing file %s "
 				"to NAND flash %s at offset 0x%8.8" PRIx32,
 				CMD_ARGV[1], CMD_ARGV[0], s.address);
-			return nand_fileio_cleanup(&s);
+			nand_fileio_cleanup(&s);
+			return retval;
 		}
 		s.address += s.page_size;
 	}
@@ -360,16 +360,16 @@ COMMAND_HANDLER(handle_nand_dump_command)
 		}
 
 		if (NULL != s.page)
-			fileio_write(&s.fileio, s.page_size, s.page, &size_written);
+			fileio_write(s.fileio, s.page_size, s.page, &size_written);
 
 		if (NULL != s.oob)
-			fileio_write(&s.fileio, s.oob_size, s.oob, &size_written);
+			fileio_write(s.fileio, s.oob_size, s.oob, &size_written);
 
 		s.size -= nand->page_size;
 		s.address += nand->page_size;
 	}
 
-	retval = fileio_size(&s.fileio, &filesize);
+	retval = fileio_size(s.fileio, &filesize);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -547,7 +547,7 @@ static COMMAND_HELPER(create_nand_device, const char *bank_name,
 	c->bus_width = 0;
 	c->address_cycles = 0;
 	c->page_size = 0;
-	c->use_raw = 0;
+	c->use_raw = false;
 	c->next = NULL;
 
 	retval = CALL_COMMAND_HANDLER(controller->nand_device_command, c);
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 834e4d47..4dac110c 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -1,66 +1,67 @@
-include $(top_srcdir)/common.mk
-
-noinst_LTLIBRARIES = libocdflashnor.la
-libocdflashnor_la_SOURCES = \
-	core.c \
-	tcl.c \
+noinst_LTLIBRARIES += %D%/libocdflashnor.la
+%C%_libocdflashnor_la_SOURCES = \
+	%D%/core.c \
+	%D%/tcl.c \
 	$(NOR_DRIVERS) \
-	drivers.c
+	%D%/drivers.c \
+	$(NORHEADERS)
 
 NOR_DRIVERS = \
-	aduc702x.c \
-	aducm360.c \
-	at91sam4.c \
-	at91sam4l.c \
-	at91samd.c \
-	at91sam3.c \
-	at91sam7.c \
-	atsamv.c \
-	avrf.c \
-	cfi.c \
-	efm32.c \
-	em357.c \
-	faux.c \
-	jtagspi.c \
-	lpc2000.c \
-	lpc288x.c \
-	lpc2900.c \
-	lpcspifi.c \
-	mdr.c \
-	non_cfi.c \
-	ocl.c \
-	pic32mx.c \
-	spi.c \
-	stmsmi.c \
-	stellaris.c \
-	stm32f1x.c \
-	stm32f2x.c \
-	stm32lx.c \
-	stm32l4x.c \
-	str7x.c \
-	str9x.c \
-	str9xpec.c \
-	tms470.c \
-	virtual.c \
-	fm3.c \
-	dsp5680xx_flash.c \
-	kinetis.c \
-	numicro.c \
-	nrf51.c \
-	mrvlqspi.c \
-	psoc4.c \
-	sim3x.c \
-	xmc4xxx.c \
-	niietcm4.c
-
-
-noinst_HEADERS = \
-	core.h \
-	cfi.h \
-	driver.h \
-	imp.h \
-	non_cfi.h \
-	ocl.h \
-	spi.h
+	%D%/aduc702x.c \
+	%D%/aducm360.c \
+	%D%/ambiqmicro.c \
+	%D%/at91sam4.c \
+	%D%/at91sam4l.c \
+	%D%/at91samd.c \
+	%D%/at91sam3.c \
+	%D%/at91sam7.c \
+	%D%/ath79.c \
+	%D%/atsamv.c \
+	%D%/avrf.c \
+	%D%/cfi.c \
+	%D%/dsp5680xx_flash.c \
+	%D%/efm32.c \
+	%D%/em357.c \
+	%D%/faux.c \
+	%D%/fm3.c \
+	%D%/fm4.c \
+	%D%/jtagspi.c \
+	%D%/kinetis.c \
+	%D%/kinetis_ke.c \
+	%D%/lpc2000.c \
+	%D%/lpc288x.c \
+	%D%/lpc2900.c \
+	%D%/lpcspifi.c \
+	%D%/mdr.c \
+	%D%/mrvlqspi.c \
+	%D%/niietcm4.c \
+	%D%/non_cfi.c \
+	%D%/nrf5.c \
+	%D%/numicro.c \
+	%D%/ocl.c \
+	%D%/pic32mx.c \
+	%D%/psoc4.c \
+	%D%/sim3x.c \
+	%D%/spi.c \
+	%D%/stmsmi.c \
+	%D%/stellaris.c \
+	%D%/stm32f1x.c \
+	%D%/stm32f2x.c \
+	%D%/stm32lx.c \
+	%D%/stm32l4x.c \
+	%D%/str7x.c \
+	%D%/str9x.c \
+	%D%/str9xpec.c \
+	%D%/tms470.c \
+	%D%/virtual.c \
+	%D%/xmc1xxx.c \
+	%D%/xmc4xxx.c
 
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+NORHEADERS = \
+	%D%/core.h \
+	%D%/cfi.h \
+	%D%/driver.h \
+	%D%/imp.h \
+	%D%/non_cfi.h \
+	%D%/ocl.h \
+	%D%/spi.h
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 88522458..34cc362e 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -373,7 +371,7 @@ static int aduc702x_check_flash_completion(struct target *target, unsigned int t
 {
 	uint8_t v = 4;
 
-	long long endtime = timeval_ms() + timeout_ms;
+	int64_t endtime = timeval_ms() + timeout_ms;
 	while (1) {
 		target_read_u8(target, ADUC702x_FLASH + ADUC702x_FLASH_FEESTA, &v);
 		if ((v & 4) == 0)
diff --git a/src/flash/nor/aducm360.c b/src/flash/nor/aducm360.c
index 3e446f53..8681a25a 100644
--- a/src/flash/nor/aducm360.c
+++ b/src/flash/nor/aducm360.c
@@ -12,6 +12,8 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
  *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /***************************************************************************
@@ -549,7 +551,7 @@ static int aducm360_check_flash_completion(struct target *target, unsigned int t
 {
 	uint32_t v = 1;
 
-	long long endtime = timeval_ms() + timeout_ms;
+	int64_t endtime = timeval_ms() + timeout_ms;
 	while (1) {
 		target_read_u32(target, ADUCM360_FLASH_BASE+ADUCM360_FLASH_FEESTA, &v);
 		if ((v & 0x00000001) == 0)
diff --git a/src/flash/nor/ambiqmicro.c b/src/flash/nor/ambiqmicro.c
new file mode 100644
index 00000000..b2c30e6f
--- /dev/null
+++ b/src/flash/nor/ambiqmicro.c
@@ -0,0 +1,904 @@
+/******************************************************************************
+ *
+ * @file ambiqmicro.c
+ *
+ * @brief Ambiq Micro flash driver.
+ *
+ *****************************************************************************/
+
+/******************************************************************************
+ * Copyright (c) 2015, David Racine <dracine at ambiqmicro.com>
+ *
+ * Copyright (c) 2016, Rick Foos <rfoos at solengtech.com>
+ *
+ * Copyright (c) 2015-2016, Ambiq Micro, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag/interface.h"
+#include "imp.h"
+#include "target/algorithm.h"
+#include "target/armv7m.h"
+#include "target/cortex_m.h"
+
+/** Check error, log error. */
+#define CHECK_STATUS(rc, msg) {	\
+		if (rc != ERROR_OK) { \
+			LOG_ERROR("status(%d):%s\n", rc, msg); } }
+
+/*
+ * Address and Key defines.
+ */
+#define PROGRAM_KEY      (0x12344321)
+#define OTP_PROGRAM_KEY  (0x87655678)
+
+#define FLASH_PROGRAM_MAIN_FROM_SRAM                0x0800005d
+#define FLASH_PROGRAM_OTP_FROM_SRAM                 0x08000061
+#define FLASH_ERASE_LIST_MAIN_PAGES_FROM_SRAM       0x08000065
+#define FLASH_MASS_ERASE_MAIN_PAGES_FROM_SRAM       0x08000069
+
+
+static const uint32_t apollo_flash_size[] = {
+	1 << 15,
+	1 << 16,
+	1 << 17,
+	1 << 18,
+	1 << 19,
+	1 << 20,
+	1 << 21
+};
+
+static const uint32_t apollo_sram_size[] = {
+	1 << 15,
+	1 << 16,
+	1 << 17,
+	1 << 18,
+	1 << 19,
+	1 << 20,
+	1 << 21
+};
+
+struct ambiqmicro_flash_bank {
+	/* chip id register */
+
+	uint32_t probed;
+
+	const char *target_name;
+	uint8_t target_class;
+
+	uint32_t sramsiz;
+	uint32_t flshsiz;
+
+	/* flash geometry */
+	uint32_t num_pages;
+	uint32_t pagesize;
+	uint32_t pages_in_lockregion;
+
+	/* nv memory bits */
+	uint16_t num_lockbits;
+
+	/* main clock status */
+	uint32_t rcc;
+	uint32_t rcc2;
+	uint8_t mck_valid;
+	uint8_t xtal_mask;
+	uint32_t iosc_freq;
+	uint32_t mck_freq;
+	const char *iosc_desc;
+	const char *mck_desc;
+};
+
+static struct {
+	uint8_t class;
+	uint8_t partno;
+	const char *partname;
+} ambiqmicroParts[6] = {
+	{0xFF, 0x00, "Unknown"},
+	{0x01, 0x00, "Apollo"},
+	{0x02, 0x00, "Apollo2"},
+	{0x03, 0x00, "Unknown"},
+	{0x04, 0x00, "Unknown"},
+	{0x05, 0x00, "Apollo"},
+};
+
+static char *ambiqmicroClassname[6] = {
+	"Unknown", "Apollo", "Apollo2", "Unknown", "Unknown", "Apollo"
+};
+
+/***************************************************************************
+*	openocd command interface                                              *
+***************************************************************************/
+
+/* flash_bank ambiqmicro <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(ambiqmicro_flash_bank_command)
+{
+	struct ambiqmicro_flash_bank *ambiqmicro_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	ambiqmicro_info = calloc(sizeof(struct ambiqmicro_flash_bank), 1);
+
+	bank->driver_priv = ambiqmicro_info;
+
+	ambiqmicro_info->target_name = "Unknown target";
+
+	/* part wasn't probed yet */
+	ambiqmicro_info->probed = 0;
+
+	return ERROR_OK;
+}
+
+static int get_ambiqmicro_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct ambiqmicro_flash_bank *ambiqmicro_info = bank->driver_priv;
+	int printed;
+	char *classname;
+
+	if (ambiqmicro_info->probed == 0) {
+		LOG_ERROR("Target not probed");
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	/* Check class name in range. */
+	if (ambiqmicro_info->target_class < sizeof(ambiqmicroClassname))
+		classname = ambiqmicroClassname[ambiqmicro_info->target_class];
+	else
+		classname = ambiqmicroClassname[0];
+
+	printed = snprintf(buf,
+		buf_size,
+		"\nAmbiq Micro information: Chip is "
+		"class %d (%s) %s\n",
+		ambiqmicro_info->target_class,
+		classname,
+		ambiqmicro_info->target_name);
+
+	if ((printed < 0))
+		return ERROR_BUF_TOO_SMALL;
+	return ERROR_OK;
+}
+
+/***************************************************************************
+*	chip identification and status                                         *
+***************************************************************************/
+
+/* Fill in driver info structure */
+static int ambiqmicro_read_part_info(struct flash_bank *bank)
+{
+	struct ambiqmicro_flash_bank *ambiqmicro_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t PartNum = 0;
+	int retval;
+
+	/*
+	 * Read Part Number.
+	 */
+	retval = target_read_u32(target, 0x40020000, &PartNum);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("status(0x%x):Could not read PartNum.\n", retval);
+		/* Set PartNum to default device */
+		PartNum = 0;
+	}
+	LOG_DEBUG("Part number: 0x%x", PartNum);
+
+	/*
+	 * Determine device class.
+	 */
+	ambiqmicro_info->target_class = (PartNum & 0xFF000000) >> 24;
+
+	switch (ambiqmicro_info->target_class) {
+		case 1:		/* 1 - Apollo */
+		case 5:		/* 5 - Apollo Bootloader */
+			bank->base = bank->bank_number * 0x40000;
+			ambiqmicro_info->pagesize = 2048;
+			ambiqmicro_info->flshsiz =
+			apollo_flash_size[(PartNum & 0x00F00000) >> 20];
+			ambiqmicro_info->sramsiz =
+			apollo_sram_size[(PartNum & 0x000F0000) >> 16];
+			ambiqmicro_info->num_pages = ambiqmicro_info->flshsiz /
+			ambiqmicro_info->pagesize;
+			if (ambiqmicro_info->num_pages > 128) {
+				ambiqmicro_info->num_pages = 128;
+				ambiqmicro_info->flshsiz = 1024 * 256;
+			}
+			break;
+
+		default:
+			LOG_INFO("Unknown Class. Using Apollo-64 as default.");
+
+			bank->base = bank->bank_number * 0x40000;
+			ambiqmicro_info->pagesize = 2048;
+			ambiqmicro_info->flshsiz = apollo_flash_size[1];
+			ambiqmicro_info->sramsiz = apollo_sram_size[0];
+			ambiqmicro_info->num_pages = ambiqmicro_info->flshsiz /
+			ambiqmicro_info->pagesize;
+			if (ambiqmicro_info->num_pages > 128) {
+				ambiqmicro_info->num_pages = 128;
+				ambiqmicro_info->flshsiz = 1024 * 256;
+			}
+			break;
+
+	}
+
+	if (ambiqmicro_info->target_class <
+		(sizeof(ambiqmicroParts)/sizeof(ambiqmicroParts[0])))
+		ambiqmicro_info->target_name =
+			ambiqmicroParts[ambiqmicro_info->target_class].partname;
+	else
+		ambiqmicro_info->target_name =
+			ambiqmicroParts[0].partname;
+
+	LOG_DEBUG("num_pages: %d, pagesize: %d, flash: %d, sram: %d",
+		ambiqmicro_info->num_pages,
+		ambiqmicro_info->pagesize,
+		ambiqmicro_info->flshsiz,
+		ambiqmicro_info->sramsiz);
+
+	return ERROR_OK;
+}
+
+/***************************************************************************
+*	flash operations                                                       *
+***************************************************************************/
+
+static int ambiqmicro_protect_check(struct flash_bank *bank)
+{
+	struct ambiqmicro_flash_bank *ambiqmicro = bank->driver_priv;
+	int status = ERROR_OK;
+	uint32_t i;
+
+
+	if (ambiqmicro->probed == 0) {
+		LOG_ERROR("Target not probed");
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	for (i = 0; i < (unsigned) bank->num_sectors; i++)
+		bank->sectors[i].is_protected = -1;
+
+	return status;
+}
+/** Read flash status from bootloader. */
+static int check_flash_status(struct target *target, uint32_t address)
+{
+	uint32_t retflash;
+	int rc;
+	rc = target_read_u32(target, address, &retflash);
+	/* target connection failed. */
+	if (rc != ERROR_OK) {
+		LOG_DEBUG("%s:%d:%s(): status(0x%x)\n",
+			__FILE__, __LINE__, __func__, rc);
+		return rc;
+	}
+	/* target flash failed, unknown cause. */
+	if (retflash != 0) {
+		LOG_ERROR("Flash not happy: status(0x%x)", retflash);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static int ambiqmicro_exec_command(struct target *target,
+	uint32_t command,
+	uint32_t flash_return_address)
+{
+	int retval, retflash;
+
+	retval = target_resume(
+		target,
+		false,
+		command,
+		true,
+		true);
+
+	CHECK_STATUS(retval, "error executing ambiqmicro command");
+
+	/*
+	 * Wait for halt.
+	 */
+	for (;; ) {
+		target_poll(target);
+		if (target->state == TARGET_HALTED)
+			break;
+		else if (target->state == TARGET_RUNNING ||
+			target->state == TARGET_DEBUG_RUNNING) {
+			/*
+			 * Keep polling until target halts.
+			 */
+			target_poll(target);
+			alive_sleep(100);
+			LOG_DEBUG("state = %d", target->state);
+		} else {
+			LOG_ERROR("Target not halted or running %d", target->state);
+			break;
+		}
+	}
+
+	/*
+	 * Read return value, flash error takes precedence.
+	 */
+	retflash = check_flash_status(target, flash_return_address);
+	if (retflash != ERROR_OK)
+		retval = retflash;
+
+	/* Return code from target_resume OR flash. */
+	return retval;
+}
+
+static int ambiqmicro_mass_erase(struct flash_bank *bank)
+{
+	struct target *target = NULL;
+	struct ambiqmicro_flash_bank *ambiqmicro_info = NULL;
+	int retval = ERROR_OK;
+
+	ambiqmicro_info = bank->driver_priv;
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (ambiqmicro_info->probed == 0) {
+		LOG_ERROR("Target not probed");
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	/*
+	 * Clear Bootloader bit.
+	 */
+	retval = target_write_u32(target, 0x400201a0, 0x0);
+	CHECK_STATUS(retval, "error clearing bootloader bit.");
+
+	/*
+	 * Set up the SRAM.
+	 */
+
+	/*
+	 * Bank.
+	 */
+	retval = target_write_u32(target, 0x10000000, bank->bank_number);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Write Key.
+	 */
+	retval = target_write_u32(target, 0x10000004, PROGRAM_KEY);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Breakpoint.
+	 */
+	retval = target_write_u32(target, 0x10000008, 0xfffffffe);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Erase the main array.
+	 */
+	LOG_INFO("Mass erase on bank %d.", bank->bank_number);
+
+	/*
+	 * passed pc, addr = ROM function, handle breakpoints, not debugging.
+	 */
+	retval = ambiqmicro_exec_command(target, FLASH_MASS_ERASE_MAIN_PAGES_FROM_SRAM, 0x10000008);
+	CHECK_STATUS(retval, "error executing ambiqmicro flash mass erase.");
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * Set Bootloader bit, regardless of command execution.
+	 */
+	retval = target_write_u32(target, 0x400201a0, 0x1);
+	CHECK_STATUS(retval, "error setting bootloader bit.");
+
+	return retval;
+}
+
+
+static int ambiqmicro_erase(struct flash_bank *bank, int first, int last)
+{
+	struct ambiqmicro_flash_bank *ambiqmicro_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t retval = ERROR_OK;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (ambiqmicro_info->probed == 0) {
+		LOG_ERROR("Target not probed");
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	/*
+	 * Check pages.
+	 * Fix num_pages for the device.
+	 */
+	if ((first < 0) || (last < first) || (last >= (int)ambiqmicro_info->num_pages))
+		return ERROR_FLASH_SECTOR_INVALID;
+
+	/*
+	 * Just Mass Erase if all pages are given.
+	 * TODO: Fix num_pages for the device
+	 */
+	if ((first == 0) && (last == ((int)ambiqmicro_info->num_pages-1)))
+		return ambiqmicro_mass_erase(bank);
+
+	/*
+	 * Clear Bootloader bit.
+	 */
+	retval = target_write_u32(target, 0x400201a0, 0x0);
+	CHECK_STATUS(retval, "error clearing bootloader bit.");
+
+	/*
+	 * Set up the SRAM.
+	 */
+
+	/*
+	 * Bank.
+	 */
+	retval = target_write_u32(target, 0x10000000, bank->bank_number);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Number of pages to erase.
+	 */
+	retval = target_write_u32(target, 0x10000004, 1 + (last-first));
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Write Key.
+	 */
+	retval = target_write_u32(target, 0x10000008, PROGRAM_KEY);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Breakpoint.
+	 */
+	retval = target_write_u32(target, 0x1000000c, 0xfffffffe);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+	/*
+	 * Pointer to flash address.
+	 */
+	retval = target_write_u32(target, 0x10000010, first);
+	CHECK_STATUS(retval, "error writing target SRAM parameters.");
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * Erase the pages.
+	 */
+	LOG_INFO("Erasing pages %d to %d on bank %d", first, last, bank->bank_number);
+
+	/*
+	 * passed pc, addr = ROM function, handle breakpoints, not debugging.
+	 */
+	retval = ambiqmicro_exec_command(target, FLASH_ERASE_LIST_MAIN_PAGES_FROM_SRAM, 0x1000000C);
+	CHECK_STATUS(retval, "error executing flash page erase");
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_INFO("%d pages erased!", 1+(last-first));
+
+	if (first == 0) {
+		/*
+		 * Set Bootloader bit.
+		 */
+		retval = target_write_u32(target, 0x400201a0, 0x1);
+		CHECK_STATUS(retval, "error setting bootloader bit.");
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int ambiqmicro_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	/* struct ambiqmicro_flash_bank *ambiqmicro_info = bank->driver_priv;
+	 * struct target *target = bank->target; */
+
+	/*
+	 * TODO
+	 */
+	LOG_INFO("Not yet implemented");
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	return ERROR_OK;
+}
+
+static int ambiqmicro_write_block(struct flash_bank *bank,
+	const uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	/* struct ambiqmicro_flash_bank *ambiqmicro_info = bank->driver_priv; */
+	struct target *target = bank->target;
+	uint32_t address = bank->base + offset;
+	uint32_t buffer_pointer = 0x10000010;
+	uint32_t maxbuffer;
+	uint32_t thisrun_count;
+	int retval = ERROR_OK;
+
+	if (((count%4) != 0) || ((offset%4) != 0)) {
+		LOG_ERROR("write block must be multiple of 4 bytes in offset & length");
+		return ERROR_FAIL;
+	}
+
+	/*
+	 * Max buffer size for this device.
+	 * Hard code 6kB for the buffer.
+	 */
+	maxbuffer = 0x1800;
+
+	LOG_INFO("Flashing main array");
+
+	while (count > 0) {
+		if (count > maxbuffer)
+			thisrun_count = maxbuffer;
+		else
+			thisrun_count = count;
+
+		/*
+		 * Set up the SRAM.
+		 */
+
+		/*
+		 * Pointer to flash.
+		 */
+		retval = target_write_u32(target, 0x10000000, address);
+		CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+		/*
+		 * Number of 32-bit words to program.
+		 */
+		retval = target_write_u32(target, 0x10000004, thisrun_count/4);
+		CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+		/*
+		 * Write Key.
+		 */
+		retval = target_write_u32(target, 0x10000008, PROGRAM_KEY);
+		CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+		/*
+		 * Breakpoint.
+		 */
+		retval = target_write_u32(target, 0x1000000c, 0xfffffffe);
+		CHECK_STATUS(retval, "error writing target SRAM parameters.");
+
+		/*
+		 * Write Buffer.
+		 */
+		retval = target_write_buffer(target, buffer_pointer, thisrun_count, buffer);
+
+		if (retval != ERROR_OK) {
+			CHECK_STATUS(retval, "error writing target SRAM parameters.");
+			break;
+		}
+
+		LOG_DEBUG("address = 0x%08x", address);
+
+		retval = ambiqmicro_exec_command(target, FLASH_PROGRAM_MAIN_FROM_SRAM, 0x1000000c);
+		CHECK_STATUS(retval, "error executing ambiqmicro flash write algorithm");
+		if (retval != ERROR_OK)
+			break;
+		buffer += thisrun_count;
+		address += thisrun_count;
+		count -= thisrun_count;
+	}
+
+
+	LOG_INFO("Main array flashed");
+
+	/*
+	 * Clear Bootloader bit.
+	 */
+	retval = target_write_u32(target, 0x400201a0, 0x0);
+	CHECK_STATUS(retval, "error clearing bootloader bit");
+
+	return retval;
+}
+
+static int ambiqmicro_write(struct flash_bank *bank, const uint8_t *buffer,
+	uint32_t offset, uint32_t count)
+{
+	uint32_t retval;
+
+	/* try using a block write */
+	retval = ambiqmicro_write_block(bank, buffer, offset, count);
+	if (retval != ERROR_OK)
+		LOG_ERROR("write failed");
+
+	return retval;
+}
+
+static int ambiqmicro_probe(struct flash_bank *bank)
+{
+	struct ambiqmicro_flash_bank *ambiqmicro_info = bank->driver_priv;
+	uint32_t retval;
+
+	/* If this is a ambiqmicro chip, it has flash; probe() is just
+	 * to figure out how much is present.  Only do it once.
+	 */
+	if (ambiqmicro_info->probed == 1) {
+		LOG_INFO("Target already probed");
+		return ERROR_OK;
+	}
+
+	/* ambiqmicro_read_part_info() already handled error checking and
+	 * reporting.  Note that it doesn't write, so we don't care about
+	 * whether the target is halted or not.
+	 */
+	retval = ambiqmicro_read_part_info(bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	/* provide this for the benefit of the NOR flash framework */
+	bank->size = ambiqmicro_info->pagesize * ambiqmicro_info->num_pages;
+	bank->num_sectors = ambiqmicro_info->num_pages;
+	bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
+	for (int i = 0; i < bank->num_sectors; i++) {
+		bank->sectors[i].offset = i * ambiqmicro_info->pagesize;
+		bank->sectors[i].size = ambiqmicro_info->pagesize;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
+	}
+
+	/*
+	 * Part has been probed.
+	 */
+	ambiqmicro_info->probed = 1;
+
+	return retval;
+}
+
+static int ambiqmicro_otp_program(struct flash_bank *bank,
+	uint32_t offset, uint32_t count)
+{
+	struct target *target = NULL;
+	struct ambiqmicro_flash_bank *ambiqmicro_info = NULL;
+	uint32_t retval = ERROR_OK;
+
+	ambiqmicro_info = bank->driver_priv;
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (ambiqmicro_info->probed == 0) {
+		LOG_ERROR("Target not probed");
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	if (count > 256) {
+		LOG_ERROR("Count must be < 256");
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	/*
+	 * Clear Bootloader bit.
+	 */
+	retval = target_write_u32(target, 0x400201a0, 0x0);
+	CHECK_STATUS(retval, "error clearing bootloader bit.");
+
+	/*
+	 * Set up the SRAM.
+	 */
+
+	/*
+	 * Bank.
+	 */
+	retval = target_write_u32(target, 0x10000000, offset);
+	CHECK_STATUS(retval, "error setting target SRAM parameters.");
+
+	/*
+	 * Num of words to program.
+	 */
+	retval = target_write_u32(target, 0x10000004, count);
+	CHECK_STATUS(retval, "error setting target SRAM parameters.");
+
+	/*
+	 * Write Key.
+	 */
+	retval = target_write_u32(target, 0x10000008, OTP_PROGRAM_KEY);
+	CHECK_STATUS(retval, "error setting target SRAM parameters.");
+
+	/*
+	 * Breakpoint.
+	 */
+	retval = target_write_u32(target, 0x1000000c, 0xfffffffe);
+	CHECK_STATUS(retval, "error setting target SRAM parameters.");
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * Program OTP.
+	 */
+	LOG_INFO("Programming OTP offset 0x%08x", offset);
+
+	/*
+	 * passed pc, addr = ROM function, handle breakpoints, not debugging.
+	 */
+	retval = ambiqmicro_exec_command(target, FLASH_PROGRAM_OTP_FROM_SRAM, 0x1000000C);
+	CHECK_STATUS(retval, "error executing ambiqmicro otp program algorithm");
+
+	LOG_INFO("Programming OTP finished.");
+
+	return retval;
+}
+
+
+
+COMMAND_HANDLER(ambiqmicro_handle_mass_erase_command)
+{
+	int i;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	uint32_t retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (ambiqmicro_mass_erase(bank) == ERROR_OK) {
+		/* set all sectors as erased */
+		for (i = 0; i < bank->num_sectors; i++)
+			bank->sectors[i].is_erased = 1;
+
+		command_print(CMD_CTX, "ambiqmicro mass erase complete");
+	} else
+		command_print(CMD_CTX, "ambiqmicro mass erase failed");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(ambiqmicro_handle_page_erase_command)
+{
+	struct flash_bank *bank;
+	uint32_t first, last;
+	uint32_t retval;
+
+	if (CMD_ARGC < 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (ambiqmicro_erase(bank, first, last) == ERROR_OK)
+		command_print(CMD_CTX, "ambiqmicro page erase complete");
+	else
+		command_print(CMD_CTX, "ambiqmicro page erase failed");
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Program the otp block.
+ */
+COMMAND_HANDLER(ambiqmicro_handle_program_otp_command)
+{
+	struct flash_bank *bank;
+	uint32_t offset, count;
+	uint32_t retval;
+
+	if (CMD_ARGC < 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], offset);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], count);
+
+	command_print(CMD_CTX, "offset=0x%08x count=%d", offset, count);
+
+	CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+
+	retval = ambiqmicro_otp_program(bank, offset, count);
+
+	if (retval != ERROR_OK)
+		LOG_ERROR("error check log");
+
+	return ERROR_OK;
+}
+
+
+
+static const struct command_registration ambiqmicro_exec_command_handlers[] = {
+	{
+		.name = "mass_erase",
+		.usage = "<bank>",
+		.handler = ambiqmicro_handle_mass_erase_command,
+		.mode = COMMAND_EXEC,
+		.help = "Erase entire device",
+	},
+	{
+		.name = "page_erase",
+		.usage = "<bank> <first> <last>",
+		.handler = ambiqmicro_handle_page_erase_command,
+		.mode = COMMAND_EXEC,
+		.help = "Erase device pages",
+	},
+	{
+		.name = "program_otp",
+		.handler = ambiqmicro_handle_program_otp_command,
+		.mode = COMMAND_EXEC,
+		.usage = "<bank> <offset> <count>",
+		.help =
+			"Program OTP (assumes you have already written array starting at 0x10000010)",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration ambiqmicro_command_handlers[] = {
+	{
+		.name = "ambiqmicro",
+		.mode = COMMAND_EXEC,
+		.help = "ambiqmicro flash command group",
+		.usage = "Support for Ambiq Micro parts.",
+		.chain = ambiqmicro_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver ambiqmicro_flash = {
+	.name = "ambiqmicro",
+	.commands = ambiqmicro_command_handlers,
+	.flash_bank_command = ambiqmicro_flash_bank_command,
+	.erase = ambiqmicro_erase,
+	.protect = ambiqmicro_protect,
+	.write = ambiqmicro_write,
+	.read = default_flash_read,
+	.probe = ambiqmicro_probe,
+	.auto_probe = ambiqmicro_probe,
+	.erase_check = default_flash_blank_check,
+	.protect_check = ambiqmicro_protect_check,
+	.info = get_ambiqmicro_info,
+};
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 9d119bbf..1536378d 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -8,19 +8,17 @@
  *   Copyright (C) 2011 by Olivier Schonken (at91sam3x* support)           *                                          *
  *                     and Jim Norris                                      *
  *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General public License as published by  *
+ *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  *   This program is distributed in the hope that it will be useful,       *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the         *
- *   GNU General public License for more details.                          *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
  *                                                                         *
- *   You should have received a copy of the GNU General public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ****************************************************************************/
 
 /* Some of the the lower level code was based on code supplied by
@@ -2177,7 +2175,7 @@ static int EFC_PerformCommand(struct sam3_bank_private *pPrivate,
 
 	int r;
 	uint32_t v;
-	long long ms_now, ms_end;
+	int64_t ms_now, ms_end;
 
 	/* default */
 	if (status)
@@ -2482,7 +2480,7 @@ static const char *const eproc_names[] = {
 	_unknown,					/* 0 */
 	"arm946es",					/* 1 */
 	"arm7tdmi",					/* 2 */
-	"cortex-m3",				/* 3 */
+	"Cortex-M3",				/* 3 */
 	"arm920t",					/* 4 */
 	"arm926ejs",				/* 5 */
 	_unknown,					/* 6 */
diff --git a/src/flash/nor/at91sam4.c b/src/flash/nor/at91sam4.c
index a8f505c8..9b9cc2b5 100644
--- a/src/flash/nor/at91sam4.c
+++ b/src/flash/nor/at91sam4.c
@@ -9,19 +9,17 @@
  *   (at91sam3x* & at91sam4 support)*                                      *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General public License as published by  *
+ *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  *   This program is distributed in the hope that it will be useful,       *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the         *
- *   GNU General public License for more details.                          *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
  *                                                                         *
- *   You should have received a copy of the GNU General public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ****************************************************************************/
 
 /* Some of the the lower level code was based on code supplied by
@@ -67,8 +65,9 @@
 
 #define REG_NAME_WIDTH  (12)
 
-/* at91sam4s/at91sam4e series (has always one flash bank)*/
+/* at91sam4s/at91sam4e/at91sam4c series (has always one flash bank)*/
 #define FLASH_BANK_BASE_S   0x00400000
+#define FLASH_BANK_BASE_C   0x01000000
 
 /* at91sam4sd series (two one flash banks), first bank address */
 #define FLASH_BANK0_BASE_SD FLASH_BANK_BASE_S
@@ -77,6 +76,10 @@
 /* at91sam4sd32x, second bank address */
 #define FLASH_BANK1_BASE_2048K_SD (FLASH_BANK0_BASE_SD+(2048*1024/2))
 
+/* at91sam4c32x, first and second bank address */
+#define FLASH_BANK0_BASE_C32 FLASH_BANK_BASE_C
+#define FLASH_BANK1_BASE_C32 (FLASH_BANK_BASE_C+(2048*1024/2))
+
 #define         AT91C_EFC_FCMD_GETD                 (0x0)	/* (EFC) Get Flash Descriptor */
 #define         AT91C_EFC_FCMD_WP                   (0x1)	/* (EFC) Write Page */
 #define         AT91C_EFC_FCMD_WPL                  (0x2)	/* (EFC) Write Page and Lock */
@@ -260,6 +263,188 @@ static struct sam4_chip *get_current_sam4(struct command_context *cmd_ctx)
 
 /* these are used to *initialize* the "pChip->details" structure. */
 static const struct sam4_chip_details all_sam4_details[] = {
+	/* Start at91sam4c* series */
+	/* at91sam4c32e - LQFP144 */
+	{
+		.chipid_cidr    = 0xA66D0EE0,
+		.name           = "at91sam4c32e",
+		.total_flash_size     = 2024 * 1024,
+		.total_sram_size      = 256 * 1024,
+		.n_gpnvms       = 3,
+		.n_banks        = 2,
+/*		.bank[0] = { */
+		{
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK0_BASE_C32,
+				.controller_address = 0x400e0a00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  1024 * 1024,
+				.nsectors   =  128,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+/*		.bank[1] = { */
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 1,
+				.base_address = FLASH_BANK1_BASE_C32,
+				.controller_address = 0x400e0c00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  1024 * 1024,
+				.nsectors   =  128,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+		},
+	},
+	/* at91sam4c32c - LQFP100 */
+	{
+		.chipid_cidr    = 0xA64D0EE0,
+		.name           = "at91sam4c32c",
+		.total_flash_size     = 2024 * 1024,
+		.total_sram_size      = 256 * 1024,
+		.n_gpnvms       = 3,
+		.n_banks        = 2,
+/*		.bank[0] = { */
+		{
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK0_BASE_C32,
+				.controller_address = 0x400e0a00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  1024 * 1024,
+				.nsectors   =  128,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+/*		.bank[1] = { */
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 1,
+				.base_address = FLASH_BANK1_BASE_C32,
+				.controller_address = 0x400e0c00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  1024 * 1024,
+				.nsectors   =  128,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+		},
+	},
+	/* at91sam4c16c - LQFP100 */
+	{
+		.chipid_cidr    = 0xA64C0CE0,
+		.name           = "at91sam4c16c",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_C,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/* at91sam4c8c - LQFP100 */
+	{
+		.chipid_cidr    = 0xA64C0AE0,
+		.name           = "at91sam4c8c",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_C,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/* at91sam4c4c (rev B) - LQFP100 */
+	{
+		.chipid_cidr    = 0xA64C0CE5,
+		.name           = "at91sam4c4c",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_C,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
 
 	/* Start at91sam4e* series */
 	/*atsam4e16e - LQFP144/LFBGA144*/
@@ -279,7 +464,308 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+
+	/* Start at91sam4n* series */
+	/*atsam4n8a - LQFP48/QFN48*/
+	{
+		.chipid_cidr    = 0x293B0AE0,
+		.name           = "at91sam4n8a",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 64 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4n8b - LQFP64/QFN64*/
+	{
+		.chipid_cidr    = 0x294B0AE0,
+		.name           = "at91sam4n8b",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 64 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4n8c - LQFP100/TFBGA100/VFBGA100*/
+	{
+		.chipid_cidr    = 0x295B0AE0,
+		.name           = "at91sam4n8c",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 64 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4n16b - LQFP64/QFN64*/
+	{
+		.chipid_cidr    = 0x29460CE0,
+		.name           = "at91sam4n16b",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 80 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4n16c - LQFP100/TFBGA100/VFBGA100*/
+	{
+		.chipid_cidr    = 0x29560CE0,
+		.name           = "at91sam4n16c",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 80 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+
+	/* Start at91sam4s* series */
+	/*atsam4s16c - LQFP100/BGA100*/
+	{
+		.chipid_cidr    = 0x28AC0CE0,
+		.name           = "at91sam4s16c",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4s16b - LQFP64/QFN64/WLCSP64*/
+	{
+		.chipid_cidr    = 0x289C0CE0,
+		.name           = "at91sam4s16b",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4sa16b - LQFP64/QFN64*/
+	{
+		.chipid_cidr    = 0x28970CE0,
+		.name           = "at91sam4sa16b",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 160 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  1024 * 1024,
+			.nsectors   =  128,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	/*atsam4s16a - LQFP48/QFN48*/
+	{
+		.chipid_cidr    = 0x288C0CE0,
+		.name           = "at91sam4s16a",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
 			.present = 1,
 			.size_bytes =  1024 * 1024,
 			.nsectors   =  128,
@@ -295,13 +781,44 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
+	/*atsam4s8c - LQFP100/BGA100*/
+	{
+		.chipid_cidr    = 0x28AC0AE0,
+		.name           = "at91sam4s8c",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 128 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+/*		.bank[0] = {*/
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+			.controller_address = 0x400e0a00,
+			.flash_wait_states = 5,
+			.present = 1,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
+			.sector_size = 8192,
+			.page_size   = 512,
+		  },
+/*		.bank[1] = {*/
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
 
-	/* Start at91sam4s* series */
-	/*atsam4s16c - LQFP100/BGA100*/
+		  },
+		},
+	},
+	/*atsam4s8b - LQFP64/QFN64/WLCSP64*/
 	{
-		.chipid_cidr    = 0x28AC0CE0,
-		.name           = "at91sam4s16c",
-		.total_flash_size     = 1024 * 1024,
+		.chipid_cidr    = 0x289C0AE0,
+		.name           = "at91sam4s8b",
+		.total_flash_size     = 512 * 1024,
 		.total_sram_size      = 128 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
@@ -314,10 +831,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  1024 * 1024,
-			.nsectors   =  128,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -330,11 +847,11 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
-	/*atsam4s16b - LQFP64/QFN64*/
+	/*atsam4s8a - LQFP48/BGA48*/
 	{
-		.chipid_cidr    = 0x289C0CE0,
-		.name           = "at91sam4s16b",
-		.total_flash_size     = 1024 * 1024,
+		.chipid_cidr    = 0x288C0AE0,
+		.name           = "at91sam4s8a",
+		.total_flash_size     = 512 * 1024,
 		.total_sram_size      = 128 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
@@ -347,10 +864,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  1024 * 1024,
-			.nsectors   =  128,
+			.size_bytes =  512 * 1024,
+			.nsectors   =  64,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -363,12 +880,13 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
-	/*atsam4sa16b - LQFP64/QFN64*/
+
+	/*atsam4s4c - LQFP100/BGA100*/
 	{
-		.chipid_cidr    = 0x28970CE0,
-		.name           = "at91sam4sa16b",
-		.total_flash_size     = 1024 * 1024,
-		.total_sram_size      = 160 * 1024,
+		.chipid_cidr    = 0x28ab09e0,
+		.name           = "at91sam4s4c",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 64 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
 		{
@@ -380,10 +898,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  1024 * 1024,
-			.nsectors   =  128,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -396,12 +914,13 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
-	/*atsam4s16a - LQFP48/QFN48*/
+
+	/*atsam4s4b - LQFP64/QFN64/WLCSP64*/
 	{
-		.chipid_cidr    = 0x288C0CE0,
-		.name           = "at91sam4s16a",
-		.total_flash_size     = 1024 * 1024,
-		.total_sram_size      = 128 * 1024,
+		.chipid_cidr    = 0x289b09e0,
+		.name           = "at91sam4s4b",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 64 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
 		{
@@ -413,10 +932,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  1024 * 1024,
-			.nsectors   =  128,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -429,12 +948,13 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
-	/*atsam4s8c - LQFP100/BGA100*/
+
+	/*atsam4s4a - LQFP48/QFN48*/
 	{
-		.chipid_cidr    = 0x28AC0AE0,
-		.name           = "at91sam4s8c",
-		.total_flash_size     = 512 * 1024,
-		.total_sram_size      = 128 * 1024,
+		.chipid_cidr    = 0x288b09e0,
+		.name           = "at91sam4s4a",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 64 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
 		{
@@ -446,10 +966,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  512 * 1024,
-			.nsectors   =  64,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -462,12 +982,13 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
-	/*atsam4s8b - LQFP64/BGA64*/
+
+	/*atsam4s2c - LQFP100/BGA100*/
 	{
-		.chipid_cidr    = 0x289C0AE0,
-		.name           = "at91sam4s8b",
-		.total_flash_size     = 512 * 1024,
-		.total_sram_size      = 128 * 1024,
+		.chipid_cidr    = 0x28ab07e0,
+		.name           = "at91sam4s2c",
+		.total_flash_size     = 128 * 1024,
+		.total_sram_size      = 64 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
 		{
@@ -479,10 +1000,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  512 * 1024,
-			.nsectors   =  64,
+			.size_bytes =  128 * 1024,
+			.nsectors   =  16,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -495,12 +1016,13 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		  },
 		},
 	},
-	/*atsam4s8a - LQFP48/BGA48*/
+
+	/*atsam4s2b - LQPF64/QFN64/WLCSP64*/
 	{
-		.chipid_cidr    = 0x288C0AE0,
-		.name           = "at91sam4s8a",
-		.total_flash_size     = 512 * 1024,
-		.total_sram_size      = 128 * 1024,
+		.chipid_cidr    = 0x289b07e0,
+		.name           = "at91sam4s2b",
+		.total_flash_size     = 128 * 1024,
+		.total_sram_size      = 64 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
 		{
@@ -512,10 +1034,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  512 * 1024,
-			.nsectors   =  64,
+			.size_bytes =  128 * 1024,
+			.nsectors   =  16,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -529,11 +1051,11 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		},
 	},
 
-	/*atsam4s4a - LQFP48/BGA48*/
+	/*atsam4s2a - LQFP48/QFN48*/
 	{
-		.chipid_cidr    = 0x288b09e0,
-		.name           = "at91sam4s4a",
-		.total_flash_size     = 256 * 1024,
+		.chipid_cidr    = 0x288b07e0,
+		.name           = "at91sam4s2a",
+		.total_flash_size     = 128 * 1024,
 		.total_sram_size      = 64 * 1024,
 		.n_gpnvms       = 2,
 		.n_banks        = 1,
@@ -546,10 +1068,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 			.bank_number = 0,
 			.base_address = FLASH_BANK_BASE_S,
 			.controller_address = 0x400e0a00,
-			.flash_wait_states = 6,	/* workaround silicon bug */
+			.flash_wait_states = 5,
 			.present = 1,
-			.size_bytes =  256 * 1024,
-			.nsectors   =  32,
+			.size_bytes =  128 * 1024,
+			.nsectors   =  16,
 			.sector_size = 8192,
 			.page_size   = 512,
 		  },
@@ -563,7 +1085,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		},
 	},
 
-	/*at91sam4sd32c*/
+	/*at91sam4sd32c  - LQFP100/BGA100*/
 	{
 		.chipid_cidr    = 0x29a70ee0,
 		.name           = "at91sam4sd32c",
@@ -581,7 +1103,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 0,
 				.base_address = FLASH_BANK0_BASE_SD,
 				.controller_address = 0x400e0a00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  1024 * 1024,
 				.nsectors   =  128,
@@ -597,7 +1119,51 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 1,
 				.base_address = FLASH_BANK1_BASE_2048K_SD,
 				.controller_address = 0x400e0c00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  1024 * 1024,
+				.nsectors   =  128,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+		},
+	},
+
+	/*at91sam4sd32b  - LQFP64/BGA64*/
+	{
+		.chipid_cidr    = 0x29970ee0,
+		.name           = "at91sam4sd32b",
+		.total_flash_size     = 2048 * 1024,
+		.total_sram_size      = 160 * 1024,
+		.n_gpnvms       = 3,
+		.n_banks        = 2,
+
+/*		.bank[0] = { */
+		{
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK0_BASE_SD,
+				.controller_address = 0x400e0a00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  1024 * 1024,
+				.nsectors   =  128,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+
+/*		.bank[1] = { */
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 1,
+				.base_address = FLASH_BANK1_BASE_2048K_SD,
+				.controller_address = 0x400e0c00,
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  1024 * 1024,
 				.nsectors   =  128,
@@ -607,7 +1173,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		},
 	},
 
-	/*at91sam4sd16c*/
+	/*at91sam4sd16c - LQFP100/BGA100*/
 	{
 		.chipid_cidr    = 0x29a70ce0,
 		.name           = "at91sam4sd16c",
@@ -625,7 +1191,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 0,
 				.base_address = FLASH_BANK0_BASE_SD,
 				.controller_address = 0x400e0a00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  512 * 1024,
 				.nsectors   =  64,
@@ -641,7 +1207,51 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 1,
 				.base_address = FLASH_BANK1_BASE_1024K_SD,
 				.controller_address = 0x400e0c00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  512 * 1024,
+				.nsectors   =  64,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+		},
+	},
+
+	/*at91sam4sd16b - LQFP64/BGA64*/
+	{
+		.chipid_cidr    = 0x29970ce0,
+		.name           = "at91sam4sd16b",
+		.total_flash_size     = 1024 * 1024,
+		.total_sram_size      = 160 * 1024,
+		.n_gpnvms       = 3,
+		.n_banks        = 2,
+
+/*		.bank[0] = { */
+		{
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK0_BASE_SD,
+				.controller_address = 0x400e0a00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  512 * 1024,
+				.nsectors   =  64,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+
+/*		.bank[1] = { */
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 1,
+				.base_address = FLASH_BANK1_BASE_1024K_SD,
+				.controller_address = 0x400e0c00,
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  512 * 1024,
 				.nsectors   =  64,
@@ -669,7 +1279,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 0,
 				.base_address = FLASH_BANK0_BASE_SD,
 				.controller_address = 0x400e0a00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  512 * 1024,
 				.nsectors   =  64,
@@ -685,7 +1295,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 1,
 				.base_address = FLASH_BANK1_BASE_1024K_SD,
 				.controller_address = 0x400e0c00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  512 * 1024,
 				.nsectors   =  64,
@@ -739,10 +1349,10 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		},
 	},
 
-	/* at91samg53n19 */
+	/* atsamg53n19 */
 	{
 		.chipid_cidr    = 0x247e0ae0,
-		.name           = "at91samg53n19",
+		.name           = "atsamg53n19",
 		.total_flash_size     = 512 * 1024,
 		.total_sram_size      = 96 * 1024,
 		.n_gpnvms       = 2,
@@ -757,7 +1367,7 @@ static const struct sam4_chip_details all_sam4_details[] = {
 				.bank_number = 0,
 				.base_address = FLASH_BANK_BASE_S,
 				.controller_address = 0x400e0a00,
-				.flash_wait_states = 6,	/* workaround silicon bug */
+				.flash_wait_states = 5,
 				.present = 1,
 				.size_bytes =  512 * 1024,
 				.nsectors   =  64,
@@ -774,6 +1384,74 @@ static const struct sam4_chip_details all_sam4_details[] = {
 		}
 	},
 
+	/* atsamg55g19 */
+	{
+		.chipid_cidr    = 0x24470ae0,
+		.name           = "atsamg55g19",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 160 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+
+		{
+/*			.bank[0] = */
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK_BASE_S,
+				.controller_address = 0x400e0a00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  512 * 1024,
+				.nsectors   =  64,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+/*			.bank[1] = */
+			{
+				.present = 0,
+				.probed = 0,
+				.bank_number = 1,
+			},
+		}
+	},
+
+	/* atsamg55j19 */
+	{
+		.chipid_cidr    = 0x24570ae0,
+		.name           = "atsamg55j19",
+		.total_flash_size     = 512 * 1024,
+		.total_sram_size      = 160 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+
+		{
+/*			.bank[0] = */
+			{
+				.probed = 0,
+				.pChip  = NULL,
+				.pBank  = NULL,
+				.bank_number = 0,
+				.base_address = FLASH_BANK_BASE_S,
+				.controller_address = 0x400e0a00,
+				.flash_wait_states = 5,
+				.present = 1,
+				.size_bytes =  512 * 1024,
+				.nsectors   =  64,
+				.sector_size = 8192,
+				.page_size   = 512,
+			},
+/*			.bank[1] = */
+			{
+				.present = 0,
+				.probed = 0,
+				.bank_number = 1,
+			},
+		}
+	},
+
 	/* terminate */
 	{
 		.chipid_cidr    = 0,
@@ -932,7 +1610,7 @@ static int EFC_PerformCommand(struct sam4_bank_private *pPrivate,
 
 	int r;
 	uint32_t v;
-	long long ms_now, ms_end;
+	int64_t ms_now, ms_end;
 
 	/* default */
 	if (status)
@@ -1281,14 +1959,14 @@ static uint32_t sam4_reg_fieldname(struct sam4_chip *pChip,
 
 static const char _unknown[] = "unknown";
 static const char *const eproc_names[] = {
-	_unknown,					/* 0 */
+	"Cortex-M7",				/* 0 */
 	"arm946es",					/* 1 */
 	"arm7tdmi",					/* 2 */
-	"cortex-m3",				/* 3 */
+	"Cortex-M3",				/* 3 */
 	"arm920t",					/* 4 */
 	"arm926ejs",				/* 5 */
-	"cortex-a5",				/* 6 */
-	"cortex-m4",				/* 7 */
+	"Cortex-A5",				/* 6 */
+	"Cortex-M4",				/* 7 */
 	_unknown,					/* 8 */
 	_unknown,					/* 9 */
 	_unknown,					/* 10 */
@@ -1309,7 +1987,7 @@ static const char *const nvpsize[] = {
 	"64K bytes",				/*  5 */
 	_unknown,					/*  6 */
 	"128K bytes",				/*  7 */
-	_unknown,					/*  8 */
+	"160K bytes",				/*  8 */
 	"256K bytes",				/*  9 */
 	"512K bytes",				/* 10 */
 	_unknown,					/* 11 */
@@ -1351,12 +2029,16 @@ static const struct archnames { unsigned value; const char *name; } archnames[]
 	{ 0x42,  "AT91x42 Series"                                                       },
 	{ 0x43,  "SAMG51 Series"
 	},
+	{ 0x44,  "SAMG55 Series (49-pin WLCSP)"                                         },
+	{ 0x45,  "SAMG55 Series (64-pin)"                                                        },
 	{ 0x47,  "SAMG53 Series"
 	},
 	{ 0x55,  "AT91x55 Series"                                                       },
 	{ 0x60,  "AT91SAM7Axx Series"                                           },
 	{ 0x61,  "AT91SAM7AQxx Series"                                          },
 	{ 0x63,  "AT91x63 Series"                                                       },
+	{ 0x64,  "SAM4CxxC (100-pin version)"                                           },
+	{ 0x66,  "SAM4CxxE (144-pin version)"                                           },
 	{ 0x70,  "AT91SAM7Sxx Series"                                           },
 	{ 0x71,  "AT91SAM7XCxx Series"                                          },
 	{ 0x72,  "AT91SAM7SExx Series"                                          },
@@ -1854,15 +2536,17 @@ FLASH_BANK_COMMAND_HANDLER(sam4_flash_bank_command)
 		/* at91sam4s series only has bank 0*/
 		/* at91sam4sd series has the same address for bank 0 (FLASH_BANK0_BASE_SD)*/
 		case FLASH_BANK_BASE_S:
+		case FLASH_BANK_BASE_C:
 			bank->driver_priv = &(pChip->details.bank[0]);
 			bank->bank_number = 0;
 			pChip->details.bank[0].pChip = pChip;
 			pChip->details.bank[0].pBank = bank;
 			break;
 
-		/* Bank 1 of at91sam4sd series */
+		/* Bank 1 of at91sam4sd/at91sam4c32 series */
 		case FLASH_BANK1_BASE_1024K_SD:
 		case FLASH_BANK1_BASE_2048K_SD:
+		case FLASH_BANK1_BASE_C32:
 			bank->driver_priv = &(pChip->details.bank[1]);
 			bank->bank_number = 1;
 			pChip->details.bank[1].pChip = pChip;
diff --git a/src/flash/nor/at91sam4l.c b/src/flash/nor/at91sam4l.c
index fa7cff38..0a605d5d 100644
--- a/src/flash/nor/at91sam4l.c
+++ b/src/flash/nor/at91sam4l.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -647,10 +645,15 @@ static int sam4l_write(struct flash_bank *bank, const uint8_t *buffer,
 COMMAND_HANDLER(sam4l_handle_reset_deassert)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
 	int retval = ERROR_OK;
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 
+	/* If the target has been unresponsive before, try to re-establish
+	 * communication now - CPU is held in reset by DSU, DAP is working */
+	if (!target_was_examined(target))
+		target_examine_one(target);
+	target_poll(target);
+
 	/* In case of sysresetreq, debug retains state set in cortex_m_assert_reset()
 	 * so we just release reset held by SMAP
 	 *
@@ -659,14 +662,14 @@ COMMAND_HANDLER(sam4l_handle_reset_deassert)
 	 * After vectreset SMAP release is not needed however makes no harm
 	 */
 	if (target->reset_halt && (jtag_reset_config & RESET_HAS_SRST)) {
-		retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
+		retval = target_write_u32(target, DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
 		if (retval == ERROR_OK)
-			retval = mem_ap_write_atomic_u32(armv7m->debug_ap, DCB_DEMCR,
+			retval = target_write_u32(target, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 		/* do not return on error here, releasing SMAP reset is more important */
 	}
 
-	int retval2 = mem_ap_write_atomic_u32(armv7m->debug_ap, SMAP_SCR, SMAP_SCR_HCR);
+	int retval2 = target_write_u32(target, SMAP_SCR, SMAP_SCR_HCR);
 	if (retval2 != ERROR_OK)
 		return retval2;
 
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index c7334ca5..03f771c8 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -5,19 +5,17 @@
  *   Copyright (C) 2008 by Gheorghe Guran (atlas)                          *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General public License as published by  *
+ *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  *   This program is distributed in the hope that it will be useful,       *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the         *
- *   GNU General public License for more details.                          *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
  *                                                                         *
- *   You should have received a copy of the GNU General public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ****************************************************************************/
 
 /***************************************************************************
@@ -373,10 +371,9 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 
 	if (at91sam7_info->cidr != 0) {
 		/* flash already configured, update clock and check for protected sectors */
-		struct flash_bank *fb = bank;
-		struct flash_bank *t_bank = bank;
-
-		while (t_bank) {
+		for (struct flash_bank *t_bank = bank; t_bank; t_bank = t_bank->next) {
+			if (t_bank->target != target)
+				continue;
 			/* re-calculate master clock frequency */
 			at91sam7_read_clock_info(t_bank);
 
@@ -385,9 +382,6 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 
 			/* check protect state */
 			at91sam7_protect_check(t_bank);
-
-			t_bank = fb->next;
-			fb = t_bank;
 		}
 
 		return ERROR_OK;
@@ -402,9 +396,10 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 
 	if (at91sam7_info->flash_autodetection == 0) {
 		/* banks and sectors are already created, based on data from input file */
-		struct flash_bank *fb = bank;
-		struct flash_bank *t_bank = bank;
-		while (t_bank) {
+		for (struct flash_bank *t_bank = bank; t_bank; t_bank = t_bank->next) {
+			if (t_bank->target != target)
+				continue;
+
 			at91sam7_info = t_bank->driver_priv;
 
 			at91sam7_info->cidr = cidr;
@@ -425,9 +420,6 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 
 			/* check protect state */
 			at91sam7_protect_check(t_bank);
-
-			t_bank = fb->next;
-			fb = t_bank;
 		}
 
 		return ERROR_OK;
@@ -669,7 +661,7 @@ static int at91sam7_erase_check(struct flash_bank *bank)
 		retval = target_blank_check_memory(target,
 				bank->base + bank->sectors[nSector].offset,
 				bank->sectors[nSector].size,
-				&blank);
+				&blank, bank->erased_value);
 		if (retval != ERROR_OK) {
 			fast_check = 0;
 			break;
diff --git a/src/flash/nor/at91samd.c b/src/flash/nor/at91samd.c
index dbfc381b..ce249edd 100644
--- a/src/flash/nor/at91samd.c
+++ b/src/flash/nor/at91samd.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -27,7 +25,7 @@
 
 #include <target/cortex_m.h>
 
-#define SAMD_NUM_SECTORS	16
+#define SAMD_NUM_PROT_BLOCKS	16
 #define SAMD_PAGE_SIZE_MAX	1024
 
 #define SAMD_FLASH			((uint32_t)0x00000000)	/* physical Flash memory */
@@ -38,6 +36,7 @@
 
 #define SAMD_DSU_STATUSA        1               /* DSU status register */
 #define SAMD_DSU_DID		0x18		/* Device ID register */
+#define SAMD_DSU_CTRL_EXT	0x100		/* CTRL register, external access */
 
 #define SAMD_NVMCTRL_CTRLA		0x00	/* NVM control A register */
 #define SAMD_NVMCTRL_CTRLB		0x04	/* NVM control B register */
@@ -73,8 +72,10 @@
 #define SAMD_FAMILY_C		0x02
 #define SAMD_SERIES_20		0x00
 #define SAMD_SERIES_21		0x01
+#define SAMD_SERIES_22		0x02
 #define SAMD_SERIES_10		0x02
 #define SAMD_SERIES_11		0x03
+#define SAMD_SERIES_09		0x04
 
 /* Device ID macros */
 #define SAMD_GET_PROCESSOR(id) (id >> 28)
@@ -89,6 +90,13 @@ struct samd_part {
 	uint32_t ram_kb;
 };
 
+/* Known SAMD09 parts. DID reset values missing in RM, see
+ * https://github.com/avrxml/asf/blob/master/sam0/utils/cmsis/samd09/include/ */
+static const struct samd_part samd09_parts[] = {
+	{ 0x0, "SAMD09D14A", 16, 4 },
+	{ 0x7, "SAMD09C13A", 8, 4 },
+};
+
 /* Known SAMD10 parts */
 static const struct samd_part samd10_parts[] = {
 	{ 0x0, "SAMD10D14AMU", 16, 4 },
@@ -151,6 +159,13 @@ static const struct samd_part samd21_parts[] = {
 	{ 0xC, "SAMD21E16A", 64, 8 },
 	{ 0xD, "SAMD21E15A", 32, 4 },
 	{ 0xE, "SAMD21E14A", 16, 2 },
+    /* Below are B Variants (Table 3-7 from rev I of datasheet) */
+	{ 0x20, "SAMD21J16B", 64, 8 },
+	{ 0x21, "SAMD21J15B", 32, 4 },
+	{ 0x23, "SAMD21G16B", 64, 8 },
+	{ 0x24, "SAMD21G15B", 32, 4 },
+	{ 0x26, "SAMD21E16B", 64, 8 },
+	{ 0x27, "SAMD21E15B", 32, 4 },
 };
 
 /* Known SAMR21 parts. */
@@ -187,6 +202,19 @@ static const struct samd_part saml21_parts[] = {
 	{ 0x1C, "SAML21E15B", 32, 4 },
 };
 
+/* Known SAML22 parts. */
+static const struct samd_part saml22_parts[] = {
+	{ 0x00, "SAML22N18A", 256, 32 },
+	{ 0x01, "SAML22N17A", 128, 16 },
+	{ 0x02, "SAML22N16A", 64, 8 },
+	{ 0x05, "SAML22J18A", 256, 32 },
+	{ 0x06, "SAML22J17A", 128, 16 },
+	{ 0x07, "SAML22J16A", 64, 8 },
+	{ 0x0A, "SAML22G18A", 256, 32 },
+	{ 0x0B, "SAML22G17A", 128, 16 },
+	{ 0x0C, "SAML22G16A", 64, 8 },
+};
+
 /* Known SAMC20 parts. */
 static const struct samd_part samc20_parts[] = {
 	{ 0x00, "SAMC20J18A", 256, 32 },
@@ -238,12 +266,16 @@ static const struct samd_family samd_families[] = {
 		samd21_parts, ARRAY_SIZE(samd21_parts) },
 	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_D, SAMD_SERIES_21,
 		samr21_parts, ARRAY_SIZE(samr21_parts) },
+	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_D, SAMD_SERIES_09,
+		samd09_parts, ARRAY_SIZE(samd09_parts) },
 	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_D, SAMD_SERIES_10,
 		samd10_parts, ARRAY_SIZE(samd10_parts) },
 	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_D, SAMD_SERIES_11,
 		samd11_parts, ARRAY_SIZE(samd11_parts) },
 	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_L, SAMD_SERIES_21,
 		saml21_parts, ARRAY_SIZE(saml21_parts) },
+	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_L, SAMD_SERIES_22,
+		saml22_parts, ARRAY_SIZE(saml22_parts) },
 	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_C, SAMD_SERIES_20,
 		samc20_parts, ARRAY_SIZE(samc20_parts) },
 	{ SAMD_PROCESSOR_M0, SAMD_FAMILY_C, SAMD_SERIES_21,
@@ -254,6 +286,7 @@ struct samd_info {
 	uint32_t page_size;
 	int num_pages;
 	int sector_size;
+	int prot_block_size;
 
 	bool probed;
 	struct target *target;
@@ -287,7 +320,7 @@ static const struct samd_part *samd_find_part(uint32_t id)
 
 static int samd_protect_check(struct flash_bank *bank)
 {
-	int res;
+	int res, prot_block;
 	uint16_t lock;
 
 	res = target_read_u16(bank->target,
@@ -296,8 +329,8 @@ static int samd_protect_check(struct flash_bank *bank)
 		return res;
 
 	/* Lock bits are active-low */
-	for (int i = 0; i < bank->num_sectors; i++)
-		bank->sectors[i].is_protected = !(lock & (1<<i));
+	for (prot_block = 0; prot_block < bank->num_prot_blocks; prot_block++)
+		bank->prot_blocks[prot_block].is_protected = !(lock & (1u<<prot_block));
 
 	return ERROR_OK;
 }
@@ -342,14 +375,12 @@ static int samd_probe(struct flash_bank *bank)
 
 	part = samd_find_part(id);
 	if (part == NULL) {
-		LOG_ERROR("Couldn't find part correspoding to DID %08" PRIx32, id);
+		LOG_ERROR("Couldn't find part corresponding to DID %08" PRIx32, id);
 		return ERROR_FAIL;
 	}
 
 	bank->size = part->flash_kb * 1024;
 
-	chip->sector_size = bank->size / SAMD_NUM_SECTORS;
-
 	res = samd_get_flash_page_info(bank->target, &chip->page_size,
 			&chip->num_pages);
 	if (res != ERROR_OK) {
@@ -365,21 +396,23 @@ static int samd_probe(struct flash_bank *bank)
 				part->flash_kb, chip->num_pages, chip->page_size);
 	}
 
+	/* Erase granularity = 1 row = 4 pages */
+	chip->sector_size = chip->page_size * 4;
+
 	/* Allocate the sector table */
-	bank->num_sectors = SAMD_NUM_SECTORS;
-	bank->sectors = calloc(bank->num_sectors, sizeof((bank->sectors)[0]));
+	bank->num_sectors = chip->num_pages / 4;
+	bank->sectors = alloc_block_array(0, chip->sector_size, bank->num_sectors);
 	if (!bank->sectors)
 		return ERROR_FAIL;
 
-	/* Fill out the sector information: all SAMD sectors are the same size and
-	 * there is always a fixed number of them. */
-	for (int i = 0; i < bank->num_sectors; i++) {
-		bank->sectors[i].size = chip->sector_size;
-		bank->sectors[i].offset = i * chip->sector_size;
-		/* mark as unknown */
-		bank->sectors[i].is_erased = -1;
-		bank->sectors[i].is_protected = -1;
-	}
+	/* 16 protection blocks per device */
+	chip->prot_block_size = bank->size / SAMD_NUM_PROT_BLOCKS;
+
+	/* Allocate the table of protection blocks */
+	bank->num_prot_blocks = SAMD_NUM_PROT_BLOCKS;
+	bank->prot_blocks = alloc_block_array(0, chip->prot_block_size, bank->num_prot_blocks);
+	if (!bank->prot_blocks)
+		return ERROR_FAIL;
 
 	samd_protect_check(bank);
 
@@ -392,39 +425,43 @@ static int samd_probe(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-static bool samd_check_error(struct target *target)
+static int samd_check_error(struct target *target)
 {
-	int ret;
-	bool error;
+	int ret, ret2;
 	uint16_t status;
 
 	ret = target_read_u16(target,
 			SAMD_NVMCTRL + SAMD_NVMCTRL_STATUS, &status);
 	if (ret != ERROR_OK) {
 		LOG_ERROR("Can't read NVM status");
-		return true;
+		return ret;
 	}
 
-	if (status & 0x001C) {
-		if (status & (1 << 4)) /* NVME */
-			LOG_ERROR("SAMD: NVM Error");
-		if (status & (1 << 3)) /* LOCKE */
-			LOG_ERROR("SAMD: NVM lock error");
-		if (status & (1 << 2)) /* PROGE */
-			LOG_ERROR("SAMD: NVM programming error");
+	if ((status & 0x001C) == 0)
+		return ERROR_OK;
 
-		error = true;
-	} else {
-		error = false;
+	if (status & (1 << 4)) { /* NVME */
+		LOG_ERROR("SAMD: NVM Error");
+		ret = ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	if (status & (1 << 3)) { /* LOCKE */
+		LOG_ERROR("SAMD: NVM lock error");
+		ret = ERROR_FLASH_PROTECTED;
+	}
+
+	if (status & (1 << 2)) { /* PROGE */
+		LOG_ERROR("SAMD: NVM programming error");
+		ret = ERROR_FLASH_OPER_UNSUPPORTED;
 	}
 
 	/* Clear the error conditions by writing a one to them */
-	ret = target_write_u16(target,
+	ret2 = target_write_u16(target,
 			SAMD_NVMCTRL + SAMD_NVMCTRL_STATUS, status);
-	if (ret != ERROR_OK)
+	if (ret2 != ERROR_OK)
 		LOG_ERROR("Can't clear NVM error conditions");
 
-	return error;
+	return ret;
 }
 
 static int samd_issue_nvmctrl_command(struct target *target, uint16_t cmd)
@@ -443,10 +480,7 @@ static int samd_issue_nvmctrl_command(struct target *target, uint16_t cmd)
 		return res;
 
 	/* Check to see if the NVM command resulted in an error condition. */
-	if (samd_check_error(target))
-		return ERROR_FAIL;
-
-	return ERROR_OK;
+	return samd_check_error(target);
 }
 
 static int samd_erase_row(struct target *target, uint32_t address)
@@ -500,12 +534,19 @@ static int samd_modify_user_row(struct target *target, uint32_t value,
 		uint8_t startb, uint8_t endb)
 {
 	int res;
+	uint32_t nvm_ctrlb;
+	bool manual_wp = true;
 
 	if (is_user_row_reserved_bit(startb) || is_user_row_reserved_bit(endb)) {
 		LOG_ERROR("Can't modify bits in the requested range");
 		return ERROR_FAIL;
 	}
 
+	/* Check if we need to do manual page write commands */
+	res = target_read_u32(target, SAMD_NVMCTRL + SAMD_NVMCTRL_CTRLB, &nvm_ctrlb);
+	if (res == ERROR_OK)
+		manual_wp = (nvm_ctrlb & SAMD_NVM_CTRLB_MANW) != 0;
+
 	/* Retrieve the MCU's page size, in bytes. This is also the size of the
 	 * entire User Row. */
 	uint32_t page_size;
@@ -528,8 +569,8 @@ static int samd_modify_user_row(struct target *target, uint32_t value,
 	if (!buf)
 		return ERROR_FAIL;
 
-	/* Read the user row (comprising one page) by half-words. */
-	res = target_read_memory(target, SAMD_USER_ROW, 2, page_size / 2, buf);
+	/* Read the user row (comprising one page) by words. */
+	res = target_read_memory(target, SAMD_USER_ROW, 4, page_size / 4, buf);
 	if (res != ERROR_OK)
 		goto out_user_row;
 
@@ -548,29 +589,28 @@ static int samd_modify_user_row(struct target *target, uint32_t value,
 	/* Modify */
 	buf_set_u32(buf, startb, endb - startb + 1, value);
 
-	/* Write the page buffer back out to the target.  A Flash write will be
-	 * triggered automatically. */
+	/* Write the page buffer back out to the target. */
 	res = target_write_memory(target, SAMD_USER_ROW, 4, page_size / 4, buf);
 	if (res != ERROR_OK)
 		goto out_user_row;
 
-	if (samd_check_error(target)) {
-		res = ERROR_FAIL;
-		goto out_user_row;
+	if (manual_wp) {
+		/* Trigger flash write */
+		res = samd_issue_nvmctrl_command(target, SAMD_NVM_CMD_WAP);
+	} else {
+		res = samd_check_error(target);
 	}
 
-	/* Success */
-	res = ERROR_OK;
-
 out_user_row:
 	free(buf);
 
 	return res;
 }
 
-static int samd_protect(struct flash_bank *bank, int set, int first, int last)
+static int samd_protect(struct flash_bank *bank, int set, int first_prot_bl, int last_prot_bl)
 {
-	struct samd_info *chip = (struct samd_info *)bank->driver_priv;
+	int res = ERROR_OK;
+	int prot_block;
 
 	/* We can issue lock/unlock region commands with the target running but
 	 * the settings won't persist unless we're able to modify the LOCK regions
@@ -580,18 +620,16 @@ static int samd_protect(struct flash_bank *bank, int set, int first, int last)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	int res = ERROR_OK;
-
-	for (int s = first; s <= last; s++) {
-		if (set != bank->sectors[s].is_protected) {
-			/* Load an address that is within this sector (we use offset 0) */
+	for (prot_block = first_prot_bl; prot_block <= last_prot_bl; prot_block++) {
+		if (set != bank->prot_blocks[prot_block].is_protected) {
+			/* Load an address that is within this protection block (we use offset 0) */
 			res = target_write_u32(bank->target,
 							SAMD_NVMCTRL + SAMD_NVMCTRL_ADDR,
-							((s * chip->sector_size) >> 1));
+							bank->prot_blocks[prot_block].offset >> 1);
 			if (res != ERROR_OK)
 				goto exit;
 
-			/* Tell the controller to lock that sector */
+			/* Tell the controller to lock that block */
 			res = samd_issue_nvmctrl_command(bank->target,
 					set ? SAMD_NVM_CMD_LR : SAMD_NVM_CMD_UR);
 			if (res != ERROR_OK)
@@ -601,12 +639,12 @@ static int samd_protect(struct flash_bank *bank, int set, int first, int last)
 
 	/* We've now applied our changes, however they will be undone by the next
 	 * reset unless we also apply them to the LOCK bits in the User Page.  The
-	 * LOCK bits start at bit 48, correspoding to Sector 0 and end with bit 63,
+	 * LOCK bits start at bit 48, corresponding to Sector 0 and end with bit 63,
 	 * corresponding to Sector 15.  A '1' means unlocked and a '0' means
 	 * locked.  See Table 9-3 in the SAMD20 datasheet for more details. */
 
 	res = samd_modify_user_row(bank->target, set ? 0x0000 : 0xFFFF,
-			48 + first, 48 + last);
+			48 + first_prot_bl, 48 + last_prot_bl);
 	if (res != ERROR_OK)
 		LOG_WARNING("SAMD: protect settings were not made persistent!");
 
@@ -618,10 +656,9 @@ exit:
 	return res;
 }
 
-static int samd_erase(struct flash_bank *bank, int first, int last)
+static int samd_erase(struct flash_bank *bank, int first_sect, int last_sect)
 {
-	int res;
-	int rows_in_sector;
+	int res, s;
 	struct samd_info *chip = (struct samd_info *)bank->driver_priv;
 
 	if (bank->target->state != TARGET_HALTED) {
@@ -635,26 +672,12 @@ static int samd_erase(struct flash_bank *bank, int first, int last)
 			return ERROR_FLASH_BANK_NOT_PROBED;
 	}
 
-	/* The SAMD NVM has row erase granularity.  There are four pages in a row
-	 * and the number of rows in a sector depends on the sector size, which in
-	 * turn depends on the Flash capacity as there is a fixed number of
-	 * sectors. */
-	rows_in_sector = chip->sector_size / (chip->page_size * 4);
-
 	/* For each sector to be erased */
-	for (int s = first; s <= last; s++) {
-		if (bank->sectors[s].is_protected) {
-			LOG_ERROR("SAMD: failed to erase sector %d. That sector is write-protected", s);
-			return ERROR_FLASH_OPERATION_FAILED;
-		}
-
-		/* For each row in that sector */
-		for (int r = s * rows_in_sector; r < (s + 1) * rows_in_sector; r++) {
-			res = samd_erase_row(bank->target, r * chip->page_size * 4);
-			if (res != ERROR_OK) {
-				LOG_ERROR("SAMD: failed to erase sector %d", s);
-				return res;
-			}
+	for (s = first_sect; s <= last_sect; s++) {
+		res = samd_erase_row(bank->target, bank->sectors[s].offset);
+		if (res != ERROR_OK) {
+			LOG_ERROR("SAMD: failed to erase sector %d at 0x%08" PRIx32, s, bank->sectors[s].offset);
+			return res;
 		}
 	}
 
@@ -753,18 +776,15 @@ static int samd_write(struct flash_bank *bank, const uint8_t *buffer,
 		 * then issue CMD_WP always */
 		if (manual_wp || pg_offset + 4 * nw < chip->page_size) {
 			res = samd_issue_nvmctrl_command(bank->target, SAMD_NVM_CMD_WP);
-			if (res != ERROR_OK) {
-				LOG_ERROR("%s: %d", __func__, __LINE__);
-				goto free_pb;
-			}
-		}
+		} else {
+			/* Access through AHB is stalled while flash is being programmed */
+			openocd_usleep(200);
 
-		/* Access through AHB is stalled while flash is being programmed */
-		openocd_usleep(200);
+			res = samd_check_error(bank->target);
+		}
 
-		if (samd_check_error(bank->target)) {
+		if (res != ERROR_OK) {
 			LOG_ERROR("%s: write failed at address 0x%08" PRIx32, __func__, address);
-			res = ERROR_FAIL;
 			goto free_pb;
 		}
 
@@ -825,18 +845,23 @@ COMMAND_HANDLER(samd_handle_info_command)
 COMMAND_HANDLER(samd_handle_chip_erase_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
+	int res = ERROR_FAIL;
 
 	if (target) {
 		/* Enable access to the DSU by disabling the write protect bit */
 		target_write_u32(target, SAMD_PAC1, (1<<1));
+		/* intentionally without error checking - not accessible on secured chip */
+
 		/* Tell the DSU to perform a full chip erase.  It takes about 240ms to
 		 * perform the erase. */
-		target_write_u8(target, SAMD_DSU, (1<<4));
-
-		command_print(CMD_CTX, "chip erased");
+		res = target_write_u8(target, SAMD_DSU + SAMD_DSU_CTRL_EXT, (1<<4));
+		if (res == ERROR_OK)
+			command_print(CMD_CTX, "chip erase started");
+		else
+			command_print(CMD_CTX, "write to DSU CTRL failed");
 	}
 
-	return ERROR_OK;
+	return res;
 }
 
 COMMAND_HANDLER(samd_handle_set_security_command)
@@ -987,10 +1012,15 @@ COMMAND_HANDLER(samd_handle_bootloader_command)
 COMMAND_HANDLER(samd_handle_reset_deassert)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
 	int retval = ERROR_OK;
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 
+	/* If the target has been unresponsive before, try to re-establish
+	 * communication now - CPU is held in reset by DSU, DAP is working */
+	if (!target_was_examined(target))
+		target_examine_one(target);
+	target_poll(target);
+
 	/* In case of sysresetreq, debug retains state set in cortex_m_assert_reset()
 	 * so we just release reset held by DSU
 	 *
@@ -999,9 +1029,9 @@ COMMAND_HANDLER(samd_handle_reset_deassert)
 	 * After vectreset DSU release is not needed however makes no harm
 	 */
 	if (target->reset_halt && (jtag_reset_config & RESET_HAS_SRST)) {
-		retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
+		retval = target_write_u32(target, DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
 		if (retval == ERROR_OK)
-			retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DEMCR,
+			retval = target_write_u32(target, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 		/* do not return on error here, releasing DSU reset is more important */
 	}
diff --git a/src/flash/nor/ath79.c b/src/flash/nor/ath79.c
new file mode 100644
index 00000000..451e8436
--- /dev/null
+++ b/src/flash/nor/ath79.c
@@ -0,0 +1,901 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by Tobias Diedrich                                 *
+ *   <ranma+openwrt@tdiedrich.de>                                          *
+ *                                                                         *
+ *   based on the stmsmi code written by Antonio Borneo                    *
+ *   <borneo.antonio@gmail.com>                                            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.                                        *
+ *                                                                         *
+ ***************************************************************************/
+/*
+ * Driver for the Atheros AR7xxx/AR9xxx SPI flash interface.
+ *
+ * Since no SPI mode register is present, presumably only
+ * SPI "mode 3" (CPOL=1 and CPHA=1) is supported.
+ *
+ * The SPI interface supports up to 3 chip selects, however the SPI flash
+ * used for booting the system must be connected to CS0.
+ *
+ * On boot, the first 4MiB of flash space are memory-mapped into the
+ * area bf000000 - bfffffff (4 copies), so the MIPS bootstrap
+ * vector bfc00000 is mapped to the beginning of the flash.
+ *
+ * By writing a 1 to the REMAP_DISABLE bit in the SPI_CONTROL register,
+ * the full area of 16MiB is mapped.
+ *
+ * By writing a 0 to the SPI_FUNCTION_SELECT register (write-only dword
+ * register @bf000000), memory mapping is disabled and the SPI registers
+ * are exposed to the CPU instead:
+ * bf000000 SPI_FUNCTION_SELECT
+ * bf000004 SPI_CONTROL
+ * bf000008 SPI_IO_CONTROL
+ * bf00000c SPI_READ_DATA
+ *
+ * When not memory-mapped, the SPI interface is essentially bitbanged
+ * using SPI_CONTROL and SPI_IO_CONTROL with the only hardware-assistance
+ * being the 32bit read-only shift-register SPI_READ_DATA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include "spi.h"
+#include <jtag/jtag.h>
+#include <helper/time_support.h>
+#include <helper/types.h>
+#include <target/mips32.h>
+#include <target/mips32_pracc.h>
+#include <target/target.h>
+
+#define BITS_PER_BYTE 8
+
+#define ATH79_REG_FS     0
+#define ATH79_REG_CLOCK  4
+#define ATH79_REG_WRITE  8
+#define ATH79_REG_DATA  12
+
+#define ATH79_SPI_CS_ALLHI 0x70000
+#define ATH79_SPI_CS0_HI   0x10000
+#define ATH79_SPI_CS1_HI   0x20000
+#define ATH79_SPI_CS2_HI   0x40000
+#define ATH79_SPI_CE_HI    0x00100
+#define ATH79_SPI_DO_HI    0x00001
+
+#define ATH79_XFER_FINAL   0x00000001
+#define ATH79_XFER_PARTIAL 0x00000000
+
+/* Timeout in ms */
+#define ATH79_MAX_TIMEOUT  (3000)
+
+struct ath79_spi_ctx {
+	uint8_t *page_buf;
+	int pre_deselect;
+	int post_deselect;
+};
+
+struct ath79_flash_bank {
+	int probed;
+	int chipselect;
+	uint32_t io_base;
+	const struct flash_device *dev;
+	struct ath79_spi_ctx spi;
+};
+
+struct ath79_target {
+	char *name;
+	uint32_t tap_idcode;
+	uint32_t io_base;
+};
+
+static const struct ath79_target target_devices[] = {
+	/* name,   tap_idcode, io_base */
+	{ "ATH79", 0x00000001, 0xbf000000 },
+	{ NULL,    0,          0 }
+};
+
+static const uint32_t ath79_chipselects[] = {
+	(~ATH79_SPI_CS0_HI & ATH79_SPI_CS_ALLHI),
+	(~ATH79_SPI_CS1_HI & ATH79_SPI_CS_ALLHI),
+	(~ATH79_SPI_CS2_HI & ATH79_SPI_CS_ALLHI),
+};
+
+static void ath79_pracc_addn(struct pracc_queue_info *ctx,
+			     const uint32_t *instr,
+			     int n)
+{
+	for (int i = 0; i < n; i++)
+		pracc_add(ctx, 0, instr[i]);
+}
+
+static int ath79_spi_bitbang_codegen(struct ath79_flash_bank *ath79_info,
+				     struct pracc_queue_info *ctx,
+				     uint8_t *data, int len,
+				     int partial_xfer)
+{
+	uint32_t cs_high = ATH79_SPI_CS_ALLHI;
+	uint32_t cs_low = ath79_chipselects[ath79_info->chipselect];
+	uint32_t clock_high = cs_low | ATH79_SPI_CE_HI;
+	uint32_t clock_low = cs_low;
+	uint32_t pracc_out = 0;
+	uint32_t io_base = ath79_info->io_base;
+
+	const uint32_t preamble1[] = {
+		/* $15 = MIPS32_PRACC_BASE_ADDR */
+		MIPS32_LUI(0, 15, PRACC_UPPER_BASE_ADDR),
+		/* $1 = io_base */
+		MIPS32_LUI(0, 1, UPPER16(io_base)),
+	};
+	ath79_pracc_addn(ctx, preamble1, ARRAY_SIZE(preamble1));
+	if (ath79_info->spi.pre_deselect) {
+		/* Clear deselect flag so we don't deselect again if
+		 * this is a partial xfer.
+		 */
+		ath79_info->spi.pre_deselect = 0;
+		const uint32_t pre_deselect[] = {
+			/* [$1 + FS] = 1  (enable flash io register access) */
+			MIPS32_LUI(0, 2, UPPER16(1)),
+			MIPS32_ORI(0, 2, 2, LOWER16(1)),
+			MIPS32_SW(0, 2, ATH79_REG_FS, 1),
+			/* deselect flash just in case */
+			/* $2 = SPI_CS_DIS */
+			MIPS32_LUI(0, 2, UPPER16(cs_high)),
+			MIPS32_ORI(0, 2, 2, LOWER16(cs_high)),
+			/* [$1 + WRITE] = $2 */
+			MIPS32_SW(0, 2, ATH79_REG_WRITE, 1),
+		};
+		ath79_pracc_addn(ctx, pre_deselect, ARRAY_SIZE(pre_deselect));
+	}
+	const uint32_t preamble2[] = {
+		/* t0 = CLOCK_LOW + 0-bit */
+		MIPS32_LUI(0, 8, UPPER16((clock_low + 0))),
+		MIPS32_ORI(0, 8, 8, LOWER16((clock_low + 0))),
+		/* t1 = CLOCK_LOW + 1-bit */
+		MIPS32_LUI(0, 9, UPPER16((clock_low + 1))),
+		MIPS32_ORI(0, 9, 9, LOWER16((clock_low + 1))),
+		/* t2 = CLOCK_HIGH + 0-bit */
+		MIPS32_LUI(0, 10, UPPER16((clock_high + 0))),
+		MIPS32_ORI(0, 10, 10, LOWER16((clock_high + 0))),
+		/* t3 = CLOCK_HIGH + 1-bit */
+		MIPS32_LUI(0, 11, UPPER16((clock_high + 1))),
+		MIPS32_ORI(0, 11, 11, LOWER16((clock_high + 1))),
+	};
+	ath79_pracc_addn(ctx, preamble2, ARRAY_SIZE(preamble2));
+
+	for (int i = 0; i < len; i++) {
+		uint8_t x = data[i];
+
+		/* Generate bitbang code for one byte, highest bit first .*/
+		for (int j = BITS_PER_BYTE - 1; j >= 0; j--) {
+			int bit = ((x >> j) & 1);
+
+			if (bit) {
+				/* [$1 + WRITE] = t1 */
+				pracc_add(ctx, 0,
+					  MIPS32_SW(0, 9, ATH79_REG_WRITE, 1));
+				/* [$1 + WRITE] = t3 */
+				pracc_add(ctx, 0,
+					  MIPS32_SW(0, 11, ATH79_REG_WRITE, 1));
+			} else {
+				/* [$1 + WRITE] = t0 */
+				pracc_add(ctx, 0,
+					  MIPS32_SW(0, 8, ATH79_REG_WRITE, 1));
+				/* [$1 + WRITE] = t2 */
+				pracc_add(ctx, 0,
+					  MIPS32_SW(0, 10, ATH79_REG_WRITE, 1));
+			}
+		}
+		if (i % 4 == 3) {
+			/* $3 = [$1 + DATA] */
+			pracc_add(ctx, 0, MIPS32_LW(0, 3, ATH79_REG_DATA, 1));
+			/* [OUTi] = $3 */
+			pracc_add(ctx, MIPS32_PRACC_PARAM_OUT + pracc_out,
+				  MIPS32_SW(0, 3, PRACC_OUT_OFFSET +
+				 pracc_out, 15));
+			pracc_out += 4;
+		}
+	}
+	if (len & 3) { /* not a multiple of 4 bytes */
+		/* $3 = [$1 + DATA] */
+		pracc_add(ctx, 0, MIPS32_LW(0, 3, ATH79_REG_DATA, 1));
+		/* [OUTi] = $3 */
+		pracc_add(ctx, MIPS32_PRACC_PARAM_OUT + pracc_out,
+			  MIPS32_SW(0, 3, PRACC_OUT_OFFSET + pracc_out, 15));
+		pracc_out += 4;
+	}
+
+	if (ath79_info->spi.post_deselect && !partial_xfer) {
+		const uint32_t post_deselect[] = {
+			/* $2 = SPI_CS_DIS */
+			MIPS32_LUI(0, 2, UPPER16(cs_high)),
+			MIPS32_ORI(0, 2, 2, LOWER16(cs_high)),
+			/* [$1 + WRITE] = $2 */
+			MIPS32_SW(0, 2, ATH79_REG_WRITE, 1),
+
+			/* [$1 + FS] = 0  (disable flash io register access) */
+			MIPS32_XORI(0, 2, 2, 0),
+			MIPS32_SW(0, 2, ATH79_REG_FS, 1),
+		};
+		ath79_pracc_addn(ctx, post_deselect, ARRAY_SIZE(post_deselect));
+	}
+
+	/* common pracc epilogue */
+	/* jump to start */
+	pracc_add(ctx, 0, MIPS32_B(0, NEG16(ctx->code_count + 1)));
+	/* restore $15 from DeSave */
+	pracc_add(ctx, 0, MIPS32_MFC0(0, 15, 31, 0));
+
+	return pracc_out / 4;
+}
+
+static int ath79_spi_bitbang_chunk(struct flash_bank *bank,
+				   uint8_t *data, int len, int *transferred)
+{
+	struct target *target = bank->target;
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	int pracc_words;
+
+	/*
+	 * These constants must match the worst case in the above code
+	 * generator function ath79_spi_bitbang_codegen.
+	 */
+	const int pracc_pre_post = 26;
+	const int pracc_loop_byte = 8 * 2 + 2;
+
+	struct pracc_queue_info ctx = {
+		.ejtag_info = ejtag_info
+	};
+	int max_len = (PRACC_MAX_INSTRUCTIONS - pracc_pre_post) / pracc_loop_byte;
+	int to_xfer = len > max_len ? max_len : len;
+	int partial_xfer = len != to_xfer;
+	int padded_len = (to_xfer + 3) & ~3;
+	uint32_t *out = malloc(padded_len);
+
+	if (!out) {
+		LOG_ERROR("not enough memory");
+		return ERROR_FAIL;
+	}
+
+	*transferred = 0;
+	pracc_queue_init(&ctx);
+
+	LOG_DEBUG("ath79_spi_bitbang_bytes(%p, %08x, %p, %d)",
+		  target, ath79_info->io_base, data, len);
+
+	LOG_DEBUG("max code %d => max len %d. to_xfer %d",
+		  PRACC_MAX_INSTRUCTIONS, max_len, to_xfer);
+
+	pracc_words = ath79_spi_bitbang_codegen(
+		ath79_info, &ctx, data, to_xfer, partial_xfer);
+
+	LOG_DEBUG("Assembled %d instructions, %d stores",
+		  ctx.code_count, ctx.store_count);
+
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, out, 1);
+	if (ctx.retval != ERROR_OK)
+		goto exit;
+
+	if (to_xfer & 3) { /* Not a multiple of 4 bytes. */
+		/*
+		 * Need to realign last word since we didn't shift the
+		 * full 32 bits.
+		 */
+		int missed_bytes = 4 - (to_xfer & 3);
+
+		out[pracc_words - 1] <<= BITS_PER_BYTE * missed_bytes;
+	}
+
+	/*
+	 * pracc reads return uint32_t in host endianness, convert to
+	 * target endianness.
+	 * Since we know the ATH79 target is big endian and the SPI
+	 * shift register has the bytes in highest to lowest bit order,
+	 * this will ensure correct memory byte order regardless of host
+	 * endianness.
+	 */
+	target_buffer_set_u32_array(target, (uint8_t *)out, pracc_words, out);
+
+	if (LOG_LEVEL_IS(LOG_LVL_DEBUG)) {
+		for (int i = 0; i < to_xfer; i++) {
+			LOG_DEBUG("bitbang %02x => %02x",
+				  data[i], ((uint8_t *)out)[i]);
+		}
+	}
+	memcpy(data, out, to_xfer);
+	*transferred = to_xfer;
+
+exit:
+	pracc_queue_free(&ctx);
+	free(out);
+	return ctx.retval;
+}
+
+static void ath79_spi_bitbang_prepare(struct flash_bank *bank)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+
+	ath79_info->spi.pre_deselect = 1;
+}
+
+static int ath79_spi_bitbang_bytes(struct flash_bank *bank,
+				   uint8_t *data, int len, uint32_t flags)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	int retval;
+	int transferred;
+
+	ath79_info->spi.post_deselect = !!(flags & ATH79_XFER_FINAL);
+
+	do {
+		transferred = 0;
+		retval = ath79_spi_bitbang_chunk(
+			bank, data, len, &transferred);
+		if (retval != ERROR_OK)
+			return retval;
+
+		data += transferred;
+		len -= transferred;
+	} while (len > 0);
+
+	return ERROR_OK;
+}
+
+FLASH_BANK_COMMAND_HANDLER(ath79_flash_bank_command)
+{
+	struct ath79_flash_bank *ath79_info;
+	int chipselect = 0;
+
+	LOG_DEBUG("%s", __func__);
+
+	if (CMD_ARGC < 6 || CMD_ARGC > 7)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (CMD_ARGC == 7) {
+		if (strcmp(CMD_ARGV[6], "cs0") == 0)
+			chipselect = 0;  /* default */
+		else if (strcmp(CMD_ARGV[6], "cs1") == 0)
+			chipselect = 1;
+		else if (strcmp(CMD_ARGV[6], "cs2") == 0)
+			chipselect = 2;
+		else {
+			LOG_ERROR("Unknown arg: %s", CMD_ARGV[6]);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	}
+
+	ath79_info = calloc(1, sizeof(struct ath79_flash_bank));
+	if (!ath79_info) {
+		LOG_ERROR("not enough memory");
+		return ERROR_FAIL;
+	}
+
+	ath79_info->chipselect = chipselect;
+	bank->driver_priv = ath79_info;
+
+	return ERROR_OK;
+}
+
+/* Read the status register of the external SPI flash chip. */
+static int read_status_reg(struct flash_bank *bank, uint32_t *status)
+{
+	uint8_t spi_bytes[] = {SPIFLASH_READ_STATUS, 0};
+	int retval;
+
+	/* Send SPI command "read STATUS" */
+	ath79_spi_bitbang_prepare(bank);
+	retval = ath79_spi_bitbang_bytes(
+		bank, spi_bytes, sizeof(spi_bytes),
+		ATH79_XFER_FINAL);
+
+	*status = spi_bytes[1];
+
+	return retval;
+}
+
+/* check for WIP (write in progress) bit in status register */
+/* timeout in ms */
+static int wait_till_ready(struct flash_bank *bank, int timeout)
+{
+	uint32_t status;
+	int retval;
+	long long endtime;
+
+	endtime = timeval_ms() + timeout;
+	do {
+		/* read flash status register */
+		retval = read_status_reg(bank, &status);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if ((status & SPIFLASH_BSY_BIT) == 0)
+			return ERROR_OK;
+		alive_sleep(1);
+	} while (timeval_ms() < endtime);
+
+	LOG_ERROR("timeout");
+	return ERROR_FAIL;
+}
+
+/* Send "write enable" command to SPI flash chip. */
+static int ath79_write_enable(struct flash_bank *bank)
+{
+	uint32_t status;
+	int retval;
+
+	uint8_t spi_bytes[] = {SPIFLASH_WRITE_ENABLE};
+
+	/* Send SPI command "write enable" */
+	ath79_spi_bitbang_prepare(bank);
+	retval = ath79_spi_bitbang_bytes(
+		bank, spi_bytes, sizeof(spi_bytes),
+		ATH79_XFER_FINAL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read flash status register */
+	retval = read_status_reg(bank, &status);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Check write enabled */
+	if ((status & SPIFLASH_WE_BIT) == 0) {
+		LOG_ERROR("Cannot enable write to flash. Status=0x%08" PRIx32,
+			  status);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int erase_command(struct flash_bank *bank, int sector)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	uint32_t offset = bank->sectors[sector].offset;
+
+	uint8_t spi_bytes[] = {
+		ath79_info->dev->erase_cmd,
+		offset >> 16,
+		offset >> 8,
+		offset
+	};
+
+	/* bitbang command */
+	ath79_spi_bitbang_prepare(bank);
+	return ath79_spi_bitbang_bytes(
+		bank, spi_bytes, sizeof(spi_bytes),
+		ATH79_XFER_FINAL);
+}
+
+static int ath79_erase_sector(struct flash_bank *bank, int sector)
+{
+	int retval = ath79_write_enable(bank);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* send SPI command "block erase" */
+	retval = erase_command(bank, sector);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* poll WIP for end of self timed Sector Erase cycle */
+	return wait_till_ready(bank, ATH79_MAX_TIMEOUT);
+}
+
+static int ath79_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	int retval = ERROR_OK;
+	int sector;
+
+	LOG_DEBUG("%s: from sector %d to sector %d", __func__, first, last);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first < 0) || (last < first) || (last >= bank->num_sectors)) {
+		LOG_ERROR("Flash sector invalid");
+		return ERROR_FLASH_SECTOR_INVALID;
+	}
+
+	if (!ath79_info->probed) {
+		LOG_ERROR("Flash bank not probed");
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	for (sector = first; sector <= last; sector++) {
+		if (bank->sectors[sector].is_protected) {
+			LOG_ERROR("Flash sector %d protected", sector);
+			return ERROR_FAIL;
+		}
+	}
+
+	for (sector = first; sector <= last; sector++) {
+		retval = ath79_erase_sector(bank, sector);
+		if (retval != ERROR_OK)
+			break;
+		keep_alive();
+	}
+
+	return retval;
+}
+
+static int ath79_protect(struct flash_bank *bank, int set,
+			 int first, int last)
+{
+	int sector;
+
+	for (sector = first; sector <= last; sector++)
+		bank->sectors[sector].is_protected = set;
+	return ERROR_OK;
+}
+
+static int ath79_write_page(struct flash_bank *bank, const uint8_t *buffer,
+			    uint32_t address, uint32_t len)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	uint8_t spi_bytes[] = {
+		SPIFLASH_PAGE_PROGRAM,
+		address >> 16,
+		address >> 8,
+		address,
+	};
+	int retval;
+	uint32_t i;
+
+	if (address & 0xff) {
+		LOG_ERROR("ath79_write_page: unaligned write address: %08x",
+			  address);
+		return ERROR_FAIL;
+	}
+	if (!ath79_info->spi.page_buf) {
+		LOG_ERROR("ath79_write_page: page buffer not initialized");
+		return ERROR_FAIL;
+	}
+	if (len > ath79_info->dev->pagesize) {
+		LOG_ERROR("ath79_write_page: len bigger than page size %d: %d",
+			  ath79_info->dev->pagesize, len);
+		return ERROR_FAIL;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (buffer[i] != 0xff)
+			break;
+	}
+	if (i == len)  /* all 0xff, no need to program. */
+		return ERROR_OK;
+
+	LOG_INFO("writing %d bytes to flash page @0x%08x", len, address);
+
+	memcpy(ath79_info->spi.page_buf, buffer, len);
+
+	/* unlock writes */
+	retval = ath79_write_enable(bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* bitbang command */
+	ath79_spi_bitbang_prepare(bank);
+	retval = ath79_spi_bitbang_bytes(
+		bank, spi_bytes, sizeof(spi_bytes),
+		ATH79_XFER_PARTIAL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write data */
+	return ath79_spi_bitbang_bytes(
+		bank, ath79_info->spi.page_buf, len,
+		ATH79_XFER_FINAL);
+}
+
+static int ath79_write_buffer(struct flash_bank *bank, const uint8_t *buffer,
+			      uint32_t address, uint32_t len)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	const uint32_t page_size = ath79_info->dev->pagesize;
+	int retval;
+
+	LOG_DEBUG("%s: address=0x%08" PRIx32 " len=0x%08" PRIx32,
+		  __func__, address, len);
+
+	while (len > 0) {
+		int page_len = len > page_size ? page_size : len;
+
+		retval = ath79_write_page(
+			bank, buffer, address, page_len);
+		if (retval != ERROR_OK)
+			return retval;
+
+		buffer += page_size;
+		address += page_size;
+		len -= page_len;
+	}
+
+	return ERROR_OK;
+}
+
+static int ath79_write(struct flash_bank *bank, const uint8_t *buffer,
+		       uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	int sector;
+
+	LOG_DEBUG("%s: offset=0x%08" PRIx32 " count=0x%08" PRIx32,
+		  __func__, offset, count);
+
+	if (offset < bank->base || offset >= bank->base + bank->size) {
+		LOG_ERROR("Start address out of range");
+		return ERROR_FAIL;
+	}
+
+	offset -= bank->base;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset + count > bank->size) {
+		LOG_WARNING("Write pasts end of flash. Extra data discarded.");
+		count = bank->size - offset;
+	}
+
+	/* Check sector protection */
+	for (sector = 0; sector < bank->num_sectors; sector++) {
+		/* Start offset in or before this sector? */
+		/* End offset in or behind this sector? */
+		struct flash_sector *bs = &bank->sectors[sector];
+
+		if ((offset < (bs->offset + bs->size)) &&
+		    ((offset + count - 1) >= bs->offset) &&
+		    bs->is_protected) {
+			LOG_ERROR("Flash sector %d protected", sector);
+			return ERROR_FAIL;
+		}
+	}
+
+	return ath79_write_buffer(bank, buffer, offset, count);
+}
+
+static int ath79_read_buffer(struct flash_bank *bank, uint8_t *buffer,
+			     uint32_t address, uint32_t len)
+{
+	uint8_t spi_bytes[] = {
+		SPIFLASH_READ,
+		address >> 16,
+		address >> 8,
+		address,
+	};
+	int retval;
+
+	LOG_DEBUG("%s: address=0x%08" PRIx32 " len=0x%08" PRIx32,
+		  __func__, address, len);
+
+	if (address & 0xff) {
+		LOG_ERROR("ath79_read_buffer: unaligned read address: %08x",
+			  address);
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("reading %d bytes from flash @0x%08x", len, address);
+
+	/* bitbang command */
+	ath79_spi_bitbang_prepare(bank);
+	retval = ath79_spi_bitbang_bytes(
+		bank, spi_bytes, sizeof(spi_bytes), ATH79_XFER_PARTIAL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read data */
+	return ath79_spi_bitbang_bytes(
+		bank, buffer, len, ATH79_XFER_FINAL);
+}
+
+static int ath79_read(struct flash_bank *bank, uint8_t *buffer,
+		      uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+
+	LOG_DEBUG("%s: offset=0x%08" PRIx32 " count=0x%08" PRIx32,
+		  __func__, offset, count);
+
+	if (offset < bank->base || offset >= bank->base + bank->size) {
+		LOG_ERROR("Start address out of range");
+		return ERROR_FAIL;
+	}
+
+	offset -= bank->base;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset + count > bank->size) {
+		LOG_WARNING("Reads past end of flash. Extra data discarded.");
+		count = bank->size - offset;
+	}
+
+	return ath79_read_buffer(bank, buffer, offset, count);
+}
+
+/* Return ID of flash device */
+static int read_flash_id(struct flash_bank *bank, uint32_t *id)
+{
+	struct target *target = bank->target;
+	int retval;
+	uint8_t spi_bytes[] = {SPIFLASH_READ_ID, 0, 0, 0};
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Send SPI command "read ID" */
+	ath79_spi_bitbang_prepare(bank);
+	retval = ath79_spi_bitbang_bytes(
+		bank, spi_bytes, sizeof(spi_bytes), ATH79_XFER_FINAL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	*id = (spi_bytes[1] << 0)
+		| (spi_bytes[2] << 8)
+		| (spi_bytes[3] << 16);
+
+	if (*id == 0xffffff) {
+		LOG_ERROR("No SPI flash found");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int ath79_probe(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+	struct flash_sector *sectors;
+	uint32_t id = 0; /* silence uninitialized warning */
+	const struct ath79_target *target_device;
+	int retval;
+
+	if (ath79_info->probed) {
+		free(bank->sectors);
+		free(ath79_info->spi.page_buf);
+	}
+	ath79_info->probed = 0;
+
+	for (target_device = target_devices; target_device->name;
+		++target_device)
+		if (target_device->tap_idcode == target->tap->idcode)
+			break;
+	if (!target_device->name) {
+		LOG_ERROR("Device ID 0x%" PRIx32 " is not known",
+			  target->tap->idcode);
+		return ERROR_FAIL;
+	}
+
+	ath79_info->io_base = target_device->io_base;
+
+	LOG_DEBUG("Found device %s at address 0x%" PRIx32,
+		  target_device->name, bank->base);
+
+	retval = read_flash_id(bank, &id);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ath79_info->dev = NULL;
+	for (const struct flash_device *p = flash_devices; p->name; p++)
+		if (p->device_id == id) {
+			ath79_info->dev = p;
+			break;
+		}
+
+	if (!ath79_info->dev) {
+		LOG_ERROR("Unknown flash device (ID 0x%08" PRIx32 ")", id);
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("Found flash device \'%s\' (ID 0x%08" PRIx32 ")",
+		 ath79_info->dev->name, ath79_info->dev->device_id);
+
+	/* Set correct size value */
+	bank->size = ath79_info->dev->size_in_bytes;
+
+	/* create and fill sectors array */
+	bank->num_sectors =
+		ath79_info->dev->size_in_bytes / ath79_info->dev->sectorsize;
+	sectors = calloc(1, sizeof(struct flash_sector) * bank->num_sectors);
+	if (!sectors) {
+		LOG_ERROR("not enough memory");
+		return ERROR_FAIL;
+	}
+	ath79_info->spi.page_buf = malloc(ath79_info->dev->pagesize);
+	if (!ath79_info->spi.page_buf) {
+		LOG_ERROR("not enough memory");
+		free(sectors);
+		return ERROR_FAIL;
+	}
+
+	for (int sector = 0; sector < bank->num_sectors; sector++) {
+		sectors[sector].offset = sector * ath79_info->dev->sectorsize;
+		sectors[sector].size = ath79_info->dev->sectorsize;
+		sectors[sector].is_erased = 0;
+		sectors[sector].is_protected = 1;
+	}
+
+	bank->sectors = sectors;
+	ath79_info->probed = 1;
+	return ERROR_OK;
+}
+
+static int ath79_auto_probe(struct flash_bank *bank)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+
+	if (ath79_info->probed)
+		return ERROR_OK;
+	return ath79_probe(bank);
+}
+
+static int ath79_flash_blank_check(struct flash_bank *bank)
+{
+	/* Not implemented */
+	return ERROR_OK;
+}
+
+static int ath79_protect_check(struct flash_bank *bank)
+{
+	/* Not implemented */
+	return ERROR_OK;
+}
+
+static int get_ath79_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct ath79_flash_bank *ath79_info = bank->driver_priv;
+
+	if (!ath79_info->probed) {
+		snprintf(buf, buf_size,
+			 "\nATH79 flash bank not probed yet\n");
+		return ERROR_OK;
+	}
+
+	snprintf(buf, buf_size, "\nATH79 flash information:\n"
+		"  Device \'%s\' (ID 0x%08" PRIx32 ")\n",
+		ath79_info->dev->name, ath79_info->dev->device_id);
+
+	return ERROR_OK;
+}
+
+struct flash_driver ath79_flash = {
+	.name = "ath79",
+	.flash_bank_command = ath79_flash_bank_command,
+	.erase = ath79_erase,
+	.protect = ath79_protect,
+	.write = ath79_write,
+	.read = ath79_read,
+	.probe = ath79_probe,
+	.auto_probe = ath79_auto_probe,
+	.erase_check = ath79_flash_blank_check,
+	.protect_check = ath79_protect_check,
+	.info = get_ath79_info,
+};
diff --git a/src/flash/nor/atsamv.c b/src/flash/nor/atsamv.c
index 08f8bb8b..73f02389 100644
--- a/src/flash/nor/atsamv.c
+++ b/src/flash/nor/atsamv.c
@@ -12,15 +12,17 @@
  *   (atsamv, atsams, and atsame support)                                  *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General public License as published by  *
+ *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  *   This program is distributed in the hope that it will be useful,       *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS for A PARTICULAR PURPOSE.  See the         *
- *   GNU General public License for more details.                          *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
  *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* Some of the the lower level code was based on code supplied by
@@ -145,7 +147,7 @@ static int samv_efc_perform_command(struct target *target,
 {
 	int r;
 	uint32_t v;
-	long long ms_now, ms_end;
+	int64_t ms_now, ms_end;
 
 	if (status)
 		*status = 0;
@@ -355,12 +357,15 @@ static int samv_probe(struct flash_bank *bank)
 
 	uint8_t eproc = (device_id >> 5) & 0x7;
 	if (eproc != 0) {
-		LOG_ERROR("unexpected eproc code: %d was expecting 0 (cortex-m7)", eproc);
+		LOG_ERROR("unexpected eproc code: %d was expecting 0 (Cortex-M7)", eproc);
 		return ERROR_FAIL;
 	}
 
 	uint8_t nvm_size_code = (device_id >> 8) & 0xf;
 	switch (nvm_size_code) {
+		case 10:
+			bank->size = 512 * 1024;
+			break;
 		case 12:
 			bank->size = 1024 * 1024;
 			break;
diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index 1984c9ef..11cc3b2d 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -68,6 +66,7 @@ static const struct avrf_type avft_chips_info[] = {
  *			eeprom_page_size, eeprom_page_num
  */
 	{"atmega128", 0x9702, 256, 512, 8, 512},
+	{"atmega128rfa1", 0xa701, 128, 512, 8, 512},
 	{"at90can128", 0x9781, 256, 512, 8, 512},
 	{"at90usb128", 0x9782, 256, 512, 8, 512},
 	{"atmega164p", 0x940a, 128, 128, 4, 128},
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 90d7d83d..ac0db827 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -17,9 +17,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -136,6 +134,7 @@ static inline uint32_t flash_address(struct flash_bank *bank, int sector, uint32
 static void cfi_command(struct flash_bank *bank, uint8_t cmd, uint8_t *cmd_buf)
 {
 	int i;
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 
 	/* clear whole buffer, to ensure bits that exceed the bus_width
 	 * are set to zero
@@ -143,7 +142,7 @@ static void cfi_command(struct flash_bank *bank, uint8_t cmd, uint8_t *cmd_buf)
 	for (i = 0; i < CFI_MAX_BUS_WIDTH; i++)
 		cmd_buf[i] = 0;
 
-	if (bank->target->endianness == TARGET_LITTLE_ENDIAN) {
+	if (cfi_info->endianness == TARGET_LITTLE_ENDIAN) {
 		for (i = bank->bus_width; i > 0; i--)
 			*cmd_buf++ = (i & (bank->chip_width - 1)) ? 0x0 : cmd;
 	} else {
@@ -167,6 +166,7 @@ static int cfi_send_command(struct flash_bank *bank, uint8_t cmd, uint32_t addre
 static int cfi_query_u8(struct flash_bank *bank, int sector, uint32_t offset, uint8_t *val)
 {
 	struct target *target = bank->target;
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	uint8_t data[CFI_MAX_BUS_WIDTH];
 
 	int retval;
@@ -175,7 +175,7 @@ static int cfi_query_u8(struct flash_bank *bank, int sector, uint32_t offset, ui
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
+	if (cfi_info->endianness == TARGET_LITTLE_ENDIAN)
 		*val = data[0];
 	else
 		*val = data[bank->bus_width - 1];
@@ -190,6 +190,7 @@ static int cfi_query_u8(struct flash_bank *bank, int sector, uint32_t offset, ui
 static int cfi_get_u8(struct flash_bank *bank, int sector, uint32_t offset, uint8_t *val)
 {
 	struct target *target = bank->target;
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	uint8_t data[CFI_MAX_BUS_WIDTH];
 	int i;
 
@@ -199,7 +200,7 @@ static int cfi_get_u8(struct flash_bank *bank, int sector, uint32_t offset, uint
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (bank->target->endianness == TARGET_LITTLE_ENDIAN) {
+	if (cfi_info->endianness == TARGET_LITTLE_ENDIAN) {
 		for (i = 0; i < bank->bus_width / bank->chip_width; i++)
 			data[0] |= data[i];
 
@@ -236,7 +237,7 @@ static int cfi_query_u16(struct flash_bank *bank, int sector, uint32_t offset, u
 			return retval;
 	}
 
-	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
+	if (cfi_info->endianness == TARGET_LITTLE_ENDIAN)
 		*val = data[0] | data[bank->bus_width] << 8;
 	else
 		*val = data[bank->bus_width - 1] | data[(2 * bank->bus_width) - 1] << 8;
@@ -266,7 +267,7 @@ static int cfi_query_u32(struct flash_bank *bank, int sector, uint32_t offset, u
 			return retval;
 	}
 
-	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
+	if (cfi_info->endianness == TARGET_LITTLE_ENDIAN)
 		*val = data[0] | data[bank->bus_width] << 8 |
 			data[bank->bus_width * 2] << 16 | data[bank->bus_width * 3] << 24;
 	else
@@ -803,6 +804,7 @@ static int cfi_intel_info(struct flash_bank *bank, char *buf, int buf_size)
 FLASH_BANK_COMMAND_HANDLER(cfi_flash_bank_command)
 {
 	struct cfi_flash_bank *cfi_info;
+	int bus_swap = 0;
 
 	if (CMD_ARGC < 6)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -832,14 +834,26 @@ FLASH_BANK_COMMAND_HANDLER(cfi_flash_bank_command)
 	cfi_info->x16_as_x8 = 0;
 	cfi_info->jedec_probe = 0;
 	cfi_info->not_cfi = 0;
+	cfi_info->data_swap = 0;
 
 	for (unsigned i = 6; i < CMD_ARGC; i++) {
 		if (strcmp(CMD_ARGV[i], "x16_as_x8") == 0)
 			cfi_info->x16_as_x8 = 1;
+		else if (strcmp(CMD_ARGV[i], "data_swap") == 0)
+			cfi_info->data_swap = 1;
+		else if (strcmp(CMD_ARGV[i], "bus_swap") == 0)
+			bus_swap = 1;
 		else if (strcmp(CMD_ARGV[i], "jedec_probe") == 0)
 			cfi_info->jedec_probe = 1;
 	}
 
+	if (bus_swap)
+		cfi_info->endianness =
+			bank->target->endianness == TARGET_LITTLE_ENDIAN ?
+			TARGET_BIG_ENDIAN : TARGET_LITTLE_ENDIAN;
+	else
+		cfi_info->endianness = bank->target->endianness;
+
 	/* bank wasn't probed yet */
 	cfi_info->qry[0] = 0xff;
 
@@ -1262,7 +1276,6 @@ static int cfi_intel_write_block(struct flash_bank *bank, const uint8_t *buffer,
 		LOG_WARNING("No working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
-	;
 
 	/* write algorithm code to working area */
 	retval = target_write_buffer(target, write_algorithm->address,
@@ -1284,7 +1297,6 @@ static int cfi_intel_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			goto cleanup;
 		}
 	}
-	;
 
 	/* setup algo registers */
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
@@ -1300,7 +1312,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	busy_pattern_val  = cfi_command_val(bank, 0x80);
 	error_pattern_val = cfi_command_val(bank, 0x7e);
 
-	LOG_DEBUG("Using target buffer at 0x%08" PRIx32 " and of size 0x%04" PRIx32,
+	LOG_DEBUG("Using target buffer at " TARGET_ADDR_FMT " and of size 0x%04" PRIx32,
 		source->address, buffer_size);
 
 	/* Programming main loop */
@@ -1412,50 +1424,50 @@ static int cfi_spansion_write_block_mips(struct flash_bank *bank, const uint8_t
 
 	static const uint32_t mips_word_16_code[] = {
 		/* start:	*/
-		MIPS32_LHU(9, 0, 4),			/* lhu $t1, ($a0)		; out = &saddr */
-		MIPS32_ADDI(4, 4, 2),			/* addi $a0, $a0, 2		; saddr += 2 */
-		MIPS32_SH(13, 0, 12),			/* sh $t5, ($t4)		; *fl_unl_addr1 = fl_unl_cmd1 */
-		MIPS32_SH(15, 0, 14),			/* sh $t7, ($t6)		; *fl_unl_addr2 = fl_unl_cmd2 */
-		MIPS32_SH(7, 0, 12),			/* sh $a3, ($t4)		; *fl_unl_addr1 = fl_write_cmd */
-		MIPS32_SH(9, 0, 5),				/* sh $t1, ($a1)		; *daddr = out */
+		MIPS32_LHU(0, 9, 0, 4),		/* lhu $t1, ($a0)		; out = &saddr */
+		MIPS32_ADDI(0, 4, 4, 2),	/* addi $a0, $a0, 2		; saddr += 2 */
+		MIPS32_SH(0, 13, 0, 12),	/* sh $t5, ($t4)		; *fl_unl_addr1 = fl_unl_cmd1 */
+		MIPS32_SH(0, 15, 0, 14),	/* sh $t7, ($t6)		; *fl_unl_addr2 = fl_unl_cmd2 */
+		MIPS32_SH(0, 7, 0, 12),		/* sh $a3, ($t4)		; *fl_unl_addr1 = fl_write_cmd */
+		MIPS32_SH(0, 9, 0, 5),		/* sh $t1, ($a1)		; *daddr = out */
 		MIPS32_NOP,						/* nop */
 		/* busy:	*/
-		MIPS32_LHU(10, 0, 5),			/* lhu $t2, ($a1)		; temp1 = *daddr */
-		MIPS32_XOR(11, 9, 10),			/* xor $t3, $a0, $t2	; temp2 = out ^ temp1; */
-		MIPS32_AND(11, 8, 11),			/* and $t3, $t0, $t3	; temp2 = temp2 & DQ7mask */
-		MIPS32_BNE(11, 8, 13),			/* bne $t3, $t0, cont	; if (temp2 != DQ7mask) goto cont */
-		MIPS32_NOP,						/* nop									*/
-
-		MIPS32_SRL(10, 8, 2),			/* srl $t2,$t0,2		; temp1 = DQ7mask >> 2 */
-		MIPS32_AND(11, 10, 11),			/* and $t3, $t2, $t3	; temp2 = temp2 & temp1	*/
-		MIPS32_BNE(11, 10, NEG16(8)),	/* bne $t3, $t2, busy	; if (temp2 != temp1) goto busy	*/
-		MIPS32_NOP,						/* nop									*/
-
-		MIPS32_LHU(10, 0, 5),			/* lhu $t2, ($a1)		; temp1 = *daddr */
-		MIPS32_XOR(11, 9, 10),			/* xor $t3, $a0, $t2	; temp2 = out ^ temp1; */
-		MIPS32_AND(11, 8, 11),			/* and $t3, $t0, $t3	; temp2 = temp2 & DQ7mask */
-		MIPS32_BNE(11, 8, 4),			/* bne $t3, $t0, cont	; if (temp2 != DQ7mask) goto cont */
+		MIPS32_LHU(0, 10, 0, 5),		/* lhu $t2, ($a1)		; temp1 = *daddr */
+		MIPS32_XOR(0, 11, 9, 10),		/* xor $t3, $a0, $t2	; temp2 = out ^ temp1; */
+		MIPS32_AND(0, 11, 8, 11),		/* and $t3, $t0, $t3	; temp2 = temp2 & DQ7mask */
+		MIPS32_BNE(0, 11, 8, 13),		/* bne $t3, $t0, cont	; if (temp2 != DQ7mask) goto cont */
+		MIPS32_NOP,						/* nop					*/
+
+		MIPS32_SRL(0, 10, 8, 2),		/* srl $t2,$t0,2		; temp1 = DQ7mask >> 2 */
+		MIPS32_AND(0, 11, 10, 11),			/* and $t3, $t2, $t3	; temp2 = temp2 & temp1	*/
+		MIPS32_BNE(0, 11, 10, NEG16(8)),	/* bne $t3, $t2, busy	; if (temp2 != temp1) goto busy	*/
+		MIPS32_NOP,						/* nop					*/
+
+		MIPS32_LHU(0, 10, 0, 5),		/* lhu $t2, ($a1)		; temp1 = *daddr */
+		MIPS32_XOR(0, 11, 9, 10),		/* xor $t3, $a0, $t2	; temp2 = out ^ temp1; */
+		MIPS32_AND(0, 11, 8, 11),		/* and $t3, $t0, $t3	; temp2 = temp2 & DQ7mask */
+		MIPS32_BNE(0, 11, 8, 4),		/* bne $t3, $t0, cont	; if (temp2 != DQ7mask) goto cont */
 		MIPS32_NOP,						/* nop */
 
-		MIPS32_XOR(9, 9, 9),			/* xor $t1, $t1, $t1	; out = 0 */
-		MIPS32_BEQ(9, 0, 11),			/* beq $t1, $zero, done	; if (out == 0) goto done */
+		MIPS32_XOR(0, 9, 9, 9),			/* xor $t1, $t1, $t1	; out = 0 */
+		MIPS32_BEQ(0, 9, 0, 11),			/* beq $t1, $zero, done	; if (out == 0) goto done */
 		MIPS32_NOP,						/* nop */
 		/* cont:	*/
-		MIPS32_ADDI(6, 6, NEG16(1)),	/* addi, $a2, $a2, -1	; numwrites-- */
-		MIPS32_BNE(6, 0, 5),			/* bne $a2, $zero, cont2	; if (numwrite != 0) goto cont2 */
+		MIPS32_ADDI(0, 6, 6, NEG16(1)),	/* addi, $a2, $a2, -1	; numwrites-- */
+		MIPS32_BNE(0, 6, 0, 5),		/* bne $a2, $zero, cont2	; if (numwrite != 0) goto cont2 */
 		MIPS32_NOP,						/* nop */
 
-		MIPS32_LUI(9, 0),				/* lui $t1, 0 */
-		MIPS32_ORI(9, 9, 0x80),			/* ori $t1, $t1, 0x80	; out = 0x80 */
+		MIPS32_LUI(0, 9, 0),				/* lui $t1, 0 */
+		MIPS32_ORI(0, 9, 9, 0x80),			/* ori $t1, $t1, 0x80	; out = 0x80 */
 
-		MIPS32_B(4),					/* b done			; goto done */
+		MIPS32_B(0, 4),					/* b done			; goto done */
 		MIPS32_NOP,						/* nop */
 		/* cont2:	*/
-		MIPS32_ADDI(5, 5, 2),			/* addi $a0, $a0, 2	; daddr += 2 */
-		MIPS32_B(NEG16(33)),			/* b start			; goto start */
+		MIPS32_ADDI(0, 5, 5, 2),			/* addi $a0, $a0, 2	; daddr += 2 */
+		MIPS32_B(0, NEG16(33)),			/* b start			; goto start */
 		MIPS32_NOP,						/* nop */
 		/* done: */
-		MIPS32_SDBBP,					/* sdbbp			; break(); */
+		MIPS32_SDBBP(0),					/* sdbbp			; break(); */
 	};
 
 	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
@@ -1527,18 +1539,17 @@ static int cfi_spansion_write_block_mips(struct flash_bank *bank, const uint8_t
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 	}
-	;
 
-	init_reg_param(&reg_params[0], "a0", 32, PARAM_OUT);
-	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
-	init_reg_param(&reg_params[2], "a2", 32, PARAM_OUT);
-	init_reg_param(&reg_params[3], "a3", 32, PARAM_OUT);
-	init_reg_param(&reg_params[4], "t0", 32, PARAM_OUT);
-	init_reg_param(&reg_params[5], "t1", 32, PARAM_IN);
-	init_reg_param(&reg_params[6], "t4", 32, PARAM_OUT);
-	init_reg_param(&reg_params[7], "t5", 32, PARAM_OUT);
-	init_reg_param(&reg_params[8], "t6", 32, PARAM_OUT);
-	init_reg_param(&reg_params[9], "t7", 32, PARAM_OUT);
+	init_reg_param(&reg_params[0], "r4", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r5", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r6", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r7", 32, PARAM_OUT);
+	init_reg_param(&reg_params[4], "r8", 32, PARAM_OUT);
+	init_reg_param(&reg_params[5], "r9", 32, PARAM_IN);
+	init_reg_param(&reg_params[6], "r12", 32, PARAM_OUT);
+	init_reg_param(&reg_params[7], "r13", 32, PARAM_OUT);
+	init_reg_param(&reg_params[8], "r14", 32, PARAM_OUT);
+	init_reg_param(&reg_params[9], "r15", 32, PARAM_OUT);
 
 	while (count > 0) {
 		uint32_t thisrun_count = (count > buffer_size) ? buffer_size : count;
@@ -1907,7 +1918,6 @@ static int cfi_spansion_write_block(struct flash_bank *bank, const uint8_t *buff
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 	}
-	;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
@@ -1989,7 +1999,9 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 
 	uint8_t status;
 	retval = cfi_intel_wait_status_busy(bank, cfi_info->word_write_timeout, &status);
-	if (retval != 0x80) {
+	if (retval != ERROR_OK)
+		return retval;
+	if (status != 0x80) {
 		retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0));
 		if (retval != ERROR_OK)
 			return retval;
@@ -2322,6 +2334,8 @@ static int cfi_write(struct flash_bank *bank, const uint8_t *buffer, uint32_t of
 	int blk_count;	/* number of bus_width bytes for block copy */
 	uint8_t current_word[CFI_MAX_BUS_WIDTH * 4];	/* word (bus_width size) currently being
 							 *programmed */
+	uint8_t *swapped_buffer = NULL;
+	const uint8_t *real_buffer = NULL;
 	int i;
 	int retval;
 
@@ -2348,8 +2362,14 @@ static int cfi_write(struct flash_bank *bank, const uint8_t *buffer, uint32_t of
 			return retval;
 
 		/* replace only bytes that must be written */
-		for (i = align; (i < bank->bus_width) && (count > 0); i++, count--)
-			current_word[i] = *buffer++;
+		for (i = align;
+		     (i < bank->bus_width) && (count > 0);
+		     i++, count--)
+			if (cfi_info->data_swap)
+				/* data bytes are swapped (reverse endianness) */
+				current_word[bank->bus_width - i] = *buffer++;
+			else
+				current_word[i] = *buffer++;
 
 		retval = cfi_write_word(bank, current_word, write_p);
 		if (retval != ERROR_OK)
@@ -2357,6 +2377,22 @@ static int cfi_write(struct flash_bank *bank, const uint8_t *buffer, uint32_t of
 		write_p += bank->bus_width;
 	}
 
+	if (cfi_info->data_swap && count) {
+		swapped_buffer = malloc(count & ~(bank->bus_width - 1));
+		switch (bank->bus_width) {
+		case 2:
+			buf_bswap16(swapped_buffer, buffer,
+				    count & ~(bank->bus_width - 1));
+			break;
+		case 4:
+			buf_bswap32(swapped_buffer, buffer,
+				    count & ~(bank->bus_width - 1));
+			break;
+		}
+		real_buffer = buffer;
+		buffer = swapped_buffer;
+	}
+
 	/* handle blocks of bus_size aligned bytes */
 	blk_count = count & ~(bank->bus_width - 1);	/* round down, leave tail bytes */
 	switch (cfi_info->pri_id) {
@@ -2426,6 +2462,11 @@ static int cfi_write(struct flash_bank *bank, const uint8_t *buffer, uint32_t of
 			return retval;
 	}
 
+	if (swapped_buffer) {
+		buffer = real_buffer + (buffer - swapped_buffer);
+		free(swapped_buffer);
+	}
+
 	/* return to read array mode, so we can read from flash again for padding */
 	retval = cfi_reset(bank);
 	if (retval != ERROR_OK)
@@ -2442,7 +2483,11 @@ static int cfi_write(struct flash_bank *bank, const uint8_t *buffer, uint32_t of
 
 		/* replace only bytes that must be written */
 		for (i = 0; (i < bank->bus_width) && (count > 0); i++, count--)
-			current_word[i] = *buffer++;
+			if (cfi_info->data_swap)
+				/* data bytes are swapped (reverse endianness) */
+				current_word[bank->bus_width - i] = *buffer++;
+			else
+				current_word[i] = *buffer++;
 
 		retval = cfi_write_word(bank, current_word, write_p);
 		if (retval != ERROR_OK)
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index d92fcc0b..ed858a9d 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef CFI_H
-#define CFI_H
+#ifndef OPENOCD_FLASH_NOR_CFI_H
+#define OPENOCD_FLASH_NOR_CFI_H
 
 #define CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7 0xE0 /* DQ5..DQ7 */
 #define CFI_STATUS_POLL_MASK_DQ6_DQ7     0xC0 /* DQ6..DQ7 */
@@ -30,6 +28,9 @@ struct cfi_flash_bank {
 	int not_cfi;
 	int probed;
 
+	enum target_endianness endianness;
+	int data_swap;
+
 	uint16_t manufacturer;
 	uint16_t device_id;
 
@@ -159,4 +160,4 @@ struct cfi_fixup {
 #define CFI_MFR_ANY		0xffff
 #define CFI_ID_ANY		0xffff
 
-#endif /* CFI_H */
+#endif /* OPENOCD_FLASH_NOR_CFI_H */
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 4410d5c6..ab69a328 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -52,10 +50,17 @@ int flash_driver_erase(struct flash_bank *bank, int first, int last)
 int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 {
 	int retval;
+	int num_blocks;
+
+	if (bank->num_prot_blocks)
+		num_blocks = bank->num_prot_blocks;
+	else
+		num_blocks = bank->num_sectors;
+
 
 	/* callers may not supply illegal parameters ... */
-	if (first < 0 || first > last || last >= bank->num_sectors) {
-		LOG_ERROR("illegal sector range");
+	if (first < 0 || first > last || last >= num_blocks) {
+		LOG_ERROR("illegal protection block range");
 		return ERROR_FAIL;
 	}
 
@@ -71,11 +76,11 @@ int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 	 * the target could have reset, power cycled, been hot plugged,
 	 * the application could have run, etc.
 	 *
-	 * Drivers only receive valid sector range.
+	 * Drivers only receive valid protection block range.
 	 */
 	retval = bank->driver->protect(bank, set, first, last);
 	if (retval != ERROR_OK)
-		LOG_ERROR("failed setting protection for areas %d to %d", first, last);
+		LOG_ERROR("failed setting protection for blocks %d to %d", first, last);
 
 	return retval;
 }
@@ -290,7 +295,7 @@ static int default_flash_mem_blank_check(struct flash_bank *bank)
 				goto done;
 
 			for (nBytes = 0; nBytes < chunk; nBytes++) {
-				if (buffer[nBytes] != 0xFF) {
+				if (buffer[nBytes] != bank->erased_value) {
 					bank->sectors[i].is_erased = 0;
 					break;
 				}
@@ -321,12 +326,12 @@ int default_flash_blank_check(struct flash_bank *bank)
 		uint32_t address = bank->base + bank->sectors[i].offset;
 		uint32_t size = bank->sectors[i].size;
 
-		retval = target_blank_check_memory(target, address, size, &blank);
+		retval = target_blank_check_memory(target, address, size, &blank, bank->erased_value);
 		if (retval != ERROR_OK) {
 			fast_check = 0;
 			break;
 		}
-		if (blank == 0xFF)
+		if (blank == bank->erased_value)
 			bank->sectors[i].is_erased = 1;
 		else
 			bank->sectors[i].is_erased = 0;
@@ -345,8 +350,9 @@ int default_flash_blank_check(struct flash_bank *bank)
  * and address.  Maps an address range to a set of sectors, and issues
  * the callback() on that set ... e.g. to erase or unprotect its members.
  *
- * (Note a current bad assumption:  that protection operates on the same
- * size sectors as erase operations use.)
+ * Parameter iterate_protect_blocks switches iteration of protect block
+ * instead of erase sectors. If there is no protect blocks array, sectors
+ * are used in iteration, so compatibility for old flash drivers is retained.
  *
  * The "pad_reason" parameter is a kind of boolean:  when it's NULL, the
  * range must fit those sectors exactly.  This is clearly safe; it can't
@@ -357,13 +363,16 @@ int default_flash_blank_check(struct flash_bank *bank)
  */
 static int flash_iterate_address_range_inner(struct target *target,
 	char *pad_reason, uint32_t addr, uint32_t length,
+	bool iterate_protect_blocks,
 	int (*callback)(struct flash_bank *bank, int first, int last))
 {
 	struct flash_bank *c;
+	struct flash_sector *block_array;
 	uint32_t last_addr = addr + length;	/* first address AFTER end */
 	int first = -1;
 	int last = -1;
 	int i;
+	int num_blocks;
 
 	int retval = get_flash_bank_by_addr(target, addr, true, &c);
 	if (retval != ERROR_OK)
@@ -390,13 +399,21 @@ static int flash_iterate_address_range_inner(struct target *target,
 		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
 	}
 
-	/** @todo: handle erasures that cross into adjacent banks */
-
 	addr -= c->base;
 	last_addr -= c->base;
 
-	for (i = 0; i < c->num_sectors; i++) {
-		struct flash_sector *f = c->sectors + i;
+	if (iterate_protect_blocks && c->prot_blocks && c->num_prot_blocks) {
+		block_array = c->prot_blocks;
+		num_blocks = c->num_prot_blocks;
+	} else {
+		block_array = c->sectors;
+		num_blocks = c->num_sectors;
+		iterate_protect_blocks = false;
+	}
+
+
+	for (i = 0; i < num_blocks; i++) {
+		struct flash_sector *f = &block_array[i];
 		uint32_t end = f->offset + f->size;
 
 		/* start only on a sector boundary */
@@ -474,6 +491,7 @@ static int flash_iterate_address_range_inner(struct target *target,
  */
 static int flash_iterate_address_range(struct target *target,
 	char *pad_reason, uint32_t addr, uint32_t length,
+	bool iterate_protect_blocks,
 	int (*callback)(struct flash_bank *bank, int first, int last))
 {
 	struct flash_bank *c;
@@ -493,6 +511,7 @@ static int flash_iterate_address_range(struct target *target,
 		}
 		retval = flash_iterate_address_range_inner(target,
 				pad_reason, addr, cur_length,
+				iterate_protect_blocks,
 				callback);
 		if (retval != ERROR_OK)
 			break;
@@ -508,7 +527,7 @@ int flash_erase_address_range(struct target *target,
 	bool pad, uint32_t addr, uint32_t length)
 {
 	return flash_iterate_address_range(target, pad ? "erase" : NULL,
-		addr, length, &flash_driver_erase);
+		addr, length, false, &flash_driver_erase);
 }
 
 static int flash_driver_unprotect(struct flash_bank *bank, int first, int last)
@@ -523,7 +542,7 @@ int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t le
 	 * and doesn't restore it.
 	 */
 	return flash_iterate_address_range(target, "unprotect",
-		addr, length, &flash_driver_unprotect);
+		addr, length, true, &flash_driver_unprotect);
 }
 
 static int compare_section(const void *a, const void *b)
@@ -764,3 +783,22 @@ int flash_write(struct target *target, struct image *image,
 {
 	return flash_write_unlock(target, image, written, erase, false);
 }
+
+struct flash_sector *alloc_block_array(uint32_t offset, uint32_t size, int num_blocks)
+{
+	int i;
+
+	struct flash_sector *array = calloc(num_blocks, sizeof(struct flash_sector));
+	if (array == NULL)
+		return NULL;
+
+	for (i = 0; i < num_blocks; i++) {
+		array[i].offset = offset;
+		array[i].size = size;
+		array[i].is_erased = -1;
+		array[i].is_protected = -1;
+		offset += size;
+	}
+
+	return array;
+}
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 726dd957..338363e2 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NOR_CORE_H
-#define FLASH_NOR_CORE_H
+#ifndef OPENOCD_FLASH_NOR_CORE_H
+#define OPENOCD_FLASH_NOR_CORE_H
 
 #include <flash/common.h>
 
@@ -48,6 +46,8 @@ struct flash_sector {
 	/**
 	 * Indication of erasure status: 0 = not erased, 1 = erased,
 	 * other = unknown.  Set by @c flash_driver_s::erase_check.
+	 *
+	 * Flag is not used in protection block
 	 */
 	int is_erased;
 	/**
@@ -58,6 +58,9 @@ struct flash_sector {
 	 * This information must be considered stale immediately.
 	 * A million things could make it stale: power cycle,
 	 * reset of target, code running on target, etc.
+	 *
+	 * If a flash_bank uses an extra array of protection blocks,
+	 * protection flag is not valid in sector array
 	 */
 	int is_protected;
 };
@@ -87,6 +90,9 @@ struct flash_bank {
 	int chip_width; /**< Width of the chip in bytes (1,2,4 bytes) */
 	int bus_width; /**< Maximum bus width, in bytes (1,2,4 bytes) */
 
+	/** Erased value. Defaults to 0xFF. */
+	uint8_t erased_value;
+
 	/** Default padded value used, normally this matches the  flash
 	 * erased value. Defaults to 0xFF. */
 	uint8_t default_padded_value;
@@ -97,9 +103,19 @@ struct flash_bank {
 	 * some non-zero value during "probe()" or "auto_probe()".
 	 */
 	int num_sectors;
-	/** Array of sectors, allocated and initilized by the flash driver */
+	/** Array of sectors, allocated and initialized by the flash driver */
 	struct flash_sector *sectors;
 
+	/**
+	 * The number of protection blocks in this bank. This value
+	 * is set intially to 0 and sectors are used as protection blocks.
+	 * Driver probe can set protection blocks array to work with
+	 * protection granularity different than sector size.
+	 */
+	int num_prot_blocks;
+	/** Array of protection blocks, allocated and initilized by the flash driver */
+	struct flash_sector *prot_blocks;
+
 	struct flash_bank *next; /**< The next flash bank on this chip */
 };
 
@@ -207,5 +223,13 @@ struct flash_bank *get_flash_bank_by_num_noprobe(int num);
  */
 int get_flash_bank_by_addr(struct target *target, uint32_t addr, bool check,
 		struct flash_bank **result_bank);
+/**
+ * Allocate and fill an array of sectors or protection blocks.
+ * @param offset Offset of first block.
+ * @param size Size of each block.
+ * @param num_blocks Number of blocks in array.
+ * @returns A struct flash_sector pointer or NULL when allocation failed.
+ */
+struct flash_sector *alloc_block_array(uint32_t offset, uint32_t size, int num_blocks);
 
-#endif /* FLASH_NOR_CORE_H */
+#endif /* OPENOCD_FLASH_NOR_CORE_H */
diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
index 8f2e1cc2..0ae4d8e2 100644
--- a/src/flash/nor/driver.h
+++ b/src/flash/nor/driver.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NOR_DRIVER_H
-#define FLASH_NOR_DRIVER_H
+#ifndef OPENOCD_FLASH_NOR_DRIVER_H
+#define OPENOCD_FLASH_NOR_DRIVER_H
 
 struct flash_bank;
 
@@ -223,4 +221,4 @@ struct flash_driver {
  */
 struct flash_driver *flash_driver_find_by_name(const char *name);
 
-#endif /* FLASH_NOR_DRIVER_H */
+#endif /* OPENOCD_FLASH_NOR_DRIVER_H */
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 48d584ee..9594ed9a 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -22,96 +20,108 @@
 #endif
 #include "imp.h"
 
-extern struct flash_driver lpc2000_flash;
-extern struct flash_driver lpc288x_flash;
-extern struct flash_driver lpc2900_flash;
-extern struct flash_driver lpcspifi_flash;
-extern struct flash_driver cfi_flash;
+extern struct flash_driver aduc702x_flash;
+extern struct flash_driver aducm360_flash;
+extern struct flash_driver ambiqmicro_flash;
 extern struct flash_driver at91sam3_flash;
 extern struct flash_driver at91sam4_flash;
 extern struct flash_driver at91sam4l_flash;
-extern struct flash_driver at91samd_flash;
 extern struct flash_driver at91sam7_flash;
+extern struct flash_driver at91samd_flash;
+extern struct flash_driver ath79_flash;
 extern struct flash_driver atsamv_flash;
-extern struct flash_driver str7x_flash;
-extern struct flash_driver str9x_flash;
-extern struct flash_driver aduc702x_flash;
-extern struct flash_driver aducm360_flash;
-extern struct flash_driver stellaris_flash;
-extern struct flash_driver str9xpec_flash;
-extern struct flash_driver stm32f1x_flash;
-extern struct flash_driver stm32f2x_flash;
-extern struct flash_driver stm32lx_flash;
-extern struct flash_driver stm32l4x_flash;
-extern struct flash_driver tms470_flash;
-extern struct flash_driver ocl_flash;
-extern struct flash_driver pic32mx_flash;
 extern struct flash_driver avr_flash;
-extern struct flash_driver faux_flash;
-extern struct flash_driver virtual_flash;
-extern struct flash_driver stmsmi_flash;
-extern struct flash_driver em357_flash;
+extern struct flash_driver cfi_flash;
 extern struct flash_driver dsp5680xx_flash;
+extern struct flash_driver efm32_flash;
+extern struct flash_driver em357_flash;
+extern struct flash_driver faux_flash;
 extern struct flash_driver fm3_flash;
+extern struct flash_driver fm4_flash;
+extern struct flash_driver jtagspi_flash;
 extern struct flash_driver kinetis_flash;
-extern struct flash_driver efm32_flash;
+extern struct flash_driver kinetis_ke_flash;
+extern struct flash_driver lpc2000_flash;
+extern struct flash_driver lpc288x_flash;
+extern struct flash_driver lpc2900_flash;
+extern struct flash_driver lpcspifi_flash;
 extern struct flash_driver mdr_flash;
-extern struct flash_driver numicro_flash;
-extern struct flash_driver nrf51_flash;
 extern struct flash_driver mrvlqspi_flash;
+extern struct flash_driver niietcm4_flash;
+extern struct flash_driver nrf5_flash;
+extern struct flash_driver nrf51_flash;
+extern struct flash_driver numicro_flash;
+extern struct flash_driver ocl_flash;
+extern struct flash_driver pic32mx_flash;
 extern struct flash_driver psoc4_flash;
 extern struct flash_driver sim3x_flash;
-extern struct flash_driver jtagspi_flash;
+extern struct flash_driver stellaris_flash;
+extern struct flash_driver stm32f1x_flash;
+extern struct flash_driver stm32f2x_flash;
+extern struct flash_driver stm32lx_flash;
+extern struct flash_driver stm32l4x_flash;
+extern struct flash_driver stmsmi_flash;
+extern struct flash_driver str7x_flash;
+extern struct flash_driver str9x_flash;
+extern struct flash_driver str9xpec_flash;
+extern struct flash_driver tms470_flash;
+extern struct flash_driver virtual_flash;
+extern struct flash_driver xmc1xxx_flash;
 extern struct flash_driver xmc4xxx_flash;
-extern struct flash_driver niietcm4_flash;
 
 /**
  * The list of built-in flash drivers.
  * @todo Make this dynamically extendable with loadable modules.
  */
 static struct flash_driver *flash_drivers[] = {
-	&lpc2000_flash,
-	&lpc288x_flash,
-	&lpc2900_flash,
-	&lpcspifi_flash,
-	&cfi_flash,
-	&at91sam7_flash,
+	&aduc702x_flash,
+	&aducm360_flash,
+	&ambiqmicro_flash,
 	&at91sam3_flash,
 	&at91sam4_flash,
 	&at91sam4l_flash,
+	&at91sam7_flash,
 	&at91samd_flash,
+	&ath79_flash,
 	&atsamv_flash,
-	&str7x_flash,
-	&str9x_flash,
-	&aduc702x_flash,
-	&aducm360_flash,
-	&stellaris_flash,
-	&str9xpec_flash,
-	&stm32f1x_flash,
-	&stm32f2x_flash,
-	&stm32lx_flash,
-	&stm32l4x_flash,
-	&tms470_flash,
-	&ocl_flash,
-	&pic32mx_flash,
 	&avr_flash,
-	&faux_flash,
-	&virtual_flash,
-	&stmsmi_flash,
+	&cfi_flash,
+	&dsp5680xx_flash,
+	&efm32_flash,
 	&em357_flash,
+	&faux_flash,
 	&fm3_flash,
-	&dsp5680xx_flash,
+	&fm4_flash,
+	&jtagspi_flash,
 	&kinetis_flash,
-	&efm32_flash,
+	&kinetis_ke_flash,
+	&lpc2000_flash,
+	&lpc288x_flash,
+	&lpc2900_flash,
+	&lpcspifi_flash,
 	&mdr_flash,
-	&numicro_flash,
-	&nrf51_flash,
 	&mrvlqspi_flash,
+	&niietcm4_flash,
+	&nrf5_flash,
+	&nrf51_flash,
+	&numicro_flash,
+	&ocl_flash,
+	&pic32mx_flash,
 	&psoc4_flash,
 	&sim3x_flash,
-	&jtagspi_flash,
+	&stellaris_flash,
+	&stm32f1x_flash,
+	&stm32f2x_flash,
+	&stm32lx_flash,
+	&stm32l4x_flash,
+	&stmsmi_flash,
+	&str7x_flash,
+	&str9x_flash,
+	&str9xpec_flash,
+	&tms470_flash,
+	&virtual_flash,
+	&xmc1xxx_flash,
 	&xmc4xxx_flash,
-	&niietcm4_flash,
 	NULL,
 };
 
diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 693ff487..38649ff0 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -18,9 +18,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /**
diff --git a/src/flash/nor/efm32.c b/src/flash/nor/efm32.c
index d268bea4..b8453e1d 100644
--- a/src/flash/nor/efm32.c
+++ b/src/flash/nor/efm32.c
@@ -25,9 +25,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -50,6 +48,9 @@
 #define EFM_FAMILY_ID_HAPPY_GECKO	77
 #define EZR_FAMILY_ID_WONDER_GECKO		120
 #define EZR_FAMILY_ID_LEOPARD_GECKO		121
+#define EZR_FAMILY_ID_HAPPY_GECKO               122
+#define EFR_FAMILY_ID_MIGHTY_GECKO	16
+#define EFR_FAMILY_ID_BLUE_GECKO	20
 
 #define EFM32_FLASH_ERASE_TMO           100
 #define EFM32_FLASH_WDATAREADY_TMO      100
@@ -73,27 +74,31 @@
 #define EFM32_MSC_DI_PROD_REV           (EFM32_MSC_DEV_INFO+0x1ff)
 
 #define EFM32_MSC_REGBASE               0x400c0000
-#define EFM32_MSC_WRITECTRL             (EFM32_MSC_REGBASE+0x008)
+#define EFR32_MSC_REGBASE               0x400e0000
+#define EFM32_MSC_REG_WRITECTRL         0x008
 #define EFM32_MSC_WRITECTRL_WREN_MASK   0x1
-#define EFM32_MSC_WRITECMD              (EFM32_MSC_REGBASE+0x00c)
+#define EFM32_MSC_REG_WRITECMD          0x00c
 #define EFM32_MSC_WRITECMD_LADDRIM_MASK 0x1
 #define EFM32_MSC_WRITECMD_ERASEPAGE_MASK 0x2
 #define EFM32_MSC_WRITECMD_WRITEONCE_MASK 0x8
-#define EFM32_MSC_ADDRB                 (EFM32_MSC_REGBASE+0x010)
-#define EFM32_MSC_WDATA                 (EFM32_MSC_REGBASE+0x018)
-#define EFM32_MSC_STATUS                (EFM32_MSC_REGBASE+0x01c)
+#define EFM32_MSC_REG_ADDRB             0x010
+#define EFM32_MSC_REG_WDATA             0x018
+#define EFM32_MSC_REG_STATUS            0x01c
 #define EFM32_MSC_STATUS_BUSY_MASK      0x1
 #define EFM32_MSC_STATUS_LOCKED_MASK    0x2
 #define EFM32_MSC_STATUS_INVADDR_MASK   0x4
 #define EFM32_MSC_STATUS_WDATAREADY_MASK 0x8
 #define EFM32_MSC_STATUS_WORDTIMEOUT_MASK 0x10
 #define EFM32_MSC_STATUS_ERASEABORTED_MASK 0x20
-#define EFM32_MSC_LOCK                  (EFM32_MSC_REGBASE+0x03c)
+#define EFM32_MSC_REG_LOCK              0x03c
+#define EFR32_MSC_REG_LOCK              0x040
 #define EFM32_MSC_LOCK_LOCKKEY          0x1b71
 
 struct efm32x_flash_bank {
 	int probed;
 	uint32_t lb_page[LOCKBITS_PAGE_SZ/4];
+	uint32_t reg_base;
+	uint32_t reg_lock;
 };
 
 struct efm32_info {
@@ -133,11 +138,30 @@ static int efm32x_get_prod_rev(struct flash_bank *bank, uint8_t *prev)
 	return target_read_u8(bank->target, EFM32_MSC_DI_PROD_REV, prev);
 }
 
+static int efm32x_read_reg_u32(struct flash_bank *bank, target_addr_t offset,
+			       uint32_t *value)
+{
+	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	uint32_t base = efm32x_info->reg_base;
+
+	return target_read_u32(bank->target, base + offset, value);
+}
+
+static int efm32x_write_reg_u32(struct flash_bank *bank, target_addr_t offset,
+			       uint32_t value)
+{
+	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	uint32_t base = efm32x_info->reg_base;
+
+	return target_write_u32(bank->target, base + offset, value);
+}
+
 static int efm32x_read_info(struct flash_bank *bank,
 	struct efm32_info *efm32_info)
 {
 	int ret;
 	uint32_t cpuid = 0;
+	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
 
 	memset(efm32_info, 0, sizeof(struct efm32_info));
 
@@ -146,11 +170,11 @@ static int efm32x_read_info(struct flash_bank *bank,
 		return ret;
 
 	if (((cpuid >> 4) & 0xfff) == 0xc23) {
-		/* Cortex M3 device */
+		/* Cortex-M3 device */
 	} else if (((cpuid >> 4) & 0xfff) == 0xc24) {
-		/* Cortex M4 device(WONDER GECKO) */
+		/* Cortex-M4 device (WONDER GECKO) */
 	} else if (((cpuid >> 4) & 0xfff) == 0xc60) {
-		/* Cortex M0plus device */
+		/* Cortex-M0+ device */
 	} else {
 		LOG_ERROR("Target is not Cortex-Mx Device");
 		return ERROR_FAIL;
@@ -176,11 +200,21 @@ static int efm32x_read_info(struct flash_bank *bank,
 	if (ERROR_OK != ret)
 		return ret;
 
+	if (EFR_FAMILY_ID_BLUE_GECKO == efm32_info->part_family ||
+	    EFR_FAMILY_ID_MIGHTY_GECKO == efm32_info->part_family) {
+		efm32x_info->reg_base = EFR32_MSC_REGBASE;
+		efm32x_info->reg_lock = EFR32_MSC_REG_LOCK;
+	} else {
+		efm32x_info->reg_base = EFM32_MSC_REGBASE;
+		efm32x_info->reg_lock = EFM32_MSC_REG_LOCK;
+	}
+
 	if (EFM_FAMILY_ID_GECKO == efm32_info->part_family ||
 			EFM_FAMILY_ID_TINY_GECKO == efm32_info->part_family)
 		efm32_info->page_size = 512;
 	else if (EFM_FAMILY_ID_ZERO_GECKO == efm32_info->part_family ||
-			EFM_FAMILY_ID_HAPPY_GECKO == efm32_info->part_family)
+			EFM_FAMILY_ID_HAPPY_GECKO == efm32_info->part_family ||
+			EZR_FAMILY_ID_HAPPY_GECKO == efm32_info->part_family)
 		efm32_info->page_size = 1024;
 	else if (EFM_FAMILY_ID_GIANT_GECKO == efm32_info->part_family ||
 			EFM_FAMILY_ID_LEOPARD_GECKO == efm32_info->part_family) {
@@ -208,7 +242,9 @@ static int efm32x_read_info(struct flash_bank *bank,
 		}
 	} else if (EFM_FAMILY_ID_WONDER_GECKO == efm32_info->part_family ||
 			EZR_FAMILY_ID_WONDER_GECKO == efm32_info->part_family ||
-			EZR_FAMILY_ID_LEOPARD_GECKO == efm32_info->part_family) {
+			EZR_FAMILY_ID_LEOPARD_GECKO == efm32_info->part_family ||
+			EFR_FAMILY_ID_BLUE_GECKO == efm32_info->part_family ||
+			EFR_FAMILY_ID_MIGHTY_GECKO == efm32_info->part_family) {
 		uint8_t pg_size = 0;
 		ret = target_read_u8(bank->target, EFM32_MSC_DI_PAGE_SIZE,
 			&pg_size);
@@ -238,8 +274,13 @@ static int efm32x_decode_info(struct efm32_info *info, char *buf, int buf_size)
 	switch (info->part_family) {
 		case EZR_FAMILY_ID_WONDER_GECKO:
 		case EZR_FAMILY_ID_LEOPARD_GECKO:
+		case EZR_FAMILY_ID_HAPPY_GECKO:
 			printed = snprintf(buf, buf_size, "EZR32 ");
 			break;
+		case EFR_FAMILY_ID_MIGHTY_GECKO:
+		case EFR_FAMILY_ID_BLUE_GECKO:
+			printed = snprintf(buf, buf_size, "EFR32 ");
+			break;
 		default:
 			printed = snprintf(buf, buf_size, "EFM32 ");
 	}
@@ -272,8 +313,15 @@ static int efm32x_decode_info(struct efm32_info *info, char *buf, int buf_size)
 			printed = snprintf(buf, buf_size, "Zero Gecko");
 			break;
 		case EFM_FAMILY_ID_HAPPY_GECKO:
+		case EZR_FAMILY_ID_HAPPY_GECKO:
 			printed = snprintf(buf, buf_size, "Happy Gecko");
 			break;
+		case EFR_FAMILY_ID_BLUE_GECKO:
+			printed = snprintf(buf, buf_size, "Blue Gecko");
+			break;
+		case EFR_FAMILY_ID_MIGHTY_GECKO:
+			printed = snprintf(buf, buf_size, "Mighty Gecko");
+			break;
 	}
 
 	buf += printed;
@@ -317,7 +365,7 @@ static int efm32x_set_reg_bits(struct flash_bank *bank, uint32_t reg,
 	int ret = 0;
 	uint32_t reg_val = 0;
 
-	ret = target_read_u32(bank->target, reg, &reg_val);
+	ret = efm32x_read_reg_u32(bank, reg, &reg_val);
 	if (ERROR_OK != ret)
 		return ret;
 
@@ -326,18 +374,19 @@ static int efm32x_set_reg_bits(struct flash_bank *bank, uint32_t reg,
 	else
 		reg_val &= ~bitmask;
 
-	return target_write_u32(bank->target, reg, reg_val);
+	return efm32x_write_reg_u32(bank, reg, reg_val);
 }
 
 static int efm32x_set_wren(struct flash_bank *bank, int write_enable)
 {
-	return efm32x_set_reg_bits(bank, EFM32_MSC_WRITECTRL,
+	return efm32x_set_reg_bits(bank, EFM32_MSC_REG_WRITECTRL,
 		EFM32_MSC_WRITECTRL_WREN_MASK, write_enable);
 }
 
 static int efm32x_msc_lock(struct flash_bank *bank, int lock)
 {
-	return target_write_u32(bank->target, EFM32_MSC_LOCK,
+	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+	return efm32x_write_reg_u32(bank, efm32x_info->reg_lock,
 		(lock ? 0 : EFM32_MSC_LOCK_LOCKKEY));
 }
 
@@ -348,7 +397,7 @@ static int efm32x_wait_status(struct flash_bank *bank, int timeout,
 	uint32_t status = 0;
 
 	while (1) {
-		ret = target_read_u32(bank->target, EFM32_MSC_STATUS, &status);
+		ret = efm32x_read_reg_u32(bank, EFM32_MSC_REG_STATUS, &status);
 		if (ERROR_OK != ret)
 			break;
 
@@ -387,16 +436,16 @@ static int efm32x_erase_page(struct flash_bank *bank, uint32_t addr)
 
 	LOG_DEBUG("erasing flash page at 0x%08" PRIx32, addr);
 
-	ret = target_write_u32(bank->target, EFM32_MSC_ADDRB, addr);
+	ret = efm32x_write_reg_u32(bank, EFM32_MSC_REG_ADDRB, addr);
 	if (ERROR_OK != ret)
 		return ret;
 
-	ret = efm32x_set_reg_bits(bank, EFM32_MSC_WRITECMD,
+	ret = efm32x_set_reg_bits(bank, EFM32_MSC_REG_WRITECMD,
 		EFM32_MSC_WRITECMD_LADDRIM_MASK, 1);
 	if (ERROR_OK != ret)
 		return ret;
 
-	ret = target_read_u32(bank->target, EFM32_MSC_STATUS, &status);
+	ret = efm32x_read_reg_u32(bank, EFM32_MSC_REG_STATUS, &status);
 	if (ERROR_OK != ret)
 		return ret;
 
@@ -410,7 +459,7 @@ static int efm32x_erase_page(struct flash_bank *bank, uint32_t addr)
 		return ERROR_FAIL;
 	}
 
-	ret = efm32x_set_reg_bits(bank, EFM32_MSC_WRITECMD,
+	ret = efm32x_set_reg_bits(bank, EFM32_MSC_REG_WRITECMD,
 		EFM32_MSC_WRITECMD_ERASEPAGE_MASK, 1);
 	if (ERROR_OK != ret)
 		return ret;
@@ -458,10 +507,10 @@ static int efm32x_read_lock_data(struct flash_bank *bank)
 	uint32_t *ptr = NULL;
 	int ret = 0;
 
-	assert(!(bank->num_sectors & 0x1f));
+	assert(bank->num_sectors > 0);
 
-	data_size = bank->num_sectors / 8; /* number of data bytes */
-	data_size /= 4; /* ...and data dwords */
+	/* calculate the number of 32-bit words to read (one lock bit per sector) */
+	data_size = (bank->num_sectors + 31) / 32;
 
 	ptr = efm32x_info->lb_page;
 
@@ -587,6 +636,7 @@ static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
 	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[5];
 	struct armv7m_algorithm armv7m_info;
+	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
 	int ret = ERROR_OK;
 
 	/* see contrib/loaders/flash/efm32.S for src */
@@ -596,10 +646,7 @@ static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
 		/* #define EFM32_MSC_ADDRB_OFFSET          0x010 */
 		/* #define EFM32_MSC_WDATA_OFFSET          0x018 */
 		/* #define EFM32_MSC_STATUS_OFFSET         0x01c */
-		/* #define EFM32_MSC_LOCK_OFFSET           0x03c */
 
-			0x15, 0x4e,    /* ldr     r6, =#0x1b71 */
-			0xc6, 0x63,    /* str     r6, [r0, #EFM32_MSC_LOCK_OFFSET] */
 			0x01, 0x26,    /* movs    r6, #1 */
 			0x86, 0x60,    /* str     r6, [r0, #EFM32_MSC_WRITECTRL_OFFSET] */
 
@@ -658,17 +705,15 @@ static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
 		/* exit: */
 			0x30, 0x46,    /* mov     r0, r6 */
 			0x00, 0xbe,    /* bkpt    #0 */
-
-		/* LOCKKEY */
-			0x71, 0x1b, 0x00, 0x00
 	};
 
+
 	/* flash write code */
 	if (target_alloc_working_area(target, sizeof(efm32x_flash_write_code),
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	ret = target_write_buffer(target, write_algorithm->address,
 			sizeof(efm32x_flash_write_code), efm32x_flash_write_code);
@@ -687,7 +732,7 @@ static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
 			LOG_WARNING("no large enough working area available, can't do block memory writes");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-	};
+	}
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* flash base (in), status (out) */
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);	/* count (word-32bit) */
@@ -695,7 +740,7 @@ static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
 	init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);	/* buffer end */
 	init_reg_param(&reg_params[4], "r4", 32, PARAM_IN_OUT);	/* target address */
 
-	buf_set_u32(reg_params[0].value, 0, 32, EFM32_MSC_REGBASE);
+	buf_set_u32(reg_params[0].value, 0, 32, efm32x_info->reg_base);
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 	buf_set_u32(reg_params[2].value, 0, 32, source->address);
 	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
@@ -760,16 +805,16 @@ static int efm32x_write_word(struct flash_bank *bank, uint32_t addr,
 	/* if not called, GDB errors will be reported during large writes */
 	keep_alive();
 
-	ret = target_write_u32(bank->target, EFM32_MSC_ADDRB, addr);
+	ret = efm32x_write_reg_u32(bank, EFM32_MSC_REG_ADDRB, addr);
 	if (ERROR_OK != ret)
 		return ret;
 
-	ret = efm32x_set_reg_bits(bank, EFM32_MSC_WRITECMD,
+	ret = efm32x_set_reg_bits(bank, EFM32_MSC_REG_WRITECMD,
 		EFM32_MSC_WRITECMD_LADDRIM_MASK, 1);
 	if (ERROR_OK != ret)
 		return ret;
 
-	ret = target_read_u32(bank->target, EFM32_MSC_STATUS, &status);
+	ret = efm32x_read_reg_u32(bank, EFM32_MSC_REG_STATUS, &status);
 	if (ERROR_OK != ret)
 		return ret;
 
@@ -790,13 +835,13 @@ static int efm32x_write_word(struct flash_bank *bank, uint32_t addr,
 		return ret;
 	}
 
-	ret = target_write_u32(bank->target, EFM32_MSC_WDATA, val);
+	ret = efm32x_write_reg_u32(bank, EFM32_MSC_REG_WDATA, val);
 	if (ERROR_OK != ret) {
 		LOG_ERROR("WDATA write failed");
 		return ret;
 	}
 
-	ret = target_write_u32(bank->target, EFM32_MSC_WRITECMD,
+	ret = efm32x_write_reg_u32(bank, EFM32_MSC_REG_WRITECMD,
 		EFM32_MSC_WRITECMD_WRITEONCE_MASK);
 	if (ERROR_OK != ret) {
 		LOG_ERROR("WRITECMD write failed");
@@ -997,7 +1042,50 @@ static int get_efm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 	return efm32x_decode_info(&info, buf, buf_size);
 }
 
+COMMAND_HANDLER(efm32x_handle_debuglock_command)
+{
+	struct target *target = NULL;
+
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
+
+	target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	uint32_t *ptr;
+	ptr = efm32x_info->lb_page + 127;
+	*ptr = 0;
+
+	retval = efm32x_write_lock_data(bank);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Failed to write LB page");
+		return retval;
+	}
+
+	command_print(CMD_CTX, "efm32x debug interface locked, reset the device to apply");
+
+	return ERROR_OK;
+}
+
 static const struct command_registration efm32x_exec_command_handlers[] = {
+	{
+		.name = "debuglock",
+		.handler = efm32x_handle_debuglock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Lock the debug interface of the device.",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/flash/nor/em357.c b/src/flash/nor/em357.c
index 70a5431a..a11743b5 100644
--- a/src/flash/nor/em357.c
+++ b/src/flash/nor/em357.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -502,7 +500,6 @@ static int em357_write_block(struct flash_bank *bank, const uint8_t *buffer,
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
-	;
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(em357_flash_write_code), em357_flash_write_code);
@@ -705,6 +702,11 @@ static int em357_probe(struct flash_bank *bank)
 			num_pages = 128;
 			page_size = 2048;
 			break;
+		case 0x80000:
+			/* 512k -- 256 2k pages */
+			num_pages = 256;
+			page_size = 2048;
+			break;
 		default:
 			LOG_WARNING("No size specified for em357 flash driver, assuming 192k!");
 			num_pages = 96;
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index 1fd1da21..203eb6ff 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -50,7 +48,7 @@ FLASH_BANK_COMMAND_HANDLER(faux_flash_bank_command)
 		return ERROR_FAIL;
 	}
 	info->memory = malloc(bank->size);
-	if (info == NULL) {
+	if (info->memory == NULL) {
 		free(info);
 		LOG_ERROR("no memory for flash bank info");
 		return ERROR_FAIL;
diff --git a/src/flash/nor/fm3.c b/src/flash/nor/fm3.c
index 315f9d1f..d8f23a75 100644
--- a/src/flash/nor/fm3.c
+++ b/src/flash/nor/fm3.c
@@ -17,9 +17,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nor/fm4.c b/src/flash/nor/fm4.c
new file mode 100644
index 00000000..c8fe8b66
--- /dev/null
+++ b/src/flash/nor/fm4.c
@@ -0,0 +1,722 @@
+/*
+ * Spansion FM4 flash
+ *
+ * Copyright (c) 2015 Andreas Färber
+ *
+ * Based on S6E2DH_MN709-00013 for S6E2DH/DF/D5/D3 series
+ * Based on S6E2CC_MN709-00007 for S6E2CC/C5/C4/C3/C2/C1 series
+ * Based on MB9B560R_MN709-00005 for MB9BFx66/x67/x68 series
+ * Based on MB9B560L_MN709-00006 for MB9BFx64/x65/x66 series
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+
+#define FLASH_BASE 0x40000000
+#define FASZR   (FLASH_BASE + 0x000)
+#define DFCTRLR (FLASH_BASE + 0x030)
+#define DFCTRLR_DFE (1UL << 0)
+
+#define WDG_BASE 0x40011000
+#define WDG_CTL (WDG_BASE + 0x008)
+#define WDG_LCK (WDG_BASE + 0xC00)
+
+enum fm4_variant {
+	mb9bfx64,
+	mb9bfx65,
+	mb9bfx66,
+	mb9bfx67,
+	mb9bfx68,
+
+	s6e2cx8,
+	s6e2cx9,
+	s6e2cxa,
+
+	s6e2dx,
+};
+
+struct fm4_flash_bank {
+	enum fm4_variant variant;
+	int macro_nr;
+	bool probed;
+};
+
+static int fm4_disable_hw_watchdog(struct target *target)
+{
+	int retval;
+
+	retval = target_write_u32(target, WDG_LCK, 0x1ACCE551);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, WDG_LCK, 0xE5331AAE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, WDG_CTL, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int fm4_enter_flash_cpu_programming_mode(struct target *target)
+{
+	uint32_t u32_value;
+	int retval;
+
+	/* FASZR ASZ = CPU programming mode */
+	retval = target_write_u32(target, FASZR, 0x00000001);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_read_u32(target, FASZR, &u32_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int fm4_enter_flash_cpu_rom_mode(struct target *target)
+{
+	uint32_t u32_value;
+	int retval;
+
+	/* FASZR ASZ = CPU ROM mode */
+	retval = target_write_u32(target, FASZR, 0x00000002);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_read_u32(target, FASZR, &u32_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int fm4_flash_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	struct working_area *workarea;
+	struct reg_param reg_params[4];
+	struct armv7m_algorithm armv7m_algo;
+	unsigned i;
+	int retval, sector;
+	const uint8_t erase_sector_code[] = {
+#include "../../../contrib/loaders/flash/fm4/erase.inc"
+	};
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	LOG_DEBUG("Spansion FM4 erase sectors %d to %d", first, last);
+
+	retval = fm4_disable_hw_watchdog(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = fm4_enter_flash_cpu_programming_mode(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_alloc_working_area(target, sizeof(erase_sector_code),
+			&workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available.");
+		retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		goto err_alloc_code;
+	}
+	retval = target_write_buffer(target, workarea->address,
+			sizeof(erase_sector_code), erase_sector_code);
+	if (retval != ERROR_OK)
+		goto err_write_code;
+
+	armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_algo.core_mode = ARM_MODE_THREAD;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN);
+
+	for (sector = first; sector <= last; sector++) {
+		uint32_t addr = bank->base + bank->sectors[sector].offset;
+		uint32_t result;
+
+		buf_set_u32(reg_params[0].value, 0, 32, (addr & ~0xffff) | 0xAA8);
+		buf_set_u32(reg_params[1].value, 0, 32, (addr & ~0xffff) | 0x554);
+		buf_set_u32(reg_params[2].value, 0, 32, addr);
+
+		retval = target_run_algorithm(target,
+				0, NULL,
+				ARRAY_SIZE(reg_params), reg_params,
+				workarea->address, 0,
+				1000, &armv7m_algo);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Error executing flash sector erase "
+				"programming algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run;
+		}
+
+		result = buf_get_u32(reg_params[3].value, 0, 32);
+		if (result == 2) {
+			LOG_ERROR("Timeout error from flash sector erase programming algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run_ret;
+		} else if (result != 0) {
+			LOG_ERROR("Unexpected error %d from flash sector erase programming algorithm", result);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run_ret;
+		} else
+			retval = ERROR_OK;
+
+		bank->sectors[sector].is_erased = 1;
+	}
+
+err_run_ret:
+err_run:
+	for (i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
+
+err_write_code:
+	target_free_working_area(target, workarea);
+
+err_alloc_code:
+	if (retval != ERROR_OK)
+		fm4_enter_flash_cpu_rom_mode(target);
+	else
+		retval = fm4_enter_flash_cpu_rom_mode(target);
+
+	return retval;
+}
+
+static int fm4_flash_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t byte_count)
+{
+	struct target *target = bank->target;
+	struct working_area *code_workarea, *data_workarea;
+	struct reg_param reg_params[6];
+	struct armv7m_algorithm armv7m_algo;
+	uint32_t halfword_count = DIV_ROUND_UP(byte_count, 2);
+	uint32_t result;
+	unsigned i;
+	int retval;
+	const uint8_t write_block_code[] = {
+#include "../../../contrib/loaders/flash/fm4/write.inc"
+	};
+
+	LOG_DEBUG("Spansion FM4 write at 0x%08" PRIx32 " (%" PRId32 " bytes)",
+		offset, byte_count);
+
+	if (offset & 0x1) {
+		LOG_ERROR("offset 0x%" PRIx32 " breaks required 2-byte alignment",
+			offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+	if (byte_count & 0x1) {
+		LOG_WARNING("length %" PRId32 " is not 2-byte aligned, rounding up",
+			byte_count);
+	}
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = fm4_disable_hw_watchdog(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_alloc_working_area(target, sizeof(write_block_code),
+			&code_workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available for write code.");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+	retval = target_write_buffer(target, code_workarea->address,
+			sizeof(write_block_code), write_block_code);
+	if (retval != ERROR_OK)
+		goto err_write_code;
+
+	retval = target_alloc_working_area(target,
+		MIN(halfword_count * 2, target_get_working_area_avail(target)),
+		&data_workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available for write data.");
+		retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		goto err_alloc_data;
+	}
+
+	armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_algo.core_mode = ARM_MODE_THREAD;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
+	init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
+	init_reg_param(&reg_params[5], "r5", 32, PARAM_IN);
+
+	retval = fm4_enter_flash_cpu_programming_mode(target);
+	if (retval != ERROR_OK)
+		goto err_flash_mode;
+
+	while (byte_count > 0) {
+		uint32_t halfwords = MIN(halfword_count, data_workarea->size / 2);
+		uint32_t addr = bank->base + offset;
+
+		LOG_DEBUG("copying %" PRId32 " bytes to SRAM 0x%08" TARGET_PRIxADDR,
+			MIN(halfwords * 2, byte_count), data_workarea->address);
+
+		retval = target_write_buffer(target, data_workarea->address,
+			MIN(halfwords * 2, byte_count), buffer);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Error writing data buffer");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_write_data;
+		}
+
+		LOG_DEBUG("writing 0x%08" PRIx32 "-0x%08" PRIx32 " (%" PRId32 "x)",
+			addr, addr + halfwords * 2 - 1, halfwords);
+
+		buf_set_u32(reg_params[0].value, 0, 32, (addr & ~0xffff) | 0xAA8);
+		buf_set_u32(reg_params[1].value, 0, 32, (addr & ~0xffff) | 0x554);
+		buf_set_u32(reg_params[2].value, 0, 32, addr);
+		buf_set_u32(reg_params[3].value, 0, 32, data_workarea->address);
+		buf_set_u32(reg_params[4].value, 0, 32, halfwords);
+
+		retval = target_run_algorithm(target,
+				0, NULL,
+				ARRAY_SIZE(reg_params), reg_params,
+				code_workarea->address, 0,
+				5 * 60 * 1000, &armv7m_algo);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Error executing flash sector erase "
+				"programming algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run;
+		}
+
+		result = buf_get_u32(reg_params[5].value, 0, 32);
+		if (result == 2) {
+			LOG_ERROR("Timeout error from flash write "
+				"programming algorithm");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run_ret;
+		} else if (result != 0) {
+			LOG_ERROR("Unexpected error %d from flash write "
+				"programming algorithm", result);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run_ret;
+		} else
+			retval = ERROR_OK;
+
+		halfword_count -= halfwords;
+		offset += halfwords * 2;
+		buffer += halfwords * 2;
+		byte_count -= MIN(halfwords * 2, byte_count);
+	}
+
+err_run_ret:
+err_run:
+err_write_data:
+	retval = fm4_enter_flash_cpu_rom_mode(target);
+
+err_flash_mode:
+	for (i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
+
+	target_free_working_area(target, data_workarea);
+err_alloc_data:
+err_write_code:
+	target_free_working_area(target, code_workarea);
+
+	return retval;
+}
+
+static int mb9bf_probe(struct flash_bank *bank)
+{
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+	uint32_t flash_addr = bank->base;
+	int i;
+
+	switch (fm4_bank->variant) {
+	case mb9bfx64:
+		bank->num_sectors = 8;
+		break;
+	case mb9bfx65:
+		bank->num_sectors = 10;
+		break;
+	case mb9bfx66:
+		bank->num_sectors = 12;
+		break;
+	case mb9bfx67:
+		bank->num_sectors = 16;
+		break;
+	case mb9bfx68:
+		bank->num_sectors = 20;
+		break;
+	default:
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
+	LOG_DEBUG("%d sectors", bank->num_sectors);
+	bank->sectors = calloc(bank->num_sectors,
+				sizeof(struct flash_sector));
+	for (i = 0; i < bank->num_sectors; i++) {
+		if (i < 4)
+			bank->sectors[i].size = 8 * 1024;
+		else if (i == 4)
+			bank->sectors[i].size = 32 * 1024;
+		else
+			bank->sectors[i].size = 64 * 1024;
+		bank->sectors[i].offset = flash_addr - bank->base;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
+
+		bank->size += bank->sectors[i].size;
+		flash_addr += bank->sectors[i].size;
+	}
+
+	return ERROR_OK;
+}
+
+static void s6e2cc_init_sector(struct flash_sector *sector, int sa)
+{
+	if (sa < 8)
+		sector->size = 8 * 1024;
+	else if (sa == 8)
+		sector->size = 32 * 1024;
+	else
+		sector->size = 64 * 1024;
+
+	sector->is_erased = -1;
+	sector->is_protected = -1;
+}
+
+static int s6e2cc_probe(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+	uint32_t u32_value;
+	uint32_t flash_addr = bank->base;
+	int i, retval, num_sectors, num_extra_sectors;
+
+	retval = target_read_u32(target, DFCTRLR, &u32_value);
+	if (retval != ERROR_OK)
+		return retval;
+	if (u32_value & DFCTRLR_DFE) {
+		LOG_WARNING("Dual Flash mode is not implemented.");
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
+	switch (fm4_bank->variant) {
+	case s6e2cx8:
+		num_sectors = (fm4_bank->macro_nr == 0) ? 20 : 0;
+		break;
+	case s6e2cx9:
+		num_sectors = (fm4_bank->macro_nr == 0) ? 20 : 12;
+		break;
+	case s6e2cxa:
+		num_sectors = 20;
+		break;
+	default:
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+	num_extra_sectors = (fm4_bank->macro_nr == 0) ? 1 : 4;
+	bank->num_sectors = num_sectors + num_extra_sectors;
+
+	LOG_DEBUG("%d sectors", bank->num_sectors);
+	bank->sectors = calloc(bank->num_sectors,
+				sizeof(struct flash_sector));
+	for (i = 0; i < num_sectors; i++) {
+		int sa = 4 + i;
+		bank->sectors[i].offset = flash_addr - bank->base;
+		s6e2cc_init_sector(&bank->sectors[i], sa);
+
+		bank->size += bank->sectors[i].size;
+		flash_addr += bank->sectors[i].size;
+	}
+
+	flash_addr = (fm4_bank->macro_nr == 0) ? 0x00406000 : 0x00408000;
+	for (; i < bank->num_sectors; i++) {
+		int sa = 4 - num_extra_sectors + (i - num_sectors);
+		bank->sectors[i].offset = flash_addr - bank->base;
+		s6e2cc_init_sector(&bank->sectors[i], sa);
+
+		/*
+		 * Don't increase bank->size for these sectors
+		 * to avoid an overlap between Flash Macros #0 and #1.
+		 */
+		flash_addr += bank->sectors[i].size;
+	}
+
+	return ERROR_OK;
+}
+
+static int s6e2dh_probe(struct flash_bank *bank)
+{
+	uint32_t flash_addr = bank->base;
+	int i;
+
+	bank->num_sectors = 10;
+	bank->sectors = calloc(bank->num_sectors,
+				sizeof(struct flash_sector));
+	for (i = 0; i < bank->num_sectors; i++) {
+		if (i < 4)
+			bank->sectors[i].size = 8 * 1024;
+		else if (i == 4)
+			bank->sectors[i].size = 32 * 1024;
+		else
+			bank->sectors[i].size = 64 * 1024;
+		bank->sectors[i].offset = flash_addr - bank->base;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
+
+		bank->size += bank->sectors[i].size;
+		flash_addr += bank->sectors[i].size;
+	}
+
+	return ERROR_OK;
+}
+
+static int fm4_probe(struct flash_bank *bank)
+{
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+	int retval;
+
+	if (fm4_bank->probed)
+		return ERROR_OK;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	switch (fm4_bank->variant) {
+	case mb9bfx64:
+	case mb9bfx65:
+	case mb9bfx66:
+	case mb9bfx67:
+	case mb9bfx68:
+		retval = mb9bf_probe(bank);
+		break;
+	case s6e2cx8:
+	case s6e2cx9:
+	case s6e2cxa:
+		retval = s6e2cc_probe(bank);
+		break;
+	case s6e2dx:
+		retval = s6e2dh_probe(bank);
+		break;
+	default:
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+	if (retval != ERROR_OK)
+		return retval;
+
+	fm4_bank->probed = true;
+
+	return ERROR_OK;
+}
+
+static int fm4_auto_probe(struct flash_bank *bank)
+{
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+
+	if (fm4_bank->probed)
+		return ERROR_OK;
+
+	return fm4_probe(bank);
+}
+
+static int fm4_protect_check(struct flash_bank *bank)
+{
+	return ERROR_OK;
+}
+
+static int fm4_get_info_command(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+	const char *name;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	switch (fm4_bank->variant) {
+	case mb9bfx64:
+		name = "MB9BFx64";
+		break;
+	case mb9bfx65:
+		name = "MB9BFx65";
+		break;
+	case mb9bfx66:
+		name = "MB9BFx66";
+		break;
+	case mb9bfx67:
+		name = "MB9BFx67";
+		break;
+	case mb9bfx68:
+		name = "MB9BFx68";
+		break;
+	case s6e2cx8:
+		name = "S6E2Cx8";
+		break;
+	case s6e2cx9:
+		name = "S6E2Cx9";
+		break;
+	case s6e2cxa:
+		name = "S6E2CxA";
+		break;
+	case s6e2dx:
+		name = "S6E2Dx";
+		break;
+	default:
+		name = "unknown";
+		break;
+	}
+
+	switch (fm4_bank->variant) {
+	case s6e2cx8:
+	case s6e2cx9:
+	case s6e2cxa:
+		snprintf(buf, buf_size, "%s MainFlash Macro #%i",
+			name, fm4_bank->macro_nr);
+		break;
+	default:
+		snprintf(buf, buf_size, "%s MainFlash", name);
+		break;
+	}
+
+	return ERROR_OK;
+}
+
+static bool fm4_name_match(const char *s, const char *pattern)
+{
+	int i = 0;
+
+	while (s[i]) {
+		/* If the match string is shorter, ignore excess */
+		if (!pattern[i])
+			return true;
+		/* Use x as wildcard */
+		if (pattern[i] != 'x' && tolower(s[i]) != tolower(pattern[i]))
+			return false;
+		i++;
+	}
+	return true;
+}
+
+static int mb9bf_bank_setup(struct flash_bank *bank, const char *variant)
+{
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+
+	if (fm4_name_match(variant, "MB9BFx64")) {
+		fm4_bank->variant = mb9bfx64;
+	} else if (fm4_name_match(variant, "MB9BFx65")) {
+		fm4_bank->variant = mb9bfx65;
+	} else if (fm4_name_match(variant, "MB9BFx66")) {
+		fm4_bank->variant = mb9bfx66;
+	} else if (fm4_name_match(variant, "MB9BFx67")) {
+		fm4_bank->variant = mb9bfx67;
+	} else if (fm4_name_match(variant, "MB9BFx68")) {
+		fm4_bank->variant = mb9bfx68;
+	} else {
+		LOG_WARNING("MB9BF variant %s not recognized.", variant);
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
+	return ERROR_OK;
+}
+
+static int s6e2cc_bank_setup(struct flash_bank *bank, const char *variant)
+{
+	struct fm4_flash_bank *fm4_bank = bank->driver_priv;
+
+	if (fm4_name_match(variant, "S6E2Cx8")) {
+		fm4_bank->variant = s6e2cx8;
+	} else if (fm4_name_match(variant, "S6E2Cx9")) {
+		fm4_bank->variant = s6e2cx9;
+	} else if (fm4_name_match(variant, "S6E2CxA")) {
+		fm4_bank->variant = s6e2cxa;
+	} else {
+		LOG_WARNING("S6E2CC variant %s not recognized.", variant);
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
+	return ERROR_OK;
+}
+
+FLASH_BANK_COMMAND_HANDLER(fm4_flash_bank_command)
+{
+	struct fm4_flash_bank *fm4_bank;
+	const char *variant;
+	int ret;
+
+	if (CMD_ARGC < 7)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	variant = CMD_ARGV[6];
+
+	fm4_bank = malloc(sizeof(struct fm4_flash_bank));
+	if (!fm4_bank)
+		return ERROR_FLASH_OPERATION_FAILED;
+
+	fm4_bank->probed = false;
+	fm4_bank->macro_nr = (bank->base == 0x00000000) ? 0 : 1;
+
+	bank->driver_priv = fm4_bank;
+
+	if (fm4_name_match(variant, "MB9BF"))
+		ret = mb9bf_bank_setup(bank, variant);
+	else if (fm4_name_match(variant, "S6E2Cx"))
+		ret = s6e2cc_bank_setup(bank, variant);
+	else if (fm4_name_match(variant, "S6E2Dx")) {
+		fm4_bank->variant = s6e2dx;
+		ret = ERROR_OK;
+	} else {
+		LOG_WARNING("Family %s not recognized.", variant);
+		ret = ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+	if (ret != ERROR_OK)
+		free(fm4_bank);
+	return ret;
+}
+
+static const struct command_registration fm4_exec_command_handlers[] = {
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration fm4_command_handlers[] = {
+	{
+		.name = "fm4",
+		.mode = COMMAND_ANY,
+		.help = "fm4 flash command group",
+		.usage = "",
+		.chain = fm4_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver fm4_flash = {
+	.name = "fm4",
+	.commands = fm4_command_handlers,
+	.flash_bank_command = fm4_flash_bank_command,
+	.info = fm4_get_info_command,
+	.probe = fm4_probe,
+	.auto_probe = fm4_auto_probe,
+	.protect_check = fm4_protect_check,
+	.read = default_flash_read,
+	.erase = fm4_flash_erase,
+	.erase_check = default_flash_blank_check,
+	.write = fm4_flash_write,
+};
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 31d09840..87475a39 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FLASH_NOR_IMP_H
-#define FLASH_NOR_IMP_H
+#ifndef OPENOCD_FLASH_NOR_IMP_H
+#define OPENOCD_FLASH_NOR_IMP_H
 
 /* this is an internal header */
 #include "core.h"
@@ -48,4 +46,4 @@ int flash_driver_read(struct flash_bank *bank,
 int flash_write_unlock(struct target *target, struct image *image,
 		uint32_t *written, int erase, bool unlock);
 
-#endif /* FLASH_NOR_IMP_H */
+#endif /* OPENOCD_FLASH_NOR_IMP_H */
diff --git a/src/flash/nor/jtagspi.c b/src/flash/nor/jtagspi.c
index 1e623a71..a995fc75 100644
--- a/src/flash/nor/jtagspi.c
+++ b/src/flash/nor/jtagspi.c
@@ -11,6 +11,8 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
  *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -208,14 +210,14 @@ static void jtagspi_read_status(struct flash_bank *bank, uint32_t *status)
 static int jtagspi_wait(struct flash_bank *bank, int timeout_ms)
 {
 	uint32_t status;
-	long long t0 = timeval_ms();
-	long long dt;
+	int64_t t0 = timeval_ms();
+	int64_t dt;
 
 	do {
 		dt = timeval_ms() - t0;
 		jtagspi_read_status(bank, &status);
 		if ((status & SPIFLASH_BSY_BIT) == 0) {
-			LOG_DEBUG("waited %lld ms", dt);
+			LOG_DEBUG("waited %" PRId64 " ms", dt);
 			return ERROR_OK;
 		}
 		alive_sleep(1);
@@ -242,14 +244,14 @@ static int jtagspi_bulk_erase(struct flash_bank *bank)
 {
 	struct jtagspi_flash_bank *info = bank->driver_priv;
 	int retval;
-	long long t0 = timeval_ms();
+	int64_t t0 = timeval_ms();
 
 	retval = jtagspi_write_enable(bank);
 	if (retval != ERROR_OK)
 		return retval;
 	jtagspi_cmd(bank, info->dev->chip_erase_cmd, NULL, NULL, 0);
 	retval = jtagspi_wait(bank, bank->num_sectors*JTAGSPI_MAX_TIMEOUT);
-	LOG_INFO("took %lld ms", timeval_ms() - t0);
+	LOG_INFO("took %" PRId64 " ms", timeval_ms() - t0);
 	return retval;
 }
 
@@ -257,14 +259,14 @@ static int jtagspi_sector_erase(struct flash_bank *bank, int sector)
 {
 	struct jtagspi_flash_bank *info = bank->driver_priv;
 	int retval;
-	long long t0 = timeval_ms();
+	int64_t t0 = timeval_ms();
 
 	retval = jtagspi_write_enable(bank);
 	if (retval != ERROR_OK)
 		return retval;
 	jtagspi_cmd(bank, info->dev->erase_cmd, &bank->sectors[sector].offset, NULL, 0);
 	retval = jtagspi_wait(bank, JTAGSPI_MAX_TIMEOUT);
-	LOG_INFO("sector %d took %lld ms", sector, timeval_ms() - t0);
+	LOG_INFO("sector %d took %" PRId64 " ms", sector, timeval_ms() - t0);
 	return retval;
 }
 
diff --git a/src/flash/nor/kinetis.c b/src/flash/nor/kinetis.c
index d618cfdd..5c0ffbd6 100644
--- a/src/flash/nor/kinetis.c
+++ b/src/flash/nor/kinetis.c
@@ -11,6 +11,9 @@
  *   Copyright (C) 2013 Nemui Trinomius                                    *
  *   nemuisan_kawausogasuki@live.jp                                        *
  *                                                                         *
+ *   Copyright (C) 2015 Tomas Vanek                                        *
+ *   vanekt@fbl.cz                                                         *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -22,9 +25,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -34,6 +35,7 @@
 #include "jtag/interface.h"
 #include "imp.h"
 #include <helper/binarybuffer.h>
+#include <helper/time_support.h>
 #include <target/target_type.h>
 #include <target/algorithm.h>
 #include <target/armv7m.h>
@@ -78,16 +80,48 @@
  */
 
 /* Addressess */
+#define FCF_ADDRESS	0x00000400
+#define FCF_FPROT	0x8
+#define FCF_FSEC	0xc
+#define FCF_FOPT	0xd
+#define FCF_FDPROT	0xf
+#define FCF_SIZE	0x10
+
 #define FLEXRAM		0x14000000
+
+#define MSCM_OCMDR0	0x40001400
+#define FMC_PFB01CR	0x4001f004
 #define FTFx_FSTAT	0x40020000
 #define FTFx_FCNFG	0x40020001
 #define FTFx_FCCOB3	0x40020004
 #define FTFx_FPROT3	0x40020010
-#define SIM_SDID	0x40048024
-#define SIM_SOPT1	0x40047000
-#define SIM_FCFG1	0x4004804c
-#define SIM_FCFG2	0x40048050
-#define WDOG_STCTRH	0x40052000
+#define FTFx_FDPROT	0x40020017
+#define SIM_BASE	0x40047000
+#define SIM_BASE_KL28	0x40074000
+#define SIM_COPC	0x40048100
+	/* SIM_COPC does not exist on devices with changed SIM_BASE */
+#define WDOG_BASE	0x40052000
+#define WDOG32_KE1X	0x40052000
+#define WDOG32_KL28	0x40076000
+#define SMC_PMCTRL	0x4007E001
+#define SMC_PMSTAT	0x4007E003
+#define SMC32_PMCTRL	0x4007E00C
+#define SMC32_PMSTAT	0x4007E014
+#define MCM_PLACR	0xF000300C
+
+/* Offsets */
+#define SIM_SOPT1_OFFSET    0x0000
+#define SIM_SDID_OFFSET	    0x1024
+#define SIM_FCFG1_OFFSET    0x104c
+#define SIM_FCFG2_OFFSET    0x1050
+
+#define WDOG_STCTRLH_OFFSET      0
+#define WDOG32_CS_OFFSET         0
+
+/* Values */
+#define PM_STAT_RUN		0x01
+#define PM_STAT_VLPR		0x04
+#define PM_CTRL_RUNM_RUN	0x00
 
 /* Commands */
 #define FTFx_CMD_BLOCKSTAT  0x00
@@ -95,8 +129,9 @@
 #define FTFx_CMD_LWORDPROG  0x06
 #define FTFx_CMD_SECTERASE  0x09
 #define FTFx_CMD_SECTWRITE  0x0b
-#define FTFx_CMD_SETFLEXRAM 0x81
 #define FTFx_CMD_MASSERASE  0x44
+#define FTFx_CMD_PGMPART    0x80
+#define FTFx_CMD_SETFLEXRAM 0x81
 
 /* The older Kinetis K series uses the following SDID layout :
  * Bit 31-16 : 0
@@ -166,9 +201,11 @@
 #define KINETIS_SDID_SERIESID_MASK 0x00F00000
 #define KINETIS_SDID_SERIESID_K   0x00000000
 #define KINETIS_SDID_SERIESID_KL   0x00100000
+#define KINETIS_SDID_SERIESID_KE   0x00200000
 #define KINETIS_SDID_SERIESID_KW   0x00500000
 #define KINETIS_SDID_SERIESID_KV   0x00600000
 
+#define KINETIS_SDID_SUBFAMID_SHIFT 24
 #define KINETIS_SDID_SUBFAMID_MASK  0x0F000000
 #define KINETIS_SDID_SUBFAMID_KX0   0x00000000
 #define KINETIS_SDID_SUBFAMID_KX1   0x01000000
@@ -177,25 +214,38 @@
 #define KINETIS_SDID_SUBFAMID_KX4   0x04000000
 #define KINETIS_SDID_SUBFAMID_KX5   0x05000000
 #define KINETIS_SDID_SUBFAMID_KX6   0x06000000
+#define KINETIS_SDID_SUBFAMID_KX7   0x07000000
+#define KINETIS_SDID_SUBFAMID_KX8   0x08000000
 
+#define KINETIS_SDID_FAMILYID_SHIFT 28
 #define KINETIS_SDID_FAMILYID_MASK  0xF0000000
 #define KINETIS_SDID_FAMILYID_K0X   0x00000000
 #define KINETIS_SDID_FAMILYID_K1X   0x10000000
 #define KINETIS_SDID_FAMILYID_K2X   0x20000000
 #define KINETIS_SDID_FAMILYID_K3X   0x30000000
 #define KINETIS_SDID_FAMILYID_K4X   0x40000000
+#define KINETIS_SDID_FAMILYID_K5X   0x50000000
 #define KINETIS_SDID_FAMILYID_K6X   0x60000000
 #define KINETIS_SDID_FAMILYID_K7X   0x70000000
+#define KINETIS_SDID_FAMILYID_K8X   0x80000000
+#define KINETIS_SDID_FAMILYID_KL8X  0x90000000
+
+/* The field originally named DIEID has new name/meaning on KE1x */
+#define KINETIS_SDID_PROJECTID_MASK  KINETIS_SDID_DIEID_MASK
+#define KINETIS_SDID_PROJECTID_KE1xF 0x00000080
+#define KINETIS_SDID_PROJECTID_KE1xZ 0x00000100
 
 struct kinetis_flash_bank {
-	unsigned bank_ordinal;
+	struct kinetis_chip *k_chip;
+	bool probed;
+	unsigned bank_number;		/* bank number in particular chip */
+	struct flash_bank *bank;
+
 	uint32_t sector_size;
-	uint32_t max_flash_prog_size;
 	uint32_t protection_size;
-
-	uint32_t sim_sdid;
-	uint32_t sim_fcfg1;
-	uint32_t sim_fcfg2;
+	uint32_t prog_base;		/* base address for FTFx operations */
+					/* usually same as bank->base for pflash, differs for FlexNVM */
+	uint32_t protection_block;	/* number of first protection block in this bank */
 
 	enum {
 		FC_AUTO = 0,
@@ -203,14 +253,109 @@ struct kinetis_flash_bank {
 		FC_FLEX_NVM,
 		FC_FLEX_RAM,
 	} flash_class;
+};
+
+#define KINETIS_MAX_BANKS 4u
+
+struct kinetis_chip {
+	struct target *target;
+	bool probed;
+
+	uint32_t sim_sdid;
+	uint32_t sim_fcfg1;
+	uint32_t sim_fcfg2;
+	uint32_t fcfg2_maxaddr0_shifted;
+	uint32_t fcfg2_maxaddr1_shifted;
+
+	unsigned num_pflash_blocks, num_nvm_blocks;
+	unsigned pflash_sector_size, nvm_sector_size;
+	unsigned max_flash_prog_size;
+
+	uint32_t pflash_base;
+	uint32_t pflash_size;
+	uint32_t nvm_base;
+	uint32_t nvm_size;		/* whole FlexNVM */
+	uint32_t dflash_size;		/* accessible rest of FlexNVM if EEPROM backup uses part of FlexNVM */
+
+	uint32_t progr_accel_ram;
+	uint32_t sim_base;
 
 	enum {
 		FS_PROGRAM_SECTOR = 1,
 		FS_PROGRAM_LONGWORD = 2,
-		FS_PROGRAM_PHRASE = 4, /* Unsupported */
+		FS_PROGRAM_PHRASE = 4,		/* Unsupported */
+
+		FS_NO_CMD_BLOCKSTAT = 0x40,
+		FS_WIDTH_256BIT = 0x80,
 	} flash_support;
+
+	enum {
+		KINETIS_CACHE_NONE,
+		KINETIS_CACHE_K,	/* invalidate using FMC->PFB0CR/PFB01CR */
+		KINETIS_CACHE_L,	/* invalidate using MCM->PLACR */
+		KINETIS_CACHE_MSCM,	/* devices like KE1xF, invalidate MSCM->OCMDR0 */
+	} cache_type;
+
+	enum {
+		KINETIS_WDOG_NONE,
+		KINETIS_WDOG_K,
+		KINETIS_WDOG_COP,
+		KINETIS_WDOG32_KE1X,
+		KINETIS_WDOG32_KL28,
+	} watchdog_type;
+
+	enum {
+		KINETIS_SMC,
+		KINETIS_SMC32,
+	} sysmodectrlr_type;
+
+	char name[40];
+
+	unsigned num_banks;
+	struct kinetis_flash_bank banks[KINETIS_MAX_BANKS];
+};
+
+struct kinetis_type {
+	uint32_t sdid;
+	char *name;
 };
 
+static const struct kinetis_type kinetis_types_old[] = {
+	{ KINETIS_K_SDID_K10_M50,  "MK10D%s5" },
+	{ KINETIS_K_SDID_K10_M72,  "MK10D%s7" },
+	{ KINETIS_K_SDID_K10_M100, "MK10D%s10" },
+	{ KINETIS_K_SDID_K10_M120, "MK10F%s12" },
+	{ KINETIS_K_SDID_K11,      "MK11D%s5" },
+	{ KINETIS_K_SDID_K12,      "MK12D%s5" },
+
+	{ KINETIS_K_SDID_K20_M50,  "MK20D%s5" },
+	{ KINETIS_K_SDID_K20_M72,  "MK20D%s7" },
+	{ KINETIS_K_SDID_K20_M100, "MK20D%s10" },
+	{ KINETIS_K_SDID_K20_M120, "MK20F%s12" },
+	{ KINETIS_K_SDID_K21_M50,  "MK21D%s5" },
+	{ KINETIS_K_SDID_K21_M120, "MK21F%s12" },
+	{ KINETIS_K_SDID_K22_M50,  "MK22D%s5" },
+	{ KINETIS_K_SDID_K22_M120, "MK22F%s12" },
+
+	{ KINETIS_K_SDID_K30_M72,  "MK30D%s7" },
+	{ KINETIS_K_SDID_K30_M100, "MK30D%s10" },
+
+	{ KINETIS_K_SDID_K40_M72,  "MK40D%s7" },
+	{ KINETIS_K_SDID_K40_M100, "MK40D%s10" },
+
+	{ KINETIS_K_SDID_K50_M72,  "MK50D%s7" },
+	{ KINETIS_K_SDID_K51_M72,  "MK51D%s7" },
+	{ KINETIS_K_SDID_K53,      "MK53D%s10" },
+
+	{ KINETIS_K_SDID_K60_M100, "MK60D%s10" },
+	{ KINETIS_K_SDID_K60_M150, "MK60F%s15" },
+
+	{ KINETIS_K_SDID_K70_M150, "MK70F%s15" },
+};
+
+
+#define MDM_AP			1
+
 #define MDM_REG_STAT		0x00
 #define MDM_REG_CTRL		0x04
 #define MDM_REG_ID		0xfc
@@ -229,23 +374,36 @@ struct kinetis_flash_bank {
 #define MDM_STAT_CORE_SLEEPDEEP	(1<<17)
 #define MDM_STAT_CORESLEEPING	(1<<18)
 
-#define MEM_CTRL_FMEIP		(1<<0)
-#define MEM_CTRL_DBG_DIS	(1<<1)
-#define MEM_CTRL_DBG_REQ	(1<<2)
-#define MEM_CTRL_SYS_RES_REQ	(1<<3)
-#define MEM_CTRL_CORE_HOLD_RES	(1<<4)
-#define MEM_CTRL_VLLSX_DBG_REQ	(1<<5)
-#define MEM_CTRL_VLLSX_DBG_ACK	(1<<6)
-#define MEM_CTRL_VLLSX_STAT_ACK	(1<<7)
+#define MDM_CTRL_FMEIP		(1<<0)
+#define MDM_CTRL_DBG_DIS	(1<<1)
+#define MDM_CTRL_DBG_REQ	(1<<2)
+#define MDM_CTRL_SYS_RES_REQ	(1<<3)
+#define MDM_CTRL_CORE_HOLD_RES	(1<<4)
+#define MDM_CTRL_VLLSX_DBG_REQ	(1<<5)
+#define MDM_CTRL_VLLSX_DBG_ACK	(1<<6)
+#define MDM_CTRL_VLLSX_STAT_ACK	(1<<7)
+
+#define MDM_ACCESS_TIMEOUT	500 /* msec */
+
+
+static bool allow_fcf_writes;
+static uint8_t fcf_fopt = 0xff;
+static bool create_banks;
+
+
+struct flash_driver kinetis_flash;
+static int kinetis_write_inner(struct flash_bank *bank, const uint8_t *buffer,
+			uint32_t offset, uint32_t count);
+static int kinetis_probe_chip(struct kinetis_chip *k_chip);
+static int kinetis_auto_probe(struct flash_bank *bank);
 
-#define MDM_ACCESS_TIMEOUT	3000 /* iterations */
 
 static int kinetis_mdm_write_register(struct adiv5_dap *dap, unsigned reg, uint32_t value)
 {
 	int retval;
 	LOG_DEBUG("MDM_REG[0x%02x] <- %08" PRIX32, reg, value);
 
-	retval = dap_queue_ap_write(dap_ap(dap, 1), reg, value);
+	retval = dap_queue_ap_write(dap_ap(dap, MDM_AP), reg, value);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("MDM: failed to queue a write request");
 		return retval;
@@ -265,7 +423,7 @@ static int kinetis_mdm_read_register(struct adiv5_dap *dap, unsigned reg, uint32
 {
 	int retval;
 
-	retval = dap_queue_ap_read(dap_ap(dap, 1), reg, result);
+	retval = dap_queue_ap_read(dap_ap(dap, MDM_AP), reg, result);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("MDM: failed to queue a read request");
 		return retval;
@@ -281,11 +439,12 @@ static int kinetis_mdm_read_register(struct adiv5_dap *dap, unsigned reg, uint32
 	return ERROR_OK;
 }
 
-static int kinetis_mdm_poll_register(struct adiv5_dap *dap, unsigned reg, uint32_t mask, uint32_t value)
+static int kinetis_mdm_poll_register(struct adiv5_dap *dap, unsigned reg,
+			uint32_t mask, uint32_t value, uint32_t timeout_ms)
 {
 	uint32_t val;
 	int retval;
-	int timeout = MDM_ACCESS_TIMEOUT;
+	int64_t ms_timeout = timeval_ms() + timeout_ms;
 
 	do {
 		retval = kinetis_mdm_read_register(dap, reg, &val);
@@ -293,17 +452,121 @@ static int kinetis_mdm_poll_register(struct adiv5_dap *dap, unsigned reg, uint32
 			return retval;
 
 		alive_sleep(1);
-	} while (timeout--);
+	} while (timeval_ms() < ms_timeout);
 
 	LOG_DEBUG("MDM: polling timed out");
 	return ERROR_FAIL;
 }
 
+/*
+ * This command can be used to break a watchdog reset loop when
+ * connecting to an unsecured target. Unlike other commands, halt will
+ * automatically retry as it does not know how far into the boot process
+ * it is when the command is called.
+ */
+COMMAND_HANDLER(kinetis_mdm_halt)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct cortex_m_common *cortex_m = target_to_cm(target);
+	struct adiv5_dap *dap = cortex_m->armv7m.arm.dap;
+	int retval;
+	int tries = 0;
+	uint32_t stat;
+	int64_t ms_timeout = timeval_ms() + MDM_ACCESS_TIMEOUT;
+
+	if (!dap) {
+		LOG_ERROR("Cannot perform halt with a high-level adapter");
+		return ERROR_FAIL;
+	}
+
+	while (true) {
+		tries++;
+
+		kinetis_mdm_write_register(dap, MDM_REG_CTRL, MDM_CTRL_CORE_HOLD_RES);
+
+		alive_sleep(1);
+
+		retval = kinetis_mdm_read_register(dap, MDM_REG_STAT, &stat);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("MDM: failed to read MDM_REG_STAT");
+			continue;
+		}
+
+		/* Repeat setting MDM_CTRL_CORE_HOLD_RES until system is out of
+		 * reset with flash ready and without security
+		 */
+		if ((stat & (MDM_STAT_FREADY | MDM_STAT_SYSSEC | MDM_STAT_SYSRES))
+				== (MDM_STAT_FREADY | MDM_STAT_SYSRES))
+			break;
+
+		if (timeval_ms() >= ms_timeout) {
+			LOG_ERROR("MDM: halt timed out");
+			return ERROR_FAIL;
+		}
+	}
+
+	LOG_DEBUG("MDM: halt succeded after %d attempts.", tries);
+
+	target_poll(target);
+	/* enable polling in case kinetis_check_flash_security_status disabled it */
+	jtag_poll_set_enabled(true);
+
+	alive_sleep(100);
+
+	target->reset_halt = true;
+	target->type->assert_reset(target);
+
+	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to clear MDM_REG_CTRL");
+		return retval;
+	}
+
+	target->type->deassert_reset(target);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kinetis_mdm_reset)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct cortex_m_common *cortex_m = target_to_cm(target);
+	struct adiv5_dap *dap = cortex_m->armv7m.arm.dap;
+	int retval;
+
+	if (!dap) {
+		LOG_ERROR("Cannot perform reset with a high-level adapter");
+		return ERROR_FAIL;
+	}
+
+	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, MDM_CTRL_SYS_RES_REQ);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to write MDM_REG_CTRL");
+		return retval;
+	}
+
+	retval = kinetis_mdm_poll_register(dap, MDM_REG_STAT, MDM_STAT_SYSRES, 0, 500);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to assert reset");
+		return retval;
+	}
+
+	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, 0);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to clear MDM_REG_CTRL");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
 /*
  * This function implements the procedure to mass erase the flash via
  * SWD/JTAG on Kinetis K and L series of devices as it is described in
  * AN4835 "Production Flash Programming Best Practices for Kinetis K-
- * and L-series MCUs" Section 4.2.1
+ * and L-series MCUs" Section 4.2.1. To prevent a watchdog reset loop,
+ * the core remains halted after this function completes as suggested
+ * by the application note.
  */
 COMMAND_HANDLER(kinetis_mdm_mass_erase)
 {
@@ -326,75 +589,129 @@ COMMAND_HANDLER(kinetis_mdm_mass_erase)
 	 * establishing communication...
 	 */
 
-	/* assert SRST */
-	if (jtag_get_reset_config() & RESET_HAS_SRST)
+	/* assert SRST if configured */
+	bool has_srst = jtag_get_reset_config() & RESET_HAS_SRST;
+	if (has_srst)
 		adapter_assert_reset();
-	else
-		LOG_WARNING("Attempting mass erase without hardware reset. This is not reliable; "
-			    "it's recommended you connect SRST and use ``reset_config srst_only''.");
 
-	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, MEM_CTRL_SYS_RES_REQ);
-	if (retval != ERROR_OK)
-		return retval;
+	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, MDM_CTRL_SYS_RES_REQ);
+	if (retval != ERROR_OK && !has_srst) {
+		LOG_ERROR("MDM: failed to assert reset");
+		goto deassert_reset_and_exit;
+	}
 
 	/*
-	 * ... Read the MDM-AP status register until the Flash Ready bit sets...
+	 * ... Read the MDM-AP status register repeatedly and wait for
+	 * stable conditions suitable for mass erase:
+	 * - mass erase is enabled
+	 * - flash is ready
+	 * - reset is finished
+	 *
+	 * Mass erase is started as soon as all conditions are met in 32
+	 * subsequent status reads.
+	 *
+	 * In case of not stable conditions (RESET/WDOG loop in secured device)
+	 * the user is asked for manual pressing of RESET button
+	 * as a last resort.
 	 */
-	retval = kinetis_mdm_poll_register(dap, MDM_REG_STAT,
-					   MDM_STAT_FREADY | MDM_STAT_SYSRES,
-					   MDM_STAT_FREADY);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("MDM : flash ready timeout");
-		return retval;
-	}
+	int cnt_mass_erase_disabled = 0;
+	int cnt_ready = 0;
+	int64_t ms_start = timeval_ms();
+	bool man_reset_requested = false;
+
+	do {
+		uint32_t stat = 0;
+		int64_t ms_elapsed = timeval_ms() - ms_start;
+
+		if (!man_reset_requested && ms_elapsed > 100) {
+			LOG_INFO("MDM: Press RESET button now if possible.");
+			man_reset_requested = true;
+		}
+
+		if (ms_elapsed > 3000) {
+			LOG_ERROR("MDM: waiting for mass erase conditions timed out.");
+			LOG_INFO("Mass erase of a secured MCU is not possible without hardware reset.");
+			LOG_INFO("Connect SRST, use 'reset_config srst_only' and retry.");
+			goto deassert_reset_and_exit;
+		}
+		retval = kinetis_mdm_read_register(dap, MDM_REG_STAT, &stat);
+		if (retval != ERROR_OK) {
+			cnt_ready = 0;
+			continue;
+		}
+
+		if (!(stat & MDM_STAT_FMEEN)) {
+			cnt_ready = 0;
+			cnt_mass_erase_disabled++;
+			if (cnt_mass_erase_disabled > 10) {
+				LOG_ERROR("MDM: mass erase is disabled");
+				goto deassert_reset_and_exit;
+			}
+			continue;
+		}
+
+		if ((stat & (MDM_STAT_FREADY | MDM_STAT_SYSRES)) == MDM_STAT_FREADY)
+			cnt_ready++;
+		else
+			cnt_ready = 0;
+
+	} while (cnt_ready < 32);
 
 	/*
 	 * ... Write the MDM-AP control register to set the Flash Mass
 	 * Erase in Progress bit. This will start the mass erase
 	 * process...
 	 */
-	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL,
-					    MEM_CTRL_SYS_RES_REQ | MEM_CTRL_FMEIP);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* As a sanity check make sure that device started mass erase procedure */
-	retval = kinetis_mdm_poll_register(dap, MDM_REG_STAT,
-					   MDM_STAT_FMEACK, MDM_STAT_FMEACK);
-	if (retval != ERROR_OK)
-		return retval;
+	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, MDM_CTRL_SYS_RES_REQ | MDM_CTRL_FMEIP);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to start mass erase");
+		goto deassert_reset_and_exit;
+	}
 
 	/*
 	 * ... Read the MDM-AP control register until the Flash Mass
 	 * Erase in Progress bit clears...
+	 * Data sheed defines erase time <3.6 sec/512kB flash block.
+	 * The biggest device has 4 pflash blocks => timeout 16 sec.
 	 */
-	retval = kinetis_mdm_poll_register(dap, MDM_REG_CTRL,
-					   MEM_CTRL_FMEIP,
-					   0);
-	if (retval != ERROR_OK)
-		return retval;
+	retval = kinetis_mdm_poll_register(dap, MDM_REG_CTRL, MDM_CTRL_FMEIP, 0, 16000);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: mass erase timeout");
+		goto deassert_reset_and_exit;
+	}
+
+	target_poll(target);
+	/* enable polling in case kinetis_check_flash_security_status disabled it */
+	jtag_poll_set_enabled(true);
+
+	alive_sleep(100);
+
+	target->reset_halt = true;
+	target->type->assert_reset(target);
 
 	/*
 	 * ... Negate the RESET signal or clear the System Reset Request
-	 * bit in the MDM-AP control register...
+	 * bit in the MDM-AP control register.
 	 */
 	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, 0);
 	if (retval != ERROR_OK)
-		return retval;
+		LOG_ERROR("MDM: failed to clear MDM_REG_CTRL");
 
-	if (jtag_get_reset_config() & RESET_HAS_SRST) {
-		/* halt MCU otherwise it loops in hard fault - WDOG reset cycle */
-		target->reset_halt = true;
-		target->type->assert_reset(target);
-		target->type->deassert_reset(target);
-	}
+	target->type->deassert_reset(target);
 
-	return ERROR_OK;
+	return retval;
+
+deassert_reset_and_exit:
+	kinetis_mdm_write_register(dap, MDM_REG_CTRL, 0);
+	if (has_srst)
+		adapter_deassert_reset();
+	return retval;
 }
 
 static const uint32_t kinetis_known_mdm_ids[] = {
 	0x001C0000,	/* Kinetis-K Series */
 	0x001C0020,	/* Kinetis-L/M/V/E Series */
+	0x001C0030,	/* Kinetis with a Cortex-M7, in time of writing KV58 */
 };
 
 /*
@@ -414,6 +731,9 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 		return ERROR_OK;
 	}
 
+	if (!dap->ops)
+		return ERROR_OK;	/* too early to check, in JTAG mode ops may not be initialised */
+
 	uint32_t val;
 	int retval;
 
@@ -424,9 +744,12 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 	retval = kinetis_mdm_read_register(dap, MDM_REG_ID, &val);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("MDM: failed to read ID register");
-		goto fail;
+		return ERROR_OK;
 	}
 
+	if (val == 0)
+		return ERROR_OK;	/* dap not yet initialised */
+
 	bool found = false;
 	for (size_t i = 0; i < ARRAY_SIZE(kinetis_known_mdm_ids); i++) {
 		if (val == kinetis_known_mdm_ids[i]) {
@@ -438,17 +761,6 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 	if (!found)
 		LOG_WARNING("MDM: unknown ID %08" PRIX32, val);
 
-	/*
-	 * ... Read the MDM-AP status register until the Flash Ready bit sets...
-	 */
-	retval = kinetis_mdm_poll_register(dap, MDM_REG_STAT,
-					   MDM_STAT_FREADY,
-					   MDM_STAT_FREADY);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("MDM: flash ready timeout");
-		goto fail;
-	}
-
 	/*
 	 * ... Read the System Security bit to determine if security is enabled.
 	 * If System Security = 0, then proceed. If System Security = 1, then
@@ -459,33 +771,40 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 	retval = kinetis_mdm_read_register(dap, MDM_REG_STAT, &val);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("MDM: failed to read MDM_REG_STAT");
-		goto fail;
+		return ERROR_OK;
 	}
 
-	if ((val & (MDM_STAT_SYSSEC | MDM_STAT_CORE_HALTED)) == MDM_STAT_SYSSEC) {
-		LOG_WARNING("MDM: Secured MCU state detected however it may be a false alarm");
-		LOG_WARNING("MDM: Halting target to detect secured state reliably");
+	/*
+	 * System Security bit is also active for short time during reset.
+	 * If a MCU has blank flash and runs in RESET/WDOG loop,
+	 * System Security bit is active most of time!
+	 * We should observe Flash Ready bit and read status several times
+	 * to avoid false detection of secured MCU
+	 */
+	int secured_score = 0, flash_not_ready_score = 0;
 
-		retval = target_halt(target);
-		if (retval == ERROR_OK)
-			retval = target_wait_state(target, TARGET_HALTED, 100);
+	if ((val & (MDM_STAT_SYSSEC | MDM_STAT_FREADY)) != MDM_STAT_FREADY) {
+		uint32_t stats[32];
+		int i;
 
-		if (retval != ERROR_OK) {
-			LOG_WARNING("MDM: Target not halted, trying reset halt");
-			target->reset_halt = true;
-			target->type->assert_reset(target);
-			target->type->deassert_reset(target);
+		for (i = 0; i < 32; i++) {
+			stats[i] = MDM_STAT_FREADY;
+			dap_queue_ap_read(dap_ap(dap, MDM_AP), MDM_REG_STAT, &stats[i]);
 		}
-
-		/* re-read status */
-		retval = kinetis_mdm_read_register(dap, MDM_REG_STAT, &val);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK) {
-			LOG_ERROR("MDM: failed to read MDM_REG_STAT");
-			goto fail;
+			LOG_DEBUG("MDM: dap_run failed when validating secured state");
+			return ERROR_OK;
+		}
+		for (i = 0; i < 32; i++) {
+			if (stats[i] & MDM_STAT_SYSSEC)
+				secured_score++;
+			if (!(stats[i] & MDM_STAT_FREADY))
+				flash_not_ready_score++;
 		}
 	}
 
-	if (val & MDM_STAT_SYSSEC) {
+	if (flash_not_ready_score <= 8 && secured_score > 24) {
 		jtag_poll_set_enabled(false);
 
 		LOG_WARNING("*********** ATTENTION! ATTENTION! ATTENTION! ATTENTION! **********");
@@ -497,202 +816,416 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 		LOG_WARNING("**** command, power cycle the MCU and restart OpenOCD.        ****");
 		LOG_WARNING("****                                                          ****");
 		LOG_WARNING("*********** ATTENTION! ATTENTION! ATTENTION! ATTENTION! **********");
+
+	} else if (flash_not_ready_score > 24) {
+		jtag_poll_set_enabled(false);
+		LOG_WARNING("**** Your Kinetis MCU is probably locked-up in RESET/WDOG loop. ****");
+		LOG_WARNING("**** Common reason is a blank flash (at least a reset vector).  ****");
+		LOG_WARNING("**** Issue 'kinetis mdm halt' command or if SRST is connected   ****");
+		LOG_WARNING("**** and configured, use 'reset halt'                           ****");
+		LOG_WARNING("**** If MCU cannot be halted, it is likely secured and running  ****");
+		LOG_WARNING("**** in RESET/WDOG loop. Issue 'kinetis mdm mass_erase'         ****");
+
 	} else {
 		LOG_INFO("MDM: Chip is unsecured. Continuing.");
 		jtag_poll_set_enabled(true);
 	}
 
 	return ERROR_OK;
+}
 
-fail:
-	LOG_ERROR("MDM: Failed to check security status of the MCU. Cannot proceed further");
-	jtag_poll_set_enabled(false);
-	return retval;
+
+static struct kinetis_chip *kinetis_get_chip(struct target *target)
+{
+	struct flash_bank *bank_iter;
+	struct kinetis_flash_bank *k_bank;
+
+	/* iterate over all kinetis banks */
+	for (bank_iter = flash_bank_list(); bank_iter; bank_iter = bank_iter->next) {
+		if (bank_iter->driver != &kinetis_flash
+		    || bank_iter->target != target)
+			continue;
+
+		k_bank = bank_iter->driver_priv;
+		if (!k_bank)
+			continue;
+
+		if (k_bank->k_chip)
+			return k_bank->k_chip;
+	}
+	return NULL;
+}
+
+static int kinetis_chip_options(struct kinetis_chip *k_chip, int argc, const char *argv[])
+{
+	int i;
+	for (i = 0; i < argc; i++) {
+		if (strcmp(argv[i], "-sim-base") == 0) {
+			if (i + 1 < argc)
+				k_chip->sim_base = strtoul(argv[++i], NULL, 0);
+		} else
+			LOG_ERROR("Unsupported flash bank option %s", argv[i]);
+	}
+	return ERROR_OK;
 }
 
 FLASH_BANK_COMMAND_HANDLER(kinetis_flash_bank_command)
 {
-	struct kinetis_flash_bank *bank_info;
+	struct target *target = bank->target;
+	struct kinetis_chip *k_chip;
+	struct kinetis_flash_bank *k_bank;
+	int retval;
 
 	if (CMD_ARGC < 6)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	LOG_INFO("add flash_bank kinetis %s", bank->name);
 
-	bank_info = malloc(sizeof(struct kinetis_flash_bank));
+	k_chip = kinetis_get_chip(target);
+
+	if (k_chip == NULL) {
+		k_chip = calloc(sizeof(struct kinetis_chip), 1);
+		if (k_chip == NULL) {
+			LOG_ERROR("No memory");
+			return ERROR_FAIL;
+		}
+
+		k_chip->target = target;
+
+		/* only the first defined bank can define chip options */
+		retval = kinetis_chip_options(k_chip, CMD_ARGC - 6, CMD_ARGV + 6);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
-	memset(bank_info, 0, sizeof(struct kinetis_flash_bank));
+	if (k_chip->num_banks >= KINETIS_MAX_BANKS) {
+		LOG_ERROR("Only %u Kinetis flash banks are supported", KINETIS_MAX_BANKS);
+		return ERROR_FAIL;
+	}
 
-	bank->driver_priv = bank_info;
+	bank->driver_priv = k_bank = &(k_chip->banks[k_chip->num_banks]);
+	k_bank->k_chip = k_chip;
+	k_bank->bank_number = k_chip->num_banks;
+	k_bank->bank = bank;
+	k_chip->num_banks++;
 
 	return ERROR_OK;
 }
 
-/* Disable the watchdog on Kinetis devices */
-int kinetis_disable_wdog(struct target *target, uint32_t sim_sdid)
+
+static int kinetis_create_missing_banks(struct kinetis_chip *k_chip)
 {
-	struct working_area *wdog_algorithm;
-	struct armv7m_algorithm armv7m_info;
-	uint16_t wdog;
-	int retval;
+	unsigned bank_idx;
+	unsigned num_blocks;
+	struct kinetis_flash_bank *k_bank;
+	struct flash_bank *bank;
+	char base_name[80], name[80], num[4];
+	char *class, *p;
+
+	num_blocks = k_chip->num_pflash_blocks + k_chip->num_nvm_blocks;
+	if (num_blocks > KINETIS_MAX_BANKS) {
+		LOG_ERROR("Only %u Kinetis flash banks are supported", KINETIS_MAX_BANKS);
+		return ERROR_FAIL;
+	}
 
-	static const uint8_t kinetis_unlock_wdog_code[] = {
-		/* WDOG_UNLOCK = 0xC520 */
-		0x4f, 0xf4, 0x00, 0x53,    /* mov.w   r3, #8192     ; 0x2000  */
-		0xc4, 0xf2, 0x05, 0x03,    /* movt    r3, #16389    ; 0x4005  */
-		0x4c, 0xf2, 0x20, 0x52,   /* movw    r2, #50464    ; 0xc520  */
-		0xda, 0x81,               /* strh    r2, [r3, #14]  */
-
-		/* WDOG_UNLOCK = 0xD928 */
-		0x4f, 0xf4, 0x00, 0x53,   /* mov.w   r3, #8192     ; 0x2000  */
-		0xc4, 0xf2, 0x05, 0x03,   /* movt    r3, #16389    ; 0x4005  */
-		0x4d, 0xf6, 0x28, 0x12,   /* movw    r2, #55592    ; 0xd928  */
-		0xda, 0x81,               /* strh    r2, [r3, #14]  */
-
-		/* WDOG_SCR = 0x1d2 */
-		0x4f, 0xf4, 0x00, 0x53,   /* mov.w   r3, #8192     ; 0x2000  */
-		0xc4, 0xf2, 0x05, 0x03,   /* movt    r3, #16389    ; 0x4005  */
-		0x4f, 0xf4, 0xe9, 0x72,   /* mov.w   r2, #466      ; 0x1d2  */
-		0x1a, 0x80,               /* strh    r2, [r3, #0]  */
-
-		/* END */
-		0x00, 0xBE,               /* bkpt #0 */
-	};
+	bank = k_chip->banks[0].bank;
+	if (bank && bank->name) {
+		strncpy(base_name, bank->name, sizeof(base_name));
+		p = strstr(base_name, ".pflash");
+		if (p) {
+			*p = '\0';
+			if (k_chip->num_pflash_blocks > 1) {
+				/* rename first bank if numbering is needed */
+				snprintf(name, sizeof(name), "%s.pflash0", base_name);
+				free((void *)bank->name);
+				bank->name = strdup(name);
+			}
+		}
+	} else {
+		strncpy(base_name, target_name(k_chip->target), sizeof(base_name));
+		p = strstr(base_name, ".cpu");
+		if (p)
+			*p = '\0';
+	}
 
-	/* Decide whether the connected device needs watchdog disabling.
-	 * Disable for all Kx devices, i.e., return if it is a KLx */
+	for (bank_idx = 1; bank_idx < num_blocks; bank_idx++) {
+		k_bank = &(k_chip->banks[bank_idx]);
+		bank = k_bank->bank;
 
-	if ((sim_sdid & KINETIS_SDID_SERIESID_MASK) == KINETIS_SDID_SERIESID_KL)
-		return ERROR_OK;
+		if (bank)
+			continue;
 
-	/* The connected device requires watchdog disabling. */
-	retval = target_read_u16(target, WDOG_STCTRH, &wdog);
-	if (retval != ERROR_OK)
-		return retval;
+		num[0] = '\0';
 
-	if ((wdog & 0x1) == 0) {
-		/* watchdog already disabled */
-		return ERROR_OK;
+		if (bank_idx < k_chip->num_pflash_blocks) {
+			class = "pflash";
+			if (k_chip->num_pflash_blocks > 1)
+				snprintf(num, sizeof(num), "%u", bank_idx);
+		} else {
+			class = "flexnvm";
+			if (k_chip->num_nvm_blocks > 1)
+				snprintf(num, sizeof(num), "%u",
+					 bank_idx - k_chip->num_pflash_blocks);
+		}
+
+		bank = calloc(sizeof(struct flash_bank), 1);
+		if (bank == NULL)
+			return ERROR_FAIL;
+
+		bank->target = k_chip->target;
+		bank->driver = &kinetis_flash;
+		bank->default_padded_value = bank->erased_value = 0xff;
+
+		snprintf(name, sizeof(name), "%s.%s%s",
+			 base_name, class, num);
+		bank->name = strdup(name);
+
+		bank->driver_priv = k_bank = &(k_chip->banks[k_chip->num_banks]);
+		k_bank->k_chip = k_chip;
+		k_bank->bank_number = bank_idx;
+		k_bank->bank = bank;
+		if (k_chip->num_banks <= bank_idx)
+			k_chip->num_banks = bank_idx + 1;
+
+		flash_bank_add(bank);
 	}
-	LOG_INFO("Disabling Kinetis watchdog (initial WDOG_STCTRLH = 0x%x)", wdog);
+	return ERROR_OK;
+}
+
+
+static int kinetis_disable_wdog_algo(struct target *target, size_t code_size, const uint8_t *code, uint32_t wdog_base)
+{
+	struct working_area *wdog_algorithm;
+	struct armv7m_algorithm armv7m_info;
+	struct reg_param reg_params[1];
+	int retval;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	retval = target_alloc_working_area(target, sizeof(kinetis_unlock_wdog_code), &wdog_algorithm);
+	retval = target_alloc_working_area(target, code_size, &wdog_algorithm);
 	if (retval != ERROR_OK)
 		return retval;
 
 	retval = target_write_buffer(target, wdog_algorithm->address,
-			sizeof(kinetis_unlock_wdog_code), (uint8_t *)kinetis_unlock_wdog_code);
-	if (retval != ERROR_OK) {
-		target_free_working_area(target, wdog_algorithm);
-		return retval;
-	}
+			code_size, code);
+	if (retval == ERROR_OK) {
+		armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+		armv7m_info.core_mode = ARM_MODE_THREAD;
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
-	armv7m_info.core_mode = ARM_MODE_THREAD;
+		init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
+		buf_set_u32(reg_params[0].value, 0, 32, wdog_base);
 
-	retval = target_run_algorithm(target, 0, NULL, 0, NULL, wdog_algorithm->address,
-			wdog_algorithm->address + (sizeof(kinetis_unlock_wdog_code) - 2),
-			10000, &armv7m_info);
+		retval = target_run_algorithm(target, 0, NULL, 1, reg_params,
+			wdog_algorithm->address,
+			wdog_algorithm->address + code_size - 2,
+			500, &armv7m_info);
 
-	if (retval != ERROR_OK)
-		LOG_ERROR("error executing kinetis wdog unlock algorithm");
+		destroy_reg_param(&reg_params[0]);
 
-	retval = target_read_u16(target, WDOG_STCTRH, &wdog);
-	if (retval != ERROR_OK)
-		return retval;
-	LOG_INFO("WDOG_STCTRLH = 0x%x", wdog);
+		if (retval != ERROR_OK)
+			LOG_ERROR("Error executing Kinetis WDOG unlock algorithm");
+	}
 
 	target_free_working_area(target, wdog_algorithm);
 
 	return retval;
 }
 
-COMMAND_HANDLER(kinetis_disable_wdog_handler)
+/* Disable the watchdog on Kinetis devices
+ * Standard Kx WDOG peripheral checks timing and therefore requires to run algo.
+ */
+static int kinetis_disable_wdog_kx(struct target *target)
 {
-	int result;
-	uint32_t sim_sdid;
-	struct target *target = get_current_target(CMD_CTX);
+	const uint32_t wdog_base = WDOG_BASE;
+	uint16_t wdog;
+	int retval;
 
-	if (CMD_ARGC > 0)
-		return ERROR_COMMAND_SYNTAX_ERROR;
+	static const uint8_t kinetis_unlock_wdog_code[] = {
+#include "../../../contrib/loaders/watchdog/armv7m_kinetis_wdog.inc"
+	};
 
-	result = target_read_u32(target, SIM_SDID, &sim_sdid);
-	if (result != ERROR_OK) {
-		LOG_ERROR("Failed to read SIMSDID");
-		return result;
+	retval = target_read_u16(target, wdog_base + WDOG_STCTRLH_OFFSET, &wdog);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((wdog & 0x1) == 0) {
+		/* watchdog already disabled */
+		return ERROR_OK;
 	}
+	LOG_INFO("Disabling Kinetis watchdog (initial WDOG_STCTRLH = 0x%04" PRIx16 ")", wdog);
 
-	result = kinetis_disable_wdog(target, sim_sdid);
-	return result;
-}
+	retval = kinetis_disable_wdog_algo(target, sizeof(kinetis_unlock_wdog_code), kinetis_unlock_wdog_code, wdog_base);
+	if (retval != ERROR_OK)
+		return retval;
 
+	retval = target_read_u16(target, wdog_base + WDOG_STCTRLH_OFFSET, &wdog);
+	if (retval != ERROR_OK)
+		return retval;
 
-/* Kinetis Program-LongWord Microcodes */
+	LOG_INFO("WDOG_STCTRLH = 0x%04" PRIx16, wdog);
+	return (wdog & 0x1) ? ERROR_FAIL : ERROR_OK;
+}
+
+static int kinetis_disable_wdog32(struct target *target, uint32_t wdog_base)
+{
+	uint32_t wdog_cs;
+	int retval;
+
+	static const uint8_t kinetis_unlock_wdog_code[] = {
+#include "../../../contrib/loaders/watchdog/armv7m_kinetis_wdog32.inc"
+	};
+
+	retval = target_read_u32(target, wdog_base + WDOG32_CS_OFFSET, &wdog_cs);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((wdog_cs & 0x80) == 0)
+		return ERROR_OK; /* watchdog already disabled */
+
+	LOG_INFO("Disabling Kinetis watchdog (initial WDOG_CS 0x%08" PRIx32 ")", wdog_cs);
+
+	retval = kinetis_disable_wdog_algo(target, sizeof(kinetis_unlock_wdog_code), kinetis_unlock_wdog_code, wdog_base);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_read_u32(target, wdog_base + WDOG32_CS_OFFSET, &wdog_cs);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((wdog_cs & 0x80) == 0)
+		return ERROR_OK; /* watchdog disabled successfully */
+
+	LOG_ERROR("Cannot disable Kinetis watchdog (WDOG_CS 0x%08" PRIx32 "), issue 'reset init'", wdog_cs);
+	return ERROR_FAIL;
+}
+
+static int kinetis_disable_wdog(struct kinetis_chip *k_chip)
+{
+	struct target *target = k_chip->target;
+	uint8_t sim_copc;
+	int retval;
+
+	if (!k_chip->probed) {
+		retval = kinetis_probe_chip(k_chip);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	switch (k_chip->watchdog_type) {
+	case KINETIS_WDOG_K:
+		return kinetis_disable_wdog_kx(target);
+
+	case KINETIS_WDOG_COP:
+		retval = target_read_u8(target, SIM_COPC, &sim_copc);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if ((sim_copc & 0xc) == 0)
+			return ERROR_OK; /* watchdog already disabled */
+
+		LOG_INFO("Disabling Kinetis watchdog (initial SIM_COPC 0x%02" PRIx8 ")", sim_copc);
+		retval = target_write_u8(target, SIM_COPC, sim_copc & ~0xc);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = target_read_u8(target, SIM_COPC, &sim_copc);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if ((sim_copc & 0xc) == 0)
+			return ERROR_OK; /* watchdog disabled successfully */
+
+		LOG_ERROR("Cannot disable Kinetis watchdog (SIM_COPC 0x%02" PRIx8 "), issue 'reset init'", sim_copc);
+		return ERROR_FAIL;
+
+	case KINETIS_WDOG32_KE1X:
+		return kinetis_disable_wdog32(target, WDOG32_KE1X);
+
+	case KINETIS_WDOG32_KL28:
+		return kinetis_disable_wdog32(target, WDOG32_KL28);
+
+	default:
+		return ERROR_OK;
+	}
+}
+
+COMMAND_HANDLER(kinetis_disable_wdog_handler)
+{
+	int result;
+	struct target *target = get_current_target(CMD_CTX);
+	struct kinetis_chip *k_chip = kinetis_get_chip(target);
+
+	if (k_chip == NULL)
+		return ERROR_FAIL;
+
+	if (CMD_ARGC > 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	result = kinetis_disable_wdog(k_chip);
+	return result;
+}
+
+
+static int kinetis_ftfx_decode_error(uint8_t fstat)
+{
+	if (fstat & 0x20) {
+		LOG_ERROR("Flash operation failed, illegal command");
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+
+	} else if (fstat & 0x10)
+		LOG_ERROR("Flash operation failed, protection violated");
+
+	else if (fstat & 0x40)
+		LOG_ERROR("Flash operation failed, read collision");
+
+	else if (fstat & 0x80)
+		return ERROR_OK;
+
+	else
+		LOG_ERROR("Flash operation timed out");
+
+	return ERROR_FLASH_OPERATION_FAILED;
+}
+
+static int kinetis_ftfx_clear_error(struct target *target)
+{
+	/* reset error flags */
+	return target_write_u8(target, FTFx_FSTAT, 0x70);
+}
+
+
+static int kinetis_ftfx_prepare(struct target *target)
+{
+	int result, i;
+	uint8_t fstat;
+
+	/* wait until busy */
+	for (i = 0; i < 50; i++) {
+		result = target_read_u8(target, FTFx_FSTAT, &fstat);
+		if (result != ERROR_OK)
+			return result;
+
+		if (fstat & 0x80)
+			break;
+	}
+
+	if ((fstat & 0x80) == 0) {
+		LOG_ERROR("Flash controller is busy");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+	if (fstat != 0x80) {
+		/* reset error flags */
+		result = kinetis_ftfx_clear_error(target);
+	}
+	return result;
+}
+
+/* Kinetis Program-LongWord Microcodes */
 static const uint8_t kinetis_flash_write_code[] = {
-	/* Params:
-	 * r0 - workarea buffer
-	* r1 - target address
-	* r2 - wordcount
-	* Clobbered:
-	* r4 - tmp
-	* r5 - tmp
-	* r6 - tmp
-	* r7 - tmp
-	*/
-
-							/* .L1: */
-						/* for(register uint32_t i=0;i<wcount;i++){ */
-	0x04, 0x1C,					/* mov    r4, r0          */
-	0x00, 0x23,					/* mov    r3, #0          */
-							/* .L2: */
-	0x0E, 0x1A,					/* sub    r6, r1, r0      */
-	0xA6, 0x19,					/* add    r6, r4, r6      */
-	0x93, 0x42,					/* cmp    r3, r2          */
-	0x16, 0xD0,					/* beq    .L9             */
-							/* .L5: */
-						/* while((FTFx_FSTAT&FTFA_FSTAT_CCIF_MASK) != FTFA_FSTAT_CCIF_MASK){}; */
-	0x0B, 0x4D,					/* ldr    r5, .L10        */
-	0x2F, 0x78,					/* ldrb   r7, [r5]        */
-	0x7F, 0xB2,					/* sxtb   r7, r7          */
-	0x00, 0x2F,					/* cmp    r7, #0          */
-	0xFA, 0xDA,					/* bge    .L5             */
-						/* FTFx_FSTAT = FTFA_FSTAT_ACCERR_MASK|FTFA_FSTAT_FPVIOL_MASK|FTFA_FSTAT_RDCO */
-	0x70, 0x27,					/* mov    r7, #112        */
-	0x2F, 0x70,					/* strb   r7, [r5]        */
-						/* FTFx_FCCOB3 = faddr; */
-	0x09, 0x4F,					/* ldr    r7, .L10+4      */
-	0x3E, 0x60,					/* str    r6, [r7]        */
-	0x06, 0x27,					/* mov    r7, #6          */
-						/* FTFx_FCCOB0 = 0x06;  */
-	0x08, 0x4E,					/* ldr    r6, .L10+8      */
-	0x37, 0x70,					/* strb   r7, [r6]        */
-						/* FTFx_FCCOB7 = *pLW;  */
-	0x80, 0xCC,					/* ldmia  r4!, {r7}       */
-	0x08, 0x4E,					/* ldr    r6, .L10+12     */
-	0x37, 0x60,					/* str    r7, [r6]        */
-						/* FTFx_FSTAT = FTFA_FSTAT_CCIF_MASK; */
-	0x80, 0x27,					/* mov    r7, #128        */
-	0x2F, 0x70,					/* strb   r7, [r5]        */
-							/* .L4: */
-						/* while((FTFx_FSTAT&FTFA_FSTAT_CCIF_MASK) != FTFA_FSTAT_CCIF_MASK){}; */
-	0x2E, 0x78,					/* ldrb    r6, [r5]       */
-	0x77, 0xB2,					/* sxtb    r7, r6         */
-	0x00, 0x2F,					/* cmp     r7, #0         */
-	0xFB, 0xDA,					/* bge     .L4            */
-	0x01, 0x33,					/* add     r3, r3, #1     */
-	0xE4, 0xE7,					/* b       .L2            */
-							/* .L9: */
-	0x00, 0xBE,					/* bkpt #0                */
-							/* .L10: */
-	0x00, 0x00, 0x02, 0x40,		/* .word    1073872896    */
-	0x04, 0x00, 0x02, 0x40,		/* .word    1073872900    */
-	0x07, 0x00, 0x02, 0x40,		/* .word    1073872903    */
-	0x08, 0x00, 0x02, 0x40,		/* .word    1073872904    */
+#include "../../../contrib/loaders/flash/kinetis/kinetis_flash.inc"
 };
 
 /* Program LongWord Block Write */
@@ -703,34 +1236,18 @@ static int kinetis_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	uint32_t buffer_size = 2048;		/* Default minimum value */
 	struct working_area *write_algorithm;
 	struct working_area *source;
-	uint32_t address = bank->base + offset;
-	struct reg_param reg_params[3];
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	uint32_t address = k_bank->prog_base + offset;
+	uint32_t end_address;
+	struct reg_param reg_params[5];
 	struct armv7m_algorithm armv7m_info;
-	int retval = ERROR_OK;
-
-	/* Params:
-	 * r0 - workarea buffer
-	 * r1 - target address
-	 * r2 - wordcount
-	 * Clobbered:
-	 * r4 - tmp
-	 * r5 - tmp
-	 * r6 - tmp
-	 * r7 - tmp
-	 */
+	int retval;
+	uint8_t fstat;
 
 	/* Increase buffer_size if needed */
 	if (buffer_size < (target->working_area_size/2))
 		buffer_size = (target->working_area_size/2);
 
-	LOG_INFO("Kinetis: FLASH Write ...");
-
-	/* check code alignment */
-	if (offset & 0x1) {
-		LOG_WARNING("offset 0x%" PRIx32 " breaks required 2-byte alignment", offset);
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-	}
-
 	/* allocate working area with flash programming code */
 	if (target_alloc_working_area(target, sizeof(kinetis_flash_write_code),
 			&write_algorithm) != ERROR_OK) {
@@ -758,35 +1275,39 @@ static int kinetis_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT); /* *pLW (*buffer) */
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT); /* faddr */
-	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT); /* number of words to program */
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT); /* address */
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT); /* word count */
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
+	init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
 
-	/* write code buffer and use Flash programming code within kinetis       */
-	/* Set breakpoint to 0 with time-out of 1000 ms                          */
-	while (wcount > 0) {
-		uint32_t thisrun_count = (wcount > (buffer_size / 4)) ? (buffer_size / 4) : wcount;
+	buf_set_u32(reg_params[0].value, 0, 32, address);
+	buf_set_u32(reg_params[1].value, 0, 32, wcount);
+	buf_set_u32(reg_params[2].value, 0, 32, source->address);
+	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
+	buf_set_u32(reg_params[4].value, 0, 32, FTFx_FSTAT);
 
-		retval = target_write_buffer(target, source->address, thisrun_count * 4, buffer);
-		if (retval != ERROR_OK)
-			break;
+	retval = target_run_flash_async_algorithm(target, buffer, wcount, 4,
+						0, NULL,
+						5, reg_params,
+						source->address, source->size,
+						write_algorithm->address, 0,
+						&armv7m_info);
 
-		buf_set_u32(reg_params[0].value, 0, 32, source->address);
-		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+	if (retval == ERROR_FLASH_OPERATION_FAILED) {
+		end_address = buf_get_u32(reg_params[0].value, 0, 32);
 
-		retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-				write_algorithm->address, 0, 100000, &armv7m_info);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("Error executing kinetis Flash programming algorithm");
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
-		}
+		LOG_ERROR("Error writing flash at %08" PRIx32, end_address);
 
-		buffer += thisrun_count * 4;
-		address += thisrun_count * 4;
-		wcount -= thisrun_count;
-	}
+		retval = target_read_u8(target, FTFx_FSTAT, &fstat);
+		if (retval == ERROR_OK) {
+			retval = kinetis_ftfx_decode_error(fstat);
+
+			/* reset error flags */
+			target_write_u8(target, FTFx_FSTAT, 0x70);
+		}
+	} else if (retval != ERROR_OK)
+		LOG_ERROR("Error executing kinetis Flash programming algorithm");
 
 	target_free_working_area(target, source);
 	target_free_working_area(target, write_algorithm);
@@ -794,172 +1315,306 @@ static int kinetis_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	destroy_reg_param(&reg_params[0]);
 	destroy_reg_param(&reg_params[1]);
 	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+	destroy_reg_param(&reg_params[4]);
 
 	return retval;
 }
 
 static int kinetis_protect(struct flash_bank *bank, int set, int first, int last)
 {
-	LOG_WARNING("kinetis_protect not supported yet");
-	/* FIXME: TODO */
+	int i;
 
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+	if (allow_fcf_writes) {
+		LOG_ERROR("Protection setting is possible with 'kinetis fcf_source protection' only!");
+		return ERROR_FAIL;
+	}
+
+	if (!bank->prot_blocks || bank->num_prot_blocks == 0) {
+		LOG_ERROR("No protection possible for current bank!");
+		return ERROR_FLASH_BANK_INVALID;
 	}
 
-	return ERROR_FLASH_BANK_INVALID;
+	for (i = first; i < bank->num_prot_blocks && i <= last; i++)
+		bank->prot_blocks[i].is_protected = set;
+
+	LOG_INFO("Protection bits will be written at the next FCF sector erase or write.");
+	LOG_INFO("Do not issue 'flash info' command until protection is written,");
+	LOG_INFO("doing so would re-read protection status from MCU.");
+
+	return ERROR_OK;
 }
 
 static int kinetis_protect_check(struct flash_bank *bank)
 {
-	struct kinetis_flash_bank *kinfo = bank->driver_priv;
-
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	int result;
+	int i, b;
+	uint32_t fprot;
 
-	if (kinfo->flash_class == FC_PFLASH) {
-		int result;
-		uint8_t buffer[4];
-		uint32_t fprot, psec;
-		int i, b;
+	if (k_bank->flash_class == FC_PFLASH) {
 
 		/* read protection register */
-		result = target_read_memory(bank->target, FTFx_FPROT3, 1, 4, buffer);
-
+		result = target_read_u32(bank->target, FTFx_FPROT3, &fprot);
 		if (result != ERROR_OK)
 			return result;
 
-		fprot = target_buffer_get_u32(bank->target, buffer);
+		/* Every bit protects 1/32 of the full flash (not necessarily just this bank) */
 
-		/*
-		 * Every bit protects 1/32 of the full flash (not necessarily
-		 * just this bank), but we enforce the bank ordinals for
-		 * PFlash to start at zero.
-		 */
-		b = kinfo->bank_ordinal * (bank->size / kinfo->protection_size);
-		for (psec = 0, i = 0; i < bank->num_sectors; i++) {
-			if ((fprot >> b) & 1)
-				bank->sectors[i].is_protected = 0;
-			else
-				bank->sectors[i].is_protected = 1;
+	} else if (k_bank->flash_class == FC_FLEX_NVM) {
+		uint8_t fdprot;
 
-			psec += bank->sectors[i].size;
+		/* read protection register */
+		result = target_read_u8(bank->target, FTFx_FDPROT, &fdprot);
+		if (result != ERROR_OK)
+			return result;
+
+		fprot = fdprot;
 
-			if (psec >= kinfo->protection_size) {
-				psec = 0;
-				b++;
-			}
-		}
 	} else {
-		LOG_ERROR("Protection checks for FlexNVM not yet supported");
+		LOG_ERROR("Protection checks for FlexRAM not supported");
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
+	b = k_bank->protection_block;
+	for (i = 0; i < bank->num_prot_blocks; i++) {
+		if ((fprot >> b) & 1)
+			bank->prot_blocks[i].is_protected = 0;
+		else
+			bank->prot_blocks[i].is_protected = 1;
+
+		b++;
+	}
+
 	return ERROR_OK;
 }
 
-static int kinetis_ftfx_command(struct flash_bank *bank, uint8_t fcmd, uint32_t faddr,
-				uint8_t fccob4, uint8_t fccob5, uint8_t fccob6, uint8_t fccob7,
-				uint8_t fccob8, uint8_t fccob9, uint8_t fccoba, uint8_t fccobb,
-				uint8_t *ftfx_fstat)
+
+static int kinetis_fill_fcf(struct flash_bank *bank, uint8_t *fcf)
 {
-	uint8_t command[12] = {faddr & 0xff, (faddr >> 8) & 0xff, (faddr >> 16) & 0xff, fcmd,
-			fccob7, fccob6, fccob5, fccob4,
-			fccobb, fccoba, fccob9, fccob8};
-	int result, i;
-	uint8_t buffer;
+	uint32_t fprot = 0xffffffff;
+	uint8_t fsec = 0xfe;		 /* set MCU unsecure */
+	uint8_t fdprot = 0xff;
+	int i;
+	unsigned bank_idx;
+	unsigned num_blocks;
+	uint32_t pflash_bit;
+	uint8_t dflash_bit;
+	struct flash_bank *bank_iter;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+
+	memset(fcf, 0xff, FCF_SIZE);
+
+	pflash_bit = 1;
+	dflash_bit = 1;
+
+	/* iterate over all kinetis banks */
+	/* current bank is bank 0, it contains FCF */
+	num_blocks = k_chip->num_pflash_blocks + k_chip->num_nvm_blocks;
+	for (bank_idx = 0; bank_idx < num_blocks; bank_idx++) {
+		k_bank = &(k_chip->banks[bank_idx]);
+		bank_iter = k_bank->bank;
+
+		if (bank_iter == NULL) {
+			LOG_WARNING("Missing bank %u configuration, FCF protection flags may be incomplette", bank_idx);
+			continue;
+		}
 
-	/* wait for done */
-	for (i = 0; i < 50; i++) {
-		result =
-			target_read_memory(bank->target, FTFx_FSTAT, 1, 1, &buffer);
+		kinetis_auto_probe(bank_iter);
 
-		if (result != ERROR_OK)
-			return result;
+		if (k_bank->flash_class == FC_PFLASH) {
+			for (i = 0; i < bank_iter->num_prot_blocks; i++) {
+				if (bank_iter->prot_blocks[i].is_protected == 1)
+					fprot &= ~pflash_bit;
 
-		if (buffer & 0x80)
-			break;
+				pflash_bit <<= 1;
+			}
 
-		buffer = 0x00;
-	}
+		} else if (k_bank->flash_class == FC_FLEX_NVM) {
+			for (i = 0; i < bank_iter->num_prot_blocks; i++) {
+				if (bank_iter->prot_blocks[i].is_protected == 1)
+					fdprot &= ~dflash_bit;
 
-	if (buffer != 0x80) {
-		/* reset error flags */
-		buffer = 0x30;
-		result =
-			target_write_memory(bank->target, FTFx_FSTAT, 1, 1, &buffer);
-		if (result != ERROR_OK)
-			return result;
+				dflash_bit <<= 1;
+			}
+
+		}
 	}
 
-	result = target_write_memory(bank->target, FTFx_FCCOB3, 4, 3, command);
+	target_buffer_set_u32(bank->target, fcf + FCF_FPROT, fprot);
+	fcf[FCF_FSEC] = fsec;
+	fcf[FCF_FOPT] = fcf_fopt;
+	fcf[FCF_FDPROT] = fdprot;
+	return ERROR_OK;
+}
+
+static int kinetis_ftfx_command(struct target *target, uint8_t fcmd, uint32_t faddr,
+				uint8_t fccob4, uint8_t fccob5, uint8_t fccob6, uint8_t fccob7,
+				uint8_t fccob8, uint8_t fccob9, uint8_t fccoba, uint8_t fccobb,
+				uint8_t *ftfx_fstat)
+{
+	uint8_t command[12] = {faddr & 0xff, (faddr >> 8) & 0xff, (faddr >> 16) & 0xff, fcmd,
+			fccob7, fccob6, fccob5, fccob4,
+			fccobb, fccoba, fccob9, fccob8};
+	int result;
+	uint8_t fstat;
+	int64_t ms_timeout = timeval_ms() + 250;
 
+	result = target_write_memory(target, FTFx_FCCOB3, 4, 3, command);
 	if (result != ERROR_OK)
 		return result;
 
 	/* start command */
-	buffer = 0x80;
-	result = target_write_memory(bank->target, FTFx_FSTAT, 1, 1, &buffer);
+	result = target_write_u8(target, FTFx_FSTAT, 0x80);
 	if (result != ERROR_OK)
 		return result;
 
 	/* wait for done */
-	for (i = 0; i < 240; i++) { /* Need longtime for "Mass Erase" Command Nemui Changed */
-		result =
-			target_read_memory(bank->target, FTFx_FSTAT, 1, 1, ftfx_fstat);
+	do {
+		result = target_read_u8(target, FTFx_FSTAT, &fstat);
 
 		if (result != ERROR_OK)
 			return result;
 
-		if (*ftfx_fstat & 0x80)
+		if (fstat & 0x80)
 			break;
-	}
 
-	if ((*ftfx_fstat & 0xf0) != 0x80) {
-		LOG_ERROR
-			("ftfx command failed FSTAT: %02X FCCOB: %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
-			 *ftfx_fstat, command[3], command[2], command[1], command[0],
+	} while (timeval_ms() < ms_timeout);
+
+	if (ftfx_fstat)
+		*ftfx_fstat = fstat;
+
+	if ((fstat & 0xf0) != 0x80) {
+		LOG_DEBUG("ftfx command failed FSTAT: %02X FCCOB: %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X",
+			 fstat, command[3], command[2], command[1], command[0],
 			 command[7], command[6], command[5], command[4],
 			 command[11], command[10], command[9], command[8]);
-		return ERROR_FLASH_OPERATION_FAILED;
+
+		return kinetis_ftfx_decode_error(fstat);
 	}
 
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(kinetis_securing_test)
+
+static int kinetis_read_pmstat(struct kinetis_chip *k_chip, uint8_t *pmstat)
 {
 	int result;
-	uint8_t ftfx_fstat;
-	struct target *target = get_current_target(CMD_CTX);
-	struct flash_bank *bank = NULL;
+	uint32_t stat32;
+	struct target *target = k_chip->target;
 
-	result = get_flash_bank_by_addr(target, 0x00000000, true, &bank);
-	if (result != ERROR_OK)
+	switch (k_chip->sysmodectrlr_type) {
+	case KINETIS_SMC:
+		result = target_read_u8(target, SMC_PMSTAT, pmstat);
 		return result;
 
-	assert(bank != NULL);
+	case KINETIS_SMC32:
+		result = target_read_u32(target, SMC32_PMSTAT, &stat32);
+		if (result == ERROR_OK)
+			*pmstat = stat32 & 0xff;
+		return result;
+	}
+	return ERROR_FAIL;
+}
+
+static int kinetis_check_run_mode(struct kinetis_chip *k_chip)
+{
+	int result, i;
+	uint8_t pmstat;
+	struct target *target;
+
+	if (k_chip == NULL) {
+		LOG_ERROR("Chip not probed.");
+		return ERROR_FAIL;
+	}
+	target = k_chip->target;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	return kinetis_ftfx_command(bank, FTFx_CMD_SECTERASE, bank->base + 0x00000400,
-				      0, 0, 0, 0,  0, 0, 0, 0,  &ftfx_fstat);
+	result = kinetis_read_pmstat(k_chip, &pmstat);
+	if (result != ERROR_OK)
+		return result;
+
+	if (pmstat == PM_STAT_RUN)
+		return ERROR_OK;
+
+	if (pmstat == PM_STAT_VLPR) {
+		/* It is safe to switch from VLPR to RUN mode without changing clock */
+		LOG_INFO("Switching from VLPR to RUN mode.");
+
+		switch (k_chip->sysmodectrlr_type) {
+		case KINETIS_SMC:
+			result = target_write_u8(target, SMC_PMCTRL, PM_CTRL_RUNM_RUN);
+			break;
+
+		case KINETIS_SMC32:
+			result = target_write_u32(target, SMC32_PMCTRL, PM_CTRL_RUNM_RUN);
+			break;
+		}
+		if (result != ERROR_OK)
+			return result;
+
+		for (i = 100; i; i--) {
+			result = kinetis_read_pmstat(k_chip, &pmstat);
+			if (result != ERROR_OK)
+				return result;
+
+			if (pmstat == PM_STAT_RUN)
+				return ERROR_OK;
+		}
+	}
+
+	LOG_ERROR("Flash operation not possible in current run mode: SMC_PMSTAT: 0x%x", pmstat);
+	LOG_ERROR("Issue a 'reset init' command.");
+	return ERROR_TARGET_NOT_HALTED;
 }
 
+
+static void kinetis_invalidate_flash_cache(struct kinetis_chip *k_chip)
+{
+	struct target *target = k_chip->target;
+
+	switch (k_chip->cache_type) {
+	case KINETIS_CACHE_K:
+		target_write_u8(target, FMC_PFB01CR + 2, 0xf0);
+		/* Set CINV_WAY bits - request invalidate of all cache ways */
+		/* FMC_PFB0CR has same address and CINV_WAY bits as FMC_PFB01CR */
+		break;
+
+	case KINETIS_CACHE_L:
+		target_write_u8(target, MCM_PLACR + 1, 0x04);
+		/* set bit CFCC - Clear Flash Controller Cache */
+		break;
+
+	case KINETIS_CACHE_MSCM:
+		target_write_u32(target, MSCM_OCMDR0, 0x30);
+		/* disable data prefetch and flash speculate */
+		break;
+
+	default:
+		break;
+	}
+}
+
+
 static int kinetis_erase(struct flash_bank *bank, int first, int last)
 {
 	int result, i;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
 
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
+	result = kinetis_check_run_mode(k_chip);
+	if (result != ERROR_OK)
+		return result;
+
+	/* reset error flags */
+	result = kinetis_ftfx_prepare(bank->target);
+	if (result != ERROR_OK)
+		return result;
 
 	if ((first > bank->num_sectors) || (last > bank->num_sectors))
 		return ERROR_FLASH_OPERATION_FAILED;
@@ -970,10 +1625,9 @@ static int kinetis_erase(struct flash_bank *bank, int first, int last)
 	 * block.  Should be quicker.
 	 */
 	for (i = first; i <= last; i++) {
-		uint8_t ftfx_fstat;
 		/* set command and sector address */
-		result = kinetis_ftfx_command(bank, FTFx_CMD_SECTERASE, bank->base + bank->sectors[i].offset,
-				0, 0, 0, 0,  0, 0, 0, 0,  &ftfx_fstat);
+		result = kinetis_ftfx_command(bank->target, FTFx_CMD_SECTERASE, k_bank->prog_base + bank->sectors[i].offset,
+				0, 0, 0, 0,  0, 0, 0, 0,  NULL);
 
 		if (result != ERROR_OK) {
 			LOG_WARNING("erase sector %d failed", i);
@@ -981,147 +1635,186 @@ static int kinetis_erase(struct flash_bank *bank, int first, int last)
 		}
 
 		bank->sectors[i].is_erased = 1;
-	}
 
-	if (first == 0) {
-		LOG_WARNING
-			("flash configuration field erased, please reset the device");
+		if (k_bank->prog_base == 0
+			&& bank->sectors[i].offset <= FCF_ADDRESS
+			&& bank->sectors[i].offset + bank->sectors[i].size > FCF_ADDRESS + FCF_SIZE) {
+			if (allow_fcf_writes) {
+				LOG_WARNING("Flash Configuration Field erased, DO NOT reset or power off the device");
+				LOG_WARNING("until correct FCF is programmed or MCU gets security lock.");
+			} else {
+				uint8_t fcf_buffer[FCF_SIZE];
+
+				kinetis_fill_fcf(bank, fcf_buffer);
+				result = kinetis_write_inner(bank, fcf_buffer, FCF_ADDRESS, FCF_SIZE);
+				if (result != ERROR_OK)
+					LOG_WARNING("Flash Configuration Field write failed");
+				bank->sectors[i].is_erased = 0;
+			}
+		}
 	}
 
+	kinetis_invalidate_flash_cache(k_bank->k_chip);
+
 	return ERROR_OK;
 }
 
-static int kinetis_write(struct flash_bank *bank, const uint8_t *buffer,
-			 uint32_t offset, uint32_t count)
+static int kinetis_make_ram_ready(struct target *target)
 {
-	unsigned int i, result, fallback = 0;
-	uint8_t buf[8];
-	uint32_t wc;
-	struct kinetis_flash_bank *kinfo = bank->driver_priv;
-	uint8_t *new_buffer = NULL;
+	int result;
+	uint8_t ftfx_fcnfg;
 
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
+	/* check if ram ready */
+	result = target_read_u8(target, FTFx_FCNFG, &ftfx_fcnfg);
+	if (result != ERROR_OK)
+		return result;
 
-	if (!(kinfo->flash_support & FS_PROGRAM_SECTOR)) {
-		/* fallback to longword write */
-		fallback = 1;
-		LOG_WARNING("This device supports Program Longword execution only.");
-		LOG_DEBUG("flash write into PFLASH @08%" PRIX32, offset);
+	if (ftfx_fcnfg & (1 << 1))
+		return ERROR_OK;	/* ram ready */
+
+	/* make flex ram available */
+	result = kinetis_ftfx_command(target, FTFx_CMD_SETFLEXRAM, 0x00ff0000,
+				 0, 0, 0, 0,  0, 0, 0, 0,  NULL);
+	if (result != ERROR_OK)
+		return ERROR_FLASH_OPERATION_FAILED;
+
+	/* check again */
+	result = target_read_u8(target, FTFx_FCNFG, &ftfx_fcnfg);
+	if (result != ERROR_OK)
+		return result;
+
+	if (ftfx_fcnfg & (1 << 1))
+		return ERROR_OK;	/* ram ready */
+
+	return ERROR_FLASH_OPERATION_FAILED;
+}
 
-	} else if (kinfo->flash_class == FC_FLEX_NVM) {
+
+static int kinetis_write_sections(struct flash_bank *bank, const uint8_t *buffer,
+			 uint32_t offset, uint32_t count)
+{
+	int result = ERROR_OK;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+	uint8_t *buffer_aligned = NULL;
+	/*
+	 * Kinetis uses different terms for the granularity of
+	 * sector writes, e.g. "phrase" or "128 bits".  We use
+	 * the generic term "chunk". The largest possible
+	 * Kinetis "chunk" is 16 bytes (128 bits).
+	 */
+	uint32_t prog_section_chunk_bytes = k_bank->sector_size >> 8;
+	uint32_t prog_size_bytes = k_chip->max_flash_prog_size;
+
+	while (count > 0) {
+		uint32_t size = prog_size_bytes - offset % prog_size_bytes;
+		uint32_t align_begin = offset % prog_section_chunk_bytes;
+		uint32_t align_end;
+		uint32_t size_aligned;
+		uint16_t chunk_count;
 		uint8_t ftfx_fstat;
 
-		LOG_DEBUG("flash write into FlexNVM @%08" PRIX32, offset);
+		if (size > count)
+			size = count;
 
-		/* make flex ram available */
-		result = kinetis_ftfx_command(bank, FTFx_CMD_SETFLEXRAM, 0x00ff0000, 0, 0, 0, 0,  0, 0, 0, 0,  &ftfx_fstat);
+		align_end = (align_begin + size) % prog_section_chunk_bytes;
+		if (align_end)
+			align_end = prog_section_chunk_bytes - align_end;
 
-		if (result != ERROR_OK)
-			return ERROR_FLASH_OPERATION_FAILED;
+		size_aligned = align_begin + size + align_end;
+		chunk_count = size_aligned / prog_section_chunk_bytes;
 
-		/* check if ram ready */
-		result = target_read_memory(bank->target, FTFx_FCNFG, 1, 1, buf);
+		if (size != size_aligned) {
+			/* aligned section: the first, the last or the only */
+			if (!buffer_aligned)
+				buffer_aligned = malloc(prog_size_bytes);
 
-		if (result != ERROR_OK)
-			return result;
+			memset(buffer_aligned, 0xff, size_aligned);
+			memcpy(buffer_aligned + align_begin, buffer, size);
 
-		if (!(buf[0] & (1 << 1))) {
-			/* fallback to longword write */
-			fallback = 1;
+			result = target_write_memory(bank->target, k_chip->progr_accel_ram,
+						4, size_aligned / 4, buffer_aligned);
 
-			LOG_WARNING("ram not ready, fallback to slow longword write (FCNFG: %02X)", buf[0]);
-		}
-	} else {
-		LOG_DEBUG("flash write into PFLASH @08%" PRIX32, offset);
-	}
+			LOG_DEBUG("section @ %08" PRIx32 " aligned begin %" PRIu32 ", end %" PRIu32,
+					bank->base + offset, align_begin, align_end);
+		} else
+			result = target_write_memory(bank->target, k_chip->progr_accel_ram,
+						4, size_aligned / 4, buffer);
 
+		LOG_DEBUG("write section @ %08" PRIx32 " with length %" PRIu32 " bytes",
+			  bank->base + offset, size);
 
-	/* program section command */
-	if (fallback == 0) {
-		/*
-		 * Kinetis uses different terms for the granularity of
-		 * sector writes, e.g. "phrase" or "128 bits".  We use
-		 * the generic term "chunk". The largest possible
-		 * Kinetis "chunk" is 16 bytes (128 bits).
-		 */
-		unsigned prog_section_chunk_bytes = kinfo->sector_size >> 8;
-		unsigned prog_size_bytes = kinfo->max_flash_prog_size;
-		for (i = 0; i < count; i += prog_size_bytes) {
-			uint8_t residual_buffer[16];
-			uint8_t ftfx_fstat;
-			uint32_t section_count = prog_size_bytes / prog_section_chunk_bytes;
-			uint32_t residual_wc = 0;
-
-			/*
-			 * Assume the word count covers an entire
-			 * sector.
-			 */
-			wc = prog_size_bytes / 4;
-
-			/*
-			 * If bytes to be programmed are less than the
-			 * full sector, then determine the number of
-			 * full-words to program, and put together the
-			 * residual buffer so that a full "section"
-			 * may always be programmed.
-			 */
-			if ((count - i) < prog_size_bytes) {
-				/* number of bytes to program beyond full section */
-				unsigned residual_bc = (count-i) % prog_section_chunk_bytes;
-
-				/* number of complete words to copy directly from buffer */
-				wc = (count - i - residual_bc) / 4;
-
-				/* number of total sections to write, including residual */
-				section_count = DIV_ROUND_UP((count-i), prog_section_chunk_bytes);
-
-				/* any residual bytes delivers a whole residual section */
-				residual_wc = (residual_bc ? prog_section_chunk_bytes : 0)/4;
-
-				/* clear residual buffer then populate residual bytes */
-				(void) memset(residual_buffer, 0xff, prog_section_chunk_bytes);
-				(void) memcpy(residual_buffer, &buffer[i+4*wc], residual_bc);
-			}
+		if (result != ERROR_OK) {
+			LOG_ERROR("target_write_memory failed");
+			break;
+		}
 
-			LOG_DEBUG("write section @ %08" PRIX32 " with length %" PRIu32 " bytes",
-				  offset + i, (uint32_t)wc*4);
+		/* execute section-write command */
+		result = kinetis_ftfx_command(bank->target, FTFx_CMD_SECTWRITE,
+				k_bank->prog_base + offset - align_begin,
+				chunk_count>>8, chunk_count, 0, 0,
+				0, 0, 0, 0,  &ftfx_fstat);
 
-			/* write data to flexram as whole-words */
-			result = target_write_memory(bank->target, FLEXRAM, 4, wc,
-					buffer + i);
+		if (result != ERROR_OK) {
+			LOG_ERROR("Error writing section at %08" PRIx32, bank->base + offset);
+			break;
+		}
 
-			if (result != ERROR_OK) {
-				LOG_ERROR("target_write_memory failed");
-				return result;
+		if (ftfx_fstat & 0x01) {
+			LOG_ERROR("Flash write error at %08" PRIx32, bank->base + offset);
+			if (k_bank->prog_base == 0 && offset == FCF_ADDRESS + FCF_SIZE
+					&& (k_chip->flash_support & FS_WIDTH_256BIT)) {
+				LOG_ERROR("Flash write immediately after the end of Flash Config Field shows error");
+				LOG_ERROR("because the flash memory is 256 bits wide (data were written correctly).");
+				LOG_ERROR("Either change the linker script to add a gap of 16 bytes after FCF");
+				LOG_ERROR("or set 'kinetis fcf_source write'");
 			}
+		}
 
-			/* write the residual words to the flexram */
-			if (residual_wc) {
-				result = target_write_memory(bank->target,
-						FLEXRAM+4*wc,
-						4, residual_wc,
-						residual_buffer);
+		buffer += size;
+		offset += size;
+		count -= size;
+	}
 
-				if (result != ERROR_OK) {
-					LOG_ERROR("target_write_memory failed");
-					return result;
-				}
-			}
+	free(buffer_aligned);
+	return result;
+}
 
-			/* execute section-write command */
-			result = kinetis_ftfx_command(bank, FTFx_CMD_SECTWRITE, bank->base + offset + i,
-					section_count>>8, section_count, 0, 0,
-					0, 0, 0, 0,  &ftfx_fstat);
 
-			if (result != ERROR_OK)
-				return ERROR_FLASH_OPERATION_FAILED;
+static int kinetis_write_inner(struct flash_bank *bank, const uint8_t *buffer,
+			 uint32_t offset, uint32_t count)
+{
+	int result, fallback = 0;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+
+	if (!(k_chip->flash_support & FS_PROGRAM_SECTOR)) {
+		/* fallback to longword write */
+		fallback = 1;
+		LOG_INFO("This device supports Program Longword execution only.");
+	} else {
+		result = kinetis_make_ram_ready(bank->target);
+		if (result != ERROR_OK) {
+			fallback = 1;
+			LOG_WARNING("FlexRAM not ready, fallback to slow longword write.");
 		}
 	}
-	/* program longword command, not supported in "SF3" devices */
-	else if (kinfo->flash_support & FS_PROGRAM_LONGWORD) {
+
+	LOG_DEBUG("flash write @ %08" PRIx32, bank->base + offset);
+
+	if (fallback == 0) {
+		/* program section command */
+		kinetis_write_sections(bank, buffer, offset, count);
+	} else if (k_chip->flash_support & FS_PROGRAM_LONGWORD) {
+		/* program longword command, not supported in FTFE */
+		uint8_t *new_buffer = NULL;
+
+		/* check word alignment */
+		if (offset & 0x3) {
+			LOG_ERROR("offset 0x%" PRIx32 " breaks the required alignment", offset);
+			return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+		}
+
 		if (count & 0x3) {
 			uint32_t old_count = count;
 			count = (old_count | 3) + 1;
@@ -1133,74 +1826,179 @@ static int kinetis_write(struct flash_bank *bank, const uint8_t *buffer,
 			}
 			LOG_INFO("odd number of bytes to write (%" PRIu32 "), extending to %" PRIu32 " "
 				"and padding with 0xff", old_count, count);
-			memset(new_buffer, 0xff, count);
+			memset(new_buffer + old_count, 0xff, count - old_count);
 			buffer = memcpy(new_buffer, buffer, old_count);
 		}
 
 		uint32_t words_remaining = count / 4;
 
-		kinetis_disable_wdog(bank->target, kinfo->sim_sdid);
+		kinetis_disable_wdog(k_chip);
 
 		/* try using a block write */
-		int retval = kinetis_write_block(bank, buffer, offset, words_remaining);
+		result = kinetis_write_block(bank, buffer, offset, words_remaining);
 
-		if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
+		if (result == ERROR_TARGET_RESOURCE_NOT_AVAILABLE) {
 			/* if block write failed (no sufficient working area),
 			 * we use normal (slow) single word accesses */
 			LOG_WARNING("couldn't use block writes, falling back to single "
 				"memory accesses");
 
-			for (i = 0; i < count; i += 4) {
+			while (words_remaining) {
 				uint8_t ftfx_fstat;
 
-				LOG_DEBUG("write longword @ %08" PRIX32, (uint32_t)(offset + i));
+				LOG_DEBUG("write longword @ %08" PRIx32, (uint32_t)(bank->base + offset));
 
-				uint8_t padding[4] = {0xff, 0xff, 0xff, 0xff};
-				memcpy(padding, buffer + i, MIN(4, count-i));
-
-				result = kinetis_ftfx_command(bank, FTFx_CMD_LWORDPROG, bank->base + offset + i,
-						padding[3], padding[2], padding[1], padding[0],
+				result = kinetis_ftfx_command(bank->target, FTFx_CMD_LWORDPROG, k_bank->prog_base + offset,
+						buffer[3], buffer[2], buffer[1], buffer[0],
 						0, 0, 0, 0,  &ftfx_fstat);
 
-				if (result != ERROR_OK)
-					return ERROR_FLASH_OPERATION_FAILED;
+				if (result != ERROR_OK) {
+					LOG_ERROR("Error writing longword at %08" PRIx32, bank->base + offset);
+					break;
+				}
+
+				if (ftfx_fstat & 0x01)
+					LOG_ERROR("Flash write error at %08" PRIx32, bank->base + offset);
+
+				buffer += 4;
+				offset += 4;
+				words_remaining--;
 			}
 		}
+		free(new_buffer);
 	} else {
 		LOG_ERROR("Flash write strategy not implemented");
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	return ERROR_OK;
+	kinetis_invalidate_flash_cache(k_chip);
+	return result;
 }
 
-static int kinetis_read_part_info(struct flash_bank *bank)
+
+static int kinetis_write(struct flash_bank *bank, const uint8_t *buffer,
+			 uint32_t offset, uint32_t count)
 {
-	int result, i;
-	uint32_t offset = 0;
-	uint8_t fcfg1_nvmsize, fcfg1_pfsize, fcfg1_eesize, fcfg2_pflsh;
-	uint32_t nvm_size = 0, pf_size = 0, ee_size = 0;
-	unsigned num_blocks = 0, num_pflash_blocks = 0, num_nvm_blocks = 0, first_nvm_bank = 0,
-			reassign = 0, pflash_sector_size_bytes = 0, nvm_sector_size_bytes = 0;
-	struct target *target = bank->target;
-	struct kinetis_flash_bank *kinfo = bank->driver_priv;
+	int result;
+	bool set_fcf = false;
+	int sect = 0;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+
+	result = kinetis_check_run_mode(k_chip);
+	if (result != ERROR_OK)
+		return result;
 
-	result = target_read_u32(target, SIM_SDID, &kinfo->sim_sdid);
+	/* reset error flags */
+	result = kinetis_ftfx_prepare(bank->target);
 	if (result != ERROR_OK)
 		return result;
 
-	if ((kinfo->sim_sdid & (~KINETIS_SDID_K_SERIES_MASK)) == 0) {
+	if (k_bank->prog_base == 0 && !allow_fcf_writes) {
+		if (bank->sectors[1].offset <= FCF_ADDRESS)
+			sect = 1;	/* 1kb sector, FCF in 2nd sector */
+
+		if (offset < bank->sectors[sect].offset + bank->sectors[sect].size
+			&& offset + count > bank->sectors[sect].offset)
+			set_fcf = true; /* write to any part of sector with FCF */
+	}
+
+	if (set_fcf) {
+		uint8_t fcf_buffer[FCF_SIZE];
+		uint8_t fcf_current[FCF_SIZE];
+
+		kinetis_fill_fcf(bank, fcf_buffer);
+
+		if (offset < FCF_ADDRESS) {
+			/* write part preceding FCF */
+			result = kinetis_write_inner(bank, buffer, offset, FCF_ADDRESS - offset);
+			if (result != ERROR_OK)
+				return result;
+		}
+
+		result = target_read_memory(bank->target, bank->base + FCF_ADDRESS, 4, FCF_SIZE / 4, fcf_current);
+		if (result == ERROR_OK && memcmp(fcf_current, fcf_buffer, FCF_SIZE) == 0)
+			set_fcf = false;
+
+		if (set_fcf) {
+			/* write FCF if differs from flash - eliminate multiple writes */
+			result = kinetis_write_inner(bank, fcf_buffer, FCF_ADDRESS, FCF_SIZE);
+			if (result != ERROR_OK)
+				return result;
+		}
+
+		LOG_WARNING("Flash Configuration Field written.");
+		LOG_WARNING("Reset or power off the device to make settings effective.");
+
+		if (offset + count > FCF_ADDRESS + FCF_SIZE) {
+			uint32_t delta = FCF_ADDRESS + FCF_SIZE - offset;
+			/* write part after FCF */
+			result = kinetis_write_inner(bank, buffer + delta, FCF_ADDRESS + FCF_SIZE, count - delta);
+		}
+		return result;
+
+	} else
+		/* no FCF fiddling, normal write */
+		return kinetis_write_inner(bank, buffer, offset, count);
+}
+
+
+static int kinetis_probe_chip(struct kinetis_chip *k_chip)
+{
+	int result;
+	uint8_t fcfg1_nvmsize, fcfg1_pfsize, fcfg1_eesize, fcfg1_depart;
+	uint8_t fcfg2_pflsh;
+	uint32_t ee_size = 0;
+	uint32_t pflash_size_k, nvm_size_k, dflash_size_k;
+	uint32_t pflash_size_m;
+	unsigned num_blocks = 0;
+	unsigned maxaddr_shift = 13;
+	struct target *target = k_chip->target;
+
+	unsigned familyid = 0, subfamid = 0;
+	unsigned cpu_mhz = 120;
+	unsigned idx;
+	bool use_nvm_marking = false;
+	char flash_marking[11], nvm_marking[2];
+	char name[40];
+
+	k_chip->probed = false;
+	k_chip->pflash_sector_size = 0;
+	k_chip->pflash_base = 0;
+	k_chip->nvm_base = 0x10000000;
+	k_chip->progr_accel_ram = FLEXRAM;
+
+	name[0] = '\0';
+
+	if (k_chip->sim_base)
+		result = target_read_u32(target, k_chip->sim_base + SIM_SDID_OFFSET, &k_chip->sim_sdid);
+	else {
+		result = target_read_u32(target, SIM_BASE + SIM_SDID_OFFSET, &k_chip->sim_sdid);
+		if (result == ERROR_OK)
+			k_chip->sim_base = SIM_BASE;
+		else {
+			result = target_read_u32(target, SIM_BASE_KL28 + SIM_SDID_OFFSET, &k_chip->sim_sdid);
+			if (result == ERROR_OK)
+				k_chip->sim_base = SIM_BASE_KL28;
+		}
+	}
+	if (result != ERROR_OK)
+		return result;
+
+	if ((k_chip->sim_sdid & (~KINETIS_SDID_K_SERIES_MASK)) == 0) {
 		/* older K-series MCU */
-		uint32_t mcu_type = kinfo->sim_sdid & KINETIS_K_SDID_TYPE_MASK;
+		uint32_t mcu_type = k_chip->sim_sdid & KINETIS_K_SDID_TYPE_MASK;
+		k_chip->cache_type = KINETIS_CACHE_K;
+		k_chip->watchdog_type = KINETIS_WDOG_K;
 
 		switch (mcu_type) {
 		case KINETIS_K_SDID_K10_M50:
 		case KINETIS_K_SDID_K20_M50:
 			/* 1kB sectors */
-			pflash_sector_size_bytes = 1<<10;
-			nvm_sector_size_bytes = 1<<10;
+			k_chip->pflash_sector_size = 1<<10;
+			k_chip->nvm_sector_size = 1<<10;
 			num_blocks = 2;
-			kinfo->flash_support = FS_PROGRAM_LONGWORD | FS_PROGRAM_SECTOR;
+			k_chip->flash_support = FS_PROGRAM_LONGWORD | FS_PROGRAM_SECTOR;
 			break;
 		case KINETIS_K_SDID_K10_M72:
 		case KINETIS_K_SDID_K20_M72:
@@ -1210,11 +2008,11 @@ static int kinetis_read_part_info(struct flash_bank *bank)
 		case KINETIS_K_SDID_K40_M100:
 		case KINETIS_K_SDID_K50_M72:
 			/* 2kB sectors, 1kB FlexNVM sectors */
-			pflash_sector_size_bytes = 2<<10;
-			nvm_sector_size_bytes = 1<<10;
+			k_chip->pflash_sector_size = 2<<10;
+			k_chip->nvm_sector_size = 1<<10;
 			num_blocks = 2;
-			kinfo->flash_support = FS_PROGRAM_LONGWORD | FS_PROGRAM_SECTOR;
-			kinfo->max_flash_prog_size = 1<<10;
+			k_chip->flash_support = FS_PROGRAM_LONGWORD | FS_PROGRAM_SECTOR;
+			k_chip->max_flash_prog_size = 1<<10;
 			break;
 		case KINETIS_K_SDID_K10_M100:
 		case KINETIS_K_SDID_K20_M100:
@@ -1226,165 +2024,399 @@ static int kinetis_read_part_info(struct flash_bank *bank)
 		case KINETIS_K_SDID_K53:
 		case KINETIS_K_SDID_K60_M100:
 			/* 2kB sectors */
-			pflash_sector_size_bytes = 2<<10;
-			nvm_sector_size_bytes = 2<<10;
+			k_chip->pflash_sector_size = 2<<10;
+			k_chip->nvm_sector_size = 2<<10;
 			num_blocks = 2;
-			kinfo->flash_support = FS_PROGRAM_LONGWORD | FS_PROGRAM_SECTOR;
+			k_chip->flash_support = FS_PROGRAM_LONGWORD | FS_PROGRAM_SECTOR;
 			break;
 		case KINETIS_K_SDID_K21_M120:
 		case KINETIS_K_SDID_K22_M120:
 			/* 4kB sectors (MK21FN1M0, MK21FX512, MK22FN1M0, MK22FX512) */
-			pflash_sector_size_bytes = 4<<10;
-			kinfo->max_flash_prog_size = 1<<10;
-			nvm_sector_size_bytes = 4<<10;
+			k_chip->pflash_sector_size = 4<<10;
+			k_chip->max_flash_prog_size = 1<<10;
+			k_chip->nvm_sector_size = 4<<10;
 			num_blocks = 2;
-			kinfo->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+			k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
 			break;
 		case KINETIS_K_SDID_K10_M120:
 		case KINETIS_K_SDID_K20_M120:
 		case KINETIS_K_SDID_K60_M150:
 		case KINETIS_K_SDID_K70_M150:
 			/* 4kB sectors */
-			pflash_sector_size_bytes = 4<<10;
-			nvm_sector_size_bytes = 4<<10;
+			k_chip->pflash_sector_size = 4<<10;
+			k_chip->nvm_sector_size = 4<<10;
 			num_blocks = 4;
-			kinfo->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+			k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
 			break;
 		default:
 			LOG_ERROR("Unsupported K-family FAMID");
 		}
+
+		for (idx = 0; idx < ARRAY_SIZE(kinetis_types_old); idx++) {
+			if (kinetis_types_old[idx].sdid == mcu_type) {
+				strcpy(name, kinetis_types_old[idx].name);
+				use_nvm_marking = true;
+				break;
+			}
+		}
+
 	} else {
 		/* Newer K-series or KL series MCU */
-		switch (kinfo->sim_sdid & KINETIS_SDID_SERIESID_MASK) {
+		familyid = (k_chip->sim_sdid & KINETIS_SDID_FAMILYID_MASK) >> KINETIS_SDID_FAMILYID_SHIFT;
+		subfamid = (k_chip->sim_sdid & KINETIS_SDID_SUBFAMID_MASK) >> KINETIS_SDID_SUBFAMID_SHIFT;
+
+		switch (k_chip->sim_sdid & KINETIS_SDID_SERIESID_MASK) {
 		case KINETIS_SDID_SERIESID_K:
-			switch (kinfo->sim_sdid & (KINETIS_SDID_FAMILYID_MASK | KINETIS_SDID_SUBFAMID_MASK)) {
+			use_nvm_marking = true;
+			k_chip->cache_type = KINETIS_CACHE_K;
+			k_chip->watchdog_type = KINETIS_WDOG_K;
+
+			switch (k_chip->sim_sdid & (KINETIS_SDID_FAMILYID_MASK | KINETIS_SDID_SUBFAMID_MASK)) {
 			case KINETIS_SDID_FAMILYID_K0X | KINETIS_SDID_SUBFAMID_KX2:
 				/* K02FN64, K02FN128: FTFA, 2kB sectors */
-				pflash_sector_size_bytes = 2<<10;
+				k_chip->pflash_sector_size = 2<<10;
+				num_blocks = 1;
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				cpu_mhz = 100;
+				break;
+
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX2: {
+				/* MK24FN1M reports as K22, this should detect it (according to errata note 1N83J) */
+				uint32_t sopt1;
+				result = target_read_u32(target, k_chip->sim_base + SIM_SOPT1_OFFSET, &sopt1);
+				if (result != ERROR_OK)
+					return result;
+
+				if (((k_chip->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K24FN1M) &&
+						((sopt1 & KINETIS_SOPT1_RAMSIZE_MASK) == KINETIS_SOPT1_RAMSIZE_K24FN1M)) {
+					/* MK24FN1M */
+					k_chip->pflash_sector_size = 4<<10;
+					num_blocks = 2;
+					k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+					k_chip->max_flash_prog_size = 1<<10;
+					subfamid = 4; /* errata 1N83J fix */
+					break;
+				}
+				if ((k_chip->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K22FN128
+					|| (k_chip->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K22FN256
+					|| (k_chip->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K22FN512) {
+					/* K22 with new-style SDID - smaller pflash with FTFA, 2kB sectors */
+					k_chip->pflash_sector_size = 2<<10;
+					/* autodetect 1 or 2 blocks */
+					k_chip->flash_support = FS_PROGRAM_LONGWORD;
+					break;
+				}
+				LOG_ERROR("Unsupported Kinetis K22 DIEID");
+				break;
+			}
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX4:
+				k_chip->pflash_sector_size = 4<<10;
+				if ((k_chip->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K24FN256) {
+					/* K24FN256 - smaller pflash with FTFA */
+					num_blocks = 1;
+					k_chip->flash_support = FS_PROGRAM_LONGWORD;
+					break;
+				}
+				/* K24FN1M without errata 7534 */
+				num_blocks = 2;
+				k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+				k_chip->max_flash_prog_size = 1<<10;
+				break;
+
+			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX1:	/* errata 7534 - should be K63 */
+			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX2:	/* errata 7534 - should be K64 */
+				subfamid += 2; /* errata 7534 fix */
+				/* fallthrough */
+			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX3:
+				/* K63FN1M0 */
+			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX4:
+				/* K64FN1M0, K64FX512 */
+				k_chip->pflash_sector_size = 4<<10;
+				k_chip->nvm_sector_size = 4<<10;
+				k_chip->max_flash_prog_size = 1<<10;
+				num_blocks = 2;
+				k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+				break;
+
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX6:
+				/* K26FN2M0 */
+			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX6:
+				/* K66FN2M0, K66FX1M0 */
+				k_chip->pflash_sector_size = 4<<10;
+				k_chip->nvm_sector_size = 4<<10;
+				k_chip->max_flash_prog_size = 1<<10;
+				num_blocks = 4;
+				k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+				cpu_mhz = 180;
+				break;
+
+			case KINETIS_SDID_FAMILYID_K8X | KINETIS_SDID_SUBFAMID_KX0:
+			case KINETIS_SDID_FAMILYID_K8X | KINETIS_SDID_SUBFAMID_KX1:
+			case KINETIS_SDID_FAMILYID_K8X | KINETIS_SDID_SUBFAMID_KX2:
+				/* K80FN256, K81FN256, K82FN256 */
+				k_chip->pflash_sector_size = 4<<10;
+				num_blocks = 1;
+				k_chip->flash_support = FS_PROGRAM_LONGWORD | FS_NO_CMD_BLOCKSTAT;
+				cpu_mhz = 150;
+				break;
+
+			case KINETIS_SDID_FAMILYID_KL8X | KINETIS_SDID_SUBFAMID_KX1:
+			case KINETIS_SDID_FAMILYID_KL8X | KINETIS_SDID_SUBFAMID_KX2:
+				/* KL81Z128, KL82Z128 */
+				k_chip->pflash_sector_size = 2<<10;
+				num_blocks = 1;
+				k_chip->flash_support = FS_PROGRAM_LONGWORD | FS_NO_CMD_BLOCKSTAT;
+				k_chip->cache_type = KINETIS_CACHE_L;
+
+				use_nvm_marking = false;
+				snprintf(name, sizeof(name), "MKL8%uZ%%s7",
+					 subfamid);
+				break;
+
+			default:
+				LOG_ERROR("Unsupported Kinetis FAMILYID SUBFAMID");
+			}
+
+			if (name[0] == '\0')
+				snprintf(name, sizeof(name), "MK%u%uF%%s%u",
+					 familyid, subfamid, cpu_mhz / 10);
+			break;
+
+		case KINETIS_SDID_SERIESID_KL:
+			/* KL-series */
+			k_chip->pflash_sector_size = 1<<10;
+			k_chip->nvm_sector_size = 1<<10;
+			/* autodetect 1 or 2 blocks */
+			k_chip->flash_support = FS_PROGRAM_LONGWORD;
+			k_chip->cache_type = KINETIS_CACHE_L;
+			k_chip->watchdog_type = KINETIS_WDOG_COP;
+
+			cpu_mhz = 48;
+			switch (k_chip->sim_sdid & (KINETIS_SDID_FAMILYID_MASK | KINETIS_SDID_SUBFAMID_MASK)) {
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX3:
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX3:
+				subfamid = 7;
+				break;
+
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX8:
+				cpu_mhz = 72;
+				k_chip->pflash_sector_size = 2<<10;
+				num_blocks = 2;
+				k_chip->watchdog_type = KINETIS_WDOG32_KL28;
+				k_chip->sysmodectrlr_type = KINETIS_SMC32;
+				break;
+			}
+
+			snprintf(name, sizeof(name), "MKL%u%uZ%%s%u",
+				 familyid, subfamid, cpu_mhz / 10);
+			break;
+
+		case KINETIS_SDID_SERIESID_KW:
+			/* Newer KW-series (all KW series except KW2xD, KW01Z) */
+			cpu_mhz = 48;
+			switch (k_chip->sim_sdid & (KINETIS_SDID_FAMILYID_MASK | KINETIS_SDID_SUBFAMID_MASK)) {
+			case KINETIS_SDID_FAMILYID_K4X | KINETIS_SDID_SUBFAMID_KX0:
+				/* KW40Z */
+			case KINETIS_SDID_FAMILYID_K3X | KINETIS_SDID_SUBFAMID_KX0:
+				/* KW30Z */
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX0:
+				/* KW20Z */
+				/* FTFA, 1kB sectors */
+				k_chip->pflash_sector_size = 1<<10;
+				k_chip->nvm_sector_size = 1<<10;
+				/* autodetect 1 or 2 blocks */
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->cache_type = KINETIS_CACHE_L;
+				k_chip->watchdog_type = KINETIS_WDOG_COP;
+				break;
+			case KINETIS_SDID_FAMILYID_K4X | KINETIS_SDID_SUBFAMID_KX1:
+				/* KW41Z */
+			case KINETIS_SDID_FAMILYID_K3X | KINETIS_SDID_SUBFAMID_KX1:
+				/* KW31Z */
+			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX1:
+				/* KW21Z */
+				/* FTFA, 2kB sectors */
+				k_chip->pflash_sector_size = 2<<10;
+				k_chip->nvm_sector_size = 2<<10;
+				/* autodetect 1 or 2 blocks */
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->cache_type = KINETIS_CACHE_L;
+				k_chip->watchdog_type = KINETIS_WDOG_COP;
+				break;
+			default:
+				LOG_ERROR("Unsupported KW FAMILYID SUBFAMID");
+			}
+			snprintf(name, sizeof(name), "MKW%u%uZ%%s%u",
+					 familyid, subfamid, cpu_mhz / 10);
+			break;
+
+		case KINETIS_SDID_SERIESID_KV:
+			/* KV-series */
+			k_chip->watchdog_type = KINETIS_WDOG_K;
+			switch (k_chip->sim_sdid & (KINETIS_SDID_FAMILYID_MASK | KINETIS_SDID_SUBFAMID_MASK)) {
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX0:
+				/* KV10: FTFA, 1kB sectors */
+				k_chip->pflash_sector_size = 1<<10;
 				num_blocks = 1;
-				kinfo->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->cache_type = KINETIS_CACHE_L;
+				strcpy(name, "MKV10Z%s7");
 				break;
 
-			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX2: {
-				/* MK24FN1M reports as K22, this should detect it (according to errata note 1N83J) */
-				uint32_t sopt1;
-				result = target_read_u32(target, SIM_SOPT1, &sopt1);
-				if (result != ERROR_OK)
-					return result;
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX1:
+				/* KV11: FTFA, 2kB sectors */
+				k_chip->pflash_sector_size = 2<<10;
+				num_blocks = 1;
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->cache_type = KINETIS_CACHE_L;
+				strcpy(name, "MKV11Z%s7");
+				break;
 
-				if (((kinfo->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K24FN1M) &&
-						((sopt1 & KINETIS_SOPT1_RAMSIZE_MASK) == KINETIS_SOPT1_RAMSIZE_K24FN1M)) {
-					/* MK24FN1M */
-					pflash_sector_size_bytes = 4<<10;
-					num_blocks = 2;
-					kinfo->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
-					kinfo->max_flash_prog_size = 1<<10;
-					break;
-				}
-				if ((kinfo->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K22FN128
-					|| (kinfo->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K22FN256
-					|| (kinfo->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K22FN512) {
-					/* K22 with new-style SDID - smaller pflash with FTFA, 2kB sectors */
-					pflash_sector_size_bytes = 2<<10;
-					num_blocks = 2;		/* 1 or 2 blocks */
-					kinfo->flash_support = FS_PROGRAM_LONGWORD;
-					break;
-				}
-				LOG_ERROR("Unsupported Kinetis K22 DIEID");
+			case KINETIS_SDID_FAMILYID_K3X | KINETIS_SDID_SUBFAMID_KX0:
+				/* KV30: FTFA, 2kB sectors, 1 block */
+			case KINETIS_SDID_FAMILYID_K3X | KINETIS_SDID_SUBFAMID_KX1:
+				/* KV31: FTFA, 2kB sectors, 2 blocks */
+				k_chip->pflash_sector_size = 2<<10;
+				/* autodetect 1 or 2 blocks */
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->cache_type = KINETIS_CACHE_K;
 				break;
+
+			case KINETIS_SDID_FAMILYID_K4X | KINETIS_SDID_SUBFAMID_KX2:
+			case KINETIS_SDID_FAMILYID_K4X | KINETIS_SDID_SUBFAMID_KX4:
+			case KINETIS_SDID_FAMILYID_K4X | KINETIS_SDID_SUBFAMID_KX6:
+				/* KV4x: FTFA, 4kB sectors */
+				k_chip->pflash_sector_size = 4<<10;
+				num_blocks = 1;
+				k_chip->flash_support = FS_PROGRAM_LONGWORD;
+				k_chip->cache_type = KINETIS_CACHE_K;
+				cpu_mhz = 168;
+				break;
+
+			case KINETIS_SDID_FAMILYID_K5X | KINETIS_SDID_SUBFAMID_KX6:
+			case KINETIS_SDID_FAMILYID_K5X | KINETIS_SDID_SUBFAMID_KX8:
+				/* KV5x: FTFE, 8kB sectors */
+				k_chip->pflash_sector_size = 8<<10;
+				k_chip->max_flash_prog_size = 1<<10;
+				num_blocks = 1;
+				maxaddr_shift = 14;
+				k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR | FS_WIDTH_256BIT;
+				k_chip->pflash_base = 0x10000000;
+				k_chip->progr_accel_ram = 0x18000000;
+				cpu_mhz = 240;
+				break;
+
+			default:
+				LOG_ERROR("Unsupported KV FAMILYID SUBFAMID");
 			}
-			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX4:
-				pflash_sector_size_bytes = 4<<10;
-				if ((kinfo->sim_sdid & (KINETIS_SDID_DIEID_MASK)) == KINETIS_SDID_DIEID_K24FN256) {
-					/* K24FN256 - smaller pflash with FTFA */
-					num_blocks = 1;
-					kinfo->flash_support = FS_PROGRAM_LONGWORD;
-					break;
-				}
-				/* K24FN1M without errata 7534 */
+
+			if (name[0] == '\0')
+				snprintf(name, sizeof(name), "MKV%u%uF%%s%u",
+					 familyid, subfamid, cpu_mhz / 10);
+			break;
+
+		case KINETIS_SDID_SERIESID_KE:
+			/* KE1x-series */
+			k_chip->watchdog_type = KINETIS_WDOG32_KE1X;
+			switch (k_chip->sim_sdid &
+				(KINETIS_SDID_FAMILYID_MASK | KINETIS_SDID_SUBFAMID_MASK | KINETIS_SDID_PROJECTID_MASK)) {
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX4 | KINETIS_SDID_PROJECTID_KE1xZ:
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX5 | KINETIS_SDID_PROJECTID_KE1xZ:
+				/* KE1xZ: FTFE, 2kB sectors */
+				k_chip->pflash_sector_size = 2<<10;
+				k_chip->nvm_sector_size = 2<<10;
+				k_chip->max_flash_prog_size = 1<<9;
 				num_blocks = 2;
-				kinfo->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
-				kinfo->max_flash_prog_size = 1<<10;
+				k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+				k_chip->cache_type = KINETIS_CACHE_L;
+
+				cpu_mhz = 72;
+				snprintf(name, sizeof(name), "MKE%u%uZ%%s%u",
+					 familyid, subfamid, cpu_mhz / 10);
 				break;
 
-			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX3:
-			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX1:	/* errata 7534 - should be K63 */
-				/* K63FN1M0 */
-			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX4:
-			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX2:	/* errata 7534 - should be K64 */
-				/* K64FN1M0, K64FX512 */
-				pflash_sector_size_bytes = 4<<10;
-				nvm_sector_size_bytes = 4<<10;
-				kinfo->max_flash_prog_size = 1<<10;
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX4 | KINETIS_SDID_PROJECTID_KE1xF:
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX6 | KINETIS_SDID_PROJECTID_KE1xF:
+			case KINETIS_SDID_FAMILYID_K1X | KINETIS_SDID_SUBFAMID_KX8 | KINETIS_SDID_PROJECTID_KE1xF:
+				/* KE1xF: FTFE, 4kB sectors */
+				k_chip->pflash_sector_size = 4<<10;
+				k_chip->nvm_sector_size = 2<<10;
+				k_chip->max_flash_prog_size = 1<<10;
 				num_blocks = 2;
-				kinfo->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
-				break;
+				k_chip->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+				k_chip->cache_type = KINETIS_CACHE_MSCM;
 
-			case KINETIS_SDID_FAMILYID_K2X | KINETIS_SDID_SUBFAMID_KX6:
-				/* K26FN2M0 */
-			case KINETIS_SDID_FAMILYID_K6X | KINETIS_SDID_SUBFAMID_KX6:
-				/* K66FN2M0, K66FX1M0 */
-				pflash_sector_size_bytes = 4<<10;
-				nvm_sector_size_bytes = 4<<10;
-				kinfo->max_flash_prog_size = 1<<10;
-				num_blocks = 4;
-				kinfo->flash_support = FS_PROGRAM_PHRASE | FS_PROGRAM_SECTOR;
+				cpu_mhz = 168;
+				snprintf(name, sizeof(name), "MKE%u%uF%%s%u",
+					 familyid, subfamid, cpu_mhz / 10);
 				break;
+
 			default:
-				LOG_ERROR("Unsupported Kinetis FAMILYID SUBFAMID");
+				LOG_ERROR("Unsupported KE FAMILYID SUBFAMID");
 			}
 			break;
-		case KINETIS_SDID_SERIESID_KL:
-			/* KL-series */
-			pflash_sector_size_bytes = 1<<10;
-			nvm_sector_size_bytes = 1<<10;
-			num_blocks = 1;
-			kinfo->flash_support = FS_PROGRAM_LONGWORD;
-			break;
+
 		default:
 			LOG_ERROR("Unsupported K-series");
 		}
 	}
 
-	if (pflash_sector_size_bytes == 0) {
-		LOG_ERROR("MCU is unsupported, SDID 0x%08" PRIx32, kinfo->sim_sdid);
+	if (k_chip->pflash_sector_size == 0) {
+		LOG_ERROR("MCU is unsupported, SDID 0x%08" PRIx32, k_chip->sim_sdid);
 		return ERROR_FLASH_OPER_UNSUPPORTED;
 	}
 
-	result = target_read_u32(target, SIM_FCFG1, &kinfo->sim_fcfg1);
+	result = target_read_u32(target, k_chip->sim_base + SIM_FCFG1_OFFSET, &k_chip->sim_fcfg1);
 	if (result != ERROR_OK)
 		return result;
 
-	result = target_read_u32(target, SIM_FCFG2, &kinfo->sim_fcfg2);
+	result = target_read_u32(target, k_chip->sim_base + SIM_FCFG2_OFFSET, &k_chip->sim_fcfg2);
 	if (result != ERROR_OK)
 		return result;
-	fcfg2_pflsh = (kinfo->sim_fcfg2 >> 23) & 0x01;
 
-	LOG_DEBUG("SDID: 0x%08" PRIX32 " FCFG1: 0x%08" PRIX32 " FCFG2: 0x%08" PRIX32, kinfo->sim_sdid,
-			kinfo->sim_fcfg1, kinfo->sim_fcfg2);
-
-	fcfg1_nvmsize = (uint8_t)((kinfo->sim_fcfg1 >> 28) & 0x0f);
-	fcfg1_pfsize = (uint8_t)((kinfo->sim_fcfg1 >> 24) & 0x0f);
-	fcfg1_eesize = (uint8_t)((kinfo->sim_fcfg1 >> 16) & 0x0f);
+	LOG_DEBUG("SDID: 0x%08" PRIX32 " FCFG1: 0x%08" PRIX32 " FCFG2: 0x%08" PRIX32, k_chip->sim_sdid,
+			k_chip->sim_fcfg1, k_chip->sim_fcfg2);
+
+	fcfg1_nvmsize = (uint8_t)((k_chip->sim_fcfg1 >> 28) & 0x0f);
+	fcfg1_pfsize = (uint8_t)((k_chip->sim_fcfg1 >> 24) & 0x0f);
+	fcfg1_eesize = (uint8_t)((k_chip->sim_fcfg1 >> 16) & 0x0f);
+	fcfg1_depart = (uint8_t)((k_chip->sim_fcfg1 >> 8) & 0x0f);
+
+	fcfg2_pflsh = (uint8_t)((k_chip->sim_fcfg2 >> 23) & 0x01);
+	k_chip->fcfg2_maxaddr0_shifted = ((k_chip->sim_fcfg2 >> 24) & 0x7f) << maxaddr_shift;
+	k_chip->fcfg2_maxaddr1_shifted = ((k_chip->sim_fcfg2 >> 16) & 0x7f) << maxaddr_shift;
+
+	if (num_blocks == 0)
+		num_blocks = k_chip->fcfg2_maxaddr1_shifted ? 2 : 1;
+	else if (k_chip->fcfg2_maxaddr1_shifted == 0 && num_blocks >= 2 && fcfg2_pflsh) {
+		/* fcfg2_maxaddr1 may be zero due to partitioning whole NVM as EEPROM backup
+		 * Do not adjust block count in this case! */
+		num_blocks = 1;
+		LOG_WARNING("MAXADDR1 is zero, number of flash banks adjusted to 1");
+	} else if (k_chip->fcfg2_maxaddr1_shifted != 0 && num_blocks == 1) {
+		num_blocks = 2;
+		LOG_WARNING("MAXADDR1 is non zero, number of flash banks adjusted to 2");
+	}
 
 	/* when the PFLSH bit is set, there is no FlexNVM/FlexRAM */
 	if (!fcfg2_pflsh) {
 		switch (fcfg1_nvmsize) {
 		case 0x03:
+		case 0x05:
 		case 0x07:
 		case 0x09:
 		case 0x0b:
-			nvm_size = 1 << (14 + (fcfg1_nvmsize >> 1));
+			k_chip->nvm_size = 1 << (14 + (fcfg1_nvmsize >> 1));
 			break;
 		case 0x0f:
-			if (pflash_sector_size_bytes >= 4<<10)
-				nvm_size = 512<<10;
+			if (k_chip->pflash_sector_size >= 4<<10)
+				k_chip->nvm_size = 512<<10;
 			else
 				/* K20_100 */
-				nvm_size = 256<<10;
+				k_chip->nvm_size = 256<<10;
 			break;
 		default:
-			nvm_size = 0;
+			k_chip->nvm_size = 0;
 			break;
 		}
 
@@ -1405,190 +2437,256 @@ static int kinetis_read_part_info(struct flash_bank *bank)
 			ee_size = 0;
 			break;
 		}
+
+		switch (fcfg1_depart) {
+		case 0x01:
+		case 0x02:
+		case 0x03:
+		case 0x04:
+		case 0x05:
+		case 0x06:
+			k_chip->dflash_size = k_chip->nvm_size - (4096 << fcfg1_depart);
+			break;
+		case 0x07:
+		case 0x08:
+			k_chip->dflash_size = 0;
+			break;
+		case 0x09:
+		case 0x0a:
+		case 0x0b:
+		case 0x0c:
+		case 0x0d:
+			k_chip->dflash_size = 4096 << (fcfg1_depart & 0x7);
+			break;
+		default:
+			k_chip->dflash_size = k_chip->nvm_size;
+			break;
+		}
 	}
 
 	switch (fcfg1_pfsize) {
+	case 0x00:
+		k_chip->pflash_size = 8192;
+		break;
+	case 0x01:
 	case 0x03:
 	case 0x05:
 	case 0x07:
 	case 0x09:
 	case 0x0b:
 	case 0x0d:
-		pf_size = 1 << (14 + (fcfg1_pfsize >> 1));
+		k_chip->pflash_size = 1 << (14 + (fcfg1_pfsize >> 1));
 		break;
 	case 0x0f:
-		if (pflash_sector_size_bytes >= 4<<10)
-			pf_size = 1024<<10;
-		else if (fcfg2_pflsh)
-			pf_size = 512<<10;
+		/* a peculiar case: Freescale states different sizes for 0xf
+		 * KL03P24M48SF0RM	32 KB .... duplicate of code 0x3
+		 * K02P64M100SFARM	128 KB ... duplicate of code 0x7
+		 * K22P121M120SF8RM	256 KB ... duplicate of code 0x9
+		 * K22P121M120SF7RM	512 KB ... duplicate of code 0xb
+		 * K22P100M120SF5RM	1024 KB ... duplicate of code 0xd
+		 * K26P169M180SF5RM	2048 KB ... the only unique value
+		 * fcfg2_maxaddr0 seems to be the only clue to pflash_size
+		 * Checking fcfg2_maxaddr0 in bank probe is pointless then
+		 */
+		if (fcfg2_pflsh)
+			k_chip->pflash_size = k_chip->fcfg2_maxaddr0_shifted * num_blocks;
 		else
-			pf_size = 256<<10;
+			k_chip->pflash_size = k_chip->fcfg2_maxaddr0_shifted * num_blocks / 2;
+		if (k_chip->pflash_size != 2048<<10)
+			LOG_WARNING("SIM_FCFG1 PFSIZE = 0xf: please check if pflash is %u KB", k_chip->pflash_size>>10);
+
 		break;
 	default:
-		pf_size = 0;
+		k_chip->pflash_size = 0;
 		break;
 	}
 
-	LOG_DEBUG("FlexNVM: %" PRIu32 " PFlash: %" PRIu32 " FlexRAM: %" PRIu32 " PFLSH: %d",
-		  nvm_size, pf_size, ee_size, fcfg2_pflsh);
+	if (k_chip->flash_support & FS_PROGRAM_SECTOR && k_chip->max_flash_prog_size == 0) {
+		k_chip->max_flash_prog_size = k_chip->pflash_sector_size;
+		/* Program section size is equal to sector size by default */
+	}
 
-	num_pflash_blocks = num_blocks / (2 - fcfg2_pflsh);
-	first_nvm_bank = num_pflash_blocks;
-	num_nvm_blocks = num_blocks - num_pflash_blocks;
+	if (fcfg2_pflsh) {
+		k_chip->num_pflash_blocks = num_blocks;
+		k_chip->num_nvm_blocks = 0;
+	} else {
+		k_chip->num_pflash_blocks = (num_blocks + 1) / 2;
+		k_chip->num_nvm_blocks = num_blocks - k_chip->num_pflash_blocks;
+	}
 
-	LOG_DEBUG("%d blocks total: %d PFlash, %d FlexNVM",
-			num_blocks, num_pflash_blocks, num_nvm_blocks);
+	if (use_nvm_marking) {
+		nvm_marking[0] = k_chip->num_nvm_blocks ? 'X' : 'N';
+		nvm_marking[1] = '\0';
+	} else
+		nvm_marking[0] = '\0';
 
-	/*
-	 * If the flash class is already assigned, verify the
-	 * parameters.
-	 */
-	if (kinfo->flash_class != FC_AUTO) {
-		if (kinfo->bank_ordinal != (unsigned) bank->bank_number) {
-			LOG_WARNING("Flash ordinal/bank number mismatch");
-			reassign = 1;
-		} else {
-			switch (kinfo->flash_class) {
-			case FC_PFLASH:
-				if (kinfo->bank_ordinal >= first_nvm_bank) {
-					LOG_WARNING("Class mismatch, bank %d is not PFlash", bank->bank_number);
-					reassign = 1;
-				} else if (bank->size != (pf_size / num_pflash_blocks)) {
-					LOG_WARNING("PFlash size mismatch");
-					reassign = 1;
-				} else if (bank->base !=
-					 (0x00000000 + bank->size * kinfo->bank_ordinal)) {
-					LOG_WARNING("PFlash address range mismatch");
-					reassign = 1;
-				} else if (kinfo->sector_size != pflash_sector_size_bytes) {
-					LOG_WARNING("PFlash sector size mismatch");
-					reassign = 1;
-				} else {
-					LOG_DEBUG("PFlash bank %d already configured okay",
-						  kinfo->bank_ordinal);
-				}
-				break;
-			case FC_FLEX_NVM:
-				if ((kinfo->bank_ordinal >= num_blocks) ||
-						(kinfo->bank_ordinal < first_nvm_bank)) {
-					LOG_WARNING("Class mismatch, bank %d is not FlexNVM", bank->bank_number);
-					reassign = 1;
-				} else if (bank->size != (nvm_size / num_nvm_blocks)) {
-					LOG_WARNING("FlexNVM size mismatch");
-					reassign = 1;
-				} else if (bank->base !=
-						(0x10000000 + bank->size * kinfo->bank_ordinal)) {
-					LOG_WARNING("FlexNVM address range mismatch");
-					reassign = 1;
-				} else if (kinfo->sector_size != nvm_sector_size_bytes) {
-					LOG_WARNING("FlexNVM sector size mismatch");
-					reassign = 1;
-				} else {
-					LOG_DEBUG("FlexNVM bank %d already configured okay",
-						  kinfo->bank_ordinal);
-				}
-				break;
-			case FC_FLEX_RAM:
-				if (kinfo->bank_ordinal != num_blocks) {
-					LOG_WARNING("Class mismatch, bank %d is not FlexRAM", bank->bank_number);
-					reassign = 1;
-				} else if (bank->size != ee_size) {
-					LOG_WARNING("FlexRAM size mismatch");
-					reassign = 1;
-				} else if (bank->base != FLEXRAM) {
-					LOG_WARNING("FlexRAM address mismatch");
-					reassign = 1;
-				} else if (kinfo->sector_size != nvm_sector_size_bytes) {
-					LOG_WARNING("FlexRAM sector size mismatch");
-					reassign = 1;
-				} else {
-					LOG_DEBUG("FlexRAM bank %d already configured okay", kinfo->bank_ordinal);
-				}
-				break;
+	pflash_size_k = k_chip->pflash_size / 1024;
+	pflash_size_m = pflash_size_k / 1024;
+	if (pflash_size_m)
+		snprintf(flash_marking, sizeof(flash_marking), "%s%" PRIu32 "M0xxx", nvm_marking, pflash_size_m);
+	else
+		snprintf(flash_marking, sizeof(flash_marking), "%s%" PRIu32 "xxx", nvm_marking, pflash_size_k);
+
+	snprintf(k_chip->name, sizeof(k_chip->name), name, flash_marking);
+	LOG_INFO("Kinetis %s detected: %u flash blocks", k_chip->name, num_blocks);
+	LOG_INFO("%u PFlash banks: %" PRIu32 "k total", k_chip->num_pflash_blocks, pflash_size_k);
+	if (k_chip->num_nvm_blocks) {
+		nvm_size_k = k_chip->nvm_size / 1024;
+		dflash_size_k = k_chip->dflash_size / 1024;
+		LOG_INFO("%u FlexNVM banks: %" PRIu32 "k total, %" PRIu32 "k available as data flash, %" PRIu32 "bytes FlexRAM",
+			 k_chip->num_nvm_blocks, nvm_size_k, dflash_size_k, ee_size);
+	}
 
-			default:
-				LOG_WARNING("Unknown or inconsistent flash class");
-				reassign = 1;
-				break;
-			}
-		}
-	} else {
-		LOG_INFO("Probing flash info for bank %d", bank->bank_number);
-		reassign = 1;
+	k_chip->probed = true;
+
+	if (create_banks)
+		kinetis_create_missing_banks(k_chip);
+
+	return ERROR_OK;
+}
+
+static int kinetis_probe(struct flash_bank *bank)
+{
+	int result, i;
+	uint8_t fcfg2_maxaddr0, fcfg2_pflsh, fcfg2_maxaddr1;
+	unsigned num_blocks, first_nvm_bank;
+	uint32_t size_k;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+
+	k_bank->probed = false;
+
+	if (!k_chip->probed) {
+		result = kinetis_probe_chip(k_chip);
+		if (result != ERROR_OK)
+			return result;
 	}
 
-	if (!reassign)
-		return ERROR_OK;
+	num_blocks = k_chip->num_pflash_blocks + k_chip->num_nvm_blocks;
+	first_nvm_bank = k_chip->num_pflash_blocks;
 
-	if ((unsigned)bank->bank_number < num_pflash_blocks) {
+	if (k_bank->bank_number < k_chip->num_pflash_blocks) {
 		/* pflash, banks start at address zero */
-		kinfo->flash_class = FC_PFLASH;
-		bank->size = (pf_size / num_pflash_blocks);
-		bank->base = 0x00000000 + bank->size * bank->bank_number;
-		kinfo->sector_size = pflash_sector_size_bytes;
-		kinfo->protection_size = pf_size / 32;
-	} else if ((unsigned)bank->bank_number < num_blocks) {
+		k_bank->flash_class = FC_PFLASH;
+		bank->size = (k_chip->pflash_size / k_chip->num_pflash_blocks);
+		bank->base = k_chip->pflash_base + bank->size * k_bank->bank_number;
+		k_bank->prog_base = 0x00000000 + bank->size * k_bank->bank_number;
+		k_bank->sector_size = k_chip->pflash_sector_size;
+		/* pflash is divided into 32 protection areas for
+		 * parts with more than 32K of PFlash. For parts with
+		 * less the protection unit is set to 1024 bytes */
+		k_bank->protection_size = MAX(k_chip->pflash_size / 32, 1024);
+		bank->num_prot_blocks = bank->size / k_bank->protection_size;
+		k_bank->protection_block = bank->num_prot_blocks * k_bank->bank_number;
+
+		size_k = bank->size / 1024;
+		LOG_DEBUG("Kinetis bank %u: %" PRIu32 "k PFlash, FTFx base 0x%08" PRIx32 ", sect %u",
+			 k_bank->bank_number, size_k, k_bank->prog_base, k_bank->sector_size);
+
+	} else if (k_bank->bank_number < num_blocks) {
 		/* nvm, banks start at address 0x10000000 */
-		kinfo->flash_class = FC_FLEX_NVM;
-		bank->size = (nvm_size / num_nvm_blocks);
-		bank->base = 0x10000000 + bank->size * (bank->bank_number - first_nvm_bank);
-		kinfo->sector_size = nvm_sector_size_bytes;
-		kinfo->protection_size = 0; /* FIXME: TODO: depends on DEPART bits, chip */
-	} else if ((unsigned)bank->bank_number == num_blocks) {
-		LOG_ERROR("FlexRAM support not yet implemented");
-		return ERROR_FLASH_OPER_UNSUPPORTED;
+		unsigned nvm_ord = k_bank->bank_number - first_nvm_bank;
+		uint32_t limit;
+
+		k_bank->flash_class = FC_FLEX_NVM;
+		bank->size = k_chip->nvm_size / k_chip->num_nvm_blocks;
+		bank->base = k_chip->nvm_base + bank->size * nvm_ord;
+		k_bank->prog_base = 0x00800000 + bank->size * nvm_ord;
+		k_bank->sector_size = k_chip->nvm_sector_size;
+		if (k_chip->dflash_size == 0) {
+			k_bank->protection_size = 0;
+		} else {
+			for (i = k_chip->dflash_size; ~i & 1; i >>= 1)
+				;
+			if (i == 1)
+				k_bank->protection_size = k_chip->dflash_size / 8;	/* data flash size = 2^^n */
+			else
+				k_bank->protection_size = k_chip->nvm_size / 8;	/* TODO: verify on SF1, not documented in RM */
+		}
+		bank->num_prot_blocks = 8 / k_chip->num_nvm_blocks;
+		k_bank->protection_block = bank->num_prot_blocks * nvm_ord;
+
+		/* EEPROM backup part of FlexNVM is not accessible, use dflash_size as a limit */
+		if (k_chip->dflash_size > bank->size * nvm_ord)
+			limit = k_chip->dflash_size - bank->size * nvm_ord;
+		else
+			limit = 0;
+
+		if (bank->size > limit) {
+			bank->size = limit;
+			LOG_DEBUG("FlexNVM bank %d limited to 0x%08" PRIx32 " due to active EEPROM backup",
+				k_bank->bank_number, limit);
+		}
+
+		size_k = bank->size / 1024;
+		LOG_DEBUG("Kinetis bank %u: %" PRIu32 "k FlexNVM, FTFx base 0x%08" PRIx32 ", sect %u",
+			 k_bank->bank_number, size_k, k_bank->prog_base, k_bank->sector_size);
+
 	} else {
 		LOG_ERROR("Cannot determine parameters for bank %d, only %d banks on device",
-				bank->bank_number, num_blocks);
+				k_bank->bank_number, num_blocks);
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
+	fcfg2_pflsh = (uint8_t)((k_chip->sim_fcfg2 >> 23) & 0x01);
+	fcfg2_maxaddr0 = (uint8_t)((k_chip->sim_fcfg2 >> 24) & 0x7f);
+	fcfg2_maxaddr1 = (uint8_t)((k_chip->sim_fcfg2 >> 16) & 0x7f);
+
+	if (k_bank->bank_number == 0 && k_chip->fcfg2_maxaddr0_shifted != bank->size)
+		LOG_WARNING("MAXADDR0 0x%02" PRIx8 " check failed,"
+				" please report to OpenOCD mailing list", fcfg2_maxaddr0);
+
+	if (fcfg2_pflsh) {
+		if (k_bank->bank_number == 1 && k_chip->fcfg2_maxaddr1_shifted != bank->size)
+			LOG_WARNING("MAXADDR1 0x%02" PRIx8 " check failed,"
+				" please report to OpenOCD mailing list", fcfg2_maxaddr1);
+	} else {
+		if (k_bank->bank_number == first_nvm_bank
+				&& k_chip->fcfg2_maxaddr1_shifted != k_chip->dflash_size)
+			LOG_WARNING("FlexNVM MAXADDR1 0x%02" PRIx8 " check failed,"
+				" please report to OpenOCD mailing list", fcfg2_maxaddr1);
+	}
+
 	if (bank->sectors) {
 		free(bank->sectors);
 		bank->sectors = NULL;
 	}
+	if (bank->prot_blocks) {
+		free(bank->prot_blocks);
+		bank->prot_blocks = NULL;
+	}
 
-	if (kinfo->sector_size == 0) {
+	if (k_bank->sector_size == 0) {
 		LOG_ERROR("Unknown sector size for bank %d", bank->bank_number);
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
-	if (kinfo->flash_support & FS_PROGRAM_SECTOR
-			 && kinfo->max_flash_prog_size == 0) {
-		kinfo->max_flash_prog_size = kinfo->sector_size;
-		/* Program section size is equal to sector size by default */
-	}
-
-	bank->num_sectors = bank->size / kinfo->sector_size;
-	assert(bank->num_sectors > 0);
-	bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
+	bank->num_sectors = bank->size / k_bank->sector_size;
 
-	for (i = 0; i < bank->num_sectors; i++) {
-		bank->sectors[i].offset = offset;
-		bank->sectors[i].size = kinfo->sector_size;
-		offset += kinfo->sector_size;
-		bank->sectors[i].is_erased = -1;
-		bank->sectors[i].is_protected = 1;
-	}
+	if (bank->num_sectors > 0) {
+		/* FlexNVM bank can be used for EEPROM backup therefore zero sized */
+		bank->sectors = alloc_block_array(0, k_bank->sector_size, bank->num_sectors);
+		if (!bank->sectors)
+			return ERROR_FAIL;
 
-	return ERROR_OK;
-}
+		bank->prot_blocks = alloc_block_array(0, k_bank->protection_size, bank->num_prot_blocks);
+		if (!bank->prot_blocks)
+			return ERROR_FAIL;
 
-static int kinetis_probe(struct flash_bank *bank)
-{
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_WARNING("Cannot communicate... target not halted.");
-		return ERROR_TARGET_NOT_HALTED;
+	} else {
+		bank->num_prot_blocks = 0;
 	}
 
-	return kinetis_read_part_info(bank);
+	k_bank->probed = true;
+
+	return ERROR_OK;
 }
 
 static int kinetis_auto_probe(struct flash_bank *bank)
 {
-	struct kinetis_flash_bank *kinfo = bank->driver_priv;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
 
-	if (kinfo->sim_sdid)
+	if (k_bank && k_bank->probed)
 		return ERROR_OK;
 
 	return kinetis_probe(bank);
@@ -1600,47 +2698,72 @@ static int kinetis_info(struct flash_bank *bank, char *buf, int buf_size)
 		"(ANY)", "PFlash", "FlexNVM", "FlexRAM"
 	};
 
-	struct kinetis_flash_bank *kinfo = bank->driver_priv;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+	uint32_t size_k = bank->size / 1024;
 
-	(void) snprintf(buf, buf_size,
-			"%s driver for %s flash bank %s at 0x%8.8" PRIx32 "",
-			bank->driver->name, bank_class_names[kinfo->flash_class],
-			bank->name, bank->base);
+	snprintf(buf, buf_size,
+		"%s %s: %" PRIu32 "k %s bank %s at 0x%08" PRIx32,
+		bank->driver->name, k_chip->name,
+		size_k, bank_class_names[k_bank->flash_class],
+		bank->name, bank->base);
 
 	return ERROR_OK;
 }
 
 static int kinetis_blank_check(struct flash_bank *bank)
 {
-	struct kinetis_flash_bank *kinfo = bank->driver_priv;
+	struct kinetis_flash_bank *k_bank = bank->driver_priv;
+	struct kinetis_chip *k_chip = k_bank->k_chip;
+	int result;
 
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
+	/* suprisingly blank check does not work in VLPR and HSRUN modes */
+	result = kinetis_check_run_mode(k_chip);
+	if (result != ERROR_OK)
+		return result;
+
+	/* reset error flags */
+	result = kinetis_ftfx_prepare(bank->target);
+	if (result != ERROR_OK)
+		return result;
 
-	if (kinfo->flash_class == FC_PFLASH) {
-		int result;
+	if (k_bank->flash_class == FC_PFLASH || k_bank->flash_class == FC_FLEX_NVM) {
+		bool block_dirty = true;
+		bool use_block_cmd = !(k_chip->flash_support & FS_NO_CMD_BLOCKSTAT);
 		uint8_t ftfx_fstat;
 
-		/* check if whole bank is blank */
-		result = kinetis_ftfx_command(bank, FTFx_CMD_BLOCKSTAT, bank->base, 0, 0, 0, 0,  0, 0, 0, 0, &ftfx_fstat);
+		if (use_block_cmd && k_bank->flash_class == FC_FLEX_NVM) {
+			uint8_t fcfg1_depart = (uint8_t)((k_chip->sim_fcfg1 >> 8) & 0x0f);
+			/* block operation cannot be used on FlexNVM when EEPROM backup partition is set */
+			if (fcfg1_depart != 0xf && fcfg1_depart != 0)
+				use_block_cmd = false;
+		}
 
-		if (result != ERROR_OK)
-			return result;
+		if (use_block_cmd) {
+			/* check if whole bank is blank */
+			result = kinetis_ftfx_command(bank->target, FTFx_CMD_BLOCKSTAT, k_bank->prog_base,
+							 0, 0, 0, 0,  0, 0, 0, 0, &ftfx_fstat);
 
-		if (ftfx_fstat & 0x01) {
+			if (result != ERROR_OK)
+				kinetis_ftfx_clear_error(bank->target);
+			else if ((ftfx_fstat & 0x01) == 0)
+				block_dirty = false;
+		}
+
+		if (block_dirty) {
 			/* the whole bank is not erased, check sector-by-sector */
 			int i;
 			for (i = 0; i < bank->num_sectors; i++) {
 				/* normal margin */
-				result = kinetis_ftfx_command(bank, FTFx_CMD_SECTSTAT, bank->base + bank->sectors[i].offset,
+				result = kinetis_ftfx_command(bank->target, FTFx_CMD_SECTSTAT,
+						k_bank->prog_base + bank->sectors[i].offset,
 						1, 0, 0, 0,  0, 0, 0, 0, &ftfx_fstat);
 
 				if (result == ERROR_OK) {
 					bank->sectors[i].is_erased = !(ftfx_fstat & 0x01);
 				} else {
 					LOG_DEBUG("Ignoring errored PFlash sector blank-check");
+					kinetis_ftfx_clear_error(bank->target);
 					bank->sectors[i].is_erased = -1;
 				}
 			}
@@ -1651,34 +2774,237 @@ static int kinetis_blank_check(struct flash_bank *bank)
 				bank->sectors[i].is_erased = 1;
 		}
 	} else {
-		LOG_WARNING("kinetis_blank_check not supported yet for FlexNVM");
+		LOG_WARNING("kinetis_blank_check not supported yet for FlexRAM");
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	return ERROR_OK;
 }
 
-static const struct command_registration kinetis_securtiy_command_handlers[] = {
+
+COMMAND_HANDLER(kinetis_nvm_partition)
+{
+	int result;
+	unsigned bank_idx;
+	unsigned num_blocks, first_nvm_bank;
+	unsigned long par, log2 = 0, ee1 = 0, ee2 = 0;
+	enum { SHOW_INFO, DF_SIZE, EEBKP_SIZE } sz_type = SHOW_INFO;
+	bool enable;
+	uint8_t load_flex_ram = 1;
+	uint8_t ee_size_code = 0x3f;
+	uint8_t flex_nvm_partition_code = 0;
+	uint8_t ee_split = 3;
+	struct target *target = get_current_target(CMD_CTX);
+	struct kinetis_chip *k_chip;
+	uint32_t sim_fcfg1;
+
+	k_chip = kinetis_get_chip(target);
+
+	if (CMD_ARGC >= 2) {
+		if (strcmp(CMD_ARGV[0], "dataflash") == 0)
+			sz_type = DF_SIZE;
+		else if (strcmp(CMD_ARGV[0], "eebkp") == 0)
+			sz_type = EEBKP_SIZE;
+
+		par = strtoul(CMD_ARGV[1], NULL, 10);
+		while (par >> (log2 + 3))
+			log2++;
+	}
+	switch (sz_type) {
+	case SHOW_INFO:
+		if (k_chip == NULL) {
+			LOG_ERROR("Chip not probed.");
+			return ERROR_FAIL;
+		}
+		result = target_read_u32(target, k_chip->sim_base + SIM_FCFG1_OFFSET, &sim_fcfg1);
+		if (result != ERROR_OK)
+			return result;
+
+		flex_nvm_partition_code = (uint8_t)((sim_fcfg1 >> 8) & 0x0f);
+		switch (flex_nvm_partition_code) {
+		case 0:
+			command_print(CMD_CTX, "No EEPROM backup, data flash only");
+			break;
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+		case 5:
+		case 6:
+			command_print(CMD_CTX, "EEPROM backup %d KB", 4 << flex_nvm_partition_code);
+			break;
+		case 8:
+			command_print(CMD_CTX, "No data flash, EEPROM backup only");
+			break;
+		case 0x9:
+		case 0xA:
+		case 0xB:
+		case 0xC:
+		case 0xD:
+		case 0xE:
+			command_print(CMD_CTX, "data flash %d KB", 4 << (flex_nvm_partition_code & 7));
+			break;
+		case 0xf:
+			command_print(CMD_CTX, "No EEPROM backup, data flash only (DEPART not set)");
+			break;
+		default:
+			command_print(CMD_CTX, "Unsupported EEPROM backup size code 0x%02" PRIx8, flex_nvm_partition_code);
+		}
+		return ERROR_OK;
+
+	case DF_SIZE:
+		flex_nvm_partition_code = 0x8 | log2;
+		break;
+
+	case EEBKP_SIZE:
+		flex_nvm_partition_code = log2;
+		break;
+	}
+
+	if (CMD_ARGC == 3)
+		ee1 = ee2 = strtoul(CMD_ARGV[2], NULL, 10) / 2;
+	else if (CMD_ARGC >= 4) {
+		ee1 = strtoul(CMD_ARGV[2], NULL, 10);
+		ee2 = strtoul(CMD_ARGV[3], NULL, 10);
+	}
+
+	enable = ee1 + ee2 > 0;
+	if (enable) {
+		for (log2 = 2; ; log2++) {
+			if (ee1 + ee2 == (16u << 10) >> log2)
+				break;
+			if (ee1 + ee2 > (16u << 10) >> log2 || log2 >= 9) {
+				LOG_ERROR("Unsupported EEPROM size");
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+		}
+
+		if (ee1 * 3 == ee2)
+			ee_split = 1;
+		else if (ee1 * 7 == ee2)
+			ee_split = 0;
+		else if (ee1 != ee2) {
+			LOG_ERROR("Unsupported EEPROM sizes ratio");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		ee_size_code = log2 | ee_split << 4;
+	}
+
+	if (CMD_ARGC >= 5)
+		COMMAND_PARSE_ON_OFF(CMD_ARGV[4], enable);
+	if (enable)
+		load_flex_ram = 0;
+
+	LOG_INFO("DEPART 0x%" PRIx8 ", EEPROM size code 0x%" PRIx8,
+		 flex_nvm_partition_code, ee_size_code);
+
+	result = kinetis_check_run_mode(k_chip);
+	if (result != ERROR_OK)
+		return result;
+
+	/* reset error flags */
+	result = kinetis_ftfx_prepare(target);
+	if (result != ERROR_OK)
+		return result;
+
+	result = kinetis_ftfx_command(target, FTFx_CMD_PGMPART, load_flex_ram,
+				      ee_size_code, flex_nvm_partition_code, 0, 0,
+				      0, 0, 0, 0,  NULL);
+	if (result != ERROR_OK)
+		return result;
+
+	command_print(CMD_CTX, "FlexNVM partition set. Please reset MCU.");
+
+	if (k_chip) {
+		first_nvm_bank = k_chip->num_pflash_blocks;
+		num_blocks = k_chip->num_pflash_blocks + k_chip->num_nvm_blocks;
+		for (bank_idx = first_nvm_bank; bank_idx < num_blocks; bank_idx++)
+			k_chip->banks[bank_idx].probed = false;	/* re-probe before next use */
+		k_chip->probed = false;
+	}
+
+	command_print(CMD_CTX, "FlexNVM banks will be re-probed to set new data flash size.");
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kinetis_fcf_source_handler)
+{
+	if (CMD_ARGC > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (CMD_ARGC == 1) {
+		if (strcmp(CMD_ARGV[0], "write") == 0)
+			allow_fcf_writes = true;
+		else if (strcmp(CMD_ARGV[0], "protection") == 0)
+			allow_fcf_writes = false;
+		else
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (allow_fcf_writes) {
+		command_print(CMD_CTX, "Arbitrary Flash Configuration Field writes enabled.");
+		command_print(CMD_CTX, "Protection info writes to FCF disabled.");
+		LOG_WARNING("BEWARE: incorrect flash configuration may permanently lock the device.");
+	} else {
+		command_print(CMD_CTX, "Protection info writes to Flash Configuration Field enabled.");
+		command_print(CMD_CTX, "Arbitrary FCF writes disabled. Mode safe from unwanted locking of the device.");
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kinetis_fopt_handler)
+{
+	if (CMD_ARGC > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (CMD_ARGC == 1)
+		fcf_fopt = (uint8_t)strtoul(CMD_ARGV[0], NULL, 0);
+	else
+		command_print(CMD_CTX, "FCF_FOPT 0x%02" PRIx8, fcf_fopt);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kinetis_create_banks_handler)
+{
+	if (CMD_ARGC > 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	create_banks = true;
+
+	return ERROR_OK;
+}
+
+
+static const struct command_registration kinetis_security_command_handlers[] = {
 	{
 		.name = "check_security",
 		.mode = COMMAND_EXEC,
-		.help = "",
+		.help = "Check status of device security lock",
 		.usage = "",
 		.handler = kinetis_check_flash_security_status,
 	},
+	{
+		.name = "halt",
+		.mode = COMMAND_EXEC,
+		.help = "Issue a halt via the MDM-AP",
+		.usage = "",
+		.handler = kinetis_mdm_halt,
+	},
 	{
 		.name = "mass_erase",
 		.mode = COMMAND_EXEC,
-		.help = "",
+		.help = "Issue a complete flash erase via the MDM-AP",
 		.usage = "",
 		.handler = kinetis_mdm_mass_erase,
 	},
-	{
-		.name = "test_securing",
+	{	.name = "reset",
 		.mode = COMMAND_EXEC,
-		.help = "",
+		.help = "Issue a reset via the MDM-AP",
 		.usage = "",
-		.handler = kinetis_securing_test,
+		.handler = kinetis_mdm_reset,
 	},
 	COMMAND_REGISTRATION_DONE
 };
@@ -1687,9 +3013,9 @@ static const struct command_registration kinetis_exec_command_handlers[] = {
 	{
 		.name = "mdm",
 		.mode = COMMAND_ANY,
-		.help = "",
+		.help = "MDM-AP command group",
 		.usage = "",
-		.chain = kinetis_securtiy_command_handlers,
+		.chain = kinetis_security_command_handlers,
 	},
 	{
 		.name = "disable_wdog",
@@ -1698,6 +3024,35 @@ static const struct command_registration kinetis_exec_command_handlers[] = {
 		.usage = "",
 		.handler = kinetis_disable_wdog_handler,
 	},
+	{
+		.name = "nvm_partition",
+		.mode = COMMAND_EXEC,
+		.help = "Show/set data flash or EEPROM backup size in kilobytes,"
+			" set two EEPROM sizes in bytes and FlexRAM loading during reset",
+		.usage = "('info'|'dataflash' size|'eebkp' size) [eesize1 eesize2] ['on'|'off']",
+		.handler = kinetis_nvm_partition,
+	},
+	{
+		.name = "fcf_source",
+		.mode = COMMAND_EXEC,
+		.help = "Use protection as a source for Flash Configuration Field or allow writing arbitrary values to the FCF"
+			" Mode 'protection' is safe from unwanted locking of the device.",
+		.usage = "['protection'|'write']",
+		.handler = kinetis_fcf_source_handler,
+	},
+	{
+		.name = "fopt",
+		.mode = COMMAND_EXEC,
+		.help = "FCF_FOPT value source in 'kinetis fcf_source protection' mode",
+		.usage = "[num]",
+		.handler = kinetis_fopt_handler,
+	},
+	{
+		.name = "create_banks",
+		.mode = COMMAND_CONFIG,
+		.help = "Driver creates additional banks if device with two/four flash blocks is probed",
+		.handler = kinetis_create_banks_handler,
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -1705,7 +3060,7 @@ static const struct command_registration kinetis_command_handler[] = {
 	{
 		.name = "kinetis",
 		.mode = COMMAND_ANY,
-		.help = "kinetis NAND flash controller commands",
+		.help = "Kinetis flash controller commands",
 		.usage = "",
 		.chain = kinetis_exec_command_handlers,
 	},
diff --git a/src/flash/nor/kinetis_ke.c b/src/flash/nor/kinetis_ke.c
new file mode 100644
index 00000000..636fcc2e
--- /dev/null
+++ b/src/flash/nor/kinetis_ke.c
@@ -0,0 +1,1314 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by Ivan Meleca                                     *
+ *   ivan@artekit.eu                                                       *
+ *                                                                         *
+ *   Modified from kinetis.c                                               *
+ *                                                                         *
+ *   Copyright (C) 2011 by Mathias Kuester                                 *
+ *   kesmtp@freenet.de                                                     *
+ *                                                                         *
+ *   Copyright (C) 2011 sleep(5) ltd                                       *
+ *   tomas@sleepfive.com                                                   *
+ *                                                                         *
+ *   Copyright (C) 2012 by Christopher D. Kilgour                          *
+ *   techie at whiterocker.com                                             *
+ *                                                                         *
+ *   Copyright (C) 2013 Nemui Trinomius                                    *
+ *   nemuisan_kawausogasuki@live.jp                                        *
+ *                                                                         *
+ *   Copyright (C) 2015 Tomas Vanek                                        *
+ *   vanekt@fbl.cz                                                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag/interface.h"
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+#include <target/cortex_m.h>
+
+/* Addresses */
+#define SIM_SRSID					0x40048000
+#define ICS_C1						0x40064000
+#define ICS_C2						0x40064001
+#define ICS_C3						0x40064002
+#define ICS_C4						0x40064003
+#define ICS_S						0x40064004
+#define SIM_BUSDIV					0x40048018
+#define SIM_CLKDIV_KE06				0x40048024
+#define SIM_CLKDIV_KE04_44_64_80	0x40048024
+#define SIM_CLKDIV_KE04_16_20_24	0x4004801C
+#define WDOG_CS1					0x40052000
+
+#define ICS_C2_BDIV_MASK			0xE0
+#define ICS_C2_BDIV_SHIFT			5
+#define ICS_C2_BDIV(x)				(((uint8_t)(((uint8_t)(x))<<ICS_C2_BDIV_SHIFT))&ICS_C2_BDIV_MASK)
+#define ICS_S_LOCK_MASK				0x40
+#define ICS_C4_SCFTRIM_MASK			0x1
+#define SIM_CLKDIV_OUTDIV2_MASK		0x1000000
+#define FTMRX_FCLKDIV_FDIV_MASK		0x3F
+#define FTMRX_FCLKDIV_FDIV_SHIFT	0
+#define FTMRX_FCLKDIV_FDIV(x)		(((uint8_t)(((uint8_t)(x))<<FTMRX_FCLKDIV_FDIV_SHIFT))&FTMRX_FCLKDIV_FDIV_MASK)
+#define FTMRX_FCLKDIV_FDIVLCK_MASK	0x40
+#define FTMRX_FCLKDIV_FDIVLCK_SHIFT	6
+#define FTMRX_FCLKDIV_FDIVLD_MASK	0x80
+#define FTMRX_FCLKDIV_FDIVLD_SHIFT	7
+#define FTMRX_FSTAT_CCIF_MASK		0x80
+#define FTMRX_FSTAT_MGSTAT0_MASK	0x01
+#define FTMRX_FSTAT_MGSTAT1_MASK	0x02
+
+/* Commands */
+#define FTMRX_CMD_ALLERASED			0x01
+#define FTMRX_CMD_BLOCKERASED		0x02
+#define FTMRX_CMD_SECTIONERASED		0x03
+#define FTMRX_CMD_READONCE			0x04
+#define FTMRX_CMD_PROGFLASH			0x06
+#define FTMRX_CMD_PROGONCE			0x07
+#define FTMRX_CMD_ERASEALL			0x08
+#define FTMRX_CMD_ERASEBLOCK		0x09
+#define FTMRX_CMD_ERASESECTOR		0x0A
+#define FTMRX_CMD_UNSECURE			0x0B
+#define FTMRX_CMD_VERIFYACCESS		0x0C
+#define FTMRX_CMD_SETMARGINLVL		0x0D
+#define FTMRX_CMD_SETFACTORYLVL		0x0E
+#define FTMRX_CMD_CONFIGNVM			0x0F
+
+/* Error codes */
+#define FTMRX_ERROR_ACCERR			0x20
+#define FTMRX_ERROR_FPVIOL			0x10
+
+#define KINETIS_KE_SRSID_FAMID(x)		((x >> 28) & 0x0F)
+#define KINETIS_KE_SRSID_SUBFAMID(x)	((x >> 24) & 0x0F)
+#define KINETIS_KE_SRSID_PINCOUNT(x)	((x >> 16) & 0x0F)
+
+#define KINETIS_KE_SRSID_KEX2	0x02
+#define KINETIS_KE_SRSID_KEX4	0x04
+#define KINETIS_KE_SRSID_KEX6	0x06
+
+struct kinetis_ke_flash_bank {
+	uint32_t sector_size;
+	uint32_t protection_size;
+
+	uint32_t sim_srsid;
+	uint32_t ftmrx_fclkdiv_addr;
+	uint32_t ftmrx_fccobix_addr;
+	uint32_t ftmrx_fstat_addr;
+	uint32_t ftmrx_fprot_addr;
+	uint32_t ftmrx_fccobhi_addr;
+	uint32_t ftmrx_fccoblo_addr;
+};
+
+#define MDM_REG_STAT		0x00
+#define MDM_REG_CTRL		0x04
+#define MDM_REG_ID			0xfc
+
+#define MDM_STAT_FMEACK		(1<<0)
+#define MDM_STAT_FREADY		(1<<1)
+#define MDM_STAT_SYSSEC		(1<<2)
+#define MDM_STAT_SYSRES		(1<<3)
+#define MDM_STAT_FMEEN		(1<<5)
+#define MDM_STAT_BACKDOOREN	(1<<6)
+#define MDM_STAT_LPEN		(1<<7)
+#define MDM_STAT_VLPEN		(1<<8)
+#define MDM_STAT_LLSMODEXIT	(1<<9)
+#define MDM_STAT_VLLSXMODEXIT	(1<<10)
+#define MDM_STAT_CORE_HALTED	(1<<16)
+#define MDM_STAT_CORE_SLEEPDEEP	(1<<17)
+#define MDM_STAT_CORESLEEPING	(1<<18)
+
+#define MEM_CTRL_FMEIP		(1<<0)
+#define MEM_CTRL_DBG_DIS	(1<<1)
+#define MEM_CTRL_DBG_REQ	(1<<2)
+#define MEM_CTRL_SYS_RES_REQ	(1<<3)
+#define MEM_CTRL_CORE_HOLD_RES	(1<<4)
+#define MEM_CTRL_VLLSX_DBG_REQ	(1<<5)
+#define MEM_CTRL_VLLSX_DBG_ACK	(1<<6)
+#define MEM_CTRL_VLLSX_STAT_ACK	(1<<7)
+
+#define MDM_ACCESS_TIMEOUT	3000 /* iterations */
+
+static int kinetis_ke_mdm_write_register(struct adiv5_dap *dap, unsigned reg, uint32_t value)
+{
+	int retval;
+	LOG_DEBUG("MDM_REG[0x%02x] <- %08" PRIX32, reg, value);
+
+	retval = dap_queue_ap_write(dap_ap(dap, 1), reg, value);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("MDM: failed to queue a write request");
+		return retval;
+	}
+
+	retval = dap_run(dap);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("MDM: dap_run failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_ke_mdm_read_register(struct adiv5_dap *dap, unsigned reg, uint32_t *result)
+{
+	int retval;
+	retval = dap_queue_ap_read(dap_ap(dap, 1), reg, result);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("MDM: failed to queue a read request");
+		return retval;
+	}
+
+	retval = dap_run(dap);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("MDM: dap_run failed");
+		return retval;
+	}
+
+	LOG_DEBUG("MDM_REG[0x%02x]: %08" PRIX32, reg, *result);
+	return ERROR_OK;
+}
+
+static int kinetis_ke_mdm_poll_register(struct adiv5_dap *dap, unsigned reg, uint32_t mask, uint32_t value)
+{
+	uint32_t val;
+	int retval;
+	int timeout = MDM_ACCESS_TIMEOUT;
+
+	do {
+		retval = kinetis_ke_mdm_read_register(dap, reg, &val);
+		if (retval != ERROR_OK || (val & mask) == value)
+			return retval;
+
+		alive_sleep(1);
+	} while (timeout--);
+
+	LOG_DEBUG("MDM: polling timed out");
+	return ERROR_FAIL;
+}
+
+static int kinetis_ke_prepare_flash(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct kinetis_ke_flash_bank *kinfo = bank->driver_priv;
+	uint8_t c2, c3, c4, s = 0;
+	uint16_t trim_value = 0;
+	uint16_t timeout = 0;
+	uint32_t bus_clock = 0;
+	uint32_t bus_reg_val = 0;
+	uint32_t bus_reg_addr = 0;
+	uint32_t flash_clk_div;
+	uint8_t fclkdiv;
+	int result;
+
+	/*
+	 * The RM states that the flash clock has to be set to 1MHz for writing and
+	 * erasing operations (otherwise it can damage the flash).
+	 * This function configures the entire clock tree to make sure we
+	 * run at the specified clock. We'll set FEI mode running from the ~32KHz
+	 * internal clock. So we need to:
+	 * - Trim internal clock.
+	 * - Configure the divider for ICSOUTCLK (ICS module).
+	 * - Configure the divider to get a bus clock (SIM module).
+	 * - Configure the flash clock that depends on the bus clock.
+	 *
+	 * For MKE02_40 and MKE02_20 we set ICSOUTCLK = 20MHz and bus clock = 20MHz.
+	 * For MKE04 and MKE06 we run at ICSOUTCLK = 48MHz and bus clock = 24MHz.
+	 */
+
+	/*
+	 * Trim internal clock
+	 */
+	switch (KINETIS_KE_SRSID_SUBFAMID(kinfo->sim_srsid)) {
+
+		case KINETIS_KE_SRSID_KEX2:
+			/* Both KE02_20 and KE02_40 should get the same trim value */
+			trim_value = 0x4C;
+			break;
+
+		case KINETIS_KE_SRSID_KEX4:
+			trim_value = 0x54;
+			break;
+
+		case KINETIS_KE_SRSID_KEX6:
+			trim_value = 0x58;
+			break;
+	}
+
+	result = target_read_u8(target, ICS_C4, &c4);
+	if (result != ERROR_OK)
+		return result;
+
+	c3 = trim_value;
+	c4 = (c4 & ~(ICS_C4_SCFTRIM_MASK)) | ((trim_value >> 8) & 0x01);
+
+	result = target_write_u8(target, ICS_C3, c3);
+	if (result != ERROR_OK)
+		return result;
+
+	result = target_write_u8(target, ICS_C4, c4);
+	if (result != ERROR_OK)
+		return result;
+
+	result = target_read_u8(target, ICS_S, &s);
+	if (result != ERROR_OK)
+		return result;
+
+	/* Wait */
+	while (!(s & ICS_S_LOCK_MASK)) {
+
+		if (timeout <= 1000) {
+			timeout++;
+			alive_sleep(1);
+		} else {
+			return ERROR_FAIL;
+		}
+
+		result = target_read_u8(target, ICS_S, &s);
+		if (result != ERROR_OK)
+			return result;
+	}
+
+	/* ... trim done ... */
+
+	/*
+	 * Configure SIM (bus clock)
+	 */
+	switch (KINETIS_KE_SRSID_SUBFAMID(kinfo->sim_srsid)) {
+
+		/* KE02 sub-family operates on SIM_BUSDIV */
+		case KINETIS_KE_SRSID_KEX2:
+			bus_reg_val = 0;
+			bus_reg_addr = SIM_BUSDIV;
+			bus_clock = 20000000;
+			break;
+
+		/* KE04 and KE06 sub-family operates on SIM_CLKDIV
+		 * Clocks are divided by:
+		 * DIV1 = core clock = 48MHz
+		 * DIV2 = bus clock = 24Mhz
+		 * DIV3 = timer clocks
+		 * So we need to configure SIM_CLKDIV, DIV1 and DIV2 value
+		 */
+		case KINETIS_KE_SRSID_KEX4:
+			/* KE04 devices have the SIM_CLKDIV register at a different offset
+			 * depending on the pin count. */
+			switch (KINETIS_KE_SRSID_PINCOUNT(kinfo->sim_srsid)) {
+
+				/* 16, 20 and 24 pins */
+				case 1:
+				case 2:
+				case 3:
+					bus_reg_addr = SIM_CLKDIV_KE04_16_20_24;
+					break;
+
+				/* 44, 64 and 80 pins */
+				case 5:
+				case 7:
+				case 8:
+					bus_reg_addr = SIM_CLKDIV_KE04_44_64_80;
+					break;
+
+				default:
+					LOG_ERROR("KE04 - Unknown pin count");
+					return ERROR_FAIL;
+			}
+
+			bus_reg_val = SIM_CLKDIV_OUTDIV2_MASK;
+			bus_clock = 24000000;
+			break;
+
+		case KINETIS_KE_SRSID_KEX6:
+			bus_reg_val = SIM_CLKDIV_OUTDIV2_MASK;
+			bus_reg_addr = SIM_CLKDIV_KE06;
+			bus_clock = 24000000;
+			break;
+	}
+
+	result = target_write_u32(target, bus_reg_addr, bus_reg_val);
+	if (result != ERROR_OK)
+		return result;
+
+	/*
+	 * Configure ICS to FEI (internal source)
+	 */
+	result = target_read_u8(target, ICS_C2, &c2);
+	if (result != ERROR_OK)
+		return result;
+
+	c2 &= ~ICS_C2_BDIV_MASK;
+
+	switch (KINETIS_KE_SRSID_SUBFAMID(kinfo->sim_srsid)) {
+
+		case KINETIS_KE_SRSID_KEX2:
+			/* Note: since there are two KE02 types, the KE02_40 @ 40MHz and the
+			 * KE02_20 @ 20MHz, we divide here the ~40MHz ICSFLLCLK down to 20MHz,
+			 * for compatibility.
+			 */
+			c2 |= ICS_C2_BDIV(1);
+			break;
+
+		case KINETIS_KE_SRSID_KEX4:
+		case KINETIS_KE_SRSID_KEX6:
+			/* For KE04 and KE06, the ICSFLLCLK can be 48MHz. */
+			c2 |= ICS_C2_BDIV(0);
+			break;
+	}
+
+	result = target_write_u8(target, ICS_C2, c2);
+	if (result != ERROR_OK)
+		return result;
+
+	/* Internal clock as reference (IREFS = 1) */
+	result = target_write_u8(target, ICS_C1, 4);
+	if (result != ERROR_OK)
+		return result;
+
+	/* Wait for FLL to lock */
+	result = target_read_u8(target, ICS_S, &s);
+	if (result != ERROR_OK)
+		return result;
+
+	while (!(s & ICS_S_LOCK_MASK)) {
+
+		if (timeout <= 1000) {
+			timeout++;
+			alive_sleep(1);
+		} else {
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		result = target_read_u8(target, ICS_S, &s);
+		if (result != ERROR_OK)
+			return result;
+	}
+
+	/*
+	 * Configure flash clock to 1MHz.
+	 */
+	flash_clk_div = bus_clock / 1000000L - 1;
+
+	/* Check if the FCLKDIV register is locked */
+	result = target_read_u8(target, kinfo->ftmrx_fclkdiv_addr, &fclkdiv);
+	if (result != ERROR_OK)
+		return result;
+
+	if (!(fclkdiv & FTMRX_FCLKDIV_FDIVLCK_MASK)) {
+		/* Unlocked. Check if the register was configured, and if so, if it has the right value */
+		if ((fclkdiv & FTMRX_FCLKDIV_FDIVLD_MASK) &&
+			((fclkdiv & FTMRX_FCLKDIV_FDIV_MASK) != FTMRX_FCLKDIV_FDIV(flash_clk_div))) {
+			LOG_WARNING("Flash clock was already set and contains an invalid value.");
+			LOG_WARNING("Please reset the target.");
+			return ERROR_FAIL;
+		}
+
+		/* Finally, configure the flash clock */
+		fclkdiv = (fclkdiv & ~(FTMRX_FCLKDIV_FDIV_MASK)) | FTMRX_FCLKDIV_FDIV(flash_clk_div);
+		result = target_write_u8(target, kinfo->ftmrx_fclkdiv_addr, fclkdiv);
+		if (result != ERROR_OK)
+			return result;
+	} else {
+		/* Locked. Check if the current value is correct. */
+		if ((fclkdiv & FTMRX_FCLKDIV_FDIV_MASK) != FTMRX_FCLKDIV_FDIV(flash_clk_div)) {
+			LOG_WARNING("Flash clock register is locked and contains an invalid value.");
+			LOG_WARNING("Please reset the target.");
+			return ERROR_FAIL;
+		}
+	}
+
+	LOG_INFO("Flash clock ready");
+	return ERROR_OK;
+}
+
+int kinetis_ke_stop_watchdog(struct target *target)
+{
+	struct working_area *watchdog_algorithm;
+	struct armv7m_algorithm armv7m_info;
+	int retval;
+	uint8_t cs1;
+
+	static const uint8_t watchdog_code[] = {
+#include "../../../contrib/loaders/flash/kinetis_ke/kinetis_ke_watchdog.inc"
+	};
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Check if the watchdog is enabled */
+	retval = target_read_u8(target, WDOG_CS1, &cs1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (!(cs1 & 0x80)) {
+		/* Already stopped */
+		return ERROR_OK;
+	}
+
+	/* allocate working area with watchdog code */
+	if (target_alloc_working_area(target, sizeof(watchdog_code), &watchdog_algorithm) != ERROR_OK) {
+		LOG_WARNING("No working area available for watchdog algorithm");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	retval = target_write_buffer(target, watchdog_algorithm->address,
+			sizeof(watchdog_code), watchdog_code);
+	if (retval != ERROR_OK)
+		return retval;
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARM_MODE_THREAD;
+
+	retval = target_run_algorithm(target, 0, NULL, 0, NULL,
+			watchdog_algorithm->address, 0, 100000, &armv7m_info);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Error executing Kinetis KE watchdog algorithm");
+		retval = ERROR_FAIL;
+	} else {
+		LOG_INFO("Watchdog stopped");
+	}
+
+	target_free_working_area(target, watchdog_algorithm);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kinetis_ke_disable_wdog_handler)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (CMD_ARGC > 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	return kinetis_ke_stop_watchdog(target);
+}
+
+COMMAND_HANDLER(kinetis_ke_mdm_mass_erase)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct cortex_m_common *cortex_m = target_to_cm(target);
+	struct adiv5_dap *dap = cortex_m->armv7m.arm.dap;
+
+	if (!dap) {
+		LOG_ERROR("Cannot perform mass erase with a high-level adapter");
+		return ERROR_FAIL;
+	}
+
+	int retval;
+
+	/* According to chapter 18.3.7.2 of the KE02 reference manual */
+
+	/* assert SRST */
+	if (jtag_get_reset_config() & RESET_HAS_SRST)
+		adapter_assert_reset();
+
+	/*
+	 * 1. Reset the device by asserting RESET pin or DAP_CTRL[3]
+	 */
+	retval = kinetis_ke_mdm_write_register(dap, MDM_REG_CTRL, MEM_CTRL_SYS_RES_REQ);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * ... Read the MDM-AP status register until the Flash Ready bit sets...
+	 */
+	retval = kinetis_ke_mdm_poll_register(dap, MDM_REG_STAT,
+					   MDM_STAT_FREADY | MDM_STAT_SYSRES,
+					   MDM_STAT_FREADY);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM : flash ready timeout");
+		return retval;
+	}
+
+	/*
+	 * 2. Set DAP_CTRL[0] bit to invoke debug mass erase via SWD
+	 * 3. Release reset by deasserting RESET pin or DAP_CTRL[3] bit via SWD.
+	 */
+	retval = kinetis_ke_mdm_write_register(dap, MDM_REG_CTRL, MEM_CTRL_FMEIP);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* As a sanity check make sure that device started mass erase procedure */
+	retval = kinetis_ke_mdm_poll_register(dap, MDM_REG_STAT,
+					   MDM_STAT_FMEACK, MDM_STAT_FMEACK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * 4. Wait till DAP_CTRL[0] bit is cleared (after mass erase completes,
+	 * DAP_CTRL[0] bit is cleared automatically).
+	 */
+	retval = kinetis_ke_mdm_poll_register(dap, MDM_REG_CTRL,
+					   MEM_CTRL_FMEIP,
+					   0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (jtag_get_reset_config() & RESET_HAS_SRST)
+		adapter_deassert_reset();
+
+	return ERROR_OK;
+}
+
+static const uint32_t kinetis_ke_known_mdm_ids[] = {
+	0x001C0020,	/* Kinetis-L/M/V/E/KE Series */
+};
+
+/*
+ * This function implements the procedure to connect to
+ * SWD/JTAG on Kinetis K and L series of devices as it is described in
+ * AN4835 "Production Flash Programming Best Practices for Kinetis K-
+ * and L-series MCUs" Section 4.1.1
+ */
+COMMAND_HANDLER(kinetis_ke_check_flash_security_status)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct cortex_m_common *cortex_m = target_to_cm(target);
+	struct adiv5_dap *dap = cortex_m->armv7m.arm.dap;
+
+	if (!dap) {
+		LOG_WARNING("Cannot check flash security status with a high-level adapter");
+		return ERROR_OK;
+	}
+
+	uint32_t val;
+	int retval;
+
+	/*
+	 * ... The MDM-AP ID register can be read to verify that the
+	 * connection is working correctly...
+	 */
+	retval = kinetis_ke_mdm_read_register(dap, MDM_REG_ID, &val);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to read ID register");
+		goto fail;
+	}
+
+	bool found = false;
+	for (size_t i = 0; i < ARRAY_SIZE(kinetis_ke_known_mdm_ids); i++) {
+		if (val == kinetis_ke_known_mdm_ids[i]) {
+			found = true;
+			break;
+		}
+	}
+
+	if (!found)
+		LOG_WARNING("MDM: unknown ID %08" PRIX32, val);
+
+	/*
+	 * ... Read the MDM-AP status register until the Flash Ready bit sets...
+	 */
+	retval = kinetis_ke_mdm_poll_register(dap, MDM_REG_STAT,
+					   MDM_STAT_FREADY,
+					   MDM_STAT_FREADY);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: flash ready timeout");
+		goto fail;
+	}
+
+	/*
+	 * ... Read the System Security bit to determine if security is enabled.
+	 * If System Security = 0, then proceed. If System Security = 1, then
+	 * communication with the internals of the processor, including the
+	 * flash, will not be possible without issuing a mass erase command or
+	 * unsecuring the part through other means (backdoor key unlock)...
+	 */
+	retval = kinetis_ke_mdm_read_register(dap, MDM_REG_STAT, &val);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MDM: failed to read MDM_REG_STAT");
+		goto fail;
+	}
+
+	if (val & MDM_STAT_SYSSEC) {
+		jtag_poll_set_enabled(false);
+
+		LOG_WARNING("*********** ATTENTION! ATTENTION! ATTENTION! ATTENTION! **********");
+		LOG_WARNING("****                                                          ****");
+		LOG_WARNING("**** Your Kinetis MCU is in secured state, which means that,  ****");
+		LOG_WARNING("**** with exception for very basic communication, JTAG/SWD    ****");
+		LOG_WARNING("**** interface will NOT work. In order to restore its         ****");
+		LOG_WARNING("**** functionality please issue 'kinetis_ke mdm mass_erase'   ****");
+		LOG_WARNING("**** command, power cycle the MCU and restart OpenOCD.        ****");
+		LOG_WARNING("****                                                          ****");
+		LOG_WARNING("*********** ATTENTION! ATTENTION! ATTENTION! ATTENTION! **********");
+	} else {
+		LOG_INFO("MDM: Chip is unsecured. Continuing.");
+		jtag_poll_set_enabled(true);
+	}
+
+	return ERROR_OK;
+
+fail:
+	LOG_ERROR("MDM: Failed to check security status of the MCU. Cannot proceed further");
+	jtag_poll_set_enabled(false);
+	return retval;
+}
+
+FLASH_BANK_COMMAND_HANDLER(kinetis_ke_flash_bank_command)
+{
+	struct kinetis_ke_flash_bank *bank_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	LOG_INFO("add flash_bank kinetis_ke %s", bank->name);
+
+	bank_info = malloc(sizeof(struct kinetis_ke_flash_bank));
+
+	memset(bank_info, 0, sizeof(struct kinetis_ke_flash_bank));
+
+	bank->driver_priv = bank_info;
+
+	return ERROR_OK;
+}
+
+/* Kinetis Program-LongWord Microcodes */
+static uint8_t kinetis_ke_flash_write_code[] = {
+#include "../../../contrib/loaders/flash/kinetis_ke/kinetis_ke_flash.inc"
+};
+
+static int kinetis_ke_write_words(struct flash_bank *bank, const uint8_t *buffer,
+								uint32_t offset, uint32_t words)
+{
+	struct kinetis_ke_flash_bank *kinfo = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t ram_buffer_size = 512 + 16;
+	struct working_area *write_algorithm;
+	struct working_area *source;
+	uint32_t address = bank->base + offset;
+	struct reg_param reg_params[4];
+	struct armv7m_algorithm armv7m_info;
+	int retval = ERROR_OK;
+	uint32_t flash_code_size;
+
+	LOG_INFO("Kinetis KE: FLASH Write ...");
+
+	/* allocate working area with flash programming code */
+	if (target_alloc_working_area(target, sizeof(kinetis_ke_flash_write_code),
+			&write_algorithm) != ERROR_OK) {
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	/* Patch the FTMRx registers addresses */
+	flash_code_size = sizeof(kinetis_ke_flash_write_code);
+	buf_set_u32(&kinetis_ke_flash_write_code[flash_code_size-16], 0, 32, kinfo->ftmrx_fstat_addr);
+	buf_set_u32(&kinetis_ke_flash_write_code[flash_code_size-12], 0, 32, kinfo->ftmrx_fccobix_addr);
+	buf_set_u32(&kinetis_ke_flash_write_code[flash_code_size-8], 0, 32, kinfo->ftmrx_fccobhi_addr);
+	buf_set_u32(&kinetis_ke_flash_write_code[flash_code_size-4], 0, 32, kinfo->ftmrx_fccoblo_addr);
+
+	retval = target_write_buffer(target, write_algorithm->address,
+		sizeof(kinetis_ke_flash_write_code), kinetis_ke_flash_write_code);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	if (target_alloc_working_area(target, ram_buffer_size, &source) != ERROR_OK) {
+		/* free working area, write algorithm already allocated */
+		target_free_working_area(target, write_algorithm);
+
+		LOG_WARNING("No large enough working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARM_MODE_THREAD;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
+
+	buf_set_u32(reg_params[0].value, 0, 32, address);
+	buf_set_u32(reg_params[1].value, 0, 32, words);
+	buf_set_u32(reg_params[2].value, 0, 32, source->address);
+	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
+
+	retval = target_run_flash_async_algorithm(target, buffer, words, 4,
+			0, NULL,
+			4, reg_params,
+			source->address, source->size,
+			write_algorithm->address, 0,
+			&armv7m_info);
+
+	if (retval == ERROR_FLASH_OPERATION_FAILED) {
+		if (buf_get_u32(reg_params[0].value, 0, 32) & FTMRX_ERROR_ACCERR)
+			LOG_ERROR("flash access error");
+
+		if (buf_get_u32(reg_params[0].value, 0, 32) & FTMRX_ERROR_FPVIOL)
+			LOG_ERROR("flash protection violation");
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+
+	return retval;
+}
+
+static int kinetis_ke_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	LOG_WARNING("kinetis_ke_protect not supported yet");
+	/* FIXME: TODO */
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	return ERROR_FLASH_BANK_INVALID;
+}
+
+static int kinetis_ke_protect_check(struct flash_bank *bank)
+{
+	struct kinetis_ke_flash_bank *kinfo = bank->driver_priv;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	int result;
+	uint8_t fprot;
+	uint8_t fpopen, fpldis, fphdis;
+	uint8_t fphs, fpls;
+	uint32_t lprot_size = 0, hprot_size = 0;
+	uint32_t lprot_to = 0, hprot_from = 0;
+
+	/* read protection register */
+	result = target_read_u8(bank->target, kinfo->ftmrx_fprot_addr, &fprot);
+
+	if (result != ERROR_OK)
+		return result;
+
+	fpopen = fprot & 0x80;
+	fpldis = fprot & 0x04;
+	fphdis = fprot & 0x20;
+	fphs = (fprot >> 3) & 0x03;
+	fpls = fprot & 0x03;
+
+	/* Fully unprotected? */
+	if (fpopen && fpldis && fphdis) {
+		LOG_WARNING("No flash protection found.");
+
+		for (uint32_t i = 0; i < (uint32_t) bank->num_sectors; i++)
+			bank->sectors[i].is_protected = 0;
+
+		kinfo->protection_size = 0;
+	} else {
+		LOG_WARNING("Flash protected. FPOPEN=%i FPLDIS=%i FPHDIS=%i FPLS=%i FPHS=%i", \
+					fpopen ? 1 : 0, fpldis ? 1 : 0, fphdis ? 1 : 0, fpls, fphs);
+
+		/* Retrieve which region is protected and how much */
+		if (fpopen) {
+			if (fpldis == 0)
+				lprot_size = (kinfo->sector_size * 4) << fpls;
+
+			if (fphdis == 0)
+				hprot_size = (kinfo->sector_size * 2) << fphs;
+		} else {
+			if (fpldis == 1)
+				lprot_size = (kinfo->sector_size * 4) << fpls;
+
+			if (fphdis == 1)
+				hprot_size = (kinfo->sector_size * 2) << fphs;
+		}
+
+		kinfo->protection_size = lprot_size + hprot_size;
+
+		/* lprot_to indicates up to where the lower region is protected */
+		lprot_to = lprot_size / kinfo->sector_size;
+
+		/* hprot_from indicates from where the upper region is protected */
+		hprot_from = (0x8000 - hprot_size) / kinfo->sector_size;
+
+		for (uint32_t i = 0; i < (uint32_t) bank->num_sectors; i++) {
+
+			/* Check if the sector is in the lower region */
+			if (bank->sectors[i].offset < 0x4000) {
+				/* Compare the sector start address against lprot_to */
+				if (lprot_to && (i < lprot_to))
+					bank->sectors[i].is_protected = 1;
+				else
+					bank->sectors[i].is_protected = 0;
+
+			/* Check if the sector is between the lower and upper region
+			 * OR after the upper region */
+			} else if (bank->sectors[i].offset < 0x6000 || bank->sectors[i].offset >= 0x8000) {
+				/* If fpopen is 1 then these regions are protected */
+				if (fpopen)
+					bank->sectors[i].is_protected = 0;
+				else
+					bank->sectors[i].is_protected = 1;
+
+			/* Check if the sector is in the upper region */
+			} else if (bank->sectors[i].offset < 0x8000) {
+				if (hprot_from && (i > hprot_from))
+					bank->sectors[i].is_protected = 1;
+				else
+					bank->sectors[i].is_protected = 0;
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_ke_ftmrx_command(struct flash_bank *bank, uint8_t count,
+									uint8_t *FCCOBIX, uint8_t *FCCOBHI, uint8_t *FCCOBLO, uint8_t *fstat)
+{
+	uint8_t i;
+	int result;
+	struct target *target = bank->target;
+	struct kinetis_ke_flash_bank *kinfo = bank->driver_priv;
+	uint32_t timeout = 0;
+
+	/* Clear error flags */
+	result = target_write_u8(target, kinfo->ftmrx_fstat_addr, 0x30);
+	if (result != ERROR_OK)
+		return result;
+
+	for (i = 0; i < count; i++)	{
+		/* Write index */
+		result = target_write_u8(target, kinfo->ftmrx_fccobix_addr, FCCOBIX[i]);
+		if (result != ERROR_OK)
+			return result;
+
+		/* Write high part */
+		result = target_write_u8(target, kinfo->ftmrx_fccobhi_addr, FCCOBHI[i]);
+		if (result != ERROR_OK)
+			return result;
+
+		/* Write low part (that is not always required) */
+		if (FCCOBLO) {
+			result = target_write_u8(target, kinfo->ftmrx_fccoblo_addr, FCCOBLO[i]);
+			if (result != ERROR_OK)
+				return result;
+		}
+	}
+
+	/* Launch the command */
+	result = target_write_u8(target, kinfo->ftmrx_fstat_addr, 0x80);
+	if (result != ERROR_OK)
+		return result;
+
+	/* Wait for it to finish */
+	result = target_read_u8(target, kinfo->ftmrx_fstat_addr, fstat);
+	if (result != ERROR_OK)
+		return result;
+
+	while (!(*fstat & FTMRX_FSTAT_CCIF_MASK)) {
+		if (timeout <= 1000) {
+			timeout++;
+			alive_sleep(1);
+		} else {
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		result = target_read_u8(target, kinfo->ftmrx_fstat_addr, fstat);
+		if (result != ERROR_OK)
+			return result;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kinetis_ke_securing_test)
+{
+	int result;
+	struct target *target = get_current_target(CMD_CTX);
+	struct flash_bank *bank = NULL;
+	uint32_t address;
+
+	uint8_t FCCOBIX[2], FCCOBHI[2], FCCOBLO[2], fstat;
+
+	result = get_flash_bank_by_addr(target, 0x00000000, true, &bank);
+	if (result != ERROR_OK)
+		return result;
+
+	assert(bank != NULL);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	address = bank->base + 0x00000400;
+
+	FCCOBIX[0] = 0;
+	FCCOBHI[0] = FTMRX_CMD_ERASESECTOR;
+	FCCOBLO[0] = address >> 16;
+
+	FCCOBIX[1] = 1;
+	FCCOBHI[1] = address >> 8;
+	FCCOBLO[1] = address;
+
+	return kinetis_ke_ftmrx_command(bank, 2, FCCOBIX, FCCOBHI, FCCOBLO, &fstat);
+}
+
+static int kinetis_ke_erase(struct flash_bank *bank, int first, int last)
+{
+	int result, i;
+	uint8_t FCCOBIX[2], FCCOBHI[2], FCCOBLO[2], fstat;
+	bool fcf_erased = false;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first > bank->num_sectors) || (last > bank->num_sectors))
+		return ERROR_FLASH_OPERATION_FAILED;
+
+	result = kinetis_ke_prepare_flash(bank);
+	if (result != ERROR_OK)
+		return result;
+
+	for (i = first; i <= last; i++) {
+		FCCOBIX[0] = 0;
+		FCCOBHI[0] = FTMRX_CMD_ERASESECTOR;
+		FCCOBLO[0] = (bank->base + bank->sectors[i].offset) >> 16;
+
+		FCCOBIX[1] = 1;
+		FCCOBHI[1] = (bank->base + bank->sectors[i].offset) >> 8;
+		FCCOBLO[1] = (bank->base + bank->sectors[i].offset);
+
+		result = kinetis_ke_ftmrx_command(bank, 2, FCCOBIX, FCCOBHI, FCCOBLO, &fstat);
+
+		if (result != ERROR_OK)	{
+			LOG_WARNING("erase sector %d failed", i);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		bank->sectors[i].is_erased = 1;
+
+		if (i == 2)
+			fcf_erased = true;
+	}
+
+	if (fcf_erased) {
+		LOG_WARNING
+			("flash configuration field erased, please reset the device");
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_ke_write(struct flash_bank *bank, const uint8_t *buffer,
+			 uint32_t offset, uint32_t count)
+{
+	int result;
+	uint8_t *new_buffer = NULL;
+	uint32_t words = count / 4;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset > bank->size)
+		return ERROR_FLASH_BANK_INVALID;
+
+	if (offset & 0x3) {
+		LOG_WARNING("offset 0x%" PRIx32 " breaks the required alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	result = kinetis_ke_stop_watchdog(bank->target);
+	if (result != ERROR_OK)
+			return result;
+
+	result = kinetis_ke_prepare_flash(bank);
+	if (result != ERROR_OK)
+		return result;
+
+	if (count & 0x3) {
+		uint32_t old_count = count;
+		count = (old_count | 3) + 1;
+		new_buffer = malloc(count);
+		if (new_buffer == NULL) {
+			LOG_ERROR("odd number of bytes to write and no memory "
+				"for padding buffer");
+			return ERROR_FAIL;
+		}
+
+		LOG_INFO("odd number of bytes to write (%" PRIu32 "), extending to %" PRIu32 " "
+			"and padding with 0xff", old_count, count);
+
+		memset(new_buffer, 0xff, count);
+		buffer = memcpy(new_buffer, buffer, old_count);
+		words++;
+	}
+
+	result = kinetis_ke_write_words(bank, buffer, offset, words);
+	free(new_buffer);
+
+	return result;
+}
+
+static int kinetis_ke_probe(struct flash_bank *bank)
+{
+	int result, i;
+	uint32_t offset = 0;
+	struct target *target = bank->target;
+	struct kinetis_ke_flash_bank *kinfo = bank->driver_priv;
+
+	result = target_read_u32(target, SIM_SRSID, &kinfo->sim_srsid);
+	if (result != ERROR_OK)
+		return result;
+
+	if (KINETIS_KE_SRSID_FAMID(kinfo->sim_srsid) != 0x00) {
+		LOG_ERROR("Unsupported KE family");
+		return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
+	switch (KINETIS_KE_SRSID_SUBFAMID(kinfo->sim_srsid)) {
+		case KINETIS_KE_SRSID_KEX2:
+			LOG_INFO("KE02 sub-family");
+			break;
+
+		case KINETIS_KE_SRSID_KEX4:
+			LOG_INFO("KE04 sub-family");
+			break;
+
+		case KINETIS_KE_SRSID_KEX6:
+			LOG_INFO("KE06 sub-family");
+			break;
+
+		default:
+			LOG_ERROR("Unsupported KE sub-family");
+			return ERROR_FLASH_OPER_UNSUPPORTED;
+	}
+
+	/* We can only retrieve the ke0x part, but there is no way to know
+	 * the flash size, so assume the maximum flash size for the entire
+	 * sub family.
+	 */
+	bank->base = 0x00000000;
+	kinfo->sector_size = 512;
+
+	switch (KINETIS_KE_SRSID_SUBFAMID(kinfo->sim_srsid)) {
+
+		case KINETIS_KE_SRSID_KEX2:
+			/* Max. 64KB */
+			bank->size = 0x00010000;
+			bank->num_sectors = 128;
+
+			/* KE02 uses the FTMRH flash controller,
+			 * and registers have a different offset from the
+			 * FTMRE flash controller. Sort this out here.
+			 */
+			kinfo->ftmrx_fclkdiv_addr = 0x40020000;
+			kinfo->ftmrx_fccobix_addr = 0x40020002;
+			kinfo->ftmrx_fstat_addr = 0x40020006;
+			kinfo->ftmrx_fprot_addr = 0x40020008;
+			kinfo->ftmrx_fccobhi_addr = 0x4002000A;
+			kinfo->ftmrx_fccoblo_addr = 0x4002000B;
+			break;
+
+		case KINETIS_KE_SRSID_KEX6:
+		case KINETIS_KE_SRSID_KEX4:
+			/* Max. 128KB */
+			bank->size = 0x00020000;
+			bank->num_sectors = 256;
+
+			/* KE04 and KE06 use the FTMRE flash controller,
+			 * and registers have a different offset from the
+			 * FTMRH flash controller. Sort this out here.
+			 */
+			kinfo->ftmrx_fclkdiv_addr = 0x40020003;
+			kinfo->ftmrx_fccobix_addr = 0x40020001;
+			kinfo->ftmrx_fstat_addr = 0x40020005;
+			kinfo->ftmrx_fprot_addr = 0x4002000B;
+			kinfo->ftmrx_fccobhi_addr = 0x40020009;
+			kinfo->ftmrx_fccoblo_addr = 0x40020008;
+			break;
+	}
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	assert(bank->num_sectors > 0);
+	bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
+
+	for (i = 0; i < bank->num_sectors; i++) {
+		bank->sectors[i].offset = offset;
+		bank->sectors[i].size = kinfo->sector_size;
+		offset += kinfo->sector_size;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	return ERROR_OK;
+}
+
+static int kinetis_ke_auto_probe(struct flash_bank *bank)
+{
+	struct kinetis_ke_flash_bank *kinfo = bank->driver_priv;
+
+	if (kinfo->sim_srsid)
+		return ERROR_OK;
+
+	return kinetis_ke_probe(bank);
+}
+
+static int kinetis_ke_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	(void) snprintf(buf, buf_size,
+			"%s driver for flash bank %s at 0x%8.8" PRIx32 "",
+			bank->driver->name,	bank->name, bank->base);
+
+	return ERROR_OK;
+}
+
+static int kinetis_ke_blank_check(struct flash_bank *bank)
+{
+	uint8_t FCCOBIX[3], FCCOBHI[3], FCCOBLO[3], fstat;
+	uint16_t longwords = 0;
+	int result;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	result = kinetis_ke_prepare_flash(bank);
+	if (result != ERROR_OK)
+		return result;
+
+	/* check if whole bank is blank */
+	FCCOBIX[0] = 0;
+	FCCOBHI[0] = FTMRX_CMD_ALLERASED;
+
+	result = kinetis_ke_ftmrx_command(bank, 1, FCCOBIX, FCCOBHI, NULL, &fstat);
+
+	if (result != ERROR_OK)
+		return result;
+
+	if (fstat & (FTMRX_FSTAT_MGSTAT0_MASK | FTMRX_FSTAT_MGSTAT1_MASK)) {
+		/* the whole bank is not erased, check sector-by-sector */
+		int i;
+
+		for (i = 0; i < bank->num_sectors; i++) {
+			FCCOBIX[0] = 0;
+			FCCOBHI[0] = FTMRX_CMD_SECTIONERASED;
+			FCCOBLO[0] = (bank->base + bank->sectors[i].offset) >> 16;
+
+			FCCOBIX[1] = 1;
+			FCCOBHI[1] = (bank->base + bank->sectors[i].offset) >> 8;
+			FCCOBLO[1] = (bank->base + bank->sectors[i].offset);
+
+			longwords = 128;
+
+			FCCOBIX[2] = 2;
+			FCCOBHI[2] = longwords >> 8;
+			FCCOBLO[2] = longwords;
+
+			result = kinetis_ke_ftmrx_command(bank, 3, FCCOBIX, FCCOBHI, FCCOBLO, &fstat);
+
+			if (result == ERROR_OK)	{
+				bank->sectors[i].is_erased = !(fstat & (FTMRX_FSTAT_MGSTAT0_MASK | FTMRX_FSTAT_MGSTAT1_MASK));
+			} else {
+				LOG_DEBUG("Ignoring errored PFlash sector blank-check");
+				bank->sectors[i].is_erased = -1;
+			}
+		}
+	} else {
+		/* the whole bank is erased, update all sectors */
+		int i;
+		for (i = 0; i < bank->num_sectors; i++)
+			bank->sectors[i].is_erased = 1;
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration kinetis_ke_security_command_handlers[] = {
+	{
+		.name = "check_security",
+		.mode = COMMAND_EXEC,
+		.help = "",
+		.usage = "",
+		.handler = kinetis_ke_check_flash_security_status,
+	},
+	{
+		.name = "mass_erase",
+		.mode = COMMAND_EXEC,
+		.help = "",
+		.usage = "",
+		.handler = kinetis_ke_mdm_mass_erase,
+	},
+	{
+		.name = "test_securing",
+		.mode = COMMAND_EXEC,
+		.help = "",
+		.usage = "",
+		.handler = kinetis_ke_securing_test,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration kinetis_ke_exec_command_handlers[] = {
+	{
+		.name = "mdm",
+		.mode = COMMAND_ANY,
+		.help = "",
+		.usage = "",
+		.chain = kinetis_ke_security_command_handlers,
+	},
+	{
+		.name = "disable_wdog",
+		.mode = COMMAND_EXEC,
+		.help = "Disable the watchdog timer",
+		.usage = "",
+		.handler = kinetis_ke_disable_wdog_handler,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration kinetis_ke_command_handler[] = {
+	{
+		.name = "kinetis_ke",
+		.mode = COMMAND_ANY,
+		.help = "Kinetis KE NAND flash controller commands",
+		.usage = "",
+		.chain = kinetis_ke_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver kinetis_ke_flash = {
+	.name = "kinetis_ke",
+	.commands = kinetis_ke_command_handler,
+	.flash_bank_command = kinetis_ke_flash_bank_command,
+	.erase = kinetis_ke_erase,
+	.protect = kinetis_ke_protect,
+	.write = kinetis_ke_write,
+	.read = default_flash_read,
+	.probe = kinetis_ke_probe,
+	.auto_probe = kinetis_ke_auto_probe,
+	.erase_check = kinetis_ke_blank_check,
+	.protect_check = kinetis_ke_protect_check,
+	.info = kinetis_ke_info,
+};
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index cc10a3bb..9da5da2c 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -261,6 +259,8 @@
 
 #define IAP_CODE_LEN 0x34
 
+#define LPC11xx_REG_SECTORS	24
+
 typedef enum {
 	lpc2000_v1,
 	lpc2000_v2,
@@ -556,14 +556,21 @@ static int lpc2000_build_sector_list(struct flash_bank *bank)
 			exit(-1);
 		}
 		lpc2000_info->cmd51_max_buffer = 512; /* smallest MCU in the series, LPC1110, has 1 kB of SRAM */
-		bank->num_sectors = bank->size / 4096;
+		unsigned int large_sectors = 0;
+		unsigned int normal_sectors = bank->size / 4096;
+
+		if (normal_sectors > LPC11xx_REG_SECTORS) {
+			large_sectors = (normal_sectors - LPC11xx_REG_SECTORS) / 8;
+			normal_sectors = LPC11xx_REG_SECTORS;
+		}
+
+		bank->num_sectors = normal_sectors + large_sectors;
 
 		bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
 
 		for (int i = 0; i < bank->num_sectors; i++) {
 			bank->sectors[i].offset = offset;
-			/* all sectors are 4kB-sized */
-			bank->sectors[i].size = 4 * 1024;
+			bank->sectors[i].size = (i < LPC11xx_REG_SECTORS ? 4 : 32) * 1024;
 			offset += bank->sectors[i].size;
 			bank->sectors[i].is_erased = -1;
 			bank->sectors[i].is_protected = 1;
@@ -681,7 +688,7 @@ static int lpc2000_iap_working_area_init(struct flash_bank *bank, struct working
 
 	int retval = target_write_memory(target, (*iap_working_area)->address, 4, 2, jump_gate);
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Write memory at address 0x%8.8" PRIx32 " failed (check work_area definition)",
+		LOG_ERROR("Write memory at address 0x%8.8" TARGET_PRIxADDR " failed (check work_area definition)",
 				(*iap_working_area)->address);
 		target_free_working_area(target, *iap_working_area);
 	}
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
index 89f79e32..a4d88de7 100644
--- a/src/flash/nor/lpc288x.c
+++ b/src/flash/nor/lpc288x.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /***************************************************************************
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 7c3e6758..515a3f7b 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -556,7 +554,7 @@ COMMAND_HANDLER(lpc2900_handle_read_custom_command)
 	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
 
 	/* Try and open the file */
-	struct fileio fileio;
+	struct fileio *fileio;
 	const char *filename = CMD_ARGV[1];
 	int ret = fileio_open(&fileio, filename, FILEIO_WRITE, FILEIO_BINARY);
 	if (ret != ERROR_OK) {
@@ -565,14 +563,14 @@ COMMAND_HANDLER(lpc2900_handle_read_custom_command)
 	}
 
 	size_t nwritten;
-	ret = fileio_write(&fileio, sizeof(customer), customer, &nwritten);
+	ret = fileio_write(fileio, sizeof(customer), customer, &nwritten);
 	if (ret != ERROR_OK) {
 		LOG_ERROR("Write operation to file %s failed", filename);
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		return ret;
 	}
 
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	return ERROR_OK;
 }
@@ -1160,7 +1158,6 @@ static int lpc2900_write(struct flash_bank *bank, const uint8_t *buffer,
 			break;
 		}
 	}
-	;
 
 	if (warea) {
 		struct reg_param reg_params[5];
diff --git a/src/flash/nor/lpcspifi.c b/src/flash/nor/lpcspifi.c
index 3b383ebd..943c151e 100644
--- a/src/flash/nor/lpcspifi.c
+++ b/src/flash/nor/lpcspifi.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -58,21 +56,6 @@ struct lpcspifi_flash_bank {
 	const struct flash_device *dev;
 };
 
-struct lpcspifi_target {
-	char *name;
-	uint32_t tap_idcode;
-	uint32_t spifi_base;
-	uint32_t ssp_base;
-	uint32_t io_base;
-	uint32_t ioconfig_base; /* base address for the port word pin registers */
-};
-
-static const struct lpcspifi_target target_devices[] = {
-	/* name,          tap_idcode, spifi_base, ssp_base,   io_base,    ioconfig_base */
-	{ "LPC43xx/18xx", 0x4ba00477, 0x14000000, 0x40083000, 0x400F4000, 0x40086000 },
-	{ NULL,           0,          0,          0,          0,          0 }
-};
-
 /* flash_bank lpcspifi <base> <size> <chip_width> <bus_width> <target>
  */
 FLASH_BANK_COMMAND_HANDLER(lpcspifi_flash_bank_command)
@@ -123,7 +106,7 @@ static int ssp_setcs(struct target *target, uint32_t io_base, unsigned int value
  * and the controller is idle. */
 static int poll_ssp_busy(struct target *target, uint32_t ssp_base, int timeout)
 {
-	long long endtime;
+	int64_t endtime;
 	uint32_t value;
 	int retval;
 
@@ -203,7 +186,7 @@ static int lpcspifi_set_hw_mode(struct flash_bank *bank)
 		return retval;
 	}
 
-	LOG_DEBUG("Writing algorithm to working area at 0x%08" PRIx32,
+	LOG_DEBUG("Writing algorithm to working area at 0x%08" TARGET_PRIxADDR,
 		spifi_init_algorithm->address);
 	/* Write algorithm to working area */
 	retval = target_write_buffer(target,
@@ -342,7 +325,7 @@ static int wait_till_ready(struct flash_bank *bank, int timeout)
 {
 	uint32_t status;
 	int retval;
-	long long endtime;
+	int64_t endtime;
 
 	endtime = timeval_ms() + timeout;
 	do {
@@ -698,7 +681,7 @@ static int lpcspifi_write(struct flash_bank *bank, const uint8_t *buffer,
 			" a working area > %zdB in order to write to SPIFI flash.",
 			sizeof(lpcspifi_flash_write_code));
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(lpcspifi_flash_write_code),
@@ -734,7 +717,7 @@ static int lpcspifi_write(struct flash_bank *bank, const uint8_t *buffer,
 	if (target_alloc_working_area(target, fifo_size, &fifo) != ERROR_OK) {
 		target_free_working_area(target, write_algorithm);
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
@@ -852,14 +835,9 @@ static int lpcspifi_read_flash_id(struct flash_bank *bank, uint32_t *id)
 
 static int lpcspifi_probe(struct flash_bank *bank)
 {
-	struct target *target = bank->target;
 	struct lpcspifi_flash_bank *lpcspifi_info = bank->driver_priv;
-	uint32_t ssp_base;
-	uint32_t io_base;
-	uint32_t ioconfig_base;
 	struct flash_sector *sectors;
 	uint32_t id = 0; /* silence uninitialized warning */
-	const struct lpcspifi_target *target_device;
 	int retval;
 
 	/* If we've already probed, we should be fine to skip this time. */
@@ -867,26 +845,11 @@ static int lpcspifi_probe(struct flash_bank *bank)
 		return ERROR_OK;
 	lpcspifi_info->probed = 0;
 
-	for (target_device = target_devices ; target_device->name ; ++target_device)
-		if (target_device->tap_idcode == target->tap->idcode)
-			break;
-	if (!target_device->name) {
-		LOG_ERROR("Device ID 0x%" PRIx32 " is not known as SPIFI capable",
-				target->tap->idcode);
-		return ERROR_FAIL;
-	}
-
-	ssp_base = target_device->ssp_base;
-	io_base = target_device->io_base;
-	ioconfig_base = target_device->ioconfig_base;
-	lpcspifi_info->ssp_base = ssp_base;
-	lpcspifi_info->io_base = io_base;
-	lpcspifi_info->ioconfig_base = ioconfig_base;
+	lpcspifi_info->ssp_base = 0x40083000;
+	lpcspifi_info->io_base = 0x400F4000;
+	lpcspifi_info->ioconfig_base = 0x40086000;
 	lpcspifi_info->bank_num = bank->bank_number;
 
-	LOG_DEBUG("Valid SPIFI on device %s at address 0x%" PRIx32,
-		target_device->name, bank->base);
-
 	/* read and decode flash ID; returns in SW mode */
 	retval = lpcspifi_read_flash_id(bank, &id);
 	if (retval != ERROR_OK)
diff --git a/src/flash/nor/mdr.c b/src/flash/nor/mdr.c
index 98e013aa..8ceb1bf4 100644
--- a/src/flash/nor/mdr.c
+++ b/src/flash/nor/mdr.c
@@ -22,9 +22,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -173,7 +171,8 @@ static int mdr_erase(struct flash_bank *bank, int first, int last)
 	if (retval != ERROR_OK)
 		goto reset_pg_and_lock;
 
-	if ((first == 0) && (last == (bank->num_sectors - 1))) {
+	if ((first == 0) && (last == (bank->num_sectors - 1)) &&
+		!mdr_info->mem_type) {
 		retval = mdr_mass_erase(bank);
 		goto reset_pg_and_lock;
 	}
@@ -255,7 +254,7 @@ static int mdr_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(mdr32fx_flash_write_code), mdr32fx_flash_write_code);
@@ -274,7 +273,7 @@ static int mdr_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			LOG_WARNING("no large enough working area available, can't do block memory writes");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-	};
+	}
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* flash base (in), status (out) */
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);	/* count (32bit) */
@@ -471,6 +470,107 @@ free_buffer:
 	if (new_buffer)
 		free(new_buffer);
 
+	/* read some bytes bytes to flush buffer in flash accelerator.
+	 * See errata for 1986VE1T and 1986VE3. Error 0007 */
+	if ((retval == ERROR_OK) && (!mdr_info->mem_type)) {
+		uint32_t tmp;
+		target_checksum_memory(bank->target, bank->base, 64, &tmp);
+	}
+
+	return retval;
+}
+
+static int mdr_read(struct flash_bank *bank, uint8_t *buffer,
+		    uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	struct mdr_flash_bank *mdr_info = bank->driver_priv;
+	int retval, retval2;
+
+	if (!mdr_info->mem_type)
+		return default_flash_read(bank, buffer, offset, count);
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x3) {
+		LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-byte alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	if (count & 0x3) {
+		LOG_ERROR("count 0x%" PRIx32 " breaks required 4-byte alignment", count);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	uint32_t flash_cmd, cur_per_clock;
+
+	retval = target_read_u32(target, MD_PER_CLOCK, &cur_per_clock);
+	if (retval != ERROR_OK)
+		goto err;
+
+	if (!(cur_per_clock & MD_PER_CLOCK_RST_CLK)) {
+		/* Something's very wrong if the RST_CLK module is not clocked */
+		LOG_ERROR("Target needs reset before flash operations");
+		retval = ERROR_FLASH_OPERATION_FAILED;
+		goto err;
+	}
+
+	retval = target_write_u32(target, MD_PER_CLOCK, cur_per_clock | MD_PER_CLOCK_EEPROM);
+	if (retval != ERROR_OK)
+		goto err;
+
+	retval = target_write_u32(target, FLASH_KEY, KEY);
+	if (retval != ERROR_OK)
+		goto err;
+
+	retval = target_read_u32(target, FLASH_CMD, &flash_cmd);
+	if (retval != ERROR_OK)
+		goto err_lock;
+
+	/* Switch on register access */
+	flash_cmd = (flash_cmd & FLASH_DELAY_MASK) | FLASH_CON | FLASH_IFREN;
+	retval = target_write_u32(target, FLASH_CMD, flash_cmd);
+	if (retval != ERROR_OK)
+		goto reset_pg_and_lock;
+
+	for (uint32_t i = 0; i < count; i += 4) {
+		retval = target_write_u32(target, FLASH_ADR, offset + i);
+		if (retval != ERROR_OK)
+			goto reset_pg_and_lock;
+
+		retval = target_write_u32(target, FLASH_CMD, flash_cmd |
+					  FLASH_XE | FLASH_YE | FLASH_SE);
+		if (retval != ERROR_OK)
+			goto reset_pg_and_lock;
+
+		uint32_t buf;
+		retval = target_read_u32(target, FLASH_DO, &buf);
+		if (retval != ERROR_OK)
+			goto reset_pg_and_lock;
+
+		buf_set_u32(buffer, i * 8, 32, buf);
+
+		retval = target_write_u32(target, FLASH_CMD, flash_cmd);
+		if (retval != ERROR_OK)
+			goto reset_pg_and_lock;
+
+	}
+
+reset_pg_and_lock:
+	flash_cmd &= FLASH_DELAY_MASK;
+	retval2 = target_write_u32(target, FLASH_CMD, flash_cmd);
+	if (retval == ERROR_OK)
+		retval = retval2;
+
+err_lock:
+	retval2 = target_write_u32(target, FLASH_KEY, 0);
+	if (retval == ERROR_OK)
+		retval = retval2;
+
+err:
 	return retval;
 }
 
@@ -527,7 +627,7 @@ struct flash_driver mdr_flash = {
 	.erase = mdr_erase,
 	.protect = mdr_protect,
 	.write = mdr_write,
-	.read = default_flash_read,
+	.read = mdr_read,
 	.probe = mdr_probe,
 	.auto_probe = mdr_auto_probe,
 	.erase_check = default_flash_blank_check,
diff --git a/src/flash/nor/mrvlqspi.c b/src/flash/nor/mrvlqspi.c
index 4d561ab9..6f9f66b0 100644
--- a/src/flash/nor/mrvlqspi.c
+++ b/src/flash/nor/mrvlqspi.c
@@ -12,10 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
- *                                                                         *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
  /*
@@ -680,7 +677,7 @@ static int mrvlqspi_flash_write(struct flash_bank *bank, const uint8_t *buffer,
 			" a working area > %zdB in order to write to SPIFI flash.",
 			sizeof(mrvlqspi_flash_write_code));
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(mrvlqspi_flash_write_code),
@@ -714,7 +711,7 @@ static int mrvlqspi_flash_write(struct flash_bank *bank, const uint8_t *buffer,
 	if (target_alloc_working_area(target, fifo_size, &fifo) != ERROR_OK) {
 		target_free_working_area(target, write_algorithm);
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
diff --git a/src/flash/nor/niietcm4.c b/src/flash/nor/niietcm4.c
index 78467c5a..4a849fd2 100644
--- a/src/flash/nor/niietcm4.c
+++ b/src/flash/nor/niietcm4.c
@@ -13,8 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.                                        *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -155,7 +154,7 @@ static int niietcm4_opstatus_check(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
 	int retval;
-	int timeout = 100;
+	int timeout = 5000;
 
 	uint32_t flash_status;
 	retval = target_read_u32(target, FCIS, &flash_status);
@@ -192,7 +191,7 @@ static int niietcm4_uopstatus_check(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
 	int retval;
-	int timeout = 100;
+	int timeout = 5000;
 
 	uint32_t uflash_status;
 	retval = target_read_u32(target, UFCIS, &uflash_status);
@@ -231,7 +230,8 @@ static int niietcm4_uopstatus_check(struct flash_bank *bank)
 static int niietcm4_dump_uflash_page(struct flash_bank *bank, uint32_t *dump, int page_num, int mem_type)
 {
 	struct target *target = bank->target;
-	int i, retval;
+	int i;
+	int retval = ERROR_OK;
 
 	uint32_t uflash_cmd;
 	if (mem_type == INFO_MEM_TYPE)
@@ -266,7 +266,8 @@ static int niietcm4_dump_uflash_page(struct flash_bank *bank, uint32_t *dump, in
 static int niietcm4_load_uflash_page(struct flash_bank *bank, uint32_t *dump, int page_num, int mem_type)
 {
 	struct target *target = bank->target;
-	int i, retval;
+	int i;
+	int retval = ERROR_OK;
 
 	uint32_t uflash_cmd;
 	if (mem_type == INFO_MEM_TYPE)
@@ -1048,7 +1049,7 @@ FLASH_BANK_COMMAND_HANDLER(niietcm4_flash_bank_command)
 {
 	struct niietcm4_flash_bank *niietcm4_info;
 
-	if (CMD_ARGC < 7)
+	if (CMD_ARGC < 6)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	niietcm4_info = malloc(sizeof(struct niietcm4_flash_bank));
@@ -1299,7 +1300,7 @@ static int niietcm4_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(niietcm4_flash_write_code), niietcm4_flash_write_code);
@@ -1319,7 +1320,7 @@ static int niietcm4_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			LOG_WARNING("no large enough working area available, can't do block memory writes");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-	};
+	}
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* write_cmd base (in), status (out) */
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);	/* count (128bit) */
@@ -1370,17 +1371,38 @@ static int niietcm4_write(struct flash_bank *bank, const uint8_t *buffer,
 {
 	struct target *target = bank->target;
 	struct niietcm4_flash_bank *niietcm4_info = bank->driver_priv;
+	uint8_t *new_buffer = NULL;
 
 	if (bank->target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (offset & 0x3) {
-		LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-byte alignment", offset);
+	if (offset & 0xF) {
+		LOG_ERROR("offset 0x%" PRIx32 " breaks required 4-word alignment", offset);
 		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
 	}
 
+	/* If there's an odd number of words, the data has to be padded. Duplicate
+	 * the buffer and use the normal code path with a single block write since
+	 * it's probably cheaper than to special case the last odd write using
+	 * discrete accesses. */
+
+	int rem = count % 16;
+	if (rem) {
+		new_buffer = malloc(count + 16 - rem);
+		if (new_buffer == NULL) {
+			LOG_ERROR("Odd number of words to write and no memory for padding buffer");
+			return ERROR_FAIL;
+		}
+		LOG_INFO("Odd number of words to write, padding with 0xFFFFFFFF");
+		buffer = memcpy(new_buffer, buffer, count);
+		while (rem < 16) {
+			new_buffer[count++] = 0xff;
+			rem++;
+		}
+	}
+
 	int retval;
 
 	/* try using block write */
@@ -1406,46 +1428,47 @@ static int niietcm4_write(struct flash_bank *bank, const uint8_t *buffer,
 			flash_addr = offset + i;
 			retval = target_write_u32(target, FMA, flash_addr);
 			if (retval != ERROR_OK)
-				return retval;
+				goto free_buffer;
 
-			/* if there's an odd number of bytes, the data has to be padded */
-			uint8_t padding[16] = { 0xff, 0xff, 0xff, 0xff,
-									0xff, 0xff, 0xff, 0xff,
-									0xff, 0xff, 0xff, 0xff,
-									0xff, 0xff, 0xff, 0xff};
-			memcpy(padding, buffer + i, MIN(16, count-i));
+			/* Prepare data (4 words) */
+			uint32_t value[4];
+			memcpy(&value, buffer + i*16, 4*sizeof(uint32_t));
 
 			/* place in reg 16 bytes of data */
-			flash_data = (padding[3]<<24) | (padding[2]<<16) | (padding[1]<<8) | padding[0];
+			flash_data = value[0];
 			retval = target_write_u32(target, FMD1, flash_data);
 			if (retval != ERROR_OK)
-				return retval;
-			flash_data = (padding[7]<<24) | (padding[6]<<16) | (padding[5]<<8) | padding[4];
+				goto free_buffer;
+			flash_data = value[1];
 			retval = target_write_u32(target, FMD2, flash_data);
 			if (retval != ERROR_OK)
-				return retval;
-			flash_data = (padding[11]<<24) | (padding[10]<<16) | (padding[9]<<8) | padding[8];
+				goto free_buffer;
+			flash_data = value[2];
 			retval = target_write_u32(target, FMD3, flash_data);
 			if (retval != ERROR_OK)
-				return retval;
-			flash_data = (padding[15]<<24) | (padding[14]<<16) | (padding[13]<<8) | padding[12];
+				goto free_buffer;
+			flash_data = value[3];
 			retval = target_write_u32(target, FMD4, flash_data);
 			if (retval != ERROR_OK)
-				return retval;
+				goto free_buffer;
 
 			/* write start */
 			retval = target_write_u32(target, FMC, flash_cmd);
 			if (retval != ERROR_OK)
-				return retval;
+				goto free_buffer;
 
 			/* status check */
 			retval = niietcm4_opstatus_check(bank);
 			if (retval != ERROR_OK)
-				return retval;
+				goto free_buffer;
 		}
 
 	}
 
+free_buffer:
+	if (new_buffer)
+		free(new_buffer);
+
 	return retval;
 }
 
@@ -1697,7 +1720,7 @@ static int niietcm4_auto_probe(struct flash_bank *bank)
 static int get_niietcm4_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	struct niietcm4_flash_bank *niietcm4_info = bank->driver_priv;
-	LOG_INFO("\nNIIET Cortex M4F %s\n%s", niietcm4_info->chip_name, niietcm4_info->chip_brief);
+	LOG_INFO("\nNIIET Cortex-M4F %s\n%s", niietcm4_info->chip_name, niietcm4_info->chip_brief);
 	snprintf(buf, buf_size, " ");
 
 	return ERROR_OK;
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index 72f11e55..851c0ae8 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -540,7 +538,6 @@ void cfi_fixup_non_cfi(struct flash_bank *bank)
 
 		pri_ext->SiliconRevision = 0x0;
 		pri_ext->EraseSuspend = 0x0;
-		pri_ext->EraseSuspend = 0x0;
 		pri_ext->BlkProt = 0x0;
 		pri_ext->TmpBlkUnprotect = 0x0;
 		pri_ext->BlkProtUnprot = 0x0;
diff --git a/src/flash/nor/non_cfi.h b/src/flash/nor/non_cfi.h
index e23ab7ed..c411cb88 100644
--- a/src/flash/nor/non_cfi.h
+++ b/src/flash/nor/non_cfi.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef NON_CFI_H
-#define NON_CFI_H
+#ifndef OPENOCD_FLASH_NOR_NON_CFI_H
+#define OPENOCD_FLASH_NOR_NON_CFI_H
 
 struct non_cfi {
 	uint16_t mfr;
@@ -35,4 +33,4 @@ struct non_cfi {
 
 void cfi_fixup_non_cfi(struct flash_bank *bank);
 
-#endif /* NON_CFI_H */
+#endif /* OPENOCD_FLASH_NOR_NON_CFI_H */
diff --git a/src/flash/nor/nrf51.c b/src/flash/nor/nrf5.c
similarity index 57%
rename from src/flash/nor/nrf51.c
rename to src/flash/nor/nrf5.c
index d8706c84..11e57291 100644
--- a/src/flash/nor/nrf51.c
+++ b/src/flash/nor/nrf5.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -30,104 +28,113 @@
 #include <helper/types.h>
 
 enum {
-	NRF51_FLASH_BASE = 0x00000000,
+	NRF5_FLASH_BASE = 0x00000000,
 };
 
-enum nrf51_ficr_registers {
-	NRF51_FICR_BASE = 0x10000000, /* Factory Information Configuration Registers */
-
-#define NRF51_FICR_REG(offset) (NRF51_FICR_BASE + offset)
-
-	NRF51_FICR_CODEPAGESIZE		= NRF51_FICR_REG(0x010),
-	NRF51_FICR_CODESIZE		= NRF51_FICR_REG(0x014),
-	NRF51_FICR_CLENR0		= NRF51_FICR_REG(0x028),
-	NRF51_FICR_PPFC			= NRF51_FICR_REG(0x02C),
-	NRF51_FICR_NUMRAMBLOCK		= NRF51_FICR_REG(0x034),
-	NRF51_FICR_SIZERAMBLOCK0	= NRF51_FICR_REG(0x038),
-	NRF51_FICR_SIZERAMBLOCK1	= NRF51_FICR_REG(0x03C),
-	NRF51_FICR_SIZERAMBLOCK2	= NRF51_FICR_REG(0x040),
-	NRF51_FICR_SIZERAMBLOCK3	= NRF51_FICR_REG(0x044),
-	NRF51_FICR_CONFIGID		= NRF51_FICR_REG(0x05C),
-	NRF51_FICR_DEVICEID0		= NRF51_FICR_REG(0x060),
-	NRF51_FICR_DEVICEID1		= NRF51_FICR_REG(0x064),
-	NRF51_FICR_ER0			= NRF51_FICR_REG(0x080),
-	NRF51_FICR_ER1			= NRF51_FICR_REG(0x084),
-	NRF51_FICR_ER2			= NRF51_FICR_REG(0x088),
-	NRF51_FICR_ER3			= NRF51_FICR_REG(0x08C),
-	NRF51_FICR_IR0			= NRF51_FICR_REG(0x090),
-	NRF51_FICR_IR1			= NRF51_FICR_REG(0x094),
-	NRF51_FICR_IR2			= NRF51_FICR_REG(0x098),
-	NRF51_FICR_IR3			= NRF51_FICR_REG(0x09C),
-	NRF51_FICR_DEVICEADDRTYPE	= NRF51_FICR_REG(0x0A0),
-	NRF51_FICR_DEVICEADDR0		= NRF51_FICR_REG(0x0A4),
-	NRF51_FICR_DEVICEADDR1		= NRF51_FICR_REG(0x0A8),
-	NRF51_FICR_OVERRIDEN		= NRF51_FICR_REG(0x0AC),
-	NRF51_FICR_NRF_1MBIT0		= NRF51_FICR_REG(0x0B0),
-	NRF51_FICR_NRF_1MBIT1		= NRF51_FICR_REG(0x0B4),
-	NRF51_FICR_NRF_1MBIT2		= NRF51_FICR_REG(0x0B8),
-	NRF51_FICR_NRF_1MBIT3		= NRF51_FICR_REG(0x0BC),
-	NRF51_FICR_NRF_1MBIT4		= NRF51_FICR_REG(0x0C0),
-	NRF51_FICR_BLE_1MBIT0		= NRF51_FICR_REG(0x0EC),
-	NRF51_FICR_BLE_1MBIT1		= NRF51_FICR_REG(0x0F0),
-	NRF51_FICR_BLE_1MBIT2		= NRF51_FICR_REG(0x0F4),
-	NRF51_FICR_BLE_1MBIT3		= NRF51_FICR_REG(0x0F8),
-	NRF51_FICR_BLE_1MBIT4		= NRF51_FICR_REG(0x0FC),
+enum nrf5_ficr_registers {
+	NRF5_FICR_BASE = 0x10000000, /* Factory Information Configuration Registers */
+
+#define NRF5_FICR_REG(offset) (NRF5_FICR_BASE + offset)
+
+	NRF5_FICR_CODEPAGESIZE		= NRF5_FICR_REG(0x010),
+	NRF5_FICR_CODESIZE		= NRF5_FICR_REG(0x014),
+	NRF5_FICR_CLENR0		= NRF5_FICR_REG(0x028),
+	NRF5_FICR_PPFC			= NRF5_FICR_REG(0x02C),
+	NRF5_FICR_NUMRAMBLOCK		= NRF5_FICR_REG(0x034),
+	NRF5_FICR_SIZERAMBLOCK0	= NRF5_FICR_REG(0x038),
+	NRF5_FICR_SIZERAMBLOCK1	= NRF5_FICR_REG(0x03C),
+	NRF5_FICR_SIZERAMBLOCK2	= NRF5_FICR_REG(0x040),
+	NRF5_FICR_SIZERAMBLOCK3	= NRF5_FICR_REG(0x044),
+	NRF5_FICR_CONFIGID		= NRF5_FICR_REG(0x05C),
+	NRF5_FICR_DEVICEID0		= NRF5_FICR_REG(0x060),
+	NRF5_FICR_DEVICEID1		= NRF5_FICR_REG(0x064),
+	NRF5_FICR_ER0			= NRF5_FICR_REG(0x080),
+	NRF5_FICR_ER1			= NRF5_FICR_REG(0x084),
+	NRF5_FICR_ER2			= NRF5_FICR_REG(0x088),
+	NRF5_FICR_ER3			= NRF5_FICR_REG(0x08C),
+	NRF5_FICR_IR0			= NRF5_FICR_REG(0x090),
+	NRF5_FICR_IR1			= NRF5_FICR_REG(0x094),
+	NRF5_FICR_IR2			= NRF5_FICR_REG(0x098),
+	NRF5_FICR_IR3			= NRF5_FICR_REG(0x09C),
+	NRF5_FICR_DEVICEADDRTYPE	= NRF5_FICR_REG(0x0A0),
+	NRF5_FICR_DEVICEADDR0		= NRF5_FICR_REG(0x0A4),
+	NRF5_FICR_DEVICEADDR1		= NRF5_FICR_REG(0x0A8),
+	NRF5_FICR_OVERRIDEN		= NRF5_FICR_REG(0x0AC),
+	NRF5_FICR_NRF_1MBIT0		= NRF5_FICR_REG(0x0B0),
+	NRF5_FICR_NRF_1MBIT1		= NRF5_FICR_REG(0x0B4),
+	NRF5_FICR_NRF_1MBIT2		= NRF5_FICR_REG(0x0B8),
+	NRF5_FICR_NRF_1MBIT3		= NRF5_FICR_REG(0x0BC),
+	NRF5_FICR_NRF_1MBIT4		= NRF5_FICR_REG(0x0C0),
+	NRF5_FICR_BLE_1MBIT0		= NRF5_FICR_REG(0x0EC),
+	NRF5_FICR_BLE_1MBIT1		= NRF5_FICR_REG(0x0F0),
+	NRF5_FICR_BLE_1MBIT2		= NRF5_FICR_REG(0x0F4),
+	NRF5_FICR_BLE_1MBIT3		= NRF5_FICR_REG(0x0F8),
+	NRF5_FICR_BLE_1MBIT4		= NRF5_FICR_REG(0x0FC),
 };
 
-enum nrf51_uicr_registers {
-	NRF51_UICR_BASE = 0x10001000, /* User Information
+enum nrf5_uicr_registers {
+	NRF5_UICR_BASE = 0x10001000, /* User Information
 				       * Configuration Regsters */
 
-	NRF51_UICR_SIZE = 0x100,
+	NRF5_UICR_SIZE = 0x100,
 
-#define NRF51_UICR_REG(offset) (NRF51_UICR_BASE + offset)
+#define NRF5_UICR_REG(offset) (NRF5_UICR_BASE + offset)
 
-	NRF51_UICR_CLENR0	= NRF51_UICR_REG(0x000),
-	NRF51_UICR_RBPCONF	= NRF51_UICR_REG(0x004),
-	NRF51_UICR_XTALFREQ	= NRF51_UICR_REG(0x008),
-	NRF51_UICR_FWID		= NRF51_UICR_REG(0x010),
+	NRF5_UICR_CLENR0	= NRF5_UICR_REG(0x000),
+	NRF5_UICR_RBPCONF	= NRF5_UICR_REG(0x004),
+	NRF5_UICR_XTALFREQ	= NRF5_UICR_REG(0x008),
+	NRF5_UICR_FWID		= NRF5_UICR_REG(0x010),
 };
 
-enum nrf51_nvmc_registers {
-	NRF51_NVMC_BASE = 0x4001E000, /* Non-Volatile Memory
+enum nrf5_nvmc_registers {
+	NRF5_NVMC_BASE = 0x4001E000, /* Non-Volatile Memory
 				       * Controller Regsters */
 
-#define NRF51_NVMC_REG(offset) (NRF51_NVMC_BASE + offset)
+#define NRF5_NVMC_REG(offset) (NRF5_NVMC_BASE + offset)
 
-	NRF51_NVMC_READY	= NRF51_NVMC_REG(0x400),
-	NRF51_NVMC_CONFIG	= NRF51_NVMC_REG(0x504),
-	NRF51_NVMC_ERASEPAGE	= NRF51_NVMC_REG(0x508),
-	NRF51_NVMC_ERASEALL	= NRF51_NVMC_REG(0x50C),
-	NRF51_NVMC_ERASEUICR	= NRF51_NVMC_REG(0x514),
+	NRF5_NVMC_READY	= NRF5_NVMC_REG(0x400),
+	NRF5_NVMC_CONFIG	= NRF5_NVMC_REG(0x504),
+	NRF5_NVMC_ERASEPAGE	= NRF5_NVMC_REG(0x508),
+	NRF5_NVMC_ERASEALL	= NRF5_NVMC_REG(0x50C),
+	NRF5_NVMC_ERASEUICR	= NRF5_NVMC_REG(0x514),
 };
 
-enum nrf51_nvmc_config_bits {
-	NRF51_NVMC_CONFIG_REN = 0x00,
-	NRF51_NVMC_CONFIG_WEN = 0x01,
-	NRF51_NVMC_CONFIG_EEN = 0x02,
+enum nrf5_nvmc_config_bits {
+	NRF5_NVMC_CONFIG_REN = 0x00,
+	NRF5_NVMC_CONFIG_WEN = 0x01,
+	NRF5_NVMC_CONFIG_EEN = 0x02,
 
 };
 
-struct nrf51_info {
+struct nrf5_info {
 	uint32_t code_page_size;
-	uint32_t code_memory_size;
 
 	struct {
 		bool probed;
 		int (*write) (struct flash_bank *bank,
-			      struct nrf51_info *chip,
+			      struct nrf5_info *chip,
 			      const uint8_t *buffer, uint32_t offset, uint32_t count);
 	} bank[2];
 	struct target *target;
 };
 
-struct nrf51_device_spec {
+struct nrf5_device_spec {
 	uint16_t hwid;
+	const char *part;
 	const char *variant;
 	const char *build_code;
 	unsigned int flash_size_kb;
 };
 
+#define NRF5_DEVICE_DEF(id, pt, var, bcode, fsize) \
+{                                                   \
+.hwid          = (id),                              \
+.part          = pt,                                \
+.variant       = var,                               \
+.build_code    = bcode,                             \
+.flash_size_kb = (fsize),                           \
+}
+
 /* The known devices table below is derived from the "nRF51 Series
  * Compatibility Matrix" document, which can be found by searching for
  * ATTN-51 on the Nordic Semi website:
@@ -140,239 +147,74 @@ struct nrf51_device_spec {
  * shown as Gx0, Bx0, etc. In these cases the HWID in the matrix is
  * for x==0, x!=0 means different (unspecified) HWIDs.
  */
-static const struct nrf51_device_spec nrf51_known_devices_table[] = {
+static const struct nrf5_device_spec nrf5_known_devices_table[] = {
 	/* nRF51822 Devices (IC rev 1). */
-	{
-		.hwid		= 0x001D,
-		.variant	= "QFAA",
-		.build_code	= "CA/C0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0026,
-		.variant	= "QFAB",
-		.build_code	= "AA",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0027,
-		.variant	= "QFAB",
-		.build_code	= "A0",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0020,
-		.variant	= "CEAA",
-		.build_code	= "BA",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x002F,
-		.variant	= "CEAA",
-		.build_code	= "B0",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x001D, "51822", "QFAA", "CA/C0", 256),
+	NRF5_DEVICE_DEF(0x0026, "51822", "QFAB", "AA",    128),
+	NRF5_DEVICE_DEF(0x0027, "51822", "QFAB", "A0",    128),
+	NRF5_DEVICE_DEF(0x0020, "51822", "CEAA", "BA",    256),
+	NRF5_DEVICE_DEF(0x002F, "51822", "CEAA", "B0",    256),
 
 	/* nRF51822 Devices (IC rev 2). */
-	{
-		.hwid		= 0x002A,
-		.variant	= "QFAA",
-		.build_code	= "FA0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0044,
-		.variant	= "QFAA",
-		.build_code	= "GC0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x003C,
-		.variant	= "QFAA",
-		.build_code	= "G0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x004C,
-		.variant	= "QFAB",
-		.build_code	= "B0",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0040,
-		.variant	= "CEAA",
-		.build_code	= "CA0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0047,
-		.variant	= "CEAA",
-		.build_code	= "DA0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x004D,
-		.variant	= "CEAA",
-		.build_code	= "D00",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x002A, "51822", "QFAA", "FA0",   256),
+	NRF5_DEVICE_DEF(0x0044, "51822", "QFAA", "GC0",   256),
+	NRF5_DEVICE_DEF(0x003C, "51822", "QFAA", "G0",    256),
+	NRF5_DEVICE_DEF(0x0057, "51822", "QFAA", "G2",    256),
+	NRF5_DEVICE_DEF(0x0058, "51822", "QFAA", "G3",    256),
+	NRF5_DEVICE_DEF(0x004C, "51822", "QFAB", "B0",    128),
+	NRF5_DEVICE_DEF(0x0040, "51822", "CEAA", "CA0",   256),
+	NRF5_DEVICE_DEF(0x0047, "51822", "CEAA", "DA0",   256),
+	NRF5_DEVICE_DEF(0x004D, "51822", "CEAA", "D00",   256),
 
 	/* nRF51822 Devices (IC rev 3). */
-	{
-		.hwid		= 0x0072,
-		.variant	= "QFAA",
-		.build_code	= "H0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x007B,
-		.variant	= "QFAB",
-		.build_code	= "C0",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0083,
-		.variant	= "QFAC",
-		.build_code	= "A0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x007D,
-		.variant	= "CDAB",
-		.build_code	= "A0",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0079,
-		.variant	= "CEAA",
-		.build_code	= "E0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0087,
-		.variant	= "CFAC",
-		.build_code	= "A0",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x0072, "51822", "QFAA", "H0",    256),
+	NRF5_DEVICE_DEF(0x007B, "51822", "QFAB", "C0",    128),
+	NRF5_DEVICE_DEF(0x0083, "51822", "QFAC", "A0",    256),
+	NRF5_DEVICE_DEF(0x0084, "51822", "QFAC", "A1",    256),
+	NRF5_DEVICE_DEF(0x007D, "51822", "CDAB", "A0",    128),
+	NRF5_DEVICE_DEF(0x0079, "51822", "CEAA", "E0",    256),
+	NRF5_DEVICE_DEF(0x0087, "51822", "CFAC", "A0",    256),
 
 	/* nRF51422 Devices (IC rev 1). */
-	{
-		.hwid		= 0x001E,
-		.variant	= "QFAA",
-		.build_code	= "CA",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0024,
-		.variant	= "QFAA",
-		.build_code	= "C0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0031,
-		.variant	= "CEAA",
-		.build_code	= "A0A",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x001E, "51422", "QFAA", "CA",    256),
+	NRF5_DEVICE_DEF(0x0024, "51422", "QFAA", "C0",    256),
+	NRF5_DEVICE_DEF(0x0031, "51422", "CEAA", "A0A",   256),
 
 	/* nRF51422 Devices (IC rev 2). */
-	{
-		.hwid		= 0x002D,
-		.variant	= "QFAA",
-		.build_code	= "DAA",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x002E,
-		.variant	= "QFAA",
-		.build_code	= "E0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0061,
-		.variant	= "QFAB",
-		.build_code	= "A00",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0050,
-		.variant	= "CEAA",
-		.build_code	= "B0",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x002D, "51422", "QFAA", "DAA",   256),
+	NRF5_DEVICE_DEF(0x002E, "51422", "QFAA", "E0",    256),
+	NRF5_DEVICE_DEF(0x0061, "51422", "QFAB", "A00",   128),
+	NRF5_DEVICE_DEF(0x0050, "51422", "CEAA", "B0",    256),
 
 	/* nRF51422 Devices (IC rev 3). */
-	{
-		.hwid		= 0x0073,
-		.variant	= "QFAA",
-		.build_code	= "F0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x007C,
-		.variant	= "QFAB",
-		.build_code	= "B0",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x0084,
-		.variant	= "QFAC",
-		.build_code	= "A1",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0085,
-		.variant	= "QFAC",
-		.build_code	= "A0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0086,
-		.variant	= "QFAC",
-		.build_code	= "A1",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x007E,
-		.variant	= "CDAB",
-		.build_code	= "A0",
-		.flash_size_kb	= 128,
-	},
-	{
-		.hwid		= 0x007A,
-		.variant	= "CEAA",
-		.build_code	= "C0",
-		.flash_size_kb	= 256,
-	},
-	{
-		.hwid		= 0x0088,
-		.variant	= "CFAC",
-		.build_code	= "A0",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x0073, "51422", "QFAA", "F0",    256),
+	NRF5_DEVICE_DEF(0x007C, "51422", "QFAB", "B0",    128),
+	NRF5_DEVICE_DEF(0x0085, "51422", "QFAC", "A0",    256),
+	NRF5_DEVICE_DEF(0x0086, "51422", "QFAC", "A1",    256),
+	NRF5_DEVICE_DEF(0x007E, "51422", "CDAB", "A0",    128),
+	NRF5_DEVICE_DEF(0x007A, "51422", "CEAA", "C0",    256),
+	NRF5_DEVICE_DEF(0x0088, "51422", "CFAC", "A0",    256),
+
+	/* nRF52832 Devices */
+	NRF5_DEVICE_DEF(0x00C7, "52832", "QFAA", "B0",    512),
 
 	/* Some early nRF51-DK (PCA10028) & nRF51-Dongle (PCA10031) boards
 	   with built-in jlink seem to use engineering samples not listed
 	   in the nRF51 Series Compatibility Matrix V1.0. */
-	{
-		.hwid		= 0x0071,
-		.variant	= "QFAC",
-		.build_code	= "AB",
-		.flash_size_kb	= 256,
-	},
+	NRF5_DEVICE_DEF(0x0071, "51822", "QFAC", "AB",    256),
 };
 
-static int nrf51_bank_is_probed(struct flash_bank *bank)
+static int nrf5_bank_is_probed(struct flash_bank *bank)
 {
-	struct nrf51_info *chip = bank->driver_priv;
+	struct nrf5_info *chip = bank->driver_priv;
 
 	assert(chip != NULL);
 
 	return chip->bank[bank->bank_number].probed;
 }
-static int nrf51_probe(struct flash_bank *bank);
+static int nrf5_probe(struct flash_bank *bank);
 
-static int nrf51_get_probed_chip_if_halted(struct flash_bank *bank, struct nrf51_info **chip)
+static int nrf5_get_probed_chip_if_halted(struct flash_bank *bank, struct nrf5_info **chip)
 {
 	if (bank->target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
@@ -381,23 +223,23 @@ static int nrf51_get_probed_chip_if_halted(struct flash_bank *bank, struct nrf51
 
 	*chip = bank->driver_priv;
 
-	int probed = nrf51_bank_is_probed(bank);
+	int probed = nrf5_bank_is_probed(bank);
 	if (probed < 0)
 		return probed;
 	else if (!probed)
-		return nrf51_probe(bank);
+		return nrf5_probe(bank);
 	else
 		return ERROR_OK;
 }
 
-static int nrf51_wait_for_nvmc(struct nrf51_info *chip)
+static int nrf5_wait_for_nvmc(struct nrf5_info *chip)
 {
 	uint32_t ready;
 	int res;
 	int timeout = 100;
 
 	do {
-		res = target_read_u32(chip->target, NRF51_NVMC_READY, &ready);
+		res = target_read_u32(chip->target, NRF5_NVMC_READY, &ready);
 		if (res != ERROR_OK) {
 			LOG_ERROR("Couldn't read NVMC_READY register");
 			return res;
@@ -413,12 +255,12 @@ static int nrf51_wait_for_nvmc(struct nrf51_info *chip)
 	return ERROR_FLASH_BUSY;
 }
 
-static int nrf51_nvmc_erase_enable(struct nrf51_info *chip)
+static int nrf5_nvmc_erase_enable(struct nrf5_info *chip)
 {
 	int res;
 	res = target_write_u32(chip->target,
-			       NRF51_NVMC_CONFIG,
-			       NRF51_NVMC_CONFIG_EEN);
+			       NRF5_NVMC_CONFIG,
+			       NRF5_NVMC_CONFIG_EEN);
 
 	if (res != ERROR_OK) {
 		LOG_ERROR("Failed to enable erase operation");
@@ -429,19 +271,19 @@ static int nrf51_nvmc_erase_enable(struct nrf51_info *chip)
 	  According to NVMC examples in Nordic SDK busy status must be
 	  checked after writing to NVMC_CONFIG
 	 */
-	res = nrf51_wait_for_nvmc(chip);
+	res = nrf5_wait_for_nvmc(chip);
 	if (res != ERROR_OK)
 		LOG_ERROR("Erase enable did not complete");
 
 	return res;
 }
 
-static int nrf51_nvmc_write_enable(struct nrf51_info *chip)
+static int nrf5_nvmc_write_enable(struct nrf5_info *chip)
 {
 	int res;
 	res = target_write_u32(chip->target,
-			       NRF51_NVMC_CONFIG,
-			       NRF51_NVMC_CONFIG_WEN);
+			       NRF5_NVMC_CONFIG,
+			       NRF5_NVMC_CONFIG_WEN);
 
 	if (res != ERROR_OK) {
 		LOG_ERROR("Failed to enable write operation");
@@ -452,19 +294,19 @@ static int nrf51_nvmc_write_enable(struct nrf51_info *chip)
 	  According to NVMC examples in Nordic SDK busy status must be
 	  checked after writing to NVMC_CONFIG
 	 */
-	res = nrf51_wait_for_nvmc(chip);
+	res = nrf5_wait_for_nvmc(chip);
 	if (res != ERROR_OK)
 		LOG_ERROR("Write enable did not complete");
 
 	return res;
 }
 
-static int nrf51_nvmc_read_only(struct nrf51_info *chip)
+static int nrf5_nvmc_read_only(struct nrf5_info *chip)
 {
 	int res;
 	res = target_write_u32(chip->target,
-			       NRF51_NVMC_CONFIG,
-			       NRF51_NVMC_CONFIG_REN);
+			       NRF5_NVMC_CONFIG,
+			       NRF5_NVMC_CONFIG_REN);
 
 	if (res != ERROR_OK) {
 		LOG_ERROR("Failed to enable read-only operation");
@@ -474,19 +316,19 @@ static int nrf51_nvmc_read_only(struct nrf51_info *chip)
 	  According to NVMC examples in Nordic SDK busy status must be
 	  checked after writing to NVMC_CONFIG
 	 */
-	res = nrf51_wait_for_nvmc(chip);
+	res = nrf5_wait_for_nvmc(chip);
 	if (res != ERROR_OK)
 		LOG_ERROR("Read only enable did not complete");
 
 	return res;
 }
 
-static int nrf51_nvmc_generic_erase(struct nrf51_info *chip,
+static int nrf5_nvmc_generic_erase(struct nrf5_info *chip,
 			       uint32_t erase_register, uint32_t erase_value)
 {
 	int res;
 
-	res = nrf51_nvmc_erase_enable(chip);
+	res = nrf5_nvmc_erase_enable(chip);
 	if (res != ERROR_OK)
 		goto error;
 
@@ -496,34 +338,34 @@ static int nrf51_nvmc_generic_erase(struct nrf51_info *chip,
 	if (res != ERROR_OK)
 		goto set_read_only;
 
-	res = nrf51_wait_for_nvmc(chip);
+	res = nrf5_wait_for_nvmc(chip);
 	if (res != ERROR_OK)
 		goto set_read_only;
 
-	return nrf51_nvmc_read_only(chip);
+	return nrf5_nvmc_read_only(chip);
 
 set_read_only:
-	nrf51_nvmc_read_only(chip);
+	nrf5_nvmc_read_only(chip);
 error:
 	LOG_ERROR("Failed to erase reg: 0x%08"PRIx32" val: 0x%08"PRIx32,
 		  erase_register, erase_value);
 	return ERROR_FAIL;
 }
 
-static int nrf51_protect_check(struct flash_bank *bank)
+static int nrf5_protect_check(struct flash_bank *bank)
 {
 	int res;
 	uint32_t clenr0;
 
 	/* UICR cannot be write protected so just return early */
-	if (bank->base == NRF51_UICR_BASE)
+	if (bank->base == NRF5_UICR_BASE)
 		return ERROR_OK;
 
-	struct nrf51_info *chip = bank->driver_priv;
+	struct nrf5_info *chip = bank->driver_priv;
 
 	assert(chip != NULL);
 
-	res = target_read_u32(chip->target, NRF51_FICR_CLENR0,
+	res = target_read_u32(chip->target, NRF5_FICR_CLENR0,
 			      &clenr0);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Couldn't read code region 0 size[FICR]");
@@ -531,7 +373,7 @@ static int nrf51_protect_check(struct flash_bank *bank)
 	}
 
 	if (clenr0 == 0xFFFFFFFF) {
-		res = target_read_u32(chip->target, NRF51_UICR_CLENR0,
+		res = target_read_u32(chip->target, NRF5_UICR_CLENR0,
 				      &clenr0);
 		if (res != ERROR_OK) {
 			LOG_ERROR("Couldn't read code region 0 size[UICR]");
@@ -546,17 +388,17 @@ static int nrf51_protect_check(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-static int nrf51_protect(struct flash_bank *bank, int set, int first, int last)
+static int nrf5_protect(struct flash_bank *bank, int set, int first, int last)
 {
 	int res;
 	uint32_t clenr0, ppfc;
-	struct nrf51_info *chip;
+	struct nrf5_info *chip;
 
 	/* UICR cannot be write protected so just bail out early */
-	if (bank->base == NRF51_UICR_BASE)
+	if (bank->base == NRF5_UICR_BASE)
 		return ERROR_FAIL;
 
-	res = nrf51_get_probed_chip_if_halted(bank, &chip);
+	res = nrf5_get_probed_chip_if_halted(bank, &chip);
 	if (res != ERROR_OK)
 		return res;
 
@@ -565,7 +407,7 @@ static int nrf51_protect(struct flash_bank *bank, int set, int first, int last)
 		return ERROR_FAIL;
 	}
 
-	res = target_read_u32(chip->target, NRF51_FICR_PPFC,
+	res = target_read_u32(chip->target, NRF5_FICR_PPFC,
 			      &ppfc);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Couldn't read PPFC register");
@@ -575,9 +417,9 @@ static int nrf51_protect(struct flash_bank *bank, int set, int first, int last)
 	if ((ppfc & 0xFF) == 0x00) {
 		LOG_ERROR("Code region 0 size was pre-programmed at the factory, can't change flash protection settings");
 		return ERROR_FAIL;
-	};
+	}
 
-	res = target_read_u32(chip->target, NRF51_UICR_CLENR0,
+	res = target_read_u32(chip->target, NRF5_UICR_CLENR0,
 			      &clenr0);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Couldn't read code region 0 size[UICR]");
@@ -585,7 +427,7 @@ static int nrf51_protect(struct flash_bank *bank, int set, int first, int last)
 	}
 
 	if (clenr0 == 0xFFFFFFFF) {
-		res = target_write_u32(chip->target, NRF51_UICR_CLENR0,
+		res = target_write_u32(chip->target, NRF5_UICR_CLENR0,
 				       clenr0);
 		if (res != ERROR_OK) {
 			LOG_ERROR("Couldn't write code region 0 size[UICR]");
@@ -596,18 +438,18 @@ static int nrf51_protect(struct flash_bank *bank, int set, int first, int last)
 		LOG_ERROR("You need to perform chip erase before changing the protection settings");
 	}
 
-	nrf51_protect_check(bank);
+	nrf5_protect_check(bank);
 
 	return ERROR_OK;
 }
 
-static int nrf51_probe(struct flash_bank *bank)
+static int nrf5_probe(struct flash_bank *bank)
 {
 	uint32_t hwid;
 	int res;
-	struct nrf51_info *chip = bank->driver_priv;
+	struct nrf5_info *chip = bank->driver_priv;
 
-	res = target_read_u32(chip->target, NRF51_FICR_CONFIGID, &hwid);
+	res = target_read_u32(chip->target, NRF5_FICR_CONFIGID, &hwid);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Couldn't read CONFIGID register");
 		return res;
@@ -616,50 +458,53 @@ static int nrf51_probe(struct flash_bank *bank)
 	hwid &= 0xFFFF;	/* HWID is stored in the lower two
 			 * bytes of the CONFIGID register */
 
-	const struct nrf51_device_spec *spec = NULL;
-	for (size_t i = 0; i < ARRAY_SIZE(nrf51_known_devices_table); i++)
-		if (hwid == nrf51_known_devices_table[i].hwid) {
-			spec = &nrf51_known_devices_table[i];
+	const struct nrf5_device_spec *spec = NULL;
+	for (size_t i = 0; i < ARRAY_SIZE(nrf5_known_devices_table); i++) {
+		if (hwid == nrf5_known_devices_table[i].hwid) {
+			spec = &nrf5_known_devices_table[i];
 			break;
 		}
+	}
 
 	if (!chip->bank[0].probed && !chip->bank[1].probed) {
 		if (spec)
-			LOG_INFO("nRF51822-%s(build code: %s) %ukB Flash",
-				 spec->variant, spec->build_code, spec->flash_size_kb);
+			LOG_INFO("nRF%s-%s(build code: %s) %ukB Flash",
+				 spec->part, spec->variant, spec->build_code,
+				 spec->flash_size_kb);
 		else
 			LOG_WARNING("Unknown device (HWID 0x%08" PRIx32 ")", hwid);
 	}
 
-
-	if (bank->base == NRF51_FLASH_BASE) {
-		res = target_read_u32(chip->target, NRF51_FICR_CODEPAGESIZE,
-				      &chip->code_page_size);
+	if (bank->base == NRF5_FLASH_BASE) {
+		/* The value stored in NRF5_FICR_CODEPAGESIZE is the number of bytes in one page of FLASH. */
+		res = target_read_u32(chip->target, NRF5_FICR_CODEPAGESIZE,
+				&chip->code_page_size);
 		if (res != ERROR_OK) {
 			LOG_ERROR("Couldn't read code page size");
 			return res;
 		}
 
-		res = target_read_u32(chip->target, NRF51_FICR_CODESIZE,
-				      &chip->code_memory_size);
+		/* Note the register name is misleading,
+		 * NRF5_FICR_CODESIZE is the number of pages in flash memory, not the number of bytes! */
+		uint32_t num_sectors;
+		res = target_read_u32(chip->target, NRF5_FICR_CODESIZE, &num_sectors);
 		if (res != ERROR_OK) {
 			LOG_ERROR("Couldn't read code memory size");
 			return res;
 		}
 
-		if (spec && chip->code_memory_size != spec->flash_size_kb) {
-			LOG_ERROR("Chip's reported Flash capacity does not match expected one");
-			return ERROR_FAIL;
-		}
+		bank->num_sectors = num_sectors;
+		bank->size = num_sectors * chip->code_page_size;
+
+		if (spec && bank->size / 1024 != spec->flash_size_kb)
+			LOG_WARNING("Chip's reported Flash capacity does not match expected one");
 
-		bank->size = chip->code_memory_size * 1024;
-		bank->num_sectors = bank->size / chip->code_page_size;
 		bank->sectors = calloc(bank->num_sectors,
 				       sizeof((bank->sectors)[0]));
 		if (!bank->sectors)
 			return ERROR_FLASH_BANK_NOT_PROBED;
 
-		/* Fill out the sector information: all NRF51 sectors are the same size and
+		/* Fill out the sector information: all NRF5 sectors are the same size and
 		 * there is always a fixed number of them. */
 		for (int i = 0; i < bank->num_sectors; i++) {
 			bank->sectors[i].size = chip->code_page_size;
@@ -670,11 +515,11 @@ static int nrf51_probe(struct flash_bank *bank)
 			bank->sectors[i].is_protected = -1;
 		}
 
-		nrf51_protect_check(bank);
+		nrf5_protect_check(bank);
 
 		chip->bank[0].probed = true;
 	} else {
-		bank->size = NRF51_UICR_SIZE;
+		bank->size = NRF5_UICR_SIZE;
 		bank->num_sectors = 1;
 		bank->sectors = calloc(bank->num_sectors,
 				       sizeof((bank->sectors)[0]));
@@ -694,21 +539,21 @@ static int nrf51_probe(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-static int nrf51_auto_probe(struct flash_bank *bank)
+static int nrf5_auto_probe(struct flash_bank *bank)
 {
-	int probed = nrf51_bank_is_probed(bank);
+	int probed = nrf5_bank_is_probed(bank);
 
 	if (probed < 0)
 		return probed;
 	else if (probed)
 		return ERROR_OK;
 	else
-		return nrf51_probe(bank);
+		return nrf5_probe(bank);
 }
 
-static struct flash_sector *nrf51_find_sector_by_address(struct flash_bank *bank, uint32_t address)
+static struct flash_sector *nrf5_find_sector_by_address(struct flash_bank *bank, uint32_t address)
 {
-	struct nrf51_info *chip = bank->driver_priv;
+	struct nrf5_info *chip = bank->driver_priv;
 
 	for (int i = 0; i < bank->num_sectors; i++)
 		if (bank->sectors[i].offset <= address &&
@@ -717,16 +562,16 @@ static struct flash_sector *nrf51_find_sector_by_address(struct flash_bank *bank
 	return NULL;
 }
 
-static int nrf51_erase_all(struct nrf51_info *chip)
+static int nrf5_erase_all(struct nrf5_info *chip)
 {
 	LOG_DEBUG("Erasing all non-volatile memory");
-	return nrf51_nvmc_generic_erase(chip,
-					NRF51_NVMC_ERASEALL,
+	return nrf5_nvmc_generic_erase(chip,
+					NRF5_NVMC_ERASEALL,
 					0x00000001);
 }
 
-static int nrf51_erase_page(struct flash_bank *bank,
-							struct nrf51_info *chip,
+static int nrf5_erase_page(struct flash_bank *bank,
+							struct nrf5_info *chip,
 							struct flash_sector *sector)
 {
 	int res;
@@ -737,9 +582,9 @@ static int nrf51_erase_page(struct flash_bank *bank,
 		return ERROR_FAIL;
 	}
 
-	if (bank->base == NRF51_UICR_BASE) {
+	if (bank->base == NRF5_UICR_BASE) {
 		uint32_t ppfc;
-		res = target_read_u32(chip->target, NRF51_FICR_PPFC,
+		res = target_read_u32(chip->target, NRF5_FICR_PPFC,
 				      &ppfc);
 		if (res != ERROR_OK) {
 			LOG_ERROR("Couldn't read PPFC register");
@@ -755,16 +600,16 @@ static int nrf51_erase_page(struct flash_bank *bank,
 
 			LOG_ERROR("The chip was not pre-programmed with SoftDevice stack and UICR cannot be erased separately. Please issue mass erase before trying to write to this region");
 			return ERROR_FAIL;
-		};
+		}
 
-		res = nrf51_nvmc_generic_erase(chip,
-					       NRF51_NVMC_ERASEUICR,
+		res = nrf5_nvmc_generic_erase(chip,
+					       NRF5_NVMC_ERASEUICR,
 					       0x00000001);
 
 
 	} else {
-		res = nrf51_nvmc_generic_erase(chip,
-					       NRF51_NVMC_ERASEPAGE,
+		res = nrf5_nvmc_generic_erase(chip,
+					       NRF5_NVMC_ERASEPAGE,
 					       sector->offset);
 	}
 
@@ -774,7 +619,7 @@ static int nrf51_erase_page(struct flash_bank *bank,
 	return res;
 }
 
-static const uint8_t nrf51_flash_write_code[] = {
+static const uint8_t nrf5_flash_write_code[] = {
 	/* See contrib/loaders/flash/cortex-m0.S */
 /* <wait_fifo>: */
 	0x0d, 0x68,		/* ldr	r5,	[r1,	#0] */
@@ -799,13 +644,13 @@ static const uint8_t nrf51_flash_write_code[] = {
 
 
 /* Start a low level flash write for the specified region */
-static int nrf51_ll_flash_write(struct nrf51_info *chip, uint32_t offset, const uint8_t *buffer, uint32_t bytes)
+static int nrf5_ll_flash_write(struct nrf5_info *chip, uint32_t offset, const uint8_t *buffer, uint32_t bytes)
 {
 	struct target *target = chip->target;
 	uint32_t buffer_size = 8192;
 	struct working_area *write_algorithm;
 	struct working_area *source;
-	uint32_t address = NRF51_FLASH_BASE + offset;
+	uint32_t address = NRF5_FLASH_BASE + offset;
 	struct reg_param reg_params[4];
 	struct armv7m_algorithm armv7m_info;
 	int retval = ERROR_OK;
@@ -815,7 +660,7 @@ static int nrf51_ll_flash_write(struct nrf51_info *chip, uint32_t offset, const
 	assert(bytes % 4 == 0);
 
 	/* allocate working area with flash programming code */
-	if (target_alloc_working_area(target, sizeof(nrf51_flash_write_code),
+	if (target_alloc_working_area(target, sizeof(nrf5_flash_write_code),
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, falling back to slow memory writes");
 
@@ -824,7 +669,7 @@ static int nrf51_ll_flash_write(struct nrf51_info *chip, uint32_t offset, const
 			if (retval != ERROR_OK)
 				return retval;
 
-			retval = nrf51_wait_for_nvmc(chip);
+			retval = nrf5_wait_for_nvmc(chip);
 			if (retval != ERROR_OK)
 				return retval;
 
@@ -837,11 +682,11 @@ static int nrf51_ll_flash_write(struct nrf51_info *chip, uint32_t offset, const
 
 	LOG_WARNING("using fast async flash loader. This is currently supported");
 	LOG_WARNING("only with ST-Link and CMSIS-DAP. If you have issues, add");
-	LOG_WARNING("\"set WORKAREASIZE 0\" before sourcing nrf51.cfg to disable it");
+	LOG_WARNING("\"set WORKAREASIZE 0\" before sourcing nrf51.cfg/nrf52.cfg to disable it");
 
 	retval = target_write_buffer(target, write_algorithm->address,
-				sizeof(nrf51_flash_write_code),
-				nrf51_flash_write_code);
+				sizeof(nrf5_flash_write_code),
+				nrf5_flash_write_code);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -892,10 +737,10 @@ static int nrf51_ll_flash_write(struct nrf51_info *chip, uint32_t offset, const
 /* Check and erase flash sectors in specified range then start a low level page write.
    start/end must be sector aligned.
 */
-static int nrf51_write_pages(struct flash_bank *bank, uint32_t start, uint32_t end, const uint8_t *buffer)
+static int nrf5_write_pages(struct flash_bank *bank, uint32_t start, uint32_t end, const uint8_t *buffer)
 {
 	int res = ERROR_FAIL;
-	struct nrf51_info *chip = bank->driver_priv;
+	struct nrf5_info *chip = bank->driver_priv;
 	struct flash_sector *sector;
 	uint32_t offset;
 
@@ -904,7 +749,7 @@ static int nrf51_write_pages(struct flash_bank *bank, uint32_t start, uint32_t e
 
 	/* Erase all sectors */
 	for (offset = start; offset < end; offset += chip->code_page_size) {
-		sector = nrf51_find_sector_by_address(bank, offset);
+		sector = nrf5_find_sector_by_address(bank, offset);
 		if (!sector) {
 			LOG_ERROR("Invalid sector @ 0x%08"PRIx32, offset);
 			return ERROR_FLASH_SECTOR_INVALID;
@@ -916,7 +761,7 @@ static int nrf51_write_pages(struct flash_bank *bank, uint32_t start, uint32_t e
 		}
 
 		if (sector->is_erased != 1) {	/* 1 = erased, 0= not erased, -1 = unknown */
-			res = nrf51_erase_page(bank, chip, sector);
+			res = nrf5_erase_page(bank, chip, sector);
 			if (res != ERROR_OK) {
 				LOG_ERROR("Failed to erase sector @ 0x%08"PRIx32, sector->offset);
 				goto error;
@@ -925,41 +770,41 @@ static int nrf51_write_pages(struct flash_bank *bank, uint32_t start, uint32_t e
 		sector->is_erased = 0;
 	}
 
-	res = nrf51_nvmc_write_enable(chip);
+	res = nrf5_nvmc_write_enable(chip);
 	if (res != ERROR_OK)
 		goto error;
 
-	res = nrf51_ll_flash_write(chip, start, buffer, (end - start));
+	res = nrf5_ll_flash_write(chip, start, buffer, (end - start));
 	if (res != ERROR_OK)
 		goto set_read_only;
 
-	return nrf51_nvmc_read_only(chip);
+	return nrf5_nvmc_read_only(chip);
 
 set_read_only:
-	nrf51_nvmc_read_only(chip);
+	nrf5_nvmc_read_only(chip);
 error:
-	LOG_ERROR("Failed to write to nrf51 flash");
+	LOG_ERROR("Failed to write to nrf5 flash");
 	return res;
 }
 
-static int nrf51_erase(struct flash_bank *bank, int first, int last)
+static int nrf5_erase(struct flash_bank *bank, int first, int last)
 {
 	int res;
-	struct nrf51_info *chip;
+	struct nrf5_info *chip;
 
-	res = nrf51_get_probed_chip_if_halted(bank, &chip);
+	res = nrf5_get_probed_chip_if_halted(bank, &chip);
 	if (res != ERROR_OK)
 		return res;
 
 	/* For each sector to be erased */
 	for (int s = first; s <= last && res == ERROR_OK; s++)
-		res = nrf51_erase_page(bank, chip, &bank->sectors[s]);
+		res = nrf5_erase_page(bank, chip, &bank->sectors[s]);
 
 	return res;
 }
 
-static int nrf51_code_flash_write(struct flash_bank *bank,
-				  struct nrf51_info *chip,
+static int nrf5_code_flash_write(struct flash_bank *bank,
+				  struct nrf5_info *chip,
 				  const uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 
@@ -1006,58 +851,58 @@ static int nrf51_code_flash_write(struct flash_bank *bank,
 			return res;
 	}
 
-	return nrf51_write_pages(bank, first_page_offset, last_page_offset, buffer_to_flash);
+	return nrf5_write_pages(bank, first_page_offset, last_page_offset, buffer_to_flash);
 }
 
-static int nrf51_uicr_flash_write(struct flash_bank *bank,
-				  struct nrf51_info *chip,
+static int nrf5_uicr_flash_write(struct flash_bank *bank,
+				  struct nrf5_info *chip,
 				  const uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	int res;
-	uint8_t uicr[NRF51_UICR_SIZE];
+	uint8_t uicr[NRF5_UICR_SIZE];
 	struct flash_sector *sector = &bank->sectors[0];
 
-	if ((offset + count) > NRF51_UICR_SIZE)
+	if ((offset + count) > NRF5_UICR_SIZE)
 		return ERROR_FAIL;
 
 	res = target_read_memory(bank->target,
-				 NRF51_UICR_BASE,
+				 NRF5_UICR_BASE,
 				 1,
-				 NRF51_UICR_SIZE,
+				 NRF5_UICR_SIZE,
 				 uicr);
 
 	if (res != ERROR_OK)
 		return res;
 
 	if (sector->is_erased != 1) {
-		res = nrf51_erase_page(bank, chip, sector);
+		res = nrf5_erase_page(bank, chip, sector);
 		if (res != ERROR_OK)
 			return res;
 	}
 
-	res = nrf51_nvmc_write_enable(chip);
+	res = nrf5_nvmc_write_enable(chip);
 	if (res != ERROR_OK)
 		return res;
 
 	memcpy(&uicr[offset], buffer, count);
 
-	res = nrf51_ll_flash_write(chip, NRF51_UICR_BASE, uicr, NRF51_UICR_SIZE);
+	res = nrf5_ll_flash_write(chip, NRF5_UICR_BASE, uicr, NRF5_UICR_SIZE);
 	if (res != ERROR_OK) {
-		nrf51_nvmc_read_only(chip);
+		nrf5_nvmc_read_only(chip);
 		return res;
 	}
 
-	return nrf51_nvmc_read_only(chip);
+	return nrf5_nvmc_read_only(chip);
 }
 
 
-static int nrf51_write(struct flash_bank *bank, const uint8_t *buffer,
+static int nrf5_write(struct flash_bank *bank, const uint8_t *buffer,
 		       uint32_t offset, uint32_t count)
 {
 	int res;
-	struct nrf51_info *chip;
+	struct nrf5_info *chip;
 
-	res = nrf51_get_probed_chip_if_halted(bank, &chip);
+	res = nrf5_get_probed_chip_if_halted(bank, &chip);
 	if (res != ERROR_OK)
 		return res;
 
@@ -1065,15 +910,15 @@ static int nrf51_write(struct flash_bank *bank, const uint8_t *buffer,
 }
 
 
-FLASH_BANK_COMMAND_HANDLER(nrf51_flash_bank_command)
+FLASH_BANK_COMMAND_HANDLER(nrf5_flash_bank_command)
 {
-	static struct nrf51_info *chip;
+	static struct nrf5_info *chip;
 
 	switch (bank->base) {
-	case NRF51_FLASH_BASE:
+	case NRF5_FLASH_BASE:
 		bank->bank_number = 0;
 		break;
-	case NRF51_UICR_BASE:
+	case NRF5_UICR_BASE:
 		bank->bank_number = 1;
 		break;
 	default:
@@ -1091,11 +936,11 @@ FLASH_BANK_COMMAND_HANDLER(nrf51_flash_bank_command)
 	}
 
 	switch (bank->base) {
-	case NRF51_FLASH_BASE:
-		chip->bank[bank->bank_number].write = nrf51_code_flash_write;
+	case NRF5_FLASH_BASE:
+		chip->bank[bank->bank_number].write = nrf5_code_flash_write;
 		break;
-	case NRF51_UICR_BASE:
-		chip->bank[bank->bank_number].write = nrf51_uicr_flash_write;
+	case NRF5_UICR_BASE:
+		chip->bank[bank->bank_number].write = nrf5_uicr_flash_write;
 		break;
 	}
 
@@ -1105,27 +950,27 @@ FLASH_BANK_COMMAND_HANDLER(nrf51_flash_bank_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(nrf51_handle_mass_erase_command)
+COMMAND_HANDLER(nrf5_handle_mass_erase_command)
 {
 	int res;
 	struct flash_bank *bank = NULL;
 	struct target *target = get_current_target(CMD_CTX);
 
-	res = get_flash_bank_by_addr(target, NRF51_FLASH_BASE, true, &bank);
+	res = get_flash_bank_by_addr(target, NRF5_FLASH_BASE, true, &bank);
 	if (res != ERROR_OK)
 		return res;
 
 	assert(bank != NULL);
 
-	struct nrf51_info *chip;
+	struct nrf5_info *chip;
 
-	res = nrf51_get_probed_chip_if_halted(bank, &chip);
+	res = nrf5_get_probed_chip_if_halted(bank, &chip);
 	if (res != ERROR_OK)
 		return res;
 
 	uint32_t ppfc;
 
-	res = target_read_u32(target, NRF51_FICR_PPFC,
+	res = target_read_u32(target, NRF5_FICR_PPFC,
 			      &ppfc);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Couldn't read PPFC register");
@@ -1136,25 +981,25 @@ COMMAND_HANDLER(nrf51_handle_mass_erase_command)
 		LOG_ERROR("Code region 0 size was pre-programmed at the factory, "
 			  "mass erase command won't work.");
 		return ERROR_FAIL;
-	};
+	}
 
-	res = nrf51_erase_all(chip);
+	res = nrf5_erase_all(chip);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Failed to erase the chip");
-		nrf51_protect_check(bank);
+		nrf5_protect_check(bank);
 		return res;
 	}
 
 	for (int i = 0; i < bank->num_sectors; i++)
 		bank->sectors[i].is_erased = 1;
 
-	res = nrf51_protect_check(bank);
+	res = nrf5_protect_check(bank);
 	if (res != ERROR_OK) {
 		LOG_ERROR("Failed to check chip's write protection");
 		return res;
 	}
 
-	res = get_flash_bank_by_addr(target, NRF51_UICR_BASE, true, &bank);
+	res = get_flash_bank_by_addr(target, NRF5_UICR_BASE, true, &bank);
 	if (res != ERROR_OK)
 		return res;
 
@@ -1163,13 +1008,13 @@ COMMAND_HANDLER(nrf51_handle_mass_erase_command)
 	return ERROR_OK;
 }
 
-static int nrf51_info(struct flash_bank *bank, char *buf, int buf_size)
+static int nrf5_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	int res;
 
-	struct nrf51_info *chip;
+	struct nrf5_info *chip;
 
-	res = nrf51_get_probed_chip_if_halted(bank, &chip);
+	res = nrf5_get_probed_chip_if_halted(bank, &chip);
 	if (res != ERROR_OK)
 		return res;
 
@@ -1177,45 +1022,45 @@ static int nrf51_info(struct flash_bank *bank, char *buf, int buf_size)
 		const uint32_t address;
 		uint32_t value;
 	} ficr[] = {
-		{ .address = NRF51_FICR_CODEPAGESIZE	},
-		{ .address = NRF51_FICR_CODESIZE	},
-		{ .address = NRF51_FICR_CLENR0		},
-		{ .address = NRF51_FICR_PPFC		},
-		{ .address = NRF51_FICR_NUMRAMBLOCK	},
-		{ .address = NRF51_FICR_SIZERAMBLOCK0	},
-		{ .address = NRF51_FICR_SIZERAMBLOCK1	},
-		{ .address = NRF51_FICR_SIZERAMBLOCK2	},
-		{ .address = NRF51_FICR_SIZERAMBLOCK3	},
-		{ .address = NRF51_FICR_CONFIGID	},
-		{ .address = NRF51_FICR_DEVICEID0	},
-		{ .address = NRF51_FICR_DEVICEID1	},
-		{ .address = NRF51_FICR_ER0		},
-		{ .address = NRF51_FICR_ER1		},
-		{ .address = NRF51_FICR_ER2		},
-		{ .address = NRF51_FICR_ER3		},
-		{ .address = NRF51_FICR_IR0		},
-		{ .address = NRF51_FICR_IR1		},
-		{ .address = NRF51_FICR_IR2		},
-		{ .address = NRF51_FICR_IR3		},
-		{ .address = NRF51_FICR_DEVICEADDRTYPE	},
-		{ .address = NRF51_FICR_DEVICEADDR0	},
-		{ .address = NRF51_FICR_DEVICEADDR1	},
-		{ .address = NRF51_FICR_OVERRIDEN	},
-		{ .address = NRF51_FICR_NRF_1MBIT0	},
-		{ .address = NRF51_FICR_NRF_1MBIT1	},
-		{ .address = NRF51_FICR_NRF_1MBIT2	},
-		{ .address = NRF51_FICR_NRF_1MBIT3	},
-		{ .address = NRF51_FICR_NRF_1MBIT4	},
-		{ .address = NRF51_FICR_BLE_1MBIT0	},
-		{ .address = NRF51_FICR_BLE_1MBIT1	},
-		{ .address = NRF51_FICR_BLE_1MBIT2	},
-		{ .address = NRF51_FICR_BLE_1MBIT3	},
-		{ .address = NRF51_FICR_BLE_1MBIT4	},
+		{ .address = NRF5_FICR_CODEPAGESIZE	},
+		{ .address = NRF5_FICR_CODESIZE	},
+		{ .address = NRF5_FICR_CLENR0		},
+		{ .address = NRF5_FICR_PPFC		},
+		{ .address = NRF5_FICR_NUMRAMBLOCK	},
+		{ .address = NRF5_FICR_SIZERAMBLOCK0	},
+		{ .address = NRF5_FICR_SIZERAMBLOCK1	},
+		{ .address = NRF5_FICR_SIZERAMBLOCK2	},
+		{ .address = NRF5_FICR_SIZERAMBLOCK3	},
+		{ .address = NRF5_FICR_CONFIGID	},
+		{ .address = NRF5_FICR_DEVICEID0	},
+		{ .address = NRF5_FICR_DEVICEID1	},
+		{ .address = NRF5_FICR_ER0		},
+		{ .address = NRF5_FICR_ER1		},
+		{ .address = NRF5_FICR_ER2		},
+		{ .address = NRF5_FICR_ER3		},
+		{ .address = NRF5_FICR_IR0		},
+		{ .address = NRF5_FICR_IR1		},
+		{ .address = NRF5_FICR_IR2		},
+		{ .address = NRF5_FICR_IR3		},
+		{ .address = NRF5_FICR_DEVICEADDRTYPE	},
+		{ .address = NRF5_FICR_DEVICEADDR0	},
+		{ .address = NRF5_FICR_DEVICEADDR1	},
+		{ .address = NRF5_FICR_OVERRIDEN	},
+		{ .address = NRF5_FICR_NRF_1MBIT0	},
+		{ .address = NRF5_FICR_NRF_1MBIT1	},
+		{ .address = NRF5_FICR_NRF_1MBIT2	},
+		{ .address = NRF5_FICR_NRF_1MBIT3	},
+		{ .address = NRF5_FICR_NRF_1MBIT4	},
+		{ .address = NRF5_FICR_BLE_1MBIT0	},
+		{ .address = NRF5_FICR_BLE_1MBIT1	},
+		{ .address = NRF5_FICR_BLE_1MBIT2	},
+		{ .address = NRF5_FICR_BLE_1MBIT3	},
+		{ .address = NRF5_FICR_BLE_1MBIT4	},
 	}, uicr[] = {
-		{ .address = NRF51_UICR_CLENR0,		},
-		{ .address = NRF51_UICR_RBPCONF		},
-		{ .address = NRF51_UICR_XTALFREQ	},
-		{ .address = NRF51_UICR_FWID		},
+		{ .address = NRF5_UICR_CLENR0,		},
+		{ .address = NRF5_UICR_RBPCONF		},
+		{ .address = NRF5_UICR_XTALFREQ	},
+		{ .address = NRF5_UICR_FWID		},
 	};
 
 	for (size_t i = 0; i < ARRAY_SIZE(ficr); i++) {
@@ -1262,7 +1107,7 @@ static int nrf51_info(struct flash_bank *bank, char *buf, int buf_size)
 		 "reset value for XTALFREQ: %"PRIx32"\n"
 		 "firmware id: 0x%04"PRIx32,
 		 ficr[0].value,
-		 ficr[1].value,
+		 (ficr[1].value * ficr[0].value) / 1024,
 		 (ficr[2].value == 0xFFFFFFFF) ? 0 : ficr[2].value / 1024,
 		 ((ficr[3].value & 0xFF) == 0x00) ? "present" : "not present",
 		 ficr[4].value,
@@ -1287,38 +1132,62 @@ static int nrf51_info(struct flash_bank *bank, char *buf, int buf_size)
 	return ERROR_OK;
 }
 
-static const struct command_registration nrf51_exec_command_handlers[] = {
+static const struct command_registration nrf5_exec_command_handlers[] = {
 	{
 		.name		= "mass_erase",
-		.handler	= nrf51_handle_mass_erase_command,
+		.handler	= nrf5_handle_mass_erase_command,
 		.mode		= COMMAND_EXEC,
 		.help		= "Erase all flash contents of the chip.",
 	},
 	COMMAND_REGISTRATION_DONE
 };
 
-static const struct command_registration nrf51_command_handlers[] = {
+static const struct command_registration nrf5_command_handlers[] = {
+	{
+		.name	= "nrf5",
+		.mode	= COMMAND_ANY,
+		.help	= "nrf5 flash command group",
+		.usage	= "",
+		.chain	= nrf5_exec_command_handlers,
+	},
 	{
 		.name	= "nrf51",
 		.mode	= COMMAND_ANY,
 		.help	= "nrf51 flash command group",
 		.usage	= "",
-		.chain	= nrf51_exec_command_handlers,
+		.chain	= nrf5_exec_command_handlers,
 	},
 	COMMAND_REGISTRATION_DONE
 };
 
+struct flash_driver nrf5_flash = {
+	.name			= "nrf5",
+	.commands		= nrf5_command_handlers,
+	.flash_bank_command	= nrf5_flash_bank_command,
+	.info			= nrf5_info,
+	.erase			= nrf5_erase,
+	.protect		= nrf5_protect,
+	.write			= nrf5_write,
+	.read			= default_flash_read,
+	.probe			= nrf5_probe,
+	.auto_probe		= nrf5_auto_probe,
+	.erase_check		= default_flash_blank_check,
+	.protect_check		= nrf5_protect_check,
+};
+
+/* We need to retain the flash-driver name as well as the commands
+ * for backwards compatability */
 struct flash_driver nrf51_flash = {
 	.name			= "nrf51",
-	.commands		= nrf51_command_handlers,
-	.flash_bank_command	= nrf51_flash_bank_command,
-	.info			= nrf51_info,
-	.erase			= nrf51_erase,
-	.protect		= nrf51_protect,
-	.write			= nrf51_write,
+	.commands		= nrf5_command_handlers,
+	.flash_bank_command	= nrf5_flash_bank_command,
+	.info			= nrf5_info,
+	.erase			= nrf5_erase,
+	.protect		= nrf5_protect,
+	.write			= nrf5_write,
 	.read			= default_flash_read,
-	.probe			= nrf51_probe,
-	.auto_probe		= nrf51_auto_probe,
+	.probe			= nrf5_probe,
+	.auto_probe		= nrf5_auto_probe,
 	.erase_check		= default_flash_blank_check,
-	.protect_check		= nrf51_protect_check,
+	.protect_check		= nrf5_protect_check,
 };
diff --git a/src/flash/nor/numicro.c b/src/flash/nor/numicro.c
index 8d8ed6eb..992baa51 100644
--- a/src/flash/nor/numicro.c
+++ b/src/flash/nor/numicro.c
@@ -20,6 +20,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
index c547d9a1..4ae56521 100644
--- a/src/flash/nor/ocl.c
+++ b/src/flash/nor/ocl.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nor/ocl.h b/src/flash/nor/ocl.h
index d056b46d..3e83f76c 100644
--- a/src/flash/nor/ocl.h
+++ b/src/flash/nor/ocl.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef OCL_H
-#define OCL_H
+#ifndef OPENOCD_FLASH_NOR_OCL_H
+#define OPENOCD_FLASH_NOR_OCL_H
 
 /* command/response mask */
 #define OCL_CMD_MASK 0xFFFF0000L
@@ -38,4 +36,4 @@
 
 #define OCL_CHKS_INIT 0xC100CD0CL
 
-#endif /* OCL_H */
+#endif /* OPENOCD_FLASH_NOR_OCL_H */
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 5e82ba63..1f148fd7 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -52,7 +50,7 @@
 
 /* pic32mx configuration register locations */
 
-#define PIC32MX_DEVCFG0_1_2	0xBFC00BFC
+#define PIC32MX_DEVCFG0_1xx_2xx	0xBFC00BFC
 #define PIC32MX_DEVCFG0		0xBFC02FFC
 #define PIC32MX_DEVCFG1		0xBFC02FF8
 #define PIC32MX_DEVCFG2		0xBFC02FF4
@@ -93,7 +91,8 @@
 #define NVMKEY1			0xAA996655
 #define NVMKEY2			0x556699AA
 
-#define MX_1_2			1	/* PIC32mx1xx/2xx */
+#define MX_1xx_2xx			1	/* PIC32mx1xx/2xx */
+#define MX_17x_27x			2	/* PIC32mx17x/27x */
 
 struct pic32mx_flash_bank {
 	int probed;
@@ -101,7 +100,7 @@ struct pic32mx_flash_bank {
 };
 
 /*
- * DEVID values as per PIC32MX Flash Programming Specification Rev J
+ * DEVID values as per PIC32MX Flash Programming Specification Rev N
  */
 
 static const struct pic32mx_devs_s {
@@ -120,6 +119,8 @@ static const struct pic32mx_devs_s {
 	{0x04D06053, "150F128B"},
 	{0x04D08053, "150F128C"},
 	{0x04D0A053, "150F128D"},
+	{0x06610053, "170F256B"},
+	{0x0661A053, "170F256D"},
 	{0x04A01053, "210F016B"},
 	{0x04A03053, "210F016C"},
 	{0x04A05053, "210F016D"},
@@ -132,6 +133,24 @@ static const struct pic32mx_devs_s {
 	{0x04D00053, "250F128B"},
 	{0x04D02053, "250F128C"},
 	{0x04D04053, "250F128D"},
+	{0x06600053, "270F256B"},
+	{0x0660A053, "270F256D"},
+	{0x05600053, "330F064H"},
+	{0x05601053, "330F064L"},
+	{0x05602053, "430F064H"},
+	{0x05603053, "430F064L"},
+	{0x0570C053, "350F128H"},
+	{0x0570D053, "350F128L"},
+	{0x0570E053, "450F128H"},
+	{0x0570F053, "450F128L"},
+	{0x05704053, "350F256H"},
+	{0x05705053, "350F256L"},
+	{0x05706053, "450F256H"},
+	{0x05707053, "450F256L"},
+	{0x05808053, "370F512H"},
+	{0x05809053, "370F512L"},
+	{0x0580A053, "470F512H"},
+	{0x0580B053, "470F512L"},
 	{0x00938053, "360F512L"},
 	{0x00934053, "360F256L"},
 	{0x0092D053, "340F128L"},
@@ -260,10 +279,15 @@ static int pic32mx_protect_check(struct flash_bank *bank)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (pic32mx_info->dev_type == MX_1_2)
-		config0_address = PIC32MX_DEVCFG0_1_2;
-	else
+	switch (pic32mx_info->dev_type) {
+	case	MX_1xx_2xx:
+	case	MX_17x_27x:
+		config0_address = PIC32MX_DEVCFG0_1xx_2xx;
+		break;
+	default:
 		config0_address = PIC32MX_DEVCFG0;
+		break;
+	}
 
 	target_read_u32(target, config0_address, &devcfg0);
 
@@ -276,10 +300,17 @@ static int pic32mx_protect_check(struct flash_bank *bank)
 			num_pages = 0xffff;		/* All pages protected */
 	} else {
 		/* pgm flash */
-		if (pic32mx_info->dev_type == MX_1_2)
-			num_pages = (~devcfg0 >> 10) & 0x3f;
-		else
+		switch (pic32mx_info->dev_type) {
+		case	MX_1xx_2xx:
+			num_pages = (~devcfg0 >> 10) & 0x7f;
+			break;
+		case	MX_17x_27x:
+			num_pages = (~devcfg0 >> 10) & 0x1ff;
+			break;
+		default:
 			num_pages = (~devcfg0 >> 12) & 0xff;
+			break;
+		}
 	}
 
 	for (s = 0; s < bank->num_sectors && s < num_pages; s++)
@@ -430,23 +461,27 @@ static int pic32mx_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	/* Change values for counters and row size, depending on variant */
-	if (pic32mx_info->dev_type == MX_1_2) {
+	switch (pic32mx_info->dev_type) {
+	case	MX_1xx_2xx:
+	case	MX_17x_27x:
 		/* 128 byte row */
 		pic32mx_flash_write_code[8] = 0x2CD30020;
 		pic32mx_flash_write_code[14] = 0x24840080;
 		pic32mx_flash_write_code[15] = 0x24A50080;
 		pic32mx_flash_write_code[17] = 0x24C6FFE0;
 		row_size = 128;
-	} else {
+		break;
+	default:
 		/* 512 byte row */
 		pic32mx_flash_write_code[8] = 0x2CD30080;
 		pic32mx_flash_write_code[14] = 0x24840200;
 		pic32mx_flash_write_code[15] = 0x24A50200;
 		pic32mx_flash_write_code[17] = 0x24C6FF80;
 		row_size = 512;
+		break;
 	}
 
 	uint8_t code[sizeof(pic32mx_flash_write_code)];
@@ -472,9 +507,9 @@ static int pic32mx_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
 	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
 
-	init_reg_param(&reg_params[0], "a0", 32, PARAM_IN_OUT);
-	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
-	init_reg_param(&reg_params[2], "a2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[0], "r4", 32, PARAM_IN_OUT);
+	init_reg_param(&reg_params[1], "r5", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r6", 32, PARAM_OUT);
 
 	int row_offset = offset % row_size;
 	uint8_t *new_buffer = NULL;
@@ -682,17 +717,21 @@ static int pic32mx_probe(struct flash_bank *bank)
 	/* Check for PIC32mx1xx/2xx */
 	for (i = 0; pic32mx_devs[i].name != NULL; i++) {
 		if (pic32mx_devs[i].devid == (device_id & 0x0fffffff)) {
-			if ((*(pic32mx_devs[i].name) == '1') || (*(pic32mx_devs[i].name) == '2'))
-				pic32mx_info->dev_type = MX_1_2;
+			if ((pic32mx_devs[i].name[0] == '1') || (pic32mx_devs[i].name[0] == '2'))
+				pic32mx_info->dev_type = (pic32mx_devs[i].name[1] == '7') ? MX_17x_27x : MX_1xx_2xx;
 			break;
 		}
 	}
 
-	if (pic32mx_info->dev_type == MX_1_2)
+	switch (pic32mx_info->dev_type) {
+	case	MX_1xx_2xx:
+	case	MX_17x_27x:
 		page_size = 1024;
-	else
+		break;
+	default:
 		page_size = 4096;
-
+		break;
+	}
 
 	if (Virt2Phys(bank->base) == PIC32MX_PHYS_BOOT_FLASH) {
 		/* 0x1FC00000: Boot flash size */
@@ -706,20 +745,29 @@ static int pic32mx_probe(struct flash_bank *bank)
 		}
 #else
 		/* fixed 12k boot bank - see comments above */
-		if (pic32mx_info->dev_type == MX_1_2)
+		switch (pic32mx_info->dev_type) {
+		case	MX_1xx_2xx:
+		case	MX_17x_27x:
 			num_pages = (3 * 1024);
-		else
+			break;
+		default:
 			num_pages = (12 * 1024);
+			break;
+		}
 #endif
 	} else {
 		/* read the flash size from the device */
 		if (target_read_u32(target, PIC32MX_BMXPFMSZ, &num_pages) != ERROR_OK) {
-			if (pic32mx_info->dev_type == MX_1_2) {
+			switch (pic32mx_info->dev_type) {
+			case	MX_1xx_2xx:
+			case	MX_17x_27x:
 				LOG_WARNING("PIC32MX flash size failed, probe inaccurate - assuming 32k flash");
 				num_pages = (32 * 1024);
-			} else {
+				break;
+			default:
 				LOG_WARNING("PIC32MX flash size failed, probe inaccurate - assuming 512k flash");
 				num_pages = (512 * 1024);
+				break;
 			}
 		}
 	}
@@ -831,7 +879,6 @@ COMMAND_HANDLER(pic32mx_handle_pgm_word_command)
 
 COMMAND_HANDLER(pic32mx_handle_unlock_command)
 {
-	uint32_t mchip_cmd;
 	struct target *target = NULL;
 	struct mips_m4k_common *mips_m4k;
 	struct mips_ejtag *ejtag_info;
@@ -856,7 +903,7 @@ COMMAND_HANDLER(pic32mx_handle_unlock_command)
 	mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
 
 	/* first check status of device */
-	mchip_cmd = MCHP_STATUS;
+	uint8_t mchip_cmd = MCHP_STATUS;
 	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
 	if (mchip_cmd & (1 << 7)) {
 		/* device is not locked */
diff --git a/src/flash/nor/psoc4.c b/src/flash/nor/psoc4.c
index 72541d5d..c7c85737 100644
--- a/src/flash/nor/psoc4.c
+++ b/src/flash/nor/psoc4.c
@@ -20,6 +20,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -102,12 +105,12 @@ const struct psoc4_chip_details psoc4_devices[] = {
 	/* 4100 series */
 	{ 0x0410, "CY8C4124PVI-432", "SSOP-28", .flash_size_in_kb = 16 },
 	{ 0x0411, "CY8C4124PVI-442", "SSOP-28", .flash_size_in_kb = 16 },
-	{ 0x0416, "CY8C4124LQI-443", "QFN-40",  .flash_size_in_kb = 16 },
+	{ 0x041C, "CY8C4124LQI-443", "QFN-40",  .flash_size_in_kb = 16 },
 	{ 0x041A, "CY8C4124AXI-443", "TQFP-44", .flash_size_in_kb = 16 },
 	{ 0x041B, "CY8C4125AXI-473", "TQFP-44", .flash_size_in_kb = 32 },
 	{ 0x0412, "CY8C4125PVI-482", "SSOP-28", .flash_size_in_kb = 32 },
 	{ 0x0417, "CY8C4125LQI-483", "QFN-40",  .flash_size_in_kb = 32 },
-	{ 0x041C, "CY8C4125AXI-483", "TQFP-44", .flash_size_in_kb = 32 },
+	{ 0x0416, "CY8C4125AXI-483", "TQFP-44", .flash_size_in_kb = 32 },
 
 	/* CCG1 series */
 	{ 0x0490, "CYPD1103-35FNXI", "CSP-35",  .flash_size_in_kb = 32 },
@@ -221,7 +224,7 @@ static int psoc4_sysreq(struct target *target, uint8_t cmd, uint16_t cmd_param,
 			&sysreq_wait_algorithm) != ERROR_OK) {
 		LOG_DEBUG("no working area for sysreq code");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	/* Write the code */
 	retval = target_write_buffer(target,
diff --git a/src/flash/nor/sim3x.c b/src/flash/nor/sim3x.c
index df4e19c2..ce9a21ed 100644
--- a/src/flash/nor/sim3x.c
+++ b/src/flash/nor/sim3x.c
@@ -14,6 +14,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -748,7 +751,7 @@ static int sim3x_read_info(struct flash_bank *bank)
 	}
 
 	if (((cpuid >> 4) & 0xfff) != 0xc23) {
-		LOG_ERROR("Target is not CortexM3");
+		LOG_ERROR("Target is not Cortex-M3");
 		return ERROR_FAIL;
 	}
 
@@ -1009,7 +1012,7 @@ COMMAND_HANDLER(sim3x_lock)
 			return ret;
 
 		if ((val & CPUID_CHECK_VALUE_MASK) != CPUID_CHECK_VALUE) {
-			LOG_ERROR("Target is not ARM CortexM3 or is already locked");
+			LOG_ERROR("Target is not ARM Cortex-M3 or is already locked");
 			return ERROR_FAIL;
 		}
 	} else {
diff --git a/src/flash/nor/spi.c b/src/flash/nor/spi.c
index fdbdec48..6501fbc1 100644
--- a/src/flash/nor/spi.c
+++ b/src/flash/nor/spi.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -49,27 +47,28 @@ const struct flash_device flash_devices[] = {
 	FLASH_ID("sp s25fl004",    0xd8, 0xc7, 0x00120201, 0x100, 0x10000, 0x80000),
 	FLASH_ID("sp s25fl008",    0xd8, 0xc7, 0x00130201, 0x100, 0x10000, 0x100000),
 	FLASH_ID("sp s25fl016",    0xd8, 0xc7, 0x00140201, 0x100, 0x10000, 0x200000),
-	FLASH_ID("sp s25fl116k",   0xd8, 0xC7, 0x00154001, 0x100, 0x10000, 0x200000),
+	FLASH_ID("sp s25fl116k",   0xd8, 0xc7, 0x00154001, 0x100, 0x10000, 0x200000),
 	FLASH_ID("sp s25fl032",    0xd8, 0xc7, 0x00150201, 0x100, 0x10000, 0x400000),
-	FLASH_ID("sp s25fl132k",   0xd8, 0xC7, 0x00164001, 0x100, 0x10000, 0x400000),
+	FLASH_ID("sp s25fl132k",   0xd8, 0xc7, 0x00164001, 0x100, 0x10000, 0x400000),
 	FLASH_ID("sp s25fl064",    0xd8, 0xc7, 0x00160201, 0x100, 0x10000, 0x800000),
-	FLASH_ID("sp s25fl164k",   0xd8, 0xC7, 0x00174001, 0x100, 0x10000, 0x800000),
-	FLASH_ID("sp s25fl128",    0xd8, 0xC7, 0x00182001, 0x100, 0x10000, 0x1000000),
-	FLASH_ID("sp s25fl256",    0xd8, 0xC7, 0x00190201, 0x100, 0x10000, 0x2000000),
+	FLASH_ID("sp s25fl164k",   0xd8, 0xc7, 0x00174001, 0x100, 0x10000, 0x800000),
+	FLASH_ID("sp s25fl128",    0xd8, 0xc7, 0x00182001, 0x100, 0x10000, 0x1000000),
+	FLASH_ID("sp s25fl256",    0xd8, 0xc7, 0x00190201, 0x100, 0x10000, 0x2000000),
 	FLASH_ID("atmel 25f512",   0x52, 0xc7, 0x0065001f, 0x80,  0x8000,  0x10000),
 	FLASH_ID("atmel 25f1024",  0x52, 0x62, 0x0060001f, 0x100, 0x8000,  0x20000),
 	FLASH_ID("atmel 25f2048",  0x52, 0x62, 0x0063001f, 0x100, 0x10000, 0x40000),
 	FLASH_ID("atmel 25f4096",  0x52, 0x62, 0x0064001f, 0x100, 0x10000, 0x80000),
 	FLASH_ID("atmel 25fs040",  0xd7, 0xc7, 0x0004661f, 0x100, 0x10000, 0x80000),
 	FLASH_ID("mac 25l512",     0xd8, 0xc7, 0x001020c2, 0x010, 0x10000, 0x10000),
-	FLASH_ID("mac 25l1005",    0xd8, 0xd8, 0x001120c2, 0x010, 0x10000, 0x20000),
+	FLASH_ID("mac 25l1005",    0xd8, 0xc7, 0x001120c2, 0x010, 0x10000, 0x20000),
 	FLASH_ID("mac 25l2005",    0xd8, 0xc7, 0x001220c2, 0x010, 0x10000, 0x40000),
 	FLASH_ID("mac 25l4005",    0xd8, 0xc7, 0x001320c2, 0x010, 0x10000, 0x80000),
 	FLASH_ID("mac 25l8005",    0xd8, 0xc7, 0x001420c2, 0x010, 0x10000, 0x100000),
 	FLASH_ID("mac 25l1605",    0xd8, 0xc7, 0x001520c2, 0x100, 0x10000, 0x200000),
 	FLASH_ID("mac 25l3205",    0xd8, 0xc7, 0x001620c2, 0x100, 0x10000, 0x400000),
 	FLASH_ID("mac 25l6405",    0xd8, 0xc7, 0x001720c2, 0x100, 0x10000, 0x800000),
-	FLASH_ID("mcr n25q064",    0xd8, 0xc7, 0x0017ba20, 0x100, 0x10000, 0x800000),
+	FLASH_ID("micron n25q064", 0xd8, 0xc7, 0x0017ba20, 0x100, 0x10000, 0x800000),
+	FLASH_ID("micron n25q128", 0xd8, 0xc7, 0x0018ba20, 0x100, 0x10000, 0x1000000),
 	FLASH_ID("win w25q80bv",   0xd8, 0xc7, 0x001440ef, 0x100, 0x10000, 0x100000),
 	FLASH_ID("win w25q32fv",   0xd8, 0xc7, 0x001640ef, 0x100, 0x10000, 0x400000),
 	FLASH_ID("win w25q32dw",   0xd8, 0xc7, 0x001660ef, 0x100, 0x10000, 0x400000),
@@ -79,6 +78,5 @@ const struct flash_device flash_devices[] = {
 	FLASH_ID("gd gd25q16c",    0xd8, 0xc7, 0x001540c8, 0x100, 0x10000, 0x200000),
 	FLASH_ID("gd gd25q32c",    0xd8, 0xc7, 0x001640c8, 0x100, 0x10000, 0x400000),
 	FLASH_ID("gd gd25q128c",   0xd8, 0xc7, 0x001840c8, 0x100, 0x10000, 0x1000000),
-	FLASH_ID("micron n25q128", 0xd8, 0xc7, 0x0018ba20, 0x100, 0x10000, 0x1000000),
 	FLASH_ID(NULL,             0,    0,	   0,          0,     0,       0)
 };
diff --git a/src/flash/nor/spi.h b/src/flash/nor/spi.h
index 6e939b76..a1849983 100644
--- a/src/flash/nor/spi.h
+++ b/src/flash/nor/spi.h
@@ -16,11 +16,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_FLASH_NOR_SPI_H
+#define OPENOCD_FLASH_NOR_SPI_H
+
 /* data structure to maintain flash ids from different vendors */
 struct flash_device {
 	char *name;
@@ -56,3 +57,5 @@ extern const struct flash_device flash_devices[];
 #define SPIFLASH_PAGE_PROGRAM	0x02 /* Page Program */
 #define SPIFLASH_FAST_READ		0x0B /* Fast Read */
 #define SPIFLASH_READ			0x03 /* Normal Read */
+
+#endif /* OPENOCD_FLASH_NOR_SPI_H */
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index e8775412..b5e62534 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /***************************************************************************
@@ -602,7 +600,7 @@ static void stellaris_read_clock_info(struct flash_bank *bank)
 	LOG_DEBUG("Stellaris PLLCFG %" PRIx32 "", pllcfg);
 
 	stellaris_info->rcc = rcc;
-	stellaris_info->rcc = rcc2;
+	stellaris_info->rcc2 = rcc2;
 
 	sysdiv = (rcc >> 23) & 0xF;
 	usesysdiv = (rcc >> 22) & 0x1;
@@ -1065,7 +1063,7 @@ static int stellaris_write_block(struct flash_bank *bank,
 			&write_algorithm) != ERROR_OK) {
 		LOG_DEBUG("no working area for block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	/* plus a buffer big enough for this data */
 	if (wcount * 4 < buffer_size)
@@ -1080,7 +1078,7 @@ static int stellaris_write_block(struct flash_bank *bank,
 		}
 		LOG_DEBUG("retry target_alloc_working_area(%s, size=%u)",
 				target_name(target), (unsigned) buffer_size);
-	};
+	}
 
 	target_write_buffer(target, write_algorithm->address,
 			sizeof(stellaris_write_code),
diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
index 82f112ef..d4467076 100644
--- a/src/flash/nor/stm32f1x.c
+++ b/src/flash/nor/stm32f1x.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -620,7 +618,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(stm32x_flash_write_code), stm32x_flash_write_code);
@@ -639,7 +637,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			LOG_WARNING("no large enough working area available, can't do block memory writes");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-	};
+	}
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* flash base (in), status (out) */
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);	/* count (halfword-16bit) */
diff --git a/src/flash/nor/stm32f2x.c b/src/flash/nor/stm32f2x.c
index 89fc75dc..65cb212b 100644
--- a/src/flash/nor/stm32f2x.c
+++ b/src/flash/nor/stm32f2x.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -61,13 +59,23 @@
  *
  * Sector sizes in kiBytes:
  * 1 MiByte part with 4 x 16, 1 x 64, 7 x 128.
+ * 1.5 MiByte part with 4 x 16, 1 x 64, 11 x 128.
  * 2 MiByte part with 4 x 16, 1 x 64, 7 x 128, 4 x 16, 1 x 64, 7 x 128.
  * 1 MiByte STM32F42x/43x part with DB1M Option set:
  *                    4 x 16, 1 x 64, 3 x 128, 4 x 16, 1 x 64, 3 x 128.
  *
- * STM32F7
+ * STM32F7[2|3]
+ * 512 kiByte part with 4 x 16, 1 x 64, 3 x 128.
+ *
+ * STM32F7[4|5]
  * 1 MiByte part with 4 x 32, 1 x 128, 3 x 256.
  *
+ * STM32F7[6|7]
+ * 1 MiByte part in single bank mode with 4 x 32, 1 x 128, 3 x 256.
+ * 1 MiByte part in dual-bank mode two banks with 4 x 16, 1 x 64, 3 x 128 each.
+ * 2 MiByte part in single-bank mode with 4 x 32, 1 x 128, 7 x 256.
+ * 2 MiByte part in dual-bank mode two banks with 4 x 16, 1 x 64, 7 x 128 each.
+ *
  * Protection size is sector size.
  *
  * Tested with STM3220F-EVAL board.
@@ -86,6 +94,15 @@
  * RM0385
  * http://www.st.com/web/en/resource/technical/document/reference_manual/DM00124865.pdf
  *
+ * RM0410
+ * http://www.st.com/resource/en/reference_manual/dm00224583.pdf
+ *
+ * RM0430
+ * http://www.st.com/resource/en/reference_manual/dm00305666.pdf
+ *
+ * RM0431
+ * http://www.st.com/resource/en/reference_manual/dm00305990.pdf
+ *
  * STM32F1x series - notice that this code was copy, pasted and knocked
  * into a stm32f2x driver, so in case something has been converted or
  * bugs haven't been fixed, here are the original manuals:
@@ -103,6 +120,9 @@
 #define FLASH_ERASE_TIMEOUT 10000
 #define FLASH_WRITE_TIMEOUT 5
 
+/* Mass erase time can be as high as 32 s in x8 mode. */
+#define FLASH_MASS_ERASE_TIMEOUT 33000
+
 #define STM32_FLASH_BASE    0x40023c00
 #define STM32_FLASH_ACR     0x40023c00
 #define STM32_FLASH_KEYR    0x40023c04
@@ -111,13 +131,13 @@
 #define STM32_FLASH_CR      0x40023c10
 #define STM32_FLASH_OPTCR   0x40023c14
 #define STM32_FLASH_OPTCR1  0x40023c18
+#define STM32_FLASH_OPTCR2  0x40023c1c
 
 /* FLASH_CR register bits */
-
 #define FLASH_PG       (1 << 0)
 #define FLASH_SER      (1 << 1)
-#define FLASH_MER      (1 << 2)
-#define FLASH_MER1     (1 << 15)
+#define FLASH_MER      (1 << 2)		/* MER/MER1 for f76x/77x */
+#define FLASH_MER1     (1 << 15)	/* MER2 for f76x/77x, confusing ... */
 #define FLASH_STRT     (1 << 16)
 #define FLASH_PSIZE_8  (0 << 8)
 #define FLASH_PSIZE_16 (1 << 8)
@@ -129,7 +149,6 @@
 #define FLASH_LOCK     (1 << 31)
 
 /* FLASH_SR register bits */
-
 #define FLASH_BSY      (1 << 16)
 #define FLASH_PGSERR   (1 << 7) /* Programming sequence error */
 #define FLASH_PGPERR   (1 << 6) /* Programming parallelism error */
@@ -140,22 +159,16 @@
 #define FLASH_ERROR (FLASH_PGSERR | FLASH_PGPERR | FLASH_PGAERR | FLASH_WRPERR | FLASH_OPERR)
 
 /* STM32_FLASH_OPTCR register bits */
+#define OPTCR_LOCK     (1 << 0)
+#define OPTCR_START    (1 << 1)
+#define OPTCR_NDBANK   (1 << 29)	/* not dual bank mode */
+#define OPTCR_DB1M     (1 << 30)	/* 1 MiB devices dual flash bank option */
+#define OPTCR_SPRMOD   (1 << 31)	/* switches PCROPi/nWPRi interpretation */
 
-#define OPT_LOCK      (1 << 0)
-#define OPT_START     (1 << 1)
-
-/* STM32_FLASH_OBR bit definitions (reading) */
-
-#define OPT_ERROR      0
-#define OPT_READOUT    1
-#define OPT_RDWDGSW    2
-#define OPT_RDRSTSTOP  3
-#define OPT_RDRSTSTDBY 4
-#define OPT_BFB2       5	/* dual flash bank only */
-#define OPT_DB1M       14	/* 1 MiB devices dual flash bank option */
+/* STM32_FLASH_OPTCR2 register bits */
+#define OPTCR2_PCROP_RDP	(1 << 31)	/* erase PCROP zone when decreasing RDP */
 
 /* register unlock keys */
-
 #define KEY1           0x45670123
 #define KEY2           0xCDEF89AB
 
@@ -165,14 +178,20 @@
 
 struct stm32x_options {
 	uint8_t RDP;
-	uint8_t user_options;
+	uint16_t user_options;	/* bit 0-7 usual options, bit 8-11 extra options */
 	uint32_t protection;
+	uint32_t boot_addr;
+	uint32_t optcr2_pcrop;
 };
 
 struct stm32x_flash_bank {
 	struct stm32x_options option_bytes;
 	int probed;
-	bool has_large_mem;		/* stm32f42x/stm32f43x family */
+	bool has_large_mem;		/* F42x/43x/469/479/7xx in dual bank mode */
+	bool has_extra_options; /* F42x/43x/469/479/7xx */
+	bool has_boot_addr;     /* F7xx */
+	bool has_optcr2_pcrop;	/* F72x/73x */
+	int protection_bits;	/* F413/423 */
 	uint32_t user_bank_size;
 };
 
@@ -286,7 +305,7 @@ static int stm32x_unlock_option_reg(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	if ((ctrl & OPT_LOCK) == 0)
+	if ((ctrl & OPTCR_LOCK) == 0)
 		return ERROR_OK;
 
 	/* unlock option registers */
@@ -302,7 +321,7 @@ static int stm32x_unlock_option_reg(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (ctrl & OPT_LOCK) {
+	if (ctrl & OPTCR_LOCK) {
 		LOG_ERROR("options not unlocked STM32_FLASH_OPTCR: %" PRIx32, ctrl);
 		return ERROR_TARGET_FAILURE;
 	}
@@ -323,18 +342,46 @@ static int stm32x_read_options(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	stm32x_info->option_bytes.user_options = optiondata & 0xec;
+    /* caution: F2 implements 5 bits (WDG_SW only)
+     * whereas F7 6 bits (IWDG_SW and WWDG_SW) in user_options */
+	stm32x_info->option_bytes.user_options = optiondata & 0xfc;
 	stm32x_info->option_bytes.RDP = (optiondata >> 8) & 0xff;
-	stm32x_info->option_bytes.protection = (optiondata >> 16) & 0xfff;
+	stm32x_info->option_bytes.protection =
+		(optiondata >> 16) & (~(0xffff << stm32x_info->protection_bits) & 0xffff);
 
-	if (stm32x_info->has_large_mem) {
+	if (stm32x_info->has_extra_options) {
+		/* F42x/43x/469/479 and 7xx have up to 4 bits of extra options */
+		stm32x_info->option_bytes.user_options |= (optiondata >> 20) &
+			((0xf00 << (stm32x_info->protection_bits - 12)) & 0xf00);
+	}
 
+	if (stm32x_info->has_large_mem || stm32x_info->has_boot_addr) {
 		retval = target_read_u32(target, STM32_FLASH_OPTCR1, &optiondata);
 		if (retval != ERROR_OK)
 			return retval;
 
-		/* append protection bits */
-		stm32x_info->option_bytes.protection |= (optiondata >> 4) & 0x00fff000;
+		/* FLASH_OPTCR1 has quite diffent meanings ... */
+		if (stm32x_info->has_boot_addr) {
+			/* for F7xx it contains boot0 and boot1 */
+			stm32x_info->option_bytes.boot_addr = optiondata;
+		} else {
+			/* for F42x/43x/469/479 it contains 12 additional protection bits */
+			stm32x_info->option_bytes.protection |= (optiondata >> 4) & 0x00fff000;
+		}
+	}
+
+	if (stm32x_info->has_optcr2_pcrop) {
+		retval = target_read_u32(target, STM32_FLASH_OPTCR2, &optiondata);
+		if (retval != ERROR_OK)
+			return retval;
+
+		stm32x_info->option_bytes.optcr2_pcrop = optiondata;
+		if (stm32x_info->has_optcr2_pcrop &&
+			(stm32x_info->option_bytes.optcr2_pcrop & ~OPTCR2_PCROP_RDP)) {
+			LOG_INFO("PCROP Engaged");
+		}
+	} else {
+		stm32x_info->option_bytes.optcr2_pcrop = 0x0;
 	}
 
 	if (stm32x_info->option_bytes.RDP != 0xAA)
@@ -347,7 +394,7 @@ static int stm32x_write_options(struct flash_bank *bank)
 {
 	struct stm32x_flash_bank *stm32x_info = NULL;
 	struct target *target = bank->target;
-	uint32_t optiondata;
+	uint32_t optiondata, optiondata2;
 
 	stm32x_info = bank->driver_priv;
 
@@ -356,36 +403,56 @@ static int stm32x_write_options(struct flash_bank *bank)
 		return retval;
 
 	/* rebuild option data */
-	optiondata = stm32x_info->option_bytes.user_options;
+	optiondata = stm32x_info->option_bytes.user_options & 0xfc;
 	optiondata |= stm32x_info->option_bytes.RDP << 8;
-	optiondata |= (stm32x_info->option_bytes.protection & 0x0fff) << 16;
+	optiondata |= (stm32x_info->option_bytes.protection &
+		(~(0xffff << stm32x_info->protection_bits))) << 16;
 
-	/* program options */
-	retval = target_write_u32(target, STM32_FLASH_OPTCR, optiondata);
-	if (retval != ERROR_OK)
-		return retval;
+	if (stm32x_info->has_extra_options) {
+		/* F42x/43x/469/479 and 7xx have up to 4 bits of extra options */
+		optiondata |= (stm32x_info->option_bytes.user_options &
+			((0xf00 << (stm32x_info->protection_bits - 12)) & 0xf00)) << 20;
+	}
 
-	if (stm32x_info->has_large_mem) {
+	if (stm32x_info->has_large_mem || stm32x_info->has_boot_addr) {
+		if (stm32x_info->has_boot_addr) {
+			/* F7xx uses FLASH_OPTCR1 for boot0 and boot1 ... */
+			optiondata2 = stm32x_info->option_bytes.boot_addr;
+		} else {
+			/* F42x/43x/469/479 uses FLASH_OPTCR1 for additional protection bits */
+			optiondata2 = (stm32x_info->option_bytes.protection & 0x00fff000) << 4;
+		}
 
-		uint32_t optiondata2 = 0;
-		optiondata2 |= (stm32x_info->option_bytes.protection & 0x00fff000) << 4;
 		retval = target_write_u32(target, STM32_FLASH_OPTCR1, optiondata2);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
+	/* program extra pcrop register */
+	if (stm32x_info->has_optcr2_pcrop) {
+		retval = target_write_u32(target, STM32_FLASH_OPTCR2,
+			stm32x_info->option_bytes.optcr2_pcrop);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* program options */
+	retval = target_write_u32(target, STM32_FLASH_OPTCR, optiondata);
+	if (retval != ERROR_OK)
+		return retval;
+
 	/* start programming cycle */
-	retval = target_write_u32(target, STM32_FLASH_OPTCR, optiondata | OPT_START);
+	retval = target_write_u32(target, STM32_FLASH_OPTCR, optiondata | OPTCR_START);
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* wait for completion */
-	retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
+	/* wait for completion, this might trigger a security erase and take a while */
+	retval = stm32x_wait_status_busy(bank, FLASH_MASS_ERASE_TIMEOUT);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* relock registers */
-	retval = target_write_u32(target, STM32_FLASH_OPTCR, optiondata | OPT_LOCK);
+	retval = target_write_u32(target, STM32_FLASH_OPTCR, optiondata | OPTCR_LOCK);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -395,6 +462,8 @@ static int stm32x_write_options(struct flash_bank *bank)
 static int stm32x_protect_check(struct flash_bank *bank)
 {
 	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
+	struct flash_sector *prot_blocks;
+	int num_prot_blocks;
 
 	/* read write protection settings */
 	int retval = stm32x_read_options(bank);
@@ -403,13 +472,18 @@ static int stm32x_protect_check(struct flash_bank *bank)
 		return retval;
 	}
 
-	for (int i = 0; i < bank->num_sectors; i++) {
-		if (stm32x_info->option_bytes.protection & (1 << i))
-			bank->sectors[i].is_protected = 0;
-		else
-			bank->sectors[i].is_protected = 1;
+	if (bank->prot_blocks) {
+		num_prot_blocks = bank->num_prot_blocks;
+		prot_blocks = bank->prot_blocks;
+	} else {
+		num_prot_blocks = bank->num_sectors;
+		prot_blocks = bank->sectors;
 	}
 
+	for (int i = 0; i < num_prot_blocks; i++)
+		prot_blocks[i].is_protected =
+			~(stm32x_info->option_bytes.protection >> i) & 1;
+
 	return ERROR_OK;
 }
 
@@ -418,8 +492,7 @@ static int stm32x_erase(struct flash_bank *bank, int first, int last)
 	struct target *target = bank->target;
 	int i;
 
-	assert(first < bank->num_sectors);
-	assert(last < bank->num_sectors);
+	assert((0 <= first) && (first <= last) && (last < bank->num_sectors));
 
 	if (bank->target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
@@ -480,7 +553,6 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 	}
 
 	for (int i = first; i <= last; i++) {
-
 		if (set)
 			stm32x_info->option_bytes.protection &= ~(1 << i);
 		else
@@ -551,7 +623,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(stm32x_flash_write_code),
@@ -570,7 +642,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			LOG_WARNING("no large enough working area available, can't do block memory writes");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-	};
+	}
 
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
@@ -721,14 +793,31 @@ static int stm32x_write(struct flash_bank *bank, const uint8_t *buffer,
 	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
 }
 
-static void setup_sector(struct flash_bank *bank, int start, int num, int size)
+static int setup_sector(struct flash_bank *bank, int start, int num, int size)
 {
+
 	for (int i = start; i < (start + num) ; i++) {
 		assert(i < bank->num_sectors);
 		bank->sectors[i].offset = bank->size;
 		bank->sectors[i].size = size;
 		bank->size += bank->sectors[i].size;
+	    LOG_DEBUG("sector %d: %dkBytes", i, size >> 10);
 	}
+
+	return start + num;
+}
+
+static void setup_bank(struct flash_bank *bank, int start,
+	uint16_t flash_size_in_kb, uint16_t max_sector_size_in_kb)
+{
+	int remain;
+
+	start = setup_sector(bank, start, 4, (max_sector_size_in_kb / 8) * 1024);
+	start = setup_sector(bank, start, 1, (max_sector_size_in_kb / 2) * 1024);
+
+	/* remaining sectors all of size max_sector_size_in_kb */
+	remain = (flash_size_in_kb / max_sector_size_in_kb) - 1;
+	start = setup_sector(bank, start, remain, max_sector_size_in_kb * 1024);
 }
 
 static int stm32x_get_device_id(struct flash_bank *bank, uint32_t *device_id)
@@ -766,7 +855,7 @@ static int stm32x_probe(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
 	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
-	int i;
+	int i, num_prot_blocks;
 	uint16_t flash_size_in_kb;
 	uint32_t flash_size_reg = 0x1FFF7A22;
 	uint16_t max_sector_size_in_kb = 128;
@@ -776,36 +865,90 @@ static int stm32x_probe(struct flash_bank *bank)
 
 	stm32x_info->probed = 0;
 	stm32x_info->has_large_mem = false;
+	stm32x_info->has_boot_addr = false;
+	stm32x_info->has_extra_options = false;
+	stm32x_info->has_optcr2_pcrop = false;
+	stm32x_info->protection_bits = 12;		/* max. number of nWRPi bits (in FLASH_OPTCR !!!) */
+	num_prot_blocks = 0;
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->num_sectors = 0;
+		bank->sectors = NULL;
+	}
+
+	if (bank->prot_blocks) {
+		free(bank->prot_blocks);
+		bank->num_prot_blocks = 0;
+		bank->prot_blocks = NULL;
+	}
 
 	/* read stm32 device id register */
 	int retval = stm32x_get_device_id(bank, &device_id);
 	if (retval != ERROR_OK)
 		return retval;
 	LOG_INFO("device id = 0x%08" PRIx32 "", device_id);
+	device_id &= 0xfff;		/* only bits 0-11 are used further on */
 
-	/* set max flash size depending on family */
-	switch (device_id & 0xfff) {
-	case 0x411:
-	case 0x413:
+	/* set max flash size depending on family, id taken from AN2606 */
+	switch (device_id) {
+	case 0x411: /* F20x/21x */
+	case 0x413: /* F40x/41x */
 		max_flash_size_in_kb = 1024;
 		break;
-	case 0x419:
-	case 0x434:
+
+	case 0x419: /* F42x/43x */
+	case 0x434: /* F469/479 */
+		stm32x_info->has_extra_options = true;
 		max_flash_size_in_kb = 2048;
 		break;
-	case 0x423:
+
+	case 0x423:	/* F401xB/C */
 		max_flash_size_in_kb = 256;
 		break;
-	case 0x431:
-	case 0x433:
-	case 0x421:
+
+	case 0x421:	/* F446 */
+	case 0x431: /* F411 */
+	case 0x433: /* F401xD/E */
+	case 0x441: /* F412 */
 		max_flash_size_in_kb = 512;
 		break;
-	case 0x449:
+
+	case 0x458: /* F410 */
+		max_flash_size_in_kb = 128;
+		break;
+
+	case 0x449:	/* F74x/75x */
 		max_flash_size_in_kb = 1024;
 		max_sector_size_in_kb = 256;
 		flash_size_reg = 0x1FF0F442;
+		stm32x_info->has_extra_options = true;
+		stm32x_info->has_boot_addr = true;
+		break;
+
+	case 0x451:	/* F76x/77x */
+		max_flash_size_in_kb = 2048;
+		max_sector_size_in_kb = 256;
+		flash_size_reg = 0x1FF0F442;
+		stm32x_info->has_extra_options = true;
+		stm32x_info->has_boot_addr = true;
 		break;
+
+	case 0x452:	/* F72x/73x */
+		max_flash_size_in_kb = 512;
+		flash_size_reg = 0x1FF07A22;	/* yes, 0x1FF*0*7A22, not 0x1FF*F*7A22 */
+		stm32x_info->has_extra_options = true;
+		stm32x_info->has_boot_addr = true;
+		stm32x_info->has_optcr2_pcrop = true;
+		break;
+
+	case 0x463:	/* F413x/423x */
+		max_flash_size_in_kb = 1536;
+		stm32x_info->has_extra_options = true;
+		stm32x_info->protection_bits = 15;
+		num_prot_blocks = 15;
+		break;
+
 	default:
 		LOG_WARNING("Cannot identify target as a STM32 family.");
 		return ERROR_FAIL;
@@ -834,71 +977,96 @@ static int stm32x_probe(struct flash_bank *bank)
 	/* did we assign flash size? */
 	assert(flash_size_in_kb != 0xffff);
 
-	/* calculate numbers of pages */
-	int num_pages = (flash_size_in_kb / max_sector_size_in_kb) + 4;
-
-	/* Devices with > 1024 kiByte always are dual-banked */
-	if (flash_size_in_kb > 1024)
-		stm32x_info->has_large_mem = true;
-
-	/* F42x/43x 1024 kiByte devices have a dual bank option */
-	if ((device_id & 0xfff) == 0x419 && (flash_size_in_kb == 1024)) {
+	/* F42x/43x/469/479 1024 kiByte devices have a dual bank option */
+	if ((device_id == 0x419) || (device_id == 0x434)) {
 		uint32_t optiondata;
 		retval = target_read_u32(target, STM32_FLASH_OPTCR, &optiondata);
 		if (retval != ERROR_OK) {
 			LOG_DEBUG("unable to read option bytes");
 			return retval;
 		}
-		if (optiondata & (1 << OPT_DB1M)) {
+		if ((flash_size_in_kb > 1024) || (optiondata & OPTCR_DB1M)) {
 			stm32x_info->has_large_mem = true;
-			LOG_INFO("Dual Bank 1024 kiB STM32F42x/43x found");
+			LOG_INFO("Dual Bank %d kiB STM32F42x/43x/469/479 found", flash_size_in_kb);
+		} else {
+			stm32x_info->has_large_mem = false;
+			LOG_INFO("Single Bank %d kiB STM32F42x/43x/469/479 found", flash_size_in_kb);
 		}
 	}
 
-	/* check for dual-banked devices */
-	if (stm32x_info->has_large_mem)
-		num_pages += 4;
-
-	/* check that calculation result makes sense */
-	assert(num_pages > 0);
-
-	if (bank->sectors) {
-		free(bank->sectors);
-		bank->sectors = NULL;
+	/* F76x/77x devices have a dual bank option */
+	if (device_id == 0x451) {
+		uint32_t optiondata;
+		retval = target_read_u32(target, STM32_FLASH_OPTCR, &optiondata);
+		if (retval != ERROR_OK) {
+			LOG_DEBUG("unable to read option bytes");
+			return retval;
+		}
+		if (optiondata & OPTCR_NDBANK) {
+			stm32x_info->has_large_mem = false;
+			LOG_INFO("Single Bank %d kiB STM32F76x/77x found", flash_size_in_kb);
+		} else {
+			stm32x_info->has_large_mem = true;
+			max_sector_size_in_kb >>= 1; /* sector size divided by 2 in dual-bank mode */
+			LOG_INFO("Dual Bank %d kiB STM32F76x/77x found", flash_size_in_kb);
+		}
 	}
 
+	/* calculate numbers of pages */
+	int num_pages = flash_size_in_kb / max_sector_size_in_kb
+		+ (stm32x_info->has_large_mem ? 8 : 4);
+
 	bank->base = base_address;
 	bank->num_sectors = num_pages;
 	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
+	for (i = 0; i < num_pages; i++) {
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 0;
+	}
 	bank->size = 0;
+	LOG_DEBUG("allocated %d sectors", num_pages);
 
-	/* fixed memory */
-	setup_sector(bank, 0, 4, (max_sector_size_in_kb / 8) * 1024);
-	setup_sector(bank, 4, 1, (max_sector_size_in_kb / 2) * 1024);
+	/* F76x/77x in dual bank mode */
+	if ((device_id == 0x451) && stm32x_info->has_large_mem)
+		num_prot_blocks = num_pages >> 1;
+
+	if (num_prot_blocks) {
+		bank->prot_blocks = malloc(sizeof(struct flash_sector) * num_prot_blocks);
+		for (i = 0; i < num_prot_blocks; i++)
+			bank->prot_blocks[i].is_protected = 0;
+		LOG_DEBUG("allocated %d prot blocks", num_prot_blocks);
+	}
 
 	if (stm32x_info->has_large_mem) {
-		if (flash_size_in_kb == 1024) {
-			setup_sector(bank,  5, 3, 128 * 1024);
-			setup_sector(bank, 12, 4,  16 * 1024);
-			setup_sector(bank, 16, 1,  64 * 1024);
-			setup_sector(bank, 17, 3, 128 * 1024);
-		} else {
-			setup_sector(bank,  5, 7, 128 * 1024);
-			setup_sector(bank, 12, 4,  16 * 1024);
-			setup_sector(bank, 16, 1,  64 * 1024);
-			setup_sector(bank, 17, 7, 128 * 1024);
+		/* dual-bank */
+		setup_bank(bank, 0, flash_size_in_kb >> 1, max_sector_size_in_kb);
+		setup_bank(bank, num_pages >> 1, flash_size_in_kb >> 1,
+			max_sector_size_in_kb);
+
+		/* F767x/F77x in dual mode, one protection bit refers to two adjacent sectors */
+		if (device_id == 0x451) {
+			for (i = 0; i < num_prot_blocks; i++) {
+				bank->prot_blocks[i].offset = bank->sectors[i << 1].offset;
+				bank->prot_blocks[i].size = bank->sectors[i << 1].size << 1;
+			}
 		}
 	} else {
-		setup_sector(bank, 4 + 1, MIN(12, num_pages) - 5,
-					 max_sector_size_in_kb * 1024);
-	}
-	for (i = 0; i < num_pages; i++) {
-		bank->sectors[i].is_erased = -1;
-		bank->sectors[i].is_protected = 0;
+		/* single-bank */
+		setup_bank(bank, 0, flash_size_in_kb, max_sector_size_in_kb);
+
+		/* F413/F423, sectors 14 and 15 share one common protection bit */
+		if (device_id == 0x463) {
+			for (i = 0; i < num_prot_blocks; i++) {
+				bank->prot_blocks[i].offset = bank->sectors[i].offset;
+				bank->prot_blocks[i].size = bank->sectors[i].size;
+			}
+			bank->prot_blocks[num_prot_blocks - 1].size <<= 1;
+		}
 	}
+	bank->num_prot_blocks = num_prot_blocks;
+	assert((bank->size >> 10) == flash_size_in_kb);
 
 	stm32x_info->probed = 1;
-
 	return ERROR_OK;
 }
 
@@ -948,6 +1116,18 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 		case 0x2003:
 			rev_str = "X";
 			break;
+
+		case 0x2007:
+			rev_str = "1";
+			break;
+
+		case 0x200F:
+			rev_str = "V";
+			break;
+
+		case 0x201F:
+			rev_str = "2";
+			break;
 		}
 		break;
 
@@ -978,6 +1158,7 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 			break;
 		}
 		break;
+
 	case 0x421:
 		device_str = "STM32F446";
 
@@ -987,9 +1168,12 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 			break;
 		}
 		break;
+
 	case 0x423:
 	case 0x431:
 	case 0x433:
+	case 0x458:
+	case 0x441:
 		device_str = "STM32F4xx (Low Power)";
 
 		switch (rev_id) {
@@ -1000,6 +1184,14 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 		case 0x1001:
 			rev_str = "Z";
 			break;
+
+		case 0x2000:
+			rev_str = "B";
+			break;
+
+		case 0x3000:
+			rev_str = "C";
+			break;
 		}
 		break;
 
@@ -1017,6 +1209,36 @@ static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 		}
 		break;
 
+	case 0x451:
+		device_str = "STM32F7[6|7]x";
+
+		switch (rev_id) {
+		case 0x1000:
+			rev_str = "A";
+			break;
+		}
+		break;
+
+	case 0x452:
+		device_str = "STM32F7[2|3]x";
+
+		switch (rev_id) {
+		case 0x1000:
+			rev_str = "A";
+			break;
+		}
+		break;
+
+	case 0x463:
+		device_str = "STM32F4[1|2]3";
+
+		switch (rev_id) {
+		case 0x1000:
+			rev_str = "A";
+			break;
+		}
+		break;
+
 	default:
 		snprintf(buf, buf_size, "Cannot identify target as a STM32F2/4/7\n");
 		return ERROR_FAIL;
@@ -1047,8 +1269,8 @@ COMMAND_HANDLER(stm32x_handle_lock_command)
 	target = bank->target;
 
 	if (target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+		LOG_INFO("Target not halted");
+		/* return ERROR_TARGET_NOT_HALTED; */
 	}
 
 	if (stm32x_read_options(bank) != ERROR_OK) {
@@ -1086,8 +1308,8 @@ COMMAND_HANDLER(stm32x_handle_unlock_command)
 	target = bank->target;
 
 	if (target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+		LOG_INFO("Target not halted");
+		/* return ERROR_TARGET_NOT_HALTED; */
 	}
 
 	if (stm32x_read_options(bank) != ERROR_OK) {
@@ -1098,6 +1320,9 @@ COMMAND_HANDLER(stm32x_handle_unlock_command)
 	/* clear readout protection and complementary option bytes
 	 * this will also force a device unlock if set */
 	stm32x_info->option_bytes.RDP = 0xAA;
+	if (stm32x_info->has_optcr2_pcrop) {
+		stm32x_info->option_bytes.optcr2_pcrop = OPTCR2_PCROP_RDP | (~1U << bank->num_sectors);
+	}
 
 	if (stm32x_write_options(bank) != ERROR_OK) {
 		command_print(CMD_CTX, "%s failed to unlock device", bank->driver->name);
@@ -1114,6 +1339,7 @@ COMMAND_HANDLER(stm32x_handle_unlock_command)
 static int stm32x_mass_erase(struct flash_bank *bank)
 {
 	int retval;
+	uint32_t flash_mer;
 	struct target *target = bank->target;
 	struct stm32x_flash_bank *stm32x_info = NULL;
 
@@ -1130,17 +1356,19 @@ static int stm32x_mass_erase(struct flash_bank *bank)
 
 	/* mass erase flash memory */
 	if (stm32x_info->has_large_mem)
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER | FLASH_MER1);
+		flash_mer = FLASH_MER | FLASH_MER1;
 	else
-		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_MER);
+		flash_mer = FLASH_MER;
+
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), flash_mer);
 	if (retval != ERROR_OK)
 		return retval;
 	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
-		FLASH_MER | FLASH_STRT);
+		flash_mer | FLASH_STRT);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = stm32x_wait_status_busy(bank, 30000);
+	retval = stm32x_wait_status_busy(bank, FLASH_MASS_ERASE_TIMEOUT);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1179,6 +1407,155 @@ COMMAND_HANDLER(stm32x_handle_mass_erase_command)
 	return retval;
 }
 
+COMMAND_HANDLER(stm32f2x_handle_options_read_command)
+{
+	int retval;
+	struct flash_bank *bank;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+
+	if (CMD_ARGC != 1) {
+		command_print(CMD_CTX, "stm32f2x options_read <bank>");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = stm32x_read_options(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	stm32x_info = bank->driver_priv;
+	if (stm32x_info->has_extra_options) {
+		if (stm32x_info->has_boot_addr) {
+			uint32_t boot_addr = stm32x_info->option_bytes.boot_addr;
+
+			command_print(CMD_CTX, "stm32f2x user_options 0x%03X,"
+				" boot_add0 0x%04X, boot_add1 0x%04X",
+				stm32x_info->option_bytes.user_options,
+				boot_addr & 0xffff, (boot_addr & 0xffff0000) >> 16);
+			if (stm32x_info->has_optcr2_pcrop) {
+				command_print(CMD_CTX, "stm32f2x optcr2_pcrop 0x%08X",
+						stm32x_info->option_bytes.optcr2_pcrop);
+			}
+		} else {
+			command_print(CMD_CTX, "stm32f2x user_options 0x%03X",
+				stm32x_info->option_bytes.user_options);
+		}
+	} else {
+		command_print(CMD_CTX, "stm32f2x user_options 0x%02X",
+			stm32x_info->option_bytes.user_options);
+
+	}
+
+	return retval;
+}
+
+COMMAND_HANDLER(stm32f2x_handle_options_write_command)
+{
+	int retval;
+	struct flash_bank *bank;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	uint16_t user_options, boot_addr0, boot_addr1, options_mask;
+
+	if (CMD_ARGC < 1) {
+		command_print(CMD_CTX, "stm32f2x options_write <bank> ...");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = stm32x_read_options(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	stm32x_info = bank->driver_priv;
+	if (stm32x_info->has_boot_addr) {
+		if (CMD_ARGC != 4) {
+			command_print(CMD_CTX, "stm32f2x options_write <bank> <user_options>"
+				" <boot_addr0> <boot_addr1>");
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[2], boot_addr0);
+		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[3], boot_addr1);
+		stm32x_info->option_bytes.boot_addr = boot_addr0 | (((uint32_t) boot_addr1) << 16);
+	} else {
+		if (CMD_ARGC != 2) {
+			command_print(CMD_CTX, "stm32f2x options_write <bank> <user_options>");
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	}
+
+	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[1], user_options);
+	options_mask = !stm32x_info->has_extra_options ? ~0xfc :
+		~(((0xf00 << (stm32x_info->protection_bits - 12)) | 0xff) & 0xffc);
+	if (user_options & options_mask) {
+		command_print(CMD_CTX, "stm32f2x invalid user_options");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	stm32x_info->option_bytes.user_options = user_options;
+
+	if (stm32x_write_options(bank) != ERROR_OK) {
+		command_print(CMD_CTX, "stm32f2x failed to write options");
+		return ERROR_OK;
+	}
+
+	/* switching between single- and dual-bank modes requires re-probe */
+	/* ... and reprogramming of whole flash */
+	stm32x_info->probed = 0;
+
+	command_print(CMD_CTX, "stm32f2x write options complete.\n"
+				"INFO: a reset or power cycle is required "
+				"for the new settings to take effect.");
+	return retval;
+}
+
+COMMAND_HANDLER(stm32f2x_handle_optcr2_write_command)
+{
+	int retval;
+	struct flash_bank *bank;
+	struct stm32x_flash_bank *stm32x_info = NULL;
+	uint32_t optcr2_pcrop;
+
+	if (CMD_ARGC != 2) {
+		command_print(CMD_CTX, "stm32f2x optcr2_write <bank> <optcr2_value>");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	stm32x_info = bank->driver_priv;
+	if (!stm32x_info->has_optcr2_pcrop) {
+		command_print(CMD_CTX, "no optcr2 register");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	command_print(CMD_CTX, "INFO: To disable PCROP, set PCROP_RDP"
+				" with PCROPi bits STILL SET, then\nlock device and"
+				" finally unlock it. Clears PCROP and mass erases flash.");
+
+	retval = stm32x_read_options(bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], optcr2_pcrop);
+	stm32x_info->option_bytes.optcr2_pcrop = optcr2_pcrop;
+
+	if (stm32x_write_options(bank) != ERROR_OK) {
+		command_print(CMD_CTX, "stm32f2x failed to write options");
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, "stm32f2x optcr2_write complete.");
+	return retval;
+}
+
 static const struct command_registration stm32x_exec_command_handlers[] = {
 	{
 		.name = "lock",
@@ -1201,6 +1578,28 @@ static const struct command_registration stm32x_exec_command_handlers[] = {
 		.usage = "bank_id",
 		.help = "Erase entire flash device.",
 	},
+	{
+		.name = "options_read",
+		.handler = stm32f2x_handle_options_read_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Read and display device option bytes.",
+	},
+	{
+		.name = "options_write",
+		.handler = stm32f2x_handle_options_write_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id user_options [ boot_add0 boot_add1 ]",
+		.help = "Write option bytes",
+	},
+	{
+		.name = "optcr2_write",
+		.handler = stm32f2x_handle_optcr2_write_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id optcr2",
+		.help = "Write optcr2 word",
+	},
+
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/flash/nor/stm32l4x.c b/src/flash/nor/stm32l4x.c
index 6bdb51d6..fa0c48b4 100644
--- a/src/flash/nor/stm32l4x.c
+++ b/src/flash/nor/stm32l4x.c
@@ -13,8 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.                                        *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -28,18 +27,22 @@
 
 /* STM32L4xxx series for reference.
  *
- * RM0351
- * http://www.st.com/st-web-ui/static/active/en/resource/technical/document/reference_manual/DM00083560.pdf
+ * RM0351 (STM32L4x5/STM32L4x6)
+ * http://www.st.com/resource/en/reference_manual/dm00083560.pdf
  *
- * STM32L476RG Datasheet (for erase timing)
- * http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/DM00108832.pdf
+ * RM0394 (STM32L43x/44x/45x/46x)
+ * http://www.st.com/resource/en/reference_manual/dm00151940.pdf
  *
+ * STM32L476RG Datasheet (for erase timing)
+ * http://www.st.com/resource/en/datasheet/stm32l476rg.pdf
  *
- * The device has normally two banks, but on 512 and 256 kiB devices an
- * option byte is available to map all sectors to the first bank.
+ * The RM0351 devices have normally two banks, but on 512 and 256 kiB devices
+ * an option byte is available to map all sectors to the first bank.
  * Both STM32 banks are treated as one OpenOCD bank, as other STM32 devices
  * handlers do!
  *
+ * RM0394 devices have a single bank only.
+ *
  */
 
 /* Erase time can be as high as 25ms, 10x this and assume it's toast... */
@@ -463,21 +466,21 @@ static int stm32l4_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	 */
 
 	static const uint8_t stm32l4_flash_write_code[] = {
-		0xd0, 0xf8, 0x00, 0x80, 0xb8, 0xf1, 0x00, 0x0f, 0x22, 0xd0, 0x47, 0x68,
-		0xb8, 0xeb, 0x07, 0x06, 0x07, 0x2e, 0xf5, 0xd3, 0xdf, 0xf8, 0x3c, 0x60,
-		0x66, 0x61, 0x57, 0xf8, 0x04, 0x6b, 0x42, 0xf8, 0x04, 0x6b, 0x57, 0xf8,
-		0x04, 0x6b, 0x42, 0xf8, 0x04, 0x6b, 0xbf, 0xf3, 0x4f, 0x8f, 0x26, 0x69,
-		0x16, 0xf4, 0x80, 0x3f, 0xfb, 0xd1, 0x16, 0xf0, 0xfa, 0x0f, 0x07, 0xd1,
-		0x8f, 0x42, 0x28, 0xbf, 0x00, 0xf1, 0x08, 0x07, 0x47, 0x60, 0x01, 0x3b,
-		0x13, 0xb1, 0xd9, 0xe7, 0x00, 0x21, 0x41, 0x60, 0x30, 0x46, 0x00, 0xbe,
-		0x01, 0x00, 0x00, 0x00
+		0xd0, 0xf8, 0x00, 0x80, 0xb8, 0xf1, 0x00, 0x0f, 0x21, 0xd0, 0x45, 0x68,
+		0xb8, 0xeb, 0x05, 0x06, 0x44, 0xbf, 0x76, 0x18, 0x36, 0x1a, 0x08, 0x2e,
+		0xf2, 0xd3, 0xdf, 0xf8, 0x36, 0x60, 0x66, 0x61, 0xf5, 0xe8, 0x02, 0x67,
+		0xe2, 0xe8, 0x02, 0x67, 0xbf, 0xf3, 0x4f, 0x8f, 0x26, 0x69, 0x16, 0xf4,
+		0x80, 0x3f, 0xfb, 0xd1, 0x16, 0xf0, 0xfa, 0x0f, 0x07, 0xd1, 0x8d, 0x42,
+		0x28, 0xbf, 0x00, 0xf1, 0x08, 0x05, 0x45, 0x60, 0x01, 0x3b, 0x13, 0xb1,
+		0xda, 0xe7, 0x00, 0x21, 0x41, 0x60, 0x30, 0x46, 0x00, 0xbe, 0x01, 0x00,
+		0x00, 0x00
 	};
 
 	if (target_alloc_working_area(target, sizeof(stm32l4_flash_write_code),
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	retval = target_write_buffer(target, write_algorithm->address,
 			sizeof(stm32l4_flash_write_code),
@@ -497,7 +500,7 @@ static int stm32l4_write_block(struct flash_bank *bank, const uint8_t *buffer,
 			LOG_WARNING("no large enough working area available, can't do block memory writes");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-	};
+	}
 
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
@@ -600,6 +603,7 @@ static int stm32l4_probe(struct flash_bank *bank)
 	struct stm32l4_flash_bank *stm32l4_info = bank->driver_priv;
 	int i;
 	uint16_t flash_size_in_kb = 0xffff;
+	uint16_t max_flash_size_in_kb;
 	uint32_t device_id;
 	uint32_t options;
 	uint32_t base_address = 0x08000000;
@@ -614,7 +618,15 @@ static int stm32l4_probe(struct flash_bank *bank)
 
 	/* set max flash size depending on family */
 	switch (device_id & 0xfff) {
+	case 0x461:
 	case 0x415:
+		max_flash_size_in_kb = 1024;
+		break;
+	case 0x462:
+		max_flash_size_in_kb = 512;
+		break;
+	case 0x435:
+		max_flash_size_in_kb = 256;
 		break;
 	default:
 		LOG_WARNING("Cannot identify target as a STM32L4 family.");
@@ -624,6 +636,19 @@ static int stm32l4_probe(struct flash_bank *bank)
 	/* get flash size from target. */
 	retval = target_read_u16(target, FLASH_SIZE_REG, &flash_size_in_kb);
 
+	/* failed reading flash size or flash size invalid (early silicon),
+	 * default to max target family */
+	if (retval != ERROR_OK || flash_size_in_kb == 0xffff || flash_size_in_kb == 0) {
+		LOG_WARNING("STM32 flash size failed, probe inaccurate - assuming %dk flash",
+			max_flash_size_in_kb);
+		flash_size_in_kb = max_flash_size_in_kb;
+	}
+
+	LOG_INFO("flash size = %dkbytes", flash_size_in_kb);
+
+	/* did we assign flash size? */
+	assert(flash_size_in_kb != 0xffff);
+
 	/* get options to for DUAL BANK. */
 	retval = target_read_u32(target, STM32_FLASH_OPTR, &options);
 
@@ -633,8 +658,6 @@ static int stm32l4_probe(struct flash_bank *bank)
 	else
 		stm32l4_info->option_bytes.bank_b_start = flash_size_in_kb << 9;
 
-	LOG_INFO("flash size = %dkbytes", flash_size_in_kb);
-
 	/* did we assign flash size? */
 	assert((flash_size_in_kb != 0xffff) && flash_size_in_kb);
 
@@ -686,7 +709,7 @@ static int get_stm32l4_info(struct flash_bank *bank, char *buf, int buf_size)
 	if (retval != ERROR_OK)
 		return retval;
 
-	uint16_t device_id = dbgmcu_idcode & 0xffff;
+	uint16_t device_id = dbgmcu_idcode & 0xfff;
 	uint8_t rev_id = dbgmcu_idcode >> 28;
 	uint8_t rev_minor = 0;
 	int i;
@@ -701,8 +724,20 @@ static int get_stm32l4_info(struct flash_bank *bank, char *buf, int buf_size)
 	const char *device_str;
 
 	switch (device_id) {
-	case 0x6415:
-		device_str = "STM32L4xx";
+	case 0x461:
+		device_str = "STM32L496/4A6";
+		break;
+
+	case 0x415:
+		device_str = "STM32L475/476/486";
+		break;
+
+	case 0x462:
+		device_str = "STM32L45x/46x";
+		break;
+
+	case 0x435:
+		device_str = "STM32L43x/44x";
 		break;
 
 	default:
diff --git a/src/flash/nor/stm32lx.c b/src/flash/nor/stm32lx.c
index 7b0b0cc1..fdfaad4c 100644
--- a/src/flash/nor/stm32lx.c
+++ b/src/flash/nor/stm32lx.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -103,8 +101,11 @@ static int stm32lx_lock_program_memory(struct flash_bank *bank);
 static int stm32lx_enable_write_half_page(struct flash_bank *bank);
 static int stm32lx_erase_sector(struct flash_bank *bank, int sector);
 static int stm32lx_wait_until_bsy_clear(struct flash_bank *bank);
+static int stm32lx_lock(struct flash_bank *bank);
+static int stm32lx_unlock(struct flash_bank *bank);
 static int stm32lx_mass_erase(struct flash_bank *bank);
 static int stm32lx_wait_until_bsy_clear_timeout(struct flash_bank *bank, int timeout);
+static int stm32lx_update_part_info(struct flash_bank *bank, uint16_t flash_size_in_kb);
 
 struct stm32lx_rev {
 	uint16_t rev;
@@ -132,14 +133,17 @@ struct stm32lx_flash_bank {
 	uint32_t user_bank_size;
 	uint32_t flash_base;
 
-	const struct stm32lx_part_info *part_info;
+	struct stm32lx_part_info part_info;
 };
 
 static const struct stm32lx_rev stm32_416_revs[] = {
 	{ 0x1000, "A" }, { 0x1008, "Y" }, { 0x1038, "W" }, { 0x1078, "V" },
 };
 static const struct stm32lx_rev stm32_417_revs[] = {
-	{ 0x1000, "A" }, { 0x1008, "Z" },
+	{ 0x1000, "A" }, { 0x1008, "Z" }, { 0x1018, "Y" }, { 0x1038, "X" }
+};
+static const struct stm32lx_rev stm32_425_revs[] = {
+	{ 0x1000, "A" }, { 0x2000, "B" }, { 0x2008, "Y" },
 };
 static const struct stm32lx_rev stm32_427_revs[] = {
 	{ 0x1000, "A" }, { 0x1018, "Y" }, { 0x1038, "X" },
@@ -153,6 +157,12 @@ static const struct stm32lx_rev stm32_436_revs[] = {
 static const struct stm32lx_rev stm32_437_revs[] = {
 	{ 0x1000, "A" },
 };
+static const struct stm32lx_rev stm32_447_revs[] = {
+	{ 0x1000, "A" }, { 0x2000, "B" }, { 0x2008, "Z" },
+};
+static const struct stm32lx_rev stm32_457_revs[] = {
+	{ 0x1000, "A" }, { 0x1008, "Z" },
+};
 
 static const struct stm32lx_part_info stm32lx_parts[] = {
 	{
@@ -171,7 +181,7 @@ static const struct stm32lx_part_info stm32lx_parts[] = {
 		.id					= 0x417,
 		.revs				= stm32_417_revs,
 		.num_revs			= ARRAY_SIZE(stm32_417_revs),
-		.device_str			= "STM32L0xx",
+		.device_str			= "STM32L0xx (Cat. 3)",
 		.page_size			= 128,
 		.pages_per_sector	= 32,
 		.max_flash_size_kb	= 64,
@@ -179,6 +189,18 @@ static const struct stm32lx_part_info stm32lx_parts[] = {
 		.flash_base			= 0x40022000,
 		.fsize_base			= 0x1FF8007C,
 	},
+	{
+		.id					= 0x425,
+		.revs				= stm32_425_revs,
+		.num_revs			= ARRAY_SIZE(stm32_425_revs),
+		.device_str			= "STM32L0xx (Cat. 2)",
+		.page_size			= 128,
+		.pages_per_sector	= 32,
+		.max_flash_size_kb	= 32,
+		.has_dual_banks		= false,
+		.flash_base			= 0x40022000,
+		.fsize_base			= 0x1FF8007C,
+	},
 	{
 		.id					= 0x427,
 		.revs				= stm32_427_revs,
@@ -187,8 +209,7 @@ static const struct stm32lx_part_info stm32lx_parts[] = {
 		.page_size			= 256,
 		.pages_per_sector	= 16,
 		.max_flash_size_kb	= 256,
-		.first_bank_size_kb	= 192,
-		.has_dual_banks		= true,
+		.has_dual_banks		= false,
 		.flash_base			= 0x40023C00,
 		.fsize_base			= 0x1FF800CC,
 	},
@@ -225,11 +246,36 @@ static const struct stm32lx_part_info stm32lx_parts[] = {
 		.page_size			= 256,
 		.pages_per_sector	= 16,
 		.max_flash_size_kb	= 512,
-		.first_bank_size_kb	= 256,
+		.first_bank_size_kb	= 0,		/* determined in runtime */
 		.has_dual_banks		= true,
 		.flash_base			= 0x40023C00,
 		.fsize_base			= 0x1FF800CC,
 	},
+	{
+		.id					= 0x447,
+		.revs				= stm32_447_revs,
+		.num_revs			= ARRAY_SIZE(stm32_447_revs),
+		.device_str			= "STM32L0xx (Cat.5)",
+		.page_size			= 128,
+		.pages_per_sector	= 32,
+		.max_flash_size_kb	= 192,
+		.first_bank_size_kb	= 0,		/* determined in runtime */
+		.has_dual_banks		= false,	/* determined in runtime */
+		.flash_base			= 0x40022000,
+		.fsize_base			= 0x1FF8007C,
+	},
+	{
+		.id					= 0x457,
+		.revs				= stm32_457_revs,
+		.num_revs			= ARRAY_SIZE(stm32_457_revs),
+		.device_str			= "STM32L0xx (Cat.1)",
+		.page_size			= 128,
+		.pages_per_sector	= 32,
+		.max_flash_size_kb	= 16,
+		.has_dual_banks		= false,
+		.flash_base			= 0x40022000,
+		.fsize_base			= 0x1FF8007C,
+	},
 };
 
 /* flash bank stm32lx <base> <size> 0 0 <target#>
@@ -255,7 +301,7 @@ FLASH_BANK_COMMAND_HANDLER(stm32lx_flash_bank_command)
 	stm32lx_info->user_bank_size = bank->size;
 
 	/* the stm32l erased value is 0x00 */
-	bank->default_padded_value = 0x00;
+	bank->default_padded_value = bank->erased_value = 0x00;
 
 	return ERROR_OK;
 }
@@ -286,6 +332,46 @@ COMMAND_HANDLER(stm32lx_handle_mass_erase_command)
 	return retval;
 }
 
+COMMAND_HANDLER(stm32lx_handle_lock_command)
+{
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = stm32lx_lock(bank);
+
+	if (retval == ERROR_OK)
+		command_print(CMD_CTX, "STM32Lx locked, takes effect after power cycle.");
+	else
+		command_print(CMD_CTX, "STM32Lx lock failed");
+
+	return retval;
+}
+
+COMMAND_HANDLER(stm32lx_handle_unlock_command)
+{
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	retval = stm32lx_unlock(bank);
+
+	if (retval == ERROR_OK)
+		command_print(CMD_CTX, "STM32Lx unlocked, takes effect after power cycle.");
+	else
+		command_print(CMD_CTX, "STM32Lx unlock failed");
+
+	return retval;
+}
+
 static int stm32lx_protect_check(struct flash_bank *bank)
 {
 	int retval;
@@ -351,7 +437,7 @@ static int stm32lx_write_half_pages(struct flash_bank *bank, const uint8_t *buff
 	struct target *target = bank->target;
 	struct stm32lx_flash_bank *stm32lx_info = bank->driver_priv;
 
-	uint32_t hp_nb = stm32lx_info->part_info->page_size / 2;
+	uint32_t hp_nb = stm32lx_info->part_info.page_size / 2;
 	uint32_t buffer_size = 16384;
 	struct working_area *write_algorithm;
 	struct working_area *source;
@@ -365,19 +451,7 @@ static int stm32lx_write_half_pages(struct flash_bank *bank, const uint8_t *buff
 	/* see contib/loaders/flash/stm32lx.S for src */
 
 	static const uint8_t stm32lx_flash_write_code[] = {
-		/* write_word: */
-		0x00, 0x23,             /* movs r3, #0 */
-		0x04, 0xe0,             /* b test_done */
-
-		/* write_word: */
-		0x51, 0xf8, 0x04, 0xcb, /* ldr ip, [r1], #4 */
-		0x40, 0xf8, 0x04, 0xcb, /* str ip, [r0], #4 */
-		0x01, 0x33,             /* adds r3, #1 */
-
-		/* test_done: */
-		0x93, 0x42,             /* cmp r3, r2 */
-		0xf8, 0xd3,             /* bcc write_word */
-		0x00, 0xbe,             /* bkpt 0 */
+			0x92, 0x00, 0x8A, 0x18, 0x01, 0xE0, 0x08, 0xC9, 0x08, 0xC0, 0x91, 0x42, 0xFB, 0xD1, 0x00, 0xBE
 	};
 
 	/* Make sure we're performing a half-page aligned write. */
@@ -391,7 +465,7 @@ static int stm32lx_write_half_pages(struct flash_bank *bank, const uint8_t *buff
 			&write_algorithm) != ERROR_OK) {
 		LOG_DEBUG("no working area for block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	/* Write the flashing code */
 	retval = target_write_buffer(target,
@@ -410,7 +484,7 @@ static int stm32lx_write_half_pages(struct flash_bank *bank, const uint8_t *buff
 		else
 			buffer_size /= 2;
 
-		if (buffer_size <= stm32lx_info->part_info->page_size) {
+		if (buffer_size <= stm32lx_info->part_info.page_size) {
 			/* we already allocated the writing code, but failed to get a
 			 * buffer, free the algorithm */
 			target_free_working_area(target, write_algorithm);
@@ -503,7 +577,7 @@ static int stm32lx_write_half_pages(struct flash_bank *bank, const uint8_t *buff
 		 * is reduced by 50% using this slower method.
 		 */
 
-		LOG_WARNING("couldn't use loader, falling back to page memory writes");
+		LOG_WARNING("Couldn't use loader, falling back to page memory writes");
 
 		while (count > 0) {
 			uint32_t this_count;
@@ -544,7 +618,7 @@ static int stm32lx_write(struct flash_bank *bank, const uint8_t *buffer,
 	struct target *target = bank->target;
 	struct stm32lx_flash_bank *stm32lx_info = bank->driver_priv;
 
-	uint32_t hp_nb = stm32lx_info->part_info->page_size / 2;
+	uint32_t hp_nb = stm32lx_info->part_info.page_size / 2;
 	uint32_t halfpages_number;
 	uint32_t bytes_remaining = 0;
 	uint32_t address = bank->base + offset;
@@ -652,16 +726,13 @@ reset_pg_and_lock:
 
 static int stm32lx_read_id_code(struct target *target, uint32_t *id)
 {
-	/* read stm32 device id register */
-	int retval = target_read_u32(target, DBGMCU_IDCODE, id);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* STM32L0 parts will have 0 there, try reading the L0's location for
-	 * DBG_IDCODE in case this is an L0 part. */
-	if (*id == 0)
+	struct armv7m_common *armv7m = target_to_armv7m(target);
+	int retval;
+	if (armv7m->arm.is_armv6m == true)
 		retval = target_read_u32(target, DBGMCU_IDCODE_L0, id);
-
+	else
+	/* read stm32 device id register */
+		retval = target_read_u32(target, DBGMCU_IDCODE, id);
 	return retval;
 }
 
@@ -674,9 +745,9 @@ static int stm32lx_probe(struct flash_bank *bank)
 	uint32_t device_id;
 	uint32_t base_address = FLASH_BANK0_ADDRESS;
 	uint32_t second_bank_base;
+	unsigned int n;
 
 	stm32lx_info->probed = 0;
-	stm32lx_info->part_info = NULL;
 
 	int retval = stm32lx_read_id_code(bank->target, &device_id);
 	if (retval != ERROR_OK)
@@ -686,20 +757,24 @@ static int stm32lx_probe(struct flash_bank *bank)
 
 	LOG_DEBUG("device id = 0x%08" PRIx32 "", device_id);
 
-	for (unsigned int n = 0; n < ARRAY_SIZE(stm32lx_parts); n++) {
-		if ((device_id & 0xfff) == stm32lx_parts[n].id)
-			stm32lx_info->part_info = &stm32lx_parts[n];
+	for (n = 0; n < ARRAY_SIZE(stm32lx_parts); n++) {
+		if ((device_id & 0xfff) == stm32lx_parts[n].id) {
+			stm32lx_info->part_info = stm32lx_parts[n];
+			break;
+		}
 	}
 
-	if (!stm32lx_info->part_info) {
+	if (n == ARRAY_SIZE(stm32lx_parts)) {
 		LOG_WARNING("Cannot identify target as a STM32L family.");
 		return ERROR_FAIL;
+	} else {
+		LOG_INFO("Device: %s", stm32lx_info->part_info.device_str);
 	}
 
-	stm32lx_info->flash_base = stm32lx_info->part_info->flash_base;
+	stm32lx_info->flash_base = stm32lx_info->part_info.flash_base;
 
 	/* Get the flash size from target. */
-	retval = target_read_u16(target, stm32lx_info->part_info->fsize_base,
+	retval = target_read_u16(target, stm32lx_info->part_info.fsize_base,
 			&flash_size_in_kb);
 
 	/* 0x436 devices report their flash size as a 0 or 1 code indicating 384K
@@ -712,33 +787,43 @@ static int stm32lx_probe(struct flash_bank *bank)
 			flash_size_in_kb = 256;
 	}
 
+	/* 0x429 devices only use the lowest 8 bits of the flash size register */
+	if (retval == ERROR_OK && (device_id & 0xfff) == 0x429) {
+		flash_size_in_kb &= 0xff;
+	}
+
 	/* Failed reading flash size or flash size invalid (early silicon),
 	 * default to max target family */
 	if (retval != ERROR_OK || flash_size_in_kb == 0xffff || flash_size_in_kb == 0) {
 		LOG_WARNING("STM32L flash size failed, probe inaccurate - assuming %dk flash",
-			stm32lx_info->part_info->max_flash_size_kb);
-		flash_size_in_kb = stm32lx_info->part_info->max_flash_size_kb;
-	} else if (flash_size_in_kb > stm32lx_info->part_info->max_flash_size_kb) {
+			stm32lx_info->part_info.max_flash_size_kb);
+		flash_size_in_kb = stm32lx_info->part_info.max_flash_size_kb;
+	} else if (flash_size_in_kb > stm32lx_info->part_info.max_flash_size_kb) {
 		LOG_WARNING("STM32L probed flash size assumed incorrect since FLASH_SIZE=%dk > %dk, - assuming %dk flash",
-			flash_size_in_kb, stm32lx_info->part_info->max_flash_size_kb,
-			stm32lx_info->part_info->max_flash_size_kb);
-		flash_size_in_kb = stm32lx_info->part_info->max_flash_size_kb;
+			flash_size_in_kb, stm32lx_info->part_info.max_flash_size_kb,
+			stm32lx_info->part_info.max_flash_size_kb);
+		flash_size_in_kb = stm32lx_info->part_info.max_flash_size_kb;
 	}
 
-	if (stm32lx_info->part_info->has_dual_banks) {
+	/* Overwrite default dual-bank configuration */
+	retval = stm32lx_update_part_info(bank, flash_size_in_kb);
+	if (retval != ERROR_OK)
+		return ERROR_FAIL;
+
+	if (stm32lx_info->part_info.has_dual_banks) {
 		/* Use the configured base address to determine if this is the first or second flash bank.
 		 * Verify that the base address is reasonably correct and determine the flash bank size
 		 */
 		second_bank_base = base_address +
-			stm32lx_info->part_info->first_bank_size_kb * 1024;
+			stm32lx_info->part_info.first_bank_size_kb * 1024;
 		if (bank->base == second_bank_base || !bank->base) {
 			/* This is the second bank  */
 			base_address = second_bank_base;
 			flash_size_in_kb = flash_size_in_kb -
-				stm32lx_info->part_info->first_bank_size_kb;
+				stm32lx_info->part_info.first_bank_size_kb;
 		} else if (bank->base == base_address) {
 			/* This is the first bank */
-			flash_size_in_kb = stm32lx_info->part_info->first_bank_size_kb;
+			flash_size_in_kb = stm32lx_info->part_info.first_bank_size_kb;
 		} else {
 			LOG_WARNING("STM32L flash bank base address config is incorrect."
 				    " 0x%" PRIx32 " but should rather be 0x%" PRIx32 " or 0x%" PRIx32,
@@ -797,60 +882,13 @@ static int stm32lx_auto_probe(struct flash_bank *bank)
 	return stm32lx_probe(bank);
 }
 
-static int stm32lx_erase_check(struct flash_bank *bank)
-{
-	struct target *target = bank->target;
-	const int buffer_size = 4096;
-	int i;
-	uint32_t nBytes;
-	int retval = ERROR_OK;
-
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	uint8_t *buffer = malloc(buffer_size);
-	if (buffer == NULL) {
-		LOG_ERROR("failed to allocate read buffer");
-		return ERROR_FAIL;
-	}
-
-	for (i = 0; i < bank->num_sectors; i++) {
-		uint32_t j;
-		bank->sectors[i].is_erased = 1;
-
-		/* Loop chunk by chunk over the sector */
-		for (j = 0; j < bank->sectors[i].size; j += buffer_size) {
-			uint32_t chunk;
-			chunk = buffer_size;
-			if (chunk > (j - bank->sectors[i].size))
-				chunk = (j - bank->sectors[i].size);
-
-			retval = target_read_memory(target, bank->base
-					+ bank->sectors[i].offset + j, 4, chunk / 4, buffer);
-			if (retval != ERROR_OK)
-				break;
-
-			for (nBytes = 0; nBytes < chunk; nBytes++) {
-				if (buffer[nBytes] != 0x00) {
-					bank->sectors[i].is_erased = 0;
-					break;
-				}
-			}
-		}
-		if (retval != ERROR_OK)
-			break;
-	}
-	free(buffer);
-
-	return retval;
-}
-
 /* This method must return a string displaying information about the bank */
 static int stm32lx_get_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	struct stm32lx_flash_bank *stm32lx_info = bank->driver_priv;
+	const struct stm32lx_part_info *info = &stm32lx_info->part_info;
+	uint16_t rev_id = stm32lx_info->idcode >> 16;
+	const char *rev_str = NULL;
 
 	if (!stm32lx_info->probed) {
 		int retval = stm32lx_probe(bank);
@@ -861,32 +899,21 @@ static int stm32lx_get_info(struct flash_bank *bank, char *buf, int buf_size)
 		}
 	}
 
-	const struct stm32lx_part_info *info = stm32lx_info->part_info;
-
-	if (info) {
-		const char *rev_str = NULL;
-		uint16_t rev_id = stm32lx_info->idcode >> 16;
+	for (unsigned int i = 0; i < info->num_revs; i++)
+		if (rev_id == info->revs[i].rev)
+			rev_str = info->revs[i].str;
 
-		for (unsigned int i = 0; i < info->num_revs; i++)
-			if (rev_id == info->revs[i].rev)
-				rev_str = info->revs[i].str;
-
-		if (rev_str != NULL) {
-			snprintf(buf, buf_size,
-				"%s - Rev: %s",
-				stm32lx_info->part_info->device_str, rev_str);
-		} else {
-			snprintf(buf, buf_size,
-				"%s - Rev: unknown (0x%04x)",
-				stm32lx_info->part_info->device_str, rev_id);
-		}
-
-		return ERROR_OK;
+	if (rev_str != NULL) {
+		snprintf(buf, buf_size,
+			"%s - Rev: %s",
+			info->device_str, rev_str);
 	} else {
-		snprintf(buf, buf_size, "Cannot identify target as a STM32Lx");
-
-		return ERROR_FAIL;
+		snprintf(buf, buf_size,
+			"%s - Rev: unknown (0x%04x)",
+			info->device_str, rev_id);
 	}
+
+	return ERROR_OK;
 }
 
 static const struct command_registration stm32lx_exec_command_handlers[] = {
@@ -897,6 +924,20 @@ static const struct command_registration stm32lx_exec_command_handlers[] = {
 		.usage = "bank_id",
 		.help = "Erase entire flash device. including available EEPROM",
 	},
+	{
+		.name = "lock",
+		.handler = stm32lx_handle_lock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Increase the readout protection to Level 1.",
+	},
+	{
+		.name = "unlock",
+		.handler = stm32lx_handle_unlock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "Lower the readout protection from Level 1 to 0.",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -921,7 +962,7 @@ struct flash_driver stm32lx_flash = {
 		.read = default_flash_read,
 		.probe = stm32lx_probe,
 		.auto_probe = stm32lx_auto_probe,
-		.erase_check = stm32lx_erase_check,
+		.erase_check = default_flash_blank_check,
 		.protect_check = stm32lx_protect_check,
 		.info = stm32lx_get_info,
 };
@@ -1081,7 +1122,7 @@ static int stm32lx_erase_sector(struct flash_bank *bank, int sector)
 	if (retval != ERROR_OK)
 		return retval;
 
-	for (int page = 0; page < (int)stm32lx_info->part_info->pages_per_sector;
+	for (int page = 0; page < (int)stm32lx_info->part_info.pages_per_sector;
 			page++) {
 		reg32 = FLASH_PECR__PROG | FLASH_PECR__ERASE;
 		retval = target_write_u32(target,
@@ -1094,7 +1135,7 @@ static int stm32lx_erase_sector(struct flash_bank *bank, int sector)
 			return retval;
 
 		uint32_t addr = bank->base + bank->sectors[sector].offset + (page
-				* stm32lx_info->part_info->page_size);
+				* stm32lx_info->part_info.page_size);
 		retval = target_write_u32(target, addr, 0x0);
 		if (retval != ERROR_OK)
 			return retval;
@@ -1230,33 +1271,37 @@ static int stm32lx_obl_launch(struct flash_bank *bank)
 	return tries ? ERROR_OK : ERROR_FAIL;
 }
 
-static int stm32lx_mass_erase(struct flash_bank *bank)
+static int stm32lx_lock(struct flash_bank *bank)
 {
 	int retval;
 	struct target *target = bank->target;
-	struct stm32lx_flash_bank *stm32lx_info = NULL;
-	uint32_t reg32;
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	stm32lx_info = bank->driver_priv;
-
 	retval = stm32lx_unlock_options_bytes(bank);
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* mass erase flash memory */
 	/* set the RDP protection level to 1 */
 	retval = target_write_u32(target, OPTION_BYTES_ADDRESS, OPTION_BYTE_0_PR1);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = stm32lx_obl_launch(bank);
-	if (retval != ERROR_OK)
-		return retval;
+	return ERROR_OK;
+}
+
+static int stm32lx_unlock(struct flash_bank *bank)
+{
+	int retval;
+	struct target *target = bank->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
 
 	retval = stm32lx_unlock_options_bytes(bank);
 	if (retval != ERROR_OK)
@@ -1271,6 +1316,35 @@ static int stm32lx_mass_erase(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
+	return ERROR_OK;
+}
+
+static int stm32lx_mass_erase(struct flash_bank *bank)
+{
+	int retval;
+	struct target *target = bank->target;
+	struct stm32lx_flash_bank *stm32lx_info = NULL;
+	uint32_t reg32;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	stm32lx_info = bank->driver_priv;
+
+	retval = stm32lx_lock(bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32lx_obl_launch(bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = stm32lx_unlock(bank);
+	if (retval != ERROR_OK)
+		return retval;
+
 	retval = stm32lx_obl_launch(bank);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1285,3 +1359,22 @@ static int stm32lx_mass_erase(struct flash_bank *bank)
 
 	return ERROR_OK;
 }
+
+static int stm32lx_update_part_info(struct flash_bank *bank, uint16_t flash_size_in_kb)
+{
+	struct stm32lx_flash_bank *stm32lx_info = bank->driver_priv;
+
+	switch (stm32lx_info->part_info.id) {
+	case 0x447: /* STM32L0xx (Cat.5) devices */
+		if (flash_size_in_kb == 192 || flash_size_in_kb == 128) {
+			stm32lx_info->part_info.first_bank_size_kb = flash_size_in_kb / 2;
+			stm32lx_info->part_info.has_dual_banks = true;
+		}
+		break;
+	case 0x437: /* STM32L1xx (Cat.5/Cat.6) */
+		stm32lx_info->part_info.first_bank_size_kb = flash_size_in_kb / 2;
+		break;
+	}
+
+	return ERROR_OK;
+}
diff --git a/src/flash/nor/stmsmi.c b/src/flash/nor/stmsmi.c
index 6f73c368..781ea3b5 100644
--- a/src/flash/nor/stmsmi.c
+++ b/src/flash/nor/stmsmi.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* STM Serial Memory Interface (SMI) controller is a SPI bus controller
@@ -162,7 +160,7 @@ FLASH_BANK_COMMAND_HANDLER(stmsmi_flash_bank_command)
 /* timeout in ms */
 static int poll_tff(struct target *target, uint32_t io_base, int timeout)
 {
-	long long endtime;
+	int64_t endtime;
 
 	if (SMI_READ_REG(SMI_SR) & SMI_TFF)
 		return ERROR_OK;
@@ -213,7 +211,7 @@ static int wait_till_ready(struct flash_bank *bank, int timeout)
 {
 	uint32_t status;
 	int retval;
-	long long endtime;
+	int64_t endtime;
 
 	endtime = timeval_ms() + timeout;
 	do {
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 515b9751..11179f52 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -487,7 +485,7 @@ static int str7x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	if (target_alloc_working_area_try(target, sizeof(str7x_flash_write_code),
 			&write_algorithm) != ERROR_OK) {
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	uint8_t code[sizeof(str7x_flash_write_code)];
 	target_buffer_set_u32_array(target, code, ARRAY_SIZE(str7x_flash_write_code),
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 8b3c1371..3b7ca2aa 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -390,7 +388,7 @@ static int str9x_write_block(struct flash_bank *bank,
 			&write_algorithm) != ERROR_OK) {
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	};
+	}
 
 	uint8_t code[sizeof(str9x_flash_write_code)];
 	target_buffer_set_u32_array(target, code, ARRAY_SIZE(str9x_flash_write_code),
diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index f0af53a4..eb391e8f 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 8a30e1cd..e5e28011 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -72,16 +70,27 @@ COMMAND_HANDLER(handle_flash_info_command)
 	struct flash_bank *p;
 	int j = 0;
 	int retval;
+	bool show_sectors = false;
+	bool prot_block_available;
 
-	if (CMD_ARGC != 1)
+	if (CMD_ARGC < 1 || CMD_ARGC > 2)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
+	if (CMD_ARGC == 2) {
+		if (strcmp("sectors", CMD_ARGV[1]) == 0)
+			show_sectors = true;
+		else
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
 	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
 	if (retval != ERROR_OK)
 		return retval;
 
 	if (p != NULL) {
 		char buf[1024];
+		int num_blocks;
+		struct flash_sector *block_array;
 
 		/* attempt auto probe */
 		retval = p->driver->auto_probe(p);
@@ -102,22 +111,32 @@ COMMAND_HANDLER(handle_flash_info_command)
 			p->size,
 			p->bus_width,
 			p->chip_width);
-		for (j = 0; j < p->num_sectors; j++) {
-			char *protect_state;
 
-			if (p->sectors[j].is_protected == 0)
+		prot_block_available = p->num_prot_blocks && p->prot_blocks;
+		if (!show_sectors && prot_block_available) {
+			block_array = p->prot_blocks;
+			num_blocks = p->num_prot_blocks;
+		} else {
+			block_array = p->sectors;
+			num_blocks = p->num_sectors;
+		}
+
+		for (j = 0; j < num_blocks; j++) {
+			char *protect_state = "";
+
+			if (block_array[j].is_protected == 0)
 				protect_state = "not protected";
-			else if (p->sectors[j].is_protected == 1)
+			else if (block_array[j].is_protected == 1)
 				protect_state = "protected";
-			else
+			else if (!show_sectors || !prot_block_available)
 				protect_state = "protection state unknown";
 
 			command_print(CMD_CTX,
 				"\t#%3i: 0x%8.8" PRIx32 " (0x%" PRIx32 " %" PRIi32 "kB) %s",
 				j,
-				p->sectors[j].offset,
-				p->sectors[j].size,
-				p->sectors[j].size >> 10,
+				block_array[j].offset,
+				block_array[j].size,
+				block_array[j].size >> 10,
 				protect_state);
 		}
 
@@ -162,6 +181,7 @@ COMMAND_HANDLER(handle_flash_probe_command)
 
 COMMAND_HANDLER(handle_flash_erase_check_command)
 {
+	bool blank = true;
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
@@ -187,10 +207,11 @@ COMMAND_HANDLER(handle_flash_erase_check_command)
 		if (p->sectors[j].is_erased == 0)
 			erase_state = "not erased";
 		else if (p->sectors[j].is_erased == 1)
-			erase_state = "erased";
+			continue;
 		else
 			erase_state = "erase state unknown";
 
+		blank = false;
 		command_print(CMD_CTX,
 			"\t#%3i: 0x%8.8" PRIx32 " (0x%" PRIx32 " %" PRIi32 "kB) %s",
 			j,
@@ -200,6 +221,8 @@ COMMAND_HANDLER(handle_flash_erase_check_command)
 			erase_state);
 	}
 
+	if (blank)
+		command_print(CMD_CTX, "\tBank is erased");
 	return retval;
 }
 
@@ -274,8 +297,8 @@ static int flash_check_sector_parameters(struct command_context *cmd_ctx,
 	}
 
 	if (!(last <= (num_sectors - 1))) {
-		command_print(cmd_ctx, "ERROR: last sector must be <= %d",
-			(int) num_sectors - 1);
+		command_print(cmd_ctx, "ERROR: last sector must be <= %" PRIu32,
+			num_sectors - 1);
 		return ERROR_FAIL;
 	}
 
@@ -318,7 +341,7 @@ COMMAND_HANDLER(handle_flash_erase_command)
 			"in %fs", first, last, p->bank_number, duration_elapsed(&bench));
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 COMMAND_HANDLER(handle_flash_protect_command)
@@ -331,30 +354,35 @@ COMMAND_HANDLER(handle_flash_protect_command)
 
 	struct flash_bank *p;
 	int retval;
+	int num_blocks;
 
 	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
 	if (retval != ERROR_OK)
 		return retval;
 
+	if (p->num_prot_blocks)
+		num_blocks = p->num_prot_blocks;
+	else
+		num_blocks = p->num_sectors;
+
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
 	if (strcmp(CMD_ARGV[2], "last") == 0)
-		last = p->num_sectors - 1;
+		last = num_blocks - 1;
 	else
 		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
 
 	bool set;
 	COMMAND_PARSE_ON_OFF(CMD_ARGV[3], set);
 
-	retval = flash_check_sector_parameters(CMD_CTX, first, last, p->num_sectors);
+	retval = flash_check_sector_parameters(CMD_CTX, first, last, num_blocks);
 	if (retval != ERROR_OK)
 		return retval;
 
 	retval = flash_driver_protect(p, set, first, last);
 	if (retval == ERROR_OK) {
-		command_print(CMD_CTX, "%s protection for sectors %i "
-			"through %i on flash bank %d",
-			(set) ? "set" : "cleared", (int) first,
-			(int) last, p->bank_number);
+		command_print(CMD_CTX, "%s protection for sectors %" PRIu32
+			" through %" PRIu32 " on flash bank %d",
+			(set) ? "set" : "cleared", first, last, p->bank_number);
 	}
 
 	return retval;
@@ -555,9 +583,10 @@ COMMAND_HANDLER(handle_flash_write_bank_command)
 {
 	uint32_t offset;
 	uint8_t *buffer;
-	struct fileio fileio;
+	size_t length;
+	struct fileio *fileio;
 
-	if (CMD_ARGC != 3)
+	if (CMD_ARGC < 2 || CMD_ARGC > 3)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	struct duration bench;
@@ -568,32 +597,59 @@ COMMAND_HANDLER(handle_flash_write_bank_command)
 	if (ERROR_OK != retval)
 		return retval;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+	offset = 0;
+
+	if (CMD_ARGC > 2)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+
+	if (offset > p->size) {
+		LOG_ERROR("Offset 0x%8.8" PRIx32 " is out of range of the flash bank",
+			offset);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
 
 	if (fileio_open(&fileio, CMD_ARGV[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
-		return ERROR_OK;
+		return ERROR_FAIL;
 
 	size_t filesize;
-	retval = fileio_size(&fileio, &filesize);
+	retval = fileio_size(fileio, &filesize);
 	if (retval != ERROR_OK) {
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		return retval;
 	}
 
-	buffer = malloc(filesize);
+	length = MIN(filesize, p->size - offset);
+
+	if (!length) {
+		LOG_INFO("Nothing to write to flash bank");
+		fileio_close(fileio);
+		return ERROR_OK;
+	}
+
+	if (length != filesize)
+		LOG_INFO("File content exceeds flash bank size. Only writing the "
+			"first %zu bytes of the file", length);
+
+	buffer = malloc(length);
 	if (buffer == NULL) {
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		LOG_ERROR("Out of memory");
 		return ERROR_FAIL;
 	}
 	size_t buf_cnt;
-	if (fileio_read(&fileio, filesize, buffer, &buf_cnt) != ERROR_OK) {
+	if (fileio_read(fileio, length, buffer, &buf_cnt) != ERROR_OK) {
 		free(buffer);
-		fileio_close(&fileio);
-		return ERROR_OK;
+		fileio_close(fileio);
+		return ERROR_FAIL;
 	}
 
-	retval = flash_driver_write(p, buffer, offset, buf_cnt);
+	if (buf_cnt != length) {
+		LOG_ERROR("Short read");
+		free(buffer);
+		return ERROR_FAIL;
+	}
+
+	retval = flash_driver_write(p, buffer, offset, length);
 
 	free(buffer);
 	buffer = NULL;
@@ -601,11 +657,11 @@ COMMAND_HANDLER(handle_flash_write_bank_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK)) {
 		command_print(CMD_CTX, "wrote %zu bytes from file %s to flash bank %u"
 			" at offset 0x%8.8" PRIx32 " in %fs (%0.3f KiB/s)",
-			filesize, CMD_ARGV[1], p->bank_number, offset,
-			duration_elapsed(&bench), duration_kbps(&bench, filesize));
+			length, CMD_ARGV[1], p->bank_number, offset,
+			duration_elapsed(&bench), duration_kbps(&bench, length));
 	}
 
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	return retval;
 }
@@ -614,11 +670,11 @@ COMMAND_HANDLER(handle_flash_read_bank_command)
 {
 	uint32_t offset;
 	uint8_t *buffer;
-	struct fileio fileio;
+	struct fileio *fileio;
 	uint32_t length;
 	size_t written;
 
-	if (CMD_ARGC != 4)
+	if (CMD_ARGC < 2 || CMD_ARGC > 4)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	struct duration bench;
@@ -626,11 +682,31 @@ COMMAND_HANDLER(handle_flash_read_bank_command)
 
 	struct flash_bank *p;
 	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
+
 	if (ERROR_OK != retval)
 		return retval;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], length);
+	offset = 0;
+
+	if (CMD_ARGC > 2)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+
+	if (offset > p->size) {
+		LOG_ERROR("Offset 0x%8.8" PRIx32 " is out of range of the flash bank",
+			offset);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	length = p->size - offset;
+
+	if (CMD_ARGC > 3)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], length);
+
+	if (offset + length > p->size) {
+		LOG_ERROR("Length of %" PRIu32 " bytes with offset 0x%8.8" PRIx32
+			" is out of range of the flash bank", length, offset);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
 
 	buffer = malloc(length);
 	if (buffer == NULL) {
@@ -652,8 +728,8 @@ COMMAND_HANDLER(handle_flash_read_bank_command)
 		return retval;
 	}
 
-	retval = fileio_write(&fileio, length, buffer, &written);
-	fileio_close(&fileio);
+	retval = fileio_write(fileio, length, buffer, &written);
+	fileio_close(fileio);
 	free(buffer);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Could not write file");
@@ -661,9 +737,9 @@ COMMAND_HANDLER(handle_flash_read_bank_command)
 	}
 
 	if (duration_measure(&bench) == ERROR_OK)
-		command_print(CMD_CTX, "wrote %ld bytes to file %s from flash bank %u"
+		command_print(CMD_CTX, "wrote %zd bytes to file %s from flash bank %u"
 			" at offset 0x%8.8" PRIx32 " in %fs (%0.3f KiB/s)",
-			(long)written, CMD_ARGV[1], p->bank_number, offset,
+			written, CMD_ARGV[1], p->bank_number, offset,
 			duration_elapsed(&bench), duration_kbps(&bench, written));
 
 	return retval;
@@ -674,12 +750,13 @@ COMMAND_HANDLER(handle_flash_verify_bank_command)
 {
 	uint32_t offset;
 	uint8_t *buffer_file, *buffer_flash;
-	struct fileio fileio;
+	struct fileio *fileio;
 	size_t read_cnt;
 	size_t filesize;
+	size_t length;
 	int differ;
 
-	if (CMD_ARGC != 3)
+	if (CMD_ARGC < 2 || CMD_ARGC > 3)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	struct duration bench;
@@ -690,7 +767,16 @@ COMMAND_HANDLER(handle_flash_verify_bank_command)
 	if (ERROR_OK != retval)
 		return retval;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+	offset = 0;
+
+	if (CMD_ARGC > 2)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+
+	if (offset > p->size) {
+		LOG_ERROR("Offset 0x%8.8" PRIx32 " is out of range of the flash bank",
+			offset);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
 
 	retval = fileio_open(&fileio, CMD_ARGV[1], FILEIO_READ, FILEIO_BINARY);
 	if (retval != ERROR_OK) {
@@ -698,41 +784,53 @@ COMMAND_HANDLER(handle_flash_verify_bank_command)
 		return retval;
 	}
 
-	retval = fileio_size(&fileio, &filesize);
+	retval = fileio_size(fileio, &filesize);
 	if (retval != ERROR_OK) {
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		return retval;
 	}
 
-	buffer_file = malloc(filesize);
+	length = MIN(filesize, p->size - offset);
+
+	if (!length) {
+		LOG_INFO("Nothing to compare with flash bank");
+		fileio_close(fileio);
+		return ERROR_OK;
+	}
+
+	if (length != filesize)
+		LOG_INFO("File content exceeds flash bank size. Only comparing the "
+			"first %zu bytes of the file", length);
+
+	buffer_file = malloc(length);
 	if (buffer_file == NULL) {
 		LOG_ERROR("Out of memory");
-		fileio_close(&fileio);
+		fileio_close(fileio);
 		return ERROR_FAIL;
 	}
 
-	retval = fileio_read(&fileio, filesize, buffer_file, &read_cnt);
-	fileio_close(&fileio);
+	retval = fileio_read(fileio, length, buffer_file, &read_cnt);
+	fileio_close(fileio);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("File read failure");
 		free(buffer_file);
 		return retval;
 	}
 
-	if (read_cnt != filesize) {
+	if (read_cnt != length) {
 		LOG_ERROR("Short read");
 		free(buffer_file);
 		return ERROR_FAIL;
 	}
 
-	buffer_flash = malloc(filesize);
+	buffer_flash = malloc(length);
 	if (buffer_flash == NULL) {
 		LOG_ERROR("Out of memory");
 		free(buffer_file);
 		return ERROR_FAIL;
 	}
 
-	retval = flash_driver_read(p, buffer_flash, offset, read_cnt);
+	retval = flash_driver_read(p, buffer_flash, offset, length);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Flash read error");
 		free(buffer_flash);
@@ -741,17 +839,17 @@ COMMAND_HANDLER(handle_flash_verify_bank_command)
 	}
 
 	if (duration_measure(&bench) == ERROR_OK)
-		command_print(CMD_CTX, "read %ld bytes from file %s and flash bank %u"
+		command_print(CMD_CTX, "read %zd bytes from file %s and flash bank %u"
 			" at offset 0x%8.8" PRIx32 " in %fs (%0.3f KiB/s)",
-			(long)read_cnt, CMD_ARGV[1], p->bank_number, offset,
-			duration_elapsed(&bench), duration_kbps(&bench, read_cnt));
+			length, CMD_ARGV[1], p->bank_number, offset,
+			duration_elapsed(&bench), duration_kbps(&bench, length));
 
-	differ = memcmp(buffer_file, buffer_flash, read_cnt);
+	differ = memcmp(buffer_file, buffer_flash, length);
 	command_print(CMD_CTX, "contents %s", differ ? "differ" : "match");
 	if (differ) {
 		uint32_t t;
 		int diffs = 0;
-		for (t = 0; t < read_cnt; t++) {
+		for (t = 0; t < length; t++) {
 			if (buffer_flash[t] == buffer_file[t])
 				continue;
 			command_print(CMD_CTX, "diff %d address 0x%08x. Was 0x%02x instead of 0x%02x",
@@ -811,7 +909,7 @@ static const struct command_registration flash_exec_command_handlers[] = {
 		.name = "info",
 		.handler = handle_flash_info_command,
 		.mode = COMMAND_EXEC,
-		.usage = "bank_id",
+		.usage = "bank_id ['sectors']",
 		.help = "Print information about a flash bank.",
 	},
 	{
@@ -871,10 +969,9 @@ static const struct command_registration flash_exec_command_handlers[] = {
 		.name = "write_bank",
 		.handler = handle_flash_write_bank_command,
 		.mode = COMMAND_EXEC,
-		.usage = "bank_id filename offset",
-		.help = "Write binary data from file to flash bank, "
-			"starting at specified byte offset from the "
-			"beginning of the bank.",
+		.usage = "bank_id filename [offset]",
+		.help = "Write binary data from file to flash bank. Allow optional "
+			"offset from beginning of the bank (defaults to zero).",
 	},
 	{
 		.name = "write_image",
@@ -889,28 +986,28 @@ static const struct command_registration flash_exec_command_handlers[] = {
 		.name = "read_bank",
 		.handler = handle_flash_read_bank_command,
 		.mode = COMMAND_EXEC,
-		.usage = "bank_id filename offset length",
-		.help = "Read binary data from flash bank to file, "
-			"starting at specified byte offset from the "
-			"beginning of the bank.",
+		.usage = "bank_id filename [offset [length]]",
+		.help = "Read binary data from flash bank to file. Allow optional "
+			"offset from beginning of the bank (defaults to zero).",
 	},
 	{
 		.name = "verify_bank",
 		.handler = handle_flash_verify_bank_command,
 		.mode = COMMAND_EXEC,
-		.usage = "bank_id filename offset",
-		.help = "Read binary data from flash bank and file, "
-			"starting at specified byte offset from the "
-			"beginning of the bank. Compare the contents.",
+		.usage = "bank_id filename [offset]",
+		.help = "Compare the contents of a file with the contents of the "
+			"flash bank. Allow optional offset from beginning of the bank "
+			"(defaults to zero).",
 	},
 	{
 		.name = "protect",
 		.handler = handle_flash_protect_command,
 		.mode = COMMAND_EXEC,
-		.usage = "bank_id first_sector [last_sector|'last'] "
+		.usage = "bank_id first_block [last_block|'last'] "
 			"('on'|'off')",
-		.help = "Turn protection on or off for a range of sectors "
-			"in a given flash bank.",
+		.help = "Turn protection on or off for a range of protection "
+			"blocks or sectors in a given flash bank. "
+			"See 'flash info' output for a list of blocks.",
 	},
 	{
 		.name = "padded_value",
@@ -983,9 +1080,11 @@ COMMAND_HANDLER(handle_flash_bank_command)
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], c->size);
 	COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], c->chip_width);
 	COMMAND_PARSE_NUMBER(int, CMD_ARGV[4], c->bus_width);
-	c->default_padded_value = 0xff;
+	c->default_padded_value = c->erased_value = 0xff;
 	c->num_sectors = 0;
 	c->sectors = NULL;
+	c->num_prot_blocks = 0;
+	c->prot_blocks = NULL;
 	c->next = NULL;
 
 	int retval;
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index 86858a84..a70891e8 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/flash/nor/virtual.c b/src/flash/nor/virtual.c
index 599a9c09..06981f4f 100644
--- a/src/flash/nor/virtual.c
+++ b/src/flash/nor/virtual.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -46,6 +44,7 @@ static void virtual_update_bank_info(struct flash_bank *bank)
 	bank->size = master_bank->size;
 	bank->chip_width = master_bank->chip_width;
 	bank->bus_width = master_bank->bus_width;
+	bank->erased_value = master_bank->erased_value;
 	bank->default_padded_value = master_bank->default_padded_value;
 	bank->num_sectors = master_bank->num_sectors;
 	bank->sectors = master_bank->sectors;
diff --git a/src/flash/nor/xmc1xxx.c b/src/flash/nor/xmc1xxx.c
new file mode 100644
index 00000000..0a76b216
--- /dev/null
+++ b/src/flash/nor/xmc1xxx.c
@@ -0,0 +1,549 @@
+/*
+ * XMC1000 flash driver
+ *
+ * Copyright (c) 2016 Andreas Färber
+ *
+ * License: GPL-2.0+
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+
+#define FLASH_BASE	0x10000000
+#define PAU_BASE	0x40000000
+#define SCU_BASE	0x40010000
+#define NVM_BASE	0x40050000
+
+#define FLASH_CS0	(FLASH_BASE + 0xf00)
+
+#define PAU_FLSIZE	(PAU_BASE + 0x404)
+
+#define SCU_IDCHIP	(SCU_BASE + 0x004)
+
+#define NVMSTATUS	(NVM_BASE + 0x00)
+#define NVMPROG		(NVM_BASE + 0x04)
+#define NVMCONF		(NVM_BASE + 0x08)
+
+#define NVMSTATUS_BUSY		(1 << 0)
+#define NVMSTATUS_VERR_MASK	(0x3 << 2)
+
+#define NVMPROG_ACTION_OPTYPE_IDLE_VERIFY	(0 << 0)
+#define NVMPROG_ACTION_OPTYPE_WRITE		(1 << 0)
+#define NVMPROG_ACTION_OPTYPE_PAGE_ERASE	(2 << 0)
+
+#define NVMPROG_ACTION_ONE_SHOT_ONCE		(1 << 4)
+#define NVMPROG_ACTION_ONE_SHOT_CONTINUOUS	(2 << 4)
+
+#define NVMPROG_ACTION_VERIFY_EACH		(1 << 6)
+#define NVMPROG_ACTION_VERIFY_NO		(2 << 6)
+#define NVMPROG_ACTION_VERIFY_ARRAY		(3 << 6)
+
+#define NVMPROG_ACTION_IDLE	0x00
+#define NVMPROG_ACTION_MASK	0xff
+
+#define NVM_WORD_SIZE 4
+#define NVM_BLOCK_SIZE (4 * NVM_WORD_SIZE)
+#define NVM_PAGE_SIZE (16 * NVM_BLOCK_SIZE)
+
+struct xmc1xxx_flash_bank {
+	bool probed;
+};
+
+static int xmc1xxx_nvm_set_idle(struct target *target)
+{
+	return target_write_u16(target, NVMPROG, NVMPROG_ACTION_IDLE);
+}
+
+static int xmc1xxx_nvm_check_idle(struct target *target)
+{
+	uint16_t val;
+	int retval;
+
+	retval = target_read_u16(target, NVMPROG, &val);
+	if (retval != ERROR_OK)
+		return retval;
+	if ((val & NVMPROG_ACTION_MASK) != NVMPROG_ACTION_IDLE) {
+		LOG_WARNING("NVMPROG.ACTION");
+		retval = xmc1xxx_nvm_set_idle(target);
+	}
+
+	return retval;
+}
+
+static int xmc1xxx_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	struct working_area *workarea;
+	struct reg_param reg_params[3];
+	struct armv7m_algorithm armv7m_algo;
+	unsigned i;
+	int retval, sector;
+	const uint8_t erase_code[] = {
+#include "../../../contrib/loaders/flash/xmc1xxx/erase.inc"
+	};
+
+	LOG_DEBUG("Infineon XMC1000 erase sectors %d to %d", first, last);
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = xmc1xxx_nvm_check_idle(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_alloc_working_area(target, sizeof(erase_code),
+			&workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available.");
+		retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		goto err_alloc_code;
+	}
+	retval = target_write_buffer(target, workarea->address,
+			sizeof(erase_code), erase_code);
+	if (retval != ERROR_OK)
+		goto err_write_code;
+
+	armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_algo.core_mode = ARM_MODE_THREAD;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+
+	buf_set_u32(reg_params[0].value, 0, 32, NVM_BASE);
+	buf_set_u32(reg_params[1].value, 0, 32, bank->base +
+		bank->sectors[first].offset);
+	buf_set_u32(reg_params[2].value, 0, 32, bank->base +
+		bank->sectors[last].offset + bank->sectors[last].size);
+
+	retval = target_run_algorithm(target,
+			0, NULL,
+			ARRAY_SIZE(reg_params), reg_params,
+			workarea->address, 0,
+			1000, &armv7m_algo);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Error executing flash sector erase "
+			"programming algorithm");
+		retval = xmc1xxx_nvm_set_idle(target);
+		if (retval != ERROR_OK)
+			LOG_WARNING("Couldn't restore NVMPROG.ACTION");
+		retval = ERROR_FLASH_OPERATION_FAILED;
+		goto err_run;
+	}
+
+	for (sector = first; sector <= last; sector++)
+		bank->sectors[sector].is_erased = 1;
+
+err_run:
+	for (i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
+
+err_write_code:
+	target_free_working_area(target, workarea);
+
+err_alloc_code:
+	return retval;
+}
+
+static int xmc1xxx_erase_check(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct working_area *workarea;
+	struct reg_param reg_params[3];
+	struct armv7m_algorithm armv7m_algo;
+	uint16_t val;
+	unsigned i;
+	int retval, sector;
+	const uint8_t erase_check_code[] = {
+#include "../../../contrib/loaders/flash/xmc1xxx/erase_check.inc"
+	};
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = target_alloc_working_area(target, sizeof(erase_check_code),
+			&workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available.");
+		retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		goto err_alloc_code;
+	}
+	retval = target_write_buffer(target, workarea->address,
+			sizeof(erase_check_code), erase_check_code);
+	if (retval != ERROR_OK)
+		goto err_write_code;
+
+	armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_algo.core_mode = ARM_MODE_THREAD;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+
+	buf_set_u32(reg_params[0].value, 0, 32, NVM_BASE);
+
+	for (sector = 0; sector < bank->num_sectors; sector++) {
+		uint32_t start = bank->base + bank->sectors[sector].offset;
+		buf_set_u32(reg_params[1].value, 0, 32, start);
+		buf_set_u32(reg_params[2].value, 0, 32, start + bank->sectors[sector].size);
+
+		retval = xmc1xxx_nvm_check_idle(target);
+		if (retval != ERROR_OK)
+			goto err_nvmprog;
+
+		LOG_DEBUG("Erase-checking 0x%08" PRIx32, start);
+		retval = target_run_algorithm(target,
+				0, NULL,
+				ARRAY_SIZE(reg_params), reg_params,
+				workarea->address, 0,
+				1000, &armv7m_algo);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Error executing flash sector erase check "
+				"programming algorithm");
+			retval = xmc1xxx_nvm_set_idle(target);
+			if (retval != ERROR_OK)
+				LOG_WARNING("Couldn't restore NVMPROG.ACTION");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run;
+		}
+
+		retval = target_read_u16(target, NVMSTATUS, &val);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Couldn't read NVMSTATUS");
+			goto err_nvmstatus;
+		}
+		bank->sectors[sector].is_erased = (val & NVMSTATUS_VERR_MASK) ? 0 : 1;
+	}
+
+err_nvmstatus:
+err_run:
+err_nvmprog:
+	for (i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
+
+err_write_code:
+	target_free_working_area(target, workarea);
+
+err_alloc_code:
+	return retval;
+}
+
+static int xmc1xxx_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t byte_count)
+{
+	struct target *target = bank->target;
+	struct working_area *code_workarea, *data_workarea;
+	struct reg_param reg_params[4];
+	struct armv7m_algorithm armv7m_algo;
+	uint32_t block_count = DIV_ROUND_UP(byte_count, NVM_BLOCK_SIZE);
+	unsigned i;
+	int retval;
+	const uint8_t write_code[] = {
+#include "../../../contrib/loaders/flash/xmc1xxx/write.inc"
+	};
+
+	LOG_DEBUG("Infineon XMC1000 write at 0x%08" PRIx32 " (%" PRId32 " bytes)",
+		offset, byte_count);
+
+	if (offset & (NVM_BLOCK_SIZE - 1)) {
+		LOG_ERROR("offset 0x%" PRIx32 " breaks required block alignment",
+			offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+	if (byte_count & (NVM_BLOCK_SIZE - 1)) {
+		LOG_WARNING("length %" PRId32 " is not block aligned, rounding up",
+			byte_count);
+	}
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = target_alloc_working_area(target, sizeof(write_code),
+			&code_workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available for write code.");
+		retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		goto err_alloc_code;
+	}
+	retval = target_write_buffer(target, code_workarea->address,
+			sizeof(write_code), write_code);
+	if (retval != ERROR_OK)
+		goto err_write_code;
+
+	retval = target_alloc_working_area(target, MAX(NVM_BLOCK_SIZE,
+		MIN(block_count * NVM_BLOCK_SIZE, target_get_working_area_avail(target))),
+		&data_workarea);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("No working area available for write data.");
+		retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		goto err_alloc_data;
+	}
+
+	armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_algo.core_mode = ARM_MODE_THREAD;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
+
+	buf_set_u32(reg_params[0].value, 0, 32, NVM_BASE);
+
+	while (byte_count > 0) {
+		uint32_t blocks = MIN(block_count, data_workarea->size / NVM_BLOCK_SIZE);
+		uint32_t addr = bank->base + offset;
+
+		LOG_DEBUG("copying %" PRId32 " bytes to SRAM 0x%08" TARGET_PRIxADDR,
+			MIN(blocks * NVM_BLOCK_SIZE, byte_count),
+			data_workarea->address);
+
+		retval = target_write_buffer(target, data_workarea->address,
+			MIN(blocks * NVM_BLOCK_SIZE, byte_count), buffer);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Error writing data buffer");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_write_data;
+		}
+		if (byte_count < blocks * NVM_BLOCK_SIZE) {
+			retval = target_write_memory(target,
+				data_workarea->address + byte_count, 1,
+				blocks * NVM_BLOCK_SIZE - byte_count,
+				&bank->default_padded_value);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Error writing data padding");
+				retval = ERROR_FLASH_OPERATION_FAILED;
+				goto err_write_pad;
+			}
+		}
+
+		LOG_DEBUG("writing 0x%08" PRIx32 "-0x%08" PRIx32 " (%" PRId32 "x)",
+			addr, addr + blocks * NVM_BLOCK_SIZE - 1, blocks);
+
+		retval = xmc1xxx_nvm_check_idle(target);
+		if (retval != ERROR_OK)
+			goto err_nvmprog;
+
+		buf_set_u32(reg_params[1].value, 0, 32, addr);
+		buf_set_u32(reg_params[2].value, 0, 32, data_workarea->address);
+		buf_set_u32(reg_params[3].value, 0, 32, blocks);
+
+		retval = target_run_algorithm(target,
+				0, NULL,
+				ARRAY_SIZE(reg_params), reg_params,
+				code_workarea->address, 0,
+				5 * 60 * 1000, &armv7m_algo);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Error executing flash write "
+				"programming algorithm");
+			retval = xmc1xxx_nvm_set_idle(target);
+			if (retval != ERROR_OK)
+				LOG_WARNING("Couldn't restore NVMPROG.ACTION");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			goto err_run;
+		}
+
+		block_count -= blocks;
+		offset += blocks * NVM_BLOCK_SIZE;
+		buffer += blocks * NVM_BLOCK_SIZE;
+		byte_count -= MIN(blocks * NVM_BLOCK_SIZE, byte_count);
+	}
+
+err_run:
+err_nvmprog:
+err_write_pad:
+err_write_data:
+	for (i = 0; i < ARRAY_SIZE(reg_params); i++)
+		destroy_reg_param(&reg_params[i]);
+
+	target_free_working_area(target, data_workarea);
+err_alloc_data:
+err_write_code:
+	target_free_working_area(target, code_workarea);
+
+err_alloc_code:
+	return retval;
+}
+
+static int xmc1xxx_protect_check(struct flash_bank *bank)
+{
+	uint32_t nvmconf;
+	int i, num_protected, retval;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = target_read_u32(bank->target, NVMCONF, &nvmconf);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Cannot read NVMCONF register.");
+		return retval;
+	}
+	LOG_DEBUG("NVMCONF = %08" PRIx32, nvmconf);
+
+	num_protected = (nvmconf >> 4) & 0xff;
+
+	for (i = 0; i < bank->num_sectors; i++)
+		bank->sectors[i].is_protected = (i < num_protected) ? 1 : 0;
+
+	return ERROR_OK;
+}
+
+static int xmc1xxx_get_info_command(struct flash_bank *bank, char *buf, int buf_size)
+{
+	uint32_t chipid[8];
+	int i, retval;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Obtain the 8-word Chip Identification Number */
+	for (i = 0; i < 7; i++) {
+		retval = target_read_u32(bank->target, FLASH_CS0 + i * 4, &chipid[i]);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Cannot read CS0 register %i.", i);
+			return retval;
+		}
+		LOG_DEBUG("ID[%d] = %08" PRIX32, i, chipid[i]);
+	}
+	retval = target_read_u32(bank->target, SCU_BASE + 0x000, &chipid[7]);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Cannot read DBGROMID register.");
+		return retval;
+	}
+	LOG_DEBUG("ID[7] = %08" PRIX32, chipid[7]);
+
+	snprintf(buf, buf_size, "XMC%" PRIx32 "00 %X flash %uKB ROM %uKB SRAM %uKB",
+			(chipid[0] >> 12) & 0xff,
+			0xAA + (chipid[7] >> 28) - 1,
+			(((chipid[6] >> 12) & 0x3f) - 1) * 4,
+			(((chipid[4] >> 8) & 0x3f) * 256) / 1024,
+			(((chipid[5] >> 8) & 0x1f) * 256 * 4) / 1024);
+
+	return ERROR_OK;
+}
+
+static int xmc1xxx_probe(struct flash_bank *bank)
+{
+	struct xmc1xxx_flash_bank *xmc_bank = bank->driver_priv;
+	uint32_t flash_addr = bank->base;
+	uint32_t idchip, flsize;
+	int i, retval;
+
+	if (xmc_bank->probed)
+		return ERROR_OK;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_WARNING("Cannot communicate... target not halted.");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = target_read_u32(bank->target, SCU_IDCHIP, &idchip);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Cannot read IDCHIP register.");
+		return retval;
+	}
+
+	if ((idchip & 0xffff0000) != 0x10000) {
+		LOG_ERROR("IDCHIP register does not match XMC1xxx.");
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("IDCHIP = %08" PRIx32, idchip);
+
+	retval = target_read_u32(bank->target, PAU_FLSIZE, &flsize);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Cannot read FLSIZE register.");
+		return retval;
+	}
+
+	bank->num_sectors = 1 + ((flsize >> 12) & 0x3f) - 1;
+	bank->size = bank->num_sectors * 4 * 1024;
+	bank->sectors = calloc(bank->num_sectors,
+			       sizeof(struct flash_sector));
+	for (i = 0; i < bank->num_sectors; i++) {
+		if (i == 0) {
+			bank->sectors[i].size = 0x200;
+			bank->sectors[i].offset = 0xE00;
+			flash_addr += 0x1000;
+		} else {
+			bank->sectors[i].size = 4 * 1024;
+			bank->sectors[i].offset = flash_addr - bank->base;
+			flash_addr += bank->sectors[i].size;
+		}
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
+	}
+
+	xmc_bank->probed = true;
+
+	return ERROR_OK;
+}
+
+static int xmc1xxx_auto_probe(struct flash_bank *bank)
+{
+	struct xmc1xxx_flash_bank *xmc_bank = bank->driver_priv;
+
+	if (xmc_bank->probed)
+		return ERROR_OK;
+
+	return xmc1xxx_probe(bank);
+}
+
+FLASH_BANK_COMMAND_HANDLER(xmc1xxx_flash_bank_command)
+{
+	struct xmc1xxx_flash_bank *xmc_bank;
+
+	xmc_bank = malloc(sizeof(struct xmc1xxx_flash_bank));
+	if (!xmc_bank)
+		return ERROR_FLASH_OPERATION_FAILED;
+
+	xmc_bank->probed = false;
+
+	bank->driver_priv = xmc_bank;
+
+	return ERROR_OK;
+}
+
+static const struct command_registration xmc1xxx_exec_command_handlers[] = {
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration xmc1xxx_command_handlers[] = {
+	{
+		.name = "xmc1xxx",
+		.mode = COMMAND_ANY,
+		.help = "xmc1xxx flash command group",
+		.usage = "",
+		.chain = xmc1xxx_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver xmc1xxx_flash = {
+	.name = "xmc1xxx",
+	.commands = xmc1xxx_command_handlers,
+	.flash_bank_command = xmc1xxx_flash_bank_command,
+	.info = xmc1xxx_get_info_command,
+	.probe = xmc1xxx_probe,
+	.auto_probe = xmc1xxx_auto_probe,
+	.protect_check = xmc1xxx_protect_check,
+	.read = default_flash_read,
+	.erase = xmc1xxx_erase,
+	.erase_check = xmc1xxx_erase_check,
+	.write = xmc1xxx_write,
+};
diff --git a/src/flash/nor/xmc4xxx.c b/src/flash/nor/xmc4xxx.c
index 9212e43e..5677ef0f 100644
--- a/src/flash/nor/xmc4xxx.c
+++ b/src/flash/nor/xmc4xxx.c
@@ -11,6 +11,8 @@
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
+*   You should have received a copy of the GNU General Public License     *
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -181,7 +183,7 @@
 
 /* Flash controller configuration values */
 #define FLASH_ID_XMC4500        0xA2
-#define FLASH_ID_XMC4800        0x92
+#define FLASH_ID_XMC4300_XMC4700_4800   0x92
 #define FLASH_ID_XMC4100_4200   0x9C
 #define FLASH_ID_XMC4400        0x9F
 
@@ -317,8 +319,8 @@ static int xmc4xxx_load_bank_layout(struct flash_bank *bank)
 	}
 
 	/* This part doesn't follow the typical standard of 0xff
-	 * being the default padding value.*/
-	bank->default_padded_value = 0x00;
+	 * being the erased value.*/
+	bank->default_padded_value = bank->erased_value = 0x00;
 
 	return ERROR_OK;
 }
@@ -381,9 +383,9 @@ static int xmc4xxx_probe(struct flash_bank *bank)
 		bank->num_sectors = 12;
 		LOG_DEBUG("XMC4xxx: XMC4500 detected.");
 		break;
-	case FLASH_ID_XMC4800:
+	case FLASH_ID_XMC4300_XMC4700_4800:
 		bank->num_sectors = 16;
-		LOG_DEBUG("XMC4xxx: XMC4800 detected.");
+		LOG_DEBUG("XMC4xxx: XMC4700/4800 detected.");
 		break;
 	default:
 		LOG_ERROR("XMC4xxx: Unexpected flash ID. got %02" PRIx8,
@@ -615,106 +617,6 @@ static int xmc4xxx_enter_page_mode(struct flash_bank *bank)
 	return res;
 }
 
-/* The logical erase value of an xmc4xxx memory cell is 0x00,
- * therefore, we cannot use the built in flash blank check and must
- * implement our own */
-
-/** Checks whether a memory region is zeroed. */
-int xmc4xxx_blank_check_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *blank)
-{
-	struct working_area *erase_check_algorithm;
-	struct reg_param reg_params[3];
-	struct armv7m_algorithm armv7m_info;
-	int retval;
-
-	/* see contrib/loaders/erase_check/armv7m_0_erase_check.s for src */
-
-	static const uint8_t erase_check_code[] = {
-		/* loop: */
-		0x03, 0x78,		/* ldrb	r3, [r0] */
-		0x01, 0x30,		/* adds	r0, #1 */
-		0x1A, 0x43,		/* orrs	r2, r2, r3 */
-		0x01, 0x39,		/* subs	r1, r1, #1 */
-		0xFA, 0xD1,		/* bne	loop */
-		0x00, 0xBE		/* bkpt	#0 */
-	};
-
-	/* make sure we have a working area */
-	if (target_alloc_working_area(target, sizeof(erase_check_code),
-		&erase_check_algorithm) != ERROR_OK)
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-
-	retval = target_write_buffer(target, erase_check_algorithm->address,
-			sizeof(erase_check_code), (uint8_t *)erase_check_code);
-	if (retval != ERROR_OK)
-		return retval;
-
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
-	armv7m_info.core_mode = ARM_MODE_THREAD;
-
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
-	buf_set_u32(reg_params[0].value, 0, 32, address);
-
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
-	buf_set_u32(reg_params[1].value, 0, 32, count);
-
-	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT);
-	buf_set_u32(reg_params[2].value, 0, 32, 0x00);
-
-	retval = target_run_algorithm(target,
-				      0,
-				      NULL,
-				      3,
-				      reg_params,
-				      erase_check_algorithm->address,
-				      erase_check_algorithm->address + (sizeof(erase_check_code) - 2),
-				      10000,
-				      &armv7m_info);
-
-	if (retval == ERROR_OK)
-		*blank = buf_get_u32(reg_params[2].value, 0, 32);
-
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-	destroy_reg_param(&reg_params[2]);
-
-	target_free_working_area(target, erase_check_algorithm);
-
-	return retval;
-}
-
-static int xmc4xxx_flash_blank_check(struct flash_bank *bank)
-{
-	struct target *target = bank->target;
-	int i;
-	int retval;
-	uint32_t blank;
-
-	if (bank->target->state != TARGET_HALTED) {
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	for (i = 0; i < bank->num_sectors; i++) {
-		uint32_t address = bank->base + bank->sectors[i].offset;
-		uint32_t size = bank->sectors[i].size;
-
-		LOG_DEBUG("Erase checking 0x%08"PRIx32, address);
-		retval = xmc4xxx_blank_check_memory(target, address, size, &blank);
-
-		if (retval != ERROR_OK)
-			break;
-
-		if (blank == 0x00)
-			bank->sectors[i].is_erased = 1;
-		else
-			bank->sectors[i].is_erased = 0;
-	}
-
-	return ERROR_OK;
-}
-
 static int xmc4xxx_write_page(struct flash_bank *bank, const uint8_t *pg_buf,
 			      uint32_t offset, bool user_config)
 {
@@ -949,6 +851,14 @@ static int xmc4xxx_get_info_command(struct flash_bank *bank, char *buf, int buf_
 			break;
 		}
 		break;
+	case 0x300:
+		dev_str = "XMC4300";
+
+		switch (rev_id) {
+		case 0x1:
+			rev_str = "AA";
+		}
+		break;
 	case 0x400:
 		dev_str = "XMC4400";
 
@@ -983,6 +893,15 @@ static int xmc4xxx_get_info_command(struct flash_bank *bank, char *buf, int buf_
 			break;
 		}
 		break;
+	case 0x700:
+		dev_str = "XMC4700";
+
+		switch (rev_id) {
+		case 0x1:
+			rev_str = "EES-AA";
+			break;
+		}
+		break;
 	case 0x800:
 		dev_str = "XMC4800";
 
@@ -1012,13 +931,13 @@ static int xmc4xxx_get_info_command(struct flash_bank *bank, char *buf, int buf_
 
 	/* If OTP Write protection is enabled (User 2), list each
 	 * sector that has it enabled */
-	char otp_str[8];
+	char otp_str[14];
 	if (otp_enabled) {
 		strcat(prot_str, "\nOTP Protection is enabled for sectors:\n");
 		for (int i = 0; i < bank->num_sectors; i++) {
 			if (fb->write_prot_otp[i]) {
 				snprintf(otp_str, sizeof(otp_str), "- %d\n", i);
-				strncat(prot_str, otp_str, ARRAY_SIZE(otp_str));
+				strncat(prot_str, otp_str, sizeof(prot_str) - strlen(prot_str) - 1);
 			}
 		}
 	}
@@ -1087,11 +1006,6 @@ static int xmc4xxx_flash_unprotect(struct flash_bank *bank, int32_t level)
 	uint32_t addr;
 	int res;
 
-	if ((level < 0) || (level > 1)) {
-		LOG_ERROR("Invalid user level. Must be 0-1");
-		return ERROR_FAIL;
-	}
-
 	switch (level) {
 	case 0:
 		addr = UCB0_BASE;
@@ -1099,6 +1013,9 @@ static int xmc4xxx_flash_unprotect(struct flash_bank *bank, int32_t level)
 	case 1:
 		addr = UCB1_BASE;
 		break;
+	default:
+		LOG_ERROR("Invalid user level. Must be 0-1");
+		return ERROR_FAIL;
 	}
 
 	res = xmc4xxx_erase_sector(bank, addr, true);
@@ -1435,7 +1352,7 @@ struct flash_driver xmc4xxx_flash = {
 	.read = default_flash_read,
 	.probe = xmc4xxx_probe,
 	.auto_probe = xmc4xxx_probe,
-	.erase_check = xmc4xxx_flash_blank_check,
+	.erase_check = default_flash_blank_check,
 	.info = xmc4xxx_get_info_command,
 	.protect_check = xmc4xxx_protect_check,
 	.protect = xmc4xxx_protect,
diff --git a/src/hello.c b/src/hello.c
index f103ed23..25938bcf 100644
--- a/src/hello.c
+++ b/src/hello.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/hello.h b/src/hello.h
index d0669512..c88c89dd 100644
--- a/src/hello.h
+++ b/src/hello.h
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef OPENOCD_HELLO_H
@@ -28,4 +26,4 @@ struct command_registration;
  */
 extern const struct command_registration hello_command_handlers[];
 
-#endif	/* OPENOCD_HELLO_H */
+#endif /* OPENOCD_HELLO_H */
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 9477267f..e0f7f49b 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -1,52 +1,49 @@
-include $(top_srcdir)/common.mk
-
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libhelper.la
-
-CONFIGFILES = options.c time_support_common.c
-
-libhelper_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS)
-
-libhelper_la_SOURCES = \
-	binarybuffer.c \
-	$(CONFIGFILES) \
-	configuration.c \
-	log.c \
-	command.c \
-	time_support.c \
-	replacements.c \
-	fileio.c \
-	util.c \
-	jim-nvp.c
+noinst_LTLIBRARIES += %D%/libhelper.la
+
+%C%_libhelper_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS)
+
+%C%_libhelper_la_SOURCES = \
+	%D%/binarybuffer.c \
+	%D%/options.c \
+	%D%/time_support_common.c \
+	%D%/configuration.c \
+	%D%/log.c \
+	%D%/command.c \
+	%D%/time_support.c \
+	%D%/replacements.c \
+	%D%/fileio.c \
+	%D%/util.c \
+	%D%/jep106.c \
+	%D%/jim-nvp.c \
+	%D%/binarybuffer.h \
+	%D%/configuration.h \
+	%D%/ioutil.h \
+	%D%/list.h \
+	%D%/util.h \
+	%D%/types.h \
+	%D%/log.h \
+	%D%/command.h \
+	%D%/time_support.h \
+	%D%/replacements.h \
+	%D%/fileio.h \
+	%D%/system.h \
+	%D%/jep106.h \
+	%D%/jep106.inc \
+	%D%/jim-nvp.h
 
 if IOUTIL
-libhelper_la_SOURCES += ioutil.c
+%C%_libhelper_la_SOURCES += %D%/ioutil.c
 else
-libhelper_la_SOURCES += ioutil_stubs.c
+%C%_libhelper_la_SOURCES += %D%/ioutil_stubs.c
 endif
 
-libhelper_la_CFLAGS =
+%C%_libhelper_la_CFLAGS = $(AM_CFLAGS)
 if IS_MINGW
 # FD_* macros are sloppy with their signs on MinGW32 platform
-libhelper_la_CFLAGS += -Wno-sign-compare
+%C%_libhelper_la_CFLAGS += -Wno-sign-compare
 endif
 
-noinst_HEADERS = \
-	binarybuffer.h \
-	configuration.h \
-	ioutil.h \
-	list.h \
-	util.h \
-	types.h \
-	log.h \
-	command.h \
-	time_support.h \
-	replacements.h \
-	fileio.h \
-	system.h \
-	bin2char.sh \
-	jim-nvp.h
-
-EXTRA_DIST = startup.tcl
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+STARTUP_TCL_SRCS += %D%/startup.tcl
+EXTRA_DIST += \
+	%D%/bin2char.sh \
+	%D%/update_jep106.pl
diff --git a/src/helper/binarybuffer.c b/src/helper/binarybuffer.c
index 3cadabdb..76f657f8 100644
--- a/src/helper/binarybuffer.c
+++ b/src/helper/binarybuffer.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -47,6 +45,11 @@ static const unsigned char bit_reverse_table256[] = {
 	0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
 };
 
+static const char hex_digits[] = {
+	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+	'a', 'b', 'c', 'd', 'e', 'f'
+};
+
 void *buf_cpy(const void *from, void *_to, unsigned size)
 {
 	if (NULL == from || NULL == _to)
@@ -371,31 +374,72 @@ void bit_copy_discard(struct bit_copy_queue *q)
 	}
 }
 
-int unhexify(char *bin, const char *hex, int count)
+/**
+ * Convert a string of hexadecimal pairs into its binary
+ * representation.
+ *
+ * @param[out] bin Buffer to store binary representation. The buffer size must
+ *                 be at least @p count.
+ * @param[in] hex String with hexadecimal pairs to convert into its binary
+ *                representation.
+ * @param[in] count Number of hexadecimal pairs to convert.
+ *
+ * @return The number of converted hexadecimal pairs.
+ */
+size_t unhexify(uint8_t *bin, const char *hex, size_t count)
 {
-	int i, tmp;
+	size_t i;
+	char tmp;
+
+	if (!bin || !hex)
+		return 0;
+
+	memset(bin, 0, count);
+
+	for (i = 0; i < 2 * count; i++) {
+		if (hex[i] >= 'a' && hex[i] <= 'f')
+			tmp = hex[i] - 'a' + 10;
+		else if (hex[i] >= 'A' && hex[i] <= 'F')
+			tmp = hex[i] - 'A' + 10;
+		else if (hex[i] >= '0' && hex[i] <= '9')
+			tmp = hex[i] - '0';
+		else
+			return i / 2;
 
-	for (i = 0; i < count; i++) {
-		if (sscanf(hex + (2 * i), "%02x", &tmp) != 1)
-			return i;
-		bin[i] = tmp;
+		bin[i / 2] |= tmp << (4 * ((i + 1) % 2));
 	}
 
-	return i;
+	return i / 2;
 }
 
-int hexify(char *hex, const char *bin, int count, int out_maxlen)
+/**
+ * Convert binary data into a string of hexadecimal pairs.
+ *
+ * @param[out] hex Buffer to store string of hexadecimal pairs. The buffer size
+ *                 must be at least @p length.
+ * @param[in] bin Buffer with binary data to convert into hexadecimal pairs.
+ * @param[in] count Number of bytes to convert.
+ * @param[in] length Maximum number of characters, including null-terminator,
+ *                   to store into @p hex.
+ *
+ * @returns The length of the converted string excluding null-terminator.
+ */
+size_t hexify(char *hex, const uint8_t *bin, size_t count, size_t length)
 {
-	int i, cmd_len = 0;
+	size_t i;
+	uint8_t tmp;
+
+	if (!length)
+		return 0;
 
-	/* May use a length, or a null-terminated string as input. */
-	if (count == 0)
-		count = strlen(bin);
+	for (i = 0; i < length - 1 && i < 2 * count; i++) {
+		tmp = (bin[i / 2] >> (4 * ((i + 1) % 2))) & 0x0f;
+		hex[i] = hex_digits[tmp];
+	}
 
-	for (i = 0; i < count; i++)
-		cmd_len += snprintf(hex + cmd_len, out_maxlen - cmd_len, "%02x", bin[i] & 0xff);
+	hex[i] = 0;
 
-	return cmd_len;
+	return i;
 }
 
 void buffer_shr(void *_buf, unsigned buf_len, unsigned count)
diff --git a/src/helper/binarybuffer.h b/src/helper/binarybuffer.h
index eaa8c526..f1da8c4a 100644
--- a/src/helper/binarybuffer.h
+++ b/src/helper/binarybuffer.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef BINARYBUFFER_H
-#define BINARYBUFFER_H
+#ifndef OPENOCD_HELPER_BINARYBUFFER_H
+#define OPENOCD_HELPER_BINARYBUFFER_H
 
 #include "list.h"
 
@@ -236,8 +234,8 @@ void bit_copy_discard(struct bit_copy_queue *q);
 
 /* functions to convert to/from hex encoded buffer
  * used in ti-icdi driver and gdb server */
-int unhexify(char *bin, const char *hex, int count);
-int hexify(char *hex, const char *bin, int count, int out_maxlen);
+size_t unhexify(uint8_t *bin, const char *hex, size_t count);
+size_t hexify(char *hex, const uint8_t *bin, size_t count, size_t out_maxlen);
 void buffer_shr(void *_buf, unsigned buf_len, unsigned count);
 
-#endif /* BINARYBUFFER_H */
+#endif /* OPENOCD_HELPER_BINARYBUFFER_H */
diff --git a/src/helper/command.c b/src/helper/command.c
index 7c2520b7..f014fce3 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -22,9 +22,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -1175,8 +1173,8 @@ COMMAND_HANDLER(handle_sleep_command)
 		return retval;
 
 	if (!busy) {
-		long long then = timeval_ms();
-		while (timeval_ms() - then < (long long)duration) {
+		int64_t then = timeval_ms();
+		while (timeval_ms() - then < (int64_t)duration) {
 			target_call_timer_callbacks_now();
 			openocd_usleep(1000);
 		}
@@ -1412,6 +1410,8 @@ DEFINE_PARSE_ULONGLONG(_u32,  uint32_t, 0, UINT32_MAX)
 DEFINE_PARSE_ULONGLONG(_u16,  uint16_t, 0, UINT16_MAX)
 DEFINE_PARSE_ULONGLONG(_u8,   uint8_t,  0, UINT8_MAX)
 
+DEFINE_PARSE_ULONGLONG(_target_addr, target_addr_t, 0, TARGET_ADDR_MAX)
+
 #define DEFINE_PARSE_LONGLONG(name, type, min, max) \
 	DEFINE_PARSE_WRAPPER(name, type, min, max, long long, _llong)
 DEFINE_PARSE_LONGLONG(_int, int,     n < INT_MIN,   INT_MAX)
@@ -1456,8 +1456,8 @@ COMMAND_HELPER(handle_command_parse_bool, bool *out, const char *label)
 				LOG_ERROR("%s: argument '%s' is not valid", CMD_NAME, in);
 				return ERROR_COMMAND_SYNTAX_ERROR;
 			}
-			/* fall through */
 		}
+			/* fallthrough */
 		case 0:
 			LOG_INFO("%s is %s", label, *out ? "enabled" : "disabled");
 			break;
diff --git a/src/helper/command.h b/src/helper/command.h
index 55b26b5d..bd24156e 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -16,18 +16,20 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef COMMAND_H
-#define COMMAND_H
+#ifndef OPENOCD_HELPER_COMMAND_H
+#define OPENOCD_HELPER_COMMAND_H
 
 #include <jim-nvp.h>
 
-/* MinGW needs to override this */
-#ifndef PRINTF_ATTRIBUTE_FORMAT
+/* To achieve C99 printf compatibility in MinGW, gnu_printf should be
+ * used for __attribute__((format( ... ))), with GCC v4.4 or later
+ */
+#if (defined(IS_MINGW) && (((__GNUC__ << 16) + __GNUC_MINOR__) >= 0x00040004))
+#define PRINTF_ATTRIBUTE_FORMAT gnu_printf
+#else
 #define PRINTF_ATTRIBUTE_FORMAT printf
 #endif
 
@@ -355,10 +357,13 @@ DECLARE_PARSE_WRAPPER(_u16, uint16_t);
 DECLARE_PARSE_WRAPPER(_u8, uint8_t);
 
 DECLARE_PARSE_WRAPPER(_int, int);
+DECLARE_PARSE_WRAPPER(_s64, int64_t);
 DECLARE_PARSE_WRAPPER(_s32, int32_t);
 DECLARE_PARSE_WRAPPER(_s16, int16_t);
 DECLARE_PARSE_WRAPPER(_s8, int8_t);
 
+DECLARE_PARSE_WRAPPER(_target_addr, target_addr_t);
+
 /**
  * @brief parses the string @a in into @a out as a @a type, or prints
  * a command error and passes the error code to the caller.  If an error
@@ -380,6 +385,9 @@ DECLARE_PARSE_WRAPPER(_s8, int8_t);
 		} \
 	} while (0)
 
+#define COMMAND_PARSE_ADDRESS(in, out) \
+	COMMAND_PARSE_NUMBER(target_addr, in, out)
+
 /**
  * Parse the string @c as a binary parameter, storing the boolean value
  * in @c out.  The strings @c on and @c off are used to match different
@@ -413,4 +421,4 @@ COMMAND_HELPER(handle_command_parse_bool, bool *out, const char *label);
 void script_debug(Jim_Interp *interp, const char *cmd,
 		  unsigned argc, Jim_Obj * const *argv);
 
-#endif	/* COMMAND_H */
+#endif /* OPENOCD_HELPER_COMMAND_H */
diff --git a/src/helper/configuration.c b/src/helper/configuration.c
index dde1491a..2a278838 100644
--- a/src/helper/configuration.c
+++ b/src/helper/configuration.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
diff --git a/src/helper/configuration.h b/src/helper/configuration.h
index 7b9f7119..3cbcd41f 100644
--- a/src/helper/configuration.h
+++ b/src/helper/configuration.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef CONFIGURATION_H
-#define CONFIGURATION_H
+#ifndef OPENOCD_HELPER_CONFIGURATION_H
+#define OPENOCD_HELPER_CONFIGURATION_H
 
 #include <helper/command.h>
 
@@ -42,4 +40,4 @@ FILE *open_file_from_path(const char *file, const char *mode);
 char *find_file(const char *name);
 char *get_home_dir(const char *append_path);
 
-#endif	/* CONFIGURATION_H */
+#endif /* OPENOCD_HELPER_CONFIGURATION_H */
diff --git a/src/helper/fileio.c b/src/helper/fileio.c
index 2664bfa1..47494dfc 100644
--- a/src/helper/fileio.c
+++ b/src/helper/fileio.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -32,7 +30,7 @@
 #include "configuration.h"
 #include "fileio.h"
 
-struct fileio_internal {
+struct fileio {
 	char *url;
 	size_t size;
 	enum fileio_type type;
@@ -40,8 +38,22 @@ struct fileio_internal {
 	FILE *file;
 };
 
-static inline int fileio_close_local(struct fileio_internal *fileio);
-static inline int fileio_open_local(struct fileio_internal *fileio)
+static inline int fileio_close_local(struct fileio *fileio)
+{
+	int retval = fclose(fileio->file);
+	if (retval != 0) {
+		if (retval == EBADF)
+			LOG_ERROR("BUG: fileio->file not a valid file descriptor");
+		else
+			LOG_ERROR("couldn't close %s: %s", fileio->url, strerror(errno));
+
+		return ERROR_FILEIO_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+static inline int fileio_open_local(struct fileio *fileio)
 {
 	char file_access[4];
 	ssize_t file_size;
@@ -104,69 +116,49 @@ static inline int fileio_open_local(struct fileio_internal *fileio)
 	return ERROR_OK;
 }
 
-int fileio_open(struct fileio *fileio_p,
-	const char *url,
-	enum fileio_access access_type,
-	enum fileio_type type)
+int fileio_open(struct fileio **fileio, const char *url,
+		enum fileio_access access_type, enum fileio_type type)
 {
 	int retval;
-	struct fileio_internal *fileio;
+	struct fileio *tmp;
 
-	fileio = malloc(sizeof(struct fileio_internal));
+	tmp = malloc(sizeof(struct fileio));
 
-	fileio->type = type;
-	fileio->access = access_type;
-	fileio->url = strdup(url);
+	tmp->type = type;
+	tmp->access = access_type;
+	tmp->url = strdup(url);
 
-	retval = fileio_open_local(fileio);
+	retval = fileio_open_local(tmp);
 
 	if (retval != ERROR_OK) {
-		free(fileio->url);
-		free(fileio);
+		free(tmp->url);
+		free(tmp);
 		return retval;
 	}
 
-	fileio_p->fp = fileio;
-
-	return ERROR_OK;
-}
-
-static inline int fileio_close_local(struct fileio_internal *fileio)
-{
-	int retval = fclose(fileio->file);
-	if (retval != 0) {
-		if (retval == EBADF)
-			LOG_ERROR("BUG: fileio_local->file not a valid file descriptor");
-		else
-			LOG_ERROR("couldn't close %s: %s", fileio->url, strerror(errno));
-
-		return ERROR_FILEIO_OPERATION_FAILED;
-	}
+	*fileio = tmp;
 
 	return ERROR_OK;
 }
 
-int fileio_close(struct fileio *fileio_p)
+int fileio_close(struct fileio *fileio)
 {
 	int retval;
-	struct fileio_internal *fileio = fileio_p->fp;
 
 	retval = fileio_close_local(fileio);
 
 	free(fileio->url);
-	fileio->url = NULL;
-
 	free(fileio);
-	fileio_p->fp = NULL;
 
 	return retval;
 }
 
-int fileio_seek(struct fileio *fileio_p, size_t position)
+int fileio_seek(struct fileio *fileio, size_t position)
 {
 	int retval;
-	struct fileio_internal *fileio = fileio_p->fp;
+
 	retval = fseek(fileio->file, position, SEEK_SET);
+
 	if (retval != 0) {
 		LOG_ERROR("couldn't seek file %s: %s", fileio->url, strerror(errno));
 		return ERROR_FILEIO_OPERATION_FAILED;
@@ -175,36 +167,40 @@ int fileio_seek(struct fileio *fileio_p, size_t position)
 	return ERROR_OK;
 }
 
-static int fileio_local_read(struct fileio_internal *fileio,
-	size_t size, void *buffer, size_t *size_read)
+static int fileio_local_read(struct fileio *fileio, size_t size, void *buffer,
+		size_t *size_read)
 {
-	ssize_t retval = fread(buffer, 1, size, fileio->file);
+	ssize_t retval;
+
+	retval = fread(buffer, 1, size, fileio->file);
 	*size_read = (retval >= 0) ? retval : 0;
+
 	return (retval < 0) ? retval : ERROR_OK;
 }
 
-int fileio_read(struct fileio *fileio_p, size_t size, void *buffer,
-	size_t *size_read)
+int fileio_read(struct fileio *fileio, size_t size, void *buffer,
+		size_t *size_read)
 {
-	struct fileio_internal *fileio = fileio_p->fp;
 	return fileio_local_read(fileio, size, buffer, size_read);
 }
 
-int fileio_read_u32(struct fileio *fileio_p, uint32_t *data)
+int fileio_read_u32(struct fileio *fileio, uint32_t *data)
 {
+	int retval;
 	uint8_t buf[4];
 	size_t size_read;
-	struct fileio_internal *fileio = fileio_p->fp;
-	int retval = fileio_local_read(fileio, sizeof(uint32_t), buf, &size_read);
+
+	retval = fileio_local_read(fileio, sizeof(uint32_t), buf, &size_read);
+
 	if (ERROR_OK == retval && sizeof(uint32_t) != size_read)
 		retval = -EIO;
 	if (ERROR_OK == retval)
 		*data = be_to_h_u32(buf);
+
 	return retval;
 }
 
-static int fileio_local_fgets(struct fileio_internal *fileio,
-	size_t size, void *buffer)
+static int fileio_local_fgets(struct fileio *fileio, size_t size, void *buffer)
 {
 	if (fgets(buffer, size, fileio->file) == NULL)
 		return ERROR_FILEIO_OPERATION_FAILED;
@@ -212,36 +208,44 @@ static int fileio_local_fgets(struct fileio_internal *fileio,
 	return ERROR_OK;
 }
 
-int fileio_fgets(struct fileio *fileio_p, size_t size, void *buffer)
+int fileio_fgets(struct fileio *fileio, size_t size, void *buffer)
 {
-	struct fileio_internal *fileio = fileio_p->fp;
 	return fileio_local_fgets(fileio, size, buffer);
 }
 
-static int fileio_local_write(struct fileio_internal *fileio,
-	size_t size, const void *buffer, size_t *size_written)
+static int fileio_local_write(struct fileio *fileio, size_t size,
+		const void *buffer, size_t *size_written)
 {
-	ssize_t retval = fwrite(buffer, 1, size, fileio->file);
+	ssize_t retval;
+
+	retval = fwrite(buffer, 1, size, fileio->file);
 	*size_written = (retval >= 0) ? retval : 0;
+
 	return (retval < 0) ? retval : ERROR_OK;
 }
 
-int fileio_write(struct fileio *fileio_p,
-	size_t size, const void *buffer, size_t *size_written)
+int fileio_write(struct fileio *fileio, size_t size, const void *buffer,
+		size_t *size_written)
 {
-	struct fileio_internal *fileio = fileio_p->fp;
-	int retval = fileio_local_write(fileio, size, buffer, size_written);
+	int retval;
+
+	retval = fileio_local_write(fileio, size, buffer, size_written);
+
 	if (retval == ERROR_OK)
 		fileio->size += *size_written;
+
 	return retval;
 }
 
-int fileio_write_u32(struct fileio *fileio_p, uint32_t data)
+int fileio_write_u32(struct fileio *fileio, uint32_t data)
 {
+	int retval;
 	uint8_t buf[4];
 	h_u32_to_be(buf, data);
 	size_t size_written;
-	int retval = fileio_write(fileio_p, 4, buf, &size_written);
+
+	retval = fileio_write(fileio, 4, buf, &size_written);
+
 	if (ERROR_OK == retval && size_written != sizeof(uint32_t))
 		retval = -EIO;
 
@@ -257,9 +261,8 @@ int fileio_write_u32(struct fileio *fileio_p, uint32_t data)
  * Avoiding the seek on startup opens up for using streams.
  *
  */
-int fileio_size(struct fileio *fileio_p, size_t *size)
+int fileio_size(struct fileio *fileio, size_t *size)
 {
-	struct fileio_internal *fileio = fileio_p->fp;
 	*size = fileio->size;
 
 	return ERROR_OK;
diff --git a/src/helper/fileio.h b/src/helper/fileio.h
index c3824ff8..ae4a3ecf 100644
--- a/src/helper/fileio.h
+++ b/src/helper/fileio.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef FILEIO_H
-#define FILEIO_H
+#ifndef OPENOCD_HELPER_FILEIO_H
+#define OPENOCD_HELPER_FILEIO_H
 
 #define FILEIO_MAX_ERROR_STRING		(128)
 
@@ -43,13 +41,10 @@ enum fileio_access {
 	FILEIO_APPENDREAD,	/* open for writing, position at end, allow reading */
 };
 
-struct fileio {
-	/* The structure is opaque */
-	struct fileio_internal *fp;
-};
+struct fileio;
 
-int fileio_open(struct fileio *fileio,
-		const char *url, enum fileio_access access_type, enum fileio_type type);
+int fileio_open(struct fileio **fileio, const char *url,
+		enum fileio_access access_type, enum fileio_type type);
 int fileio_close(struct fileio *fileio);
 
 int fileio_seek(struct fileio *fileio, size_t position);
@@ -71,4 +66,4 @@ int fileio_size(struct fileio *fileio, size_t *size);
 #define ERROR_FILEIO_RESOURCE_TYPE_UNKNOWN		(-1204)
 #define ERROR_FILEIO_OPERATION_NOT_SUPPORTED	(-1205)
 
-#endif	/* FILEIO_H */
+#endif /* OPENOCD_HELPER_FILEIO_H */
diff --git a/src/helper/ioutil.c b/src/helper/ioutil.c
index 166256c7..f1123cd8 100644
--- a/src/helper/ioutil.c
+++ b/src/helper/ioutil.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* this file contains various functionality useful to standalone systems */
@@ -243,117 +241,6 @@ COMMAND_HANDLER(handle_cp_command)
 	return retval;
 }
 
-#define SHOW_RESULT(a, b) LOG_ERROR(# a " failed %d\n", (int)b)
-
-#define IOSIZE 512
-void copyfile(char *name2, char *name1)
-{
-
-	int err;
-	char buf[IOSIZE];
-	int fd1, fd2;
-	ssize_t done, wrote;
-
-	fd1 = open(name1, O_WRONLY | O_CREAT, 0664);
-	if (fd1 < 0)
-		SHOW_RESULT(open, fd1);
-
-	fd2 = open(name2, O_RDONLY);
-	if (fd2 < 0)
-		SHOW_RESULT(open, fd2);
-
-	for (;; ) {
-		done = read(fd2, buf, IOSIZE);
-		if (done < 0) {
-			SHOW_RESULT(read, done);
-			break;
-		}
-
-		if (done == 0)
-			break;
-
-		wrote = write(fd1, buf, done);
-		if (wrote != done)
-			SHOW_RESULT(write, wrote);
-
-		if (wrote != done)
-			break;
-	}
-
-	err = close(fd1);
-	if (err < 0)
-		SHOW_RESULT(close, err);
-
-	err = close(fd2);
-	if (err < 0)
-		SHOW_RESULT(close, err);
-}
-
-/* utility fn to copy a directory */
-void copydir(char *name, char *destdir)
-{
-	int err;
-	DIR *dirp;
-
-	dirp = opendir(destdir);
-	if (dirp == NULL)
-		mkdir(destdir, 0777);
-	else
-		err = closedir(dirp);
-
-	dirp = opendir(name);
-	if (dirp == NULL)
-		SHOW_RESULT(opendir, -1);
-
-	for (;; ) {
-		struct dirent *entry = readdir(dirp);
-
-		if (entry == NULL)
-			break;
-
-		if (strcmp(entry->d_name, ".") == 0)
-			continue;
-		if (strcmp(entry->d_name, "..") == 0)
-			continue;
-
-		int isDir = 0;
-		struct stat buf;
-		char fullPath[PATH_MAX];
-		strncpy(fullPath, name, PATH_MAX);
-		strcat(fullPath, "/");
-		strncat(fullPath, entry->d_name, PATH_MAX - strlen(fullPath));
-
-		if (stat(fullPath, &buf) == -1) {
-			LOG_ERROR("unable to read status from %s", fullPath);
-			break;
-		}
-		isDir = S_ISDIR(buf.st_mode) != 0;
-
-		if (isDir)
-			continue;
-
-		/*        diag_printf("<INFO>: entry %14s",entry->d_name); */
-		char fullname[PATH_MAX];
-		char fullname2[PATH_MAX];
-
-		strcpy(fullname, name);
-		strcat(fullname, "/");
-		strcat(fullname, entry->d_name);
-
-		strcpy(fullname2, destdir);
-		strcat(fullname2, "/");
-		strcat(fullname2, entry->d_name);
-		/*        diag_printf("from %s to %s\n", fullname, fullname2); */
-		copyfile(fullname, fullname2);
-
-		/*       diag_printf("\n"); */
-	}
-
-	err = closedir(dirp);
-	if (err < 0)
-		SHOW_RESULT(stat, err);
-}
-
 COMMAND_HANDLER(handle_rm_command)
 {
 	if (CMD_ARGC != 1)
diff --git a/src/helper/ioutil.h b/src/helper/ioutil.h
index 8cd9157b..f060aab0 100644
--- a/src/helper/ioutil.h
+++ b/src/helper/ioutil.h
@@ -12,16 +12,14 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef HELPER_IOUTILS_H
-#define HELPER_IOUTILS_H
+#ifndef OPENOCD_HELPER_IOUTIL_H
+#define OPENOCD_HELPER_IOUTIL_H
 
 struct command_context;
 
 int ioutil_init(struct command_context *cmd_ctx);
 
-#endif	/* HELPER_IOUTILS_H */
+#endif /* OPENOCD_HELPER_IOUTIL_H */
diff --git a/src/helper/ioutil_stubs.c b/src/helper/ioutil_stubs.c
index a87f1b6e..0d81fe66 100644
--- a/src/helper/ioutil_stubs.c
+++ b/src/helper/ioutil_stubs.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/helper/jep106.c b/src/helper/jep106.c
new file mode 100644
index 00000000..33dc61c9
--- /dev/null
+++ b/src/helper/jep106.c
@@ -0,0 +1,44 @@
+/***************************************************************************
+ *   Copyright (C) 2015 Andreas Fritiofson                                 *
+ *   andreas.fritiofson@gmail.com                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jep106.h"
+#include "log.h"
+
+static const char * const jep106[][126] = {
+#include "jep106.inc"
+};
+
+const char *jep106_manufacturer(unsigned bank, unsigned id)
+{
+	if (id < 1 || id > 126) {
+		LOG_DEBUG("BUG: Caller passed out-of-range JEP106 ID!");
+		return "<invalid>";
+	}
+
+	/* index is zero based */
+	id--;
+
+	if (bank >= ARRAY_SIZE(jep106) || jep106[bank][id] == 0)
+		return "<unknown>";
+
+	return jep106[bank][id];
+}
diff --git a/src/helper/jep106.h b/src/helper/jep106.h
new file mode 100644
index 00000000..08445803
--- /dev/null
+++ b/src/helper/jep106.h
@@ -0,0 +1,32 @@
+/***************************************************************************
+ *   Copyright (C) 2015 Andreas Fritiofson                                 *
+ *   andreas.fritiofson@gmail.com                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifndef OPENOCD_HELPER_JEP106_H
+#define OPENOCD_HELPER_JEP106_H
+
+/**
+ * Get the manufacturer name associated with a JEP106 ID.
+ * @param bank The bank (number of continuation codes) of the manufacturer ID.
+ * @param id The 7-bit manufacturer ID (i.e. with parity stripped).
+ * @return A pointer to static const storage containing the name of the
+ *         manufacturer associated with bank and id, or one of the strings
+ *         "<invalid>" and "<unknown>".
+ */
+const char *jep106_manufacturer(unsigned bank, unsigned id);
+
+#endif /* OPENOCD_HELPER_JEP106_H */
diff --git a/src/helper/jep106.inc b/src/helper/jep106.inc
new file mode 100644
index 00000000..c0295a60
--- /dev/null
+++ b/src/helper/jep106.inc
@@ -0,0 +1,1156 @@
+/* Autogenerated with update_jep106.pl*/
+[0][0x01 - 1] = "AMD",
+[0][0x02 - 1] = "AMI",
+[0][0x03 - 1] = "Fairchild",
+[0][0x04 - 1] = "Fujitsu",
+[0][0x05 - 1] = "GTE",
+[0][0x06 - 1] = "Harris",
+[0][0x07 - 1] = "Hitachi",
+[0][0x08 - 1] = "Inmos",
+[0][0x09 - 1] = "Intel",
+[0][0x0a - 1] = "I.T.T.",
+[0][0x0b - 1] = "Intersil",
+[0][0x0c - 1] = "Monolithic Memories",
+[0][0x0d - 1] = "Mostek",
+[0][0x0e - 1] = "Freescale (Motorola)",
+[0][0x0f - 1] = "National",
+[0][0x10 - 1] = "NEC",
+[0][0x11 - 1] = "RCA",
+[0][0x12 - 1] = "Raytheon",
+[0][0x13 - 1] = "Conexant (Rockwell)",
+[0][0x14 - 1] = "Seeq",
+[0][0x15 - 1] = "NXP (Philips)",
+[0][0x16 - 1] = "Synertek",
+[0][0x17 - 1] = "Texas Instruments",
+[0][0x18 - 1] = "Toshiba",
+[0][0x19 - 1] = "Xicor",
+[0][0x1a - 1] = "Zilog",
+[0][0x1b - 1] = "Eurotechnique",
+[0][0x1c - 1] = "Mitsubishi",
+[0][0x1d - 1] = "Lucent (AT&T)",
+[0][0x1e - 1] = "Exel",
+[0][0x1f - 1] = "Atmel",
+[0][0x20 - 1] = "STMicroelectronics",
+[0][0x21 - 1] = "Lattice Semi.",
+[0][0x22 - 1] = "NCR",
+[0][0x23 - 1] = "Wafer Scale Integration",
+[0][0x24 - 1] = "IBM",
+[0][0x25 - 1] = "Tristar",
+[0][0x26 - 1] = "Visic",
+[0][0x27 - 1] = "Intl. CMOS Technology",
+[0][0x28 - 1] = "SSSI",
+[0][0x29 - 1] = "MicrochipTechnology",
+[0][0x2a - 1] = "Ricoh Ltd.",
+[0][0x2b - 1] = "VLSI",
+[0][0x2c - 1] = "Micron Technology",
+[0][0x2d - 1] = "SK Hynix",
+[0][0x2e - 1] = "OKI Semiconductor",
+[0][0x2f - 1] = "ACTEL",
+[0][0x30 - 1] = "Sharp",
+[0][0x31 - 1] = "Catalyst",
+[0][0x32 - 1] = "Panasonic",
+[0][0x33 - 1] = "IDT",
+[0][0x34 - 1] = "Cypress",
+[0][0x35 - 1] = "DEC",
+[0][0x36 - 1] = "LSI Logic",
+[0][0x37 - 1] = "Zarlink (Plessey)",
+[0][0x38 - 1] = "UTMC",
+[0][0x39 - 1] = "Thinking Machine",
+[0][0x3a - 1] = "Thomson CSF",
+[0][0x3b - 1] = "Integrated CMOS (Vertex)",
+[0][0x3c - 1] = "Honeywell",
+[0][0x3d - 1] = "Tektronix",
+[0][0x3e - 1] = "Oracle Corporation",
+[0][0x3f - 1] = "Silicon Storage Technology",
+[0][0x40 - 1] = "ProMos/Mosel Vitelic",
+[0][0x41 - 1] = "Infineon (Siemens)",
+[0][0x42 - 1] = "Macronix",
+[0][0x43 - 1] = "Xerox",
+[0][0x44 - 1] = "Plus Logic",
+[0][0x45 - 1] = "SanDisk Corporation",
+[0][0x46 - 1] = "Elan Circuit Tech.",
+[0][0x47 - 1] = "European Silicon Str.",
+[0][0x48 - 1] = "Apple Computer",
+[0][0x49 - 1] = "Xilinx",
+[0][0x4a - 1] = "Compaq",
+[0][0x4b - 1] = "Protocol Engines",
+[0][0x4c - 1] = "SCI",
+[0][0x4d - 1] = "Seiko Instruments",
+[0][0x4e - 1] = "Samsung",
+[0][0x4f - 1] = "I3 Design System",
+[0][0x50 - 1] = "Klic",
+[0][0x51 - 1] = "Crosspoint Solutions",
+[0][0x52 - 1] = "Alliance Semiconductor",
+[0][0x53 - 1] = "Tandem",
+[0][0x54 - 1] = "Hewlett-Packard",
+[0][0x55 - 1] = "Integrated Silicon Solutions",
+[0][0x56 - 1] = "Brooktree",
+[0][0x57 - 1] = "New Media",
+[0][0x58 - 1] = "MHS Electronic",
+[0][0x59 - 1] = "Performance Semi.",
+[0][0x5a - 1] = "Winbond Electronic",
+[0][0x5b - 1] = "Kawasaki Steel",
+[0][0x5c - 1] = "Bright Micro",
+[0][0x5d - 1] = "TECMAR",
+[0][0x5e - 1] = "Exar",
+[0][0x5f - 1] = "PCMCIA",
+[0][0x60 - 1] = "LG Semi (Goldstar)",
+[0][0x61 - 1] = "Northern Telecom",
+[0][0x62 - 1] = "Sanyo",
+[0][0x63 - 1] = "Array Microsystems",
+[0][0x64 - 1] = "Crystal Semiconductor",
+[0][0x65 - 1] = "Analog Devices",
+[0][0x66 - 1] = "PMC-Sierra",
+[0][0x67 - 1] = "Asparix",
+[0][0x68 - 1] = "Convex Computer",
+[0][0x69 - 1] = "Quality Semiconductor",
+[0][0x6a - 1] = "Nimbus Technology",
+[0][0x6b - 1] = "Transwitch",
+[0][0x6c - 1] = "Micronas (ITT Intermetall)",
+[0][0x6d - 1] = "Cannon",
+[0][0x6e - 1] = "Altera",
+[0][0x6f - 1] = "NEXCOM",
+[0][0x70 - 1] = "Qualcomm",
+[0][0x71 - 1] = "Sony",
+[0][0x72 - 1] = "Cray Research",
+[0][0x73 - 1] = "AMS(Austria Micro)",
+[0][0x74 - 1] = "Vitesse",
+[0][0x75 - 1] = "Aster Electronics",
+[0][0x76 - 1] = "Bay Networks (Synoptic)",
+[0][0x77 - 1] = "Zentrum/ZMD",
+[0][0x78 - 1] = "TRW",
+[0][0x79 - 1] = "Thesys",
+[0][0x7a - 1] = "Solbourne Computer",
+[0][0x7b - 1] = "Allied-Signal",
+[0][0x7c - 1] = "Dialog Semiconductor",
+[0][0x7d - 1] = "Media Vision",
+[0][0x7e - 1] = "Numonyx Corporation",
+[1][0x01 - 1] = "Cirrus Logic",
+[1][0x02 - 1] = "National Instruments",
+[1][0x03 - 1] = "ILC Data Device",
+[1][0x04 - 1] = "Alcatel Mietec",
+[1][0x05 - 1] = "Micro Linear",
+[1][0x06 - 1] = "Univ. of NC",
+[1][0x07 - 1] = "JTAG Technologies",
+[1][0x08 - 1] = "BAE Systems (Loral)",
+[1][0x09 - 1] = "Nchip",
+[1][0x0a - 1] = "Galileo Tech",
+[1][0x0b - 1] = "Bestlink Systems",
+[1][0x0c - 1] = "Graychip",
+[1][0x0d - 1] = "GENNUM",
+[1][0x0e - 1] = "VideoLogic",
+[1][0x0f - 1] = "Robert Bosch",
+[1][0x10 - 1] = "Chip Express",
+[1][0x11 - 1] = "DATARAM",
+[1][0x12 - 1] = "United Microelectronics Corp.",
+[1][0x13 - 1] = "TCSI",
+[1][0x14 - 1] = "Smart Modular",
+[1][0x15 - 1] = "Hughes Aircraft",
+[1][0x16 - 1] = "Lanstar Semiconductor",
+[1][0x17 - 1] = "Qlogic",
+[1][0x18 - 1] = "Kingston",
+[1][0x19 - 1] = "Music Semi",
+[1][0x1a - 1] = "Ericsson Components",
+[1][0x1b - 1] = "SpaSE",
+[1][0x1c - 1] = "Eon Silicon Devices",
+[1][0x1d - 1] = "Integrated Silicon Solution (ISSI)",
+[1][0x1e - 1] = "DoD",
+[1][0x1f - 1] = "Integ. Memories Tech.",
+[1][0x20 - 1] = "Corollary Inc.",
+[1][0x21 - 1] = "Dallas Semiconductor",
+[1][0x22 - 1] = "Omnivision",
+[1][0x23 - 1] = "EIV(Switzerland)",
+[1][0x24 - 1] = "Novatel Wireless",
+[1][0x25 - 1] = "Zarlink (Mitel)",
+[1][0x26 - 1] = "Clearpoint",
+[1][0x27 - 1] = "Cabletron",
+[1][0x28 - 1] = "STEC (Silicon Tech)",
+[1][0x29 - 1] = "Vanguard",
+[1][0x2a - 1] = "Hagiwara Sys-Com",
+[1][0x2b - 1] = "Vantis",
+[1][0x2c - 1] = "Celestica",
+[1][0x2d - 1] = "Century",
+[1][0x2e - 1] = "Hal Computers",
+[1][0x2f - 1] = "Rohm Company Ltd.",
+[1][0x30 - 1] = "Juniper Networks",
+[1][0x31 - 1] = "Libit Signal Processing",
+[1][0x32 - 1] = "Mushkin Enhanced Memory",
+[1][0x33 - 1] = "Tundra Semiconductor",
+[1][0x34 - 1] = "Adaptec Inc.",
+[1][0x35 - 1] = "LightSpeed Semi.",
+[1][0x36 - 1] = "ZSP Corp.",
+[1][0x37 - 1] = "AMIC Technology",
+[1][0x38 - 1] = "Adobe Systems",
+[1][0x39 - 1] = "Dynachip",
+[1][0x3a - 1] = "PNY Technologies, Inc.",
+[1][0x3b - 1] = "Newport Digital",
+[1][0x3c - 1] = "MMC Networks",
+[1][0x3d - 1] = "T Square",
+[1][0x3e - 1] = "Seiko Epson",
+[1][0x3f - 1] = "Broadcom",
+[1][0x40 - 1] = "Viking Components",
+[1][0x41 - 1] = "V3 Semiconductor",
+[1][0x42 - 1] = "Flextronics (Orbit Semiconductor)",
+[1][0x43 - 1] = "Suwa Electronics",
+[1][0x44 - 1] = "Transmeta",
+[1][0x45 - 1] = "Micron CMS",
+[1][0x46 - 1] = "American Computer & Digital",
+[1][0x47 - 1] = "Enhance 3000 Inc.",
+[1][0x48 - 1] = "Tower Semiconductor",
+[1][0x49 - 1] = "CPU Design",
+[1][0x4a - 1] = "Price Point",
+[1][0x4b - 1] = "Maxim Integrated Product",
+[1][0x4c - 1] = "Tellabs",
+[1][0x4d - 1] = "Centaur Technology",
+[1][0x4e - 1] = "Unigen Corporation",
+[1][0x4f - 1] = "Transcend Information",
+[1][0x50 - 1] = "Memory Card Technology",
+[1][0x51 - 1] = "CKD Corporation Ltd.",
+[1][0x52 - 1] = "Capital Instruments, Inc.",
+[1][0x53 - 1] = "Aica Kogyo, Ltd.",
+[1][0x54 - 1] = "Linvex Technology",
+[1][0x55 - 1] = "MSC Vertriebs GmbH",
+[1][0x56 - 1] = "AKM Company, Ltd.",
+[1][0x57 - 1] = "Dynamem, Inc.",
+[1][0x58 - 1] = "NERA ASA",
+[1][0x59 - 1] = "GSI Technology",
+[1][0x5a - 1] = "Dane-Elec (C Memory)",
+[1][0x5b - 1] = "Acorn Computers",
+[1][0x5c - 1] = "Lara Technology",
+[1][0x5d - 1] = "Oak Technology, Inc.",
+[1][0x5e - 1] = "Itec Memory",
+[1][0x5f - 1] = "Tanisys Technology",
+[1][0x60 - 1] = "Truevision",
+[1][0x61 - 1] = "Wintec Industries",
+[1][0x62 - 1] = "Super PC Memory",
+[1][0x63 - 1] = "MGV Memory",
+[1][0x64 - 1] = "Galvantech",
+[1][0x65 - 1] = "Gadzoox Networks",
+[1][0x66 - 1] = "Multi Dimensional Cons.",
+[1][0x67 - 1] = "GateField",
+[1][0x68 - 1] = "Integrated Memory System",
+[1][0x69 - 1] = "Triscend",
+[1][0x6a - 1] = "XaQti",
+[1][0x6b - 1] = "Goldenram",
+[1][0x6c - 1] = "Clear Logic",
+[1][0x6d - 1] = "Cimaron Communications",
+[1][0x6e - 1] = "Nippon Steel Semi. Corp.",
+[1][0x6f - 1] = "Advantage Memory",
+[1][0x70 - 1] = "AMCC",
+[1][0x71 - 1] = "LeCroy",
+[1][0x72 - 1] = "Yamaha Corporation",
+[1][0x73 - 1] = "Digital Microwave",
+[1][0x74 - 1] = "NetLogic Microsystems",
+[1][0x75 - 1] = "MIMOS Semiconductor",
+[1][0x76 - 1] = "Advanced Fibre",
+[1][0x77 - 1] = "BF Goodrich Data.",
+[1][0x78 - 1] = "Epigram",
+[1][0x79 - 1] = "Acbel Polytech Inc.",
+[1][0x7a - 1] = "Apacer Technology",
+[1][0x7b - 1] = "Admor Memory",
+[1][0x7c - 1] = "FOXCONN",
+[1][0x7d - 1] = "Quadratics Superconductor",
+[1][0x7e - 1] = "3COM",
+[2][0x01 - 1] = "Camintonn Corporation",
+[2][0x02 - 1] = "ISOA Incorporated",
+[2][0x03 - 1] = "Agate Semiconductor",
+[2][0x04 - 1] = "ADMtek Incorporated",
+[2][0x05 - 1] = "HYPERTEC",
+[2][0x06 - 1] = "Adhoc Technologies",
+[2][0x07 - 1] = "MOSAID Technologies",
+[2][0x08 - 1] = "Ardent Technologies",
+[2][0x09 - 1] = "Switchcore",
+[2][0x0a - 1] = "Cisco Systems, Inc.",
+[2][0x0b - 1] = "Allayer Technologies",
+[2][0x0c - 1] = "WorkX AG (Wichman)",
+[2][0x0d - 1] = "Oasis Semiconductor",
+[2][0x0e - 1] = "Novanet Semiconductor",
+[2][0x0f - 1] = "E-M Solutions",
+[2][0x10 - 1] = "Power General",
+[2][0x11 - 1] = "Advanced Hardware Arch.",
+[2][0x12 - 1] = "Inova Semiconductors GmbH",
+[2][0x13 - 1] = "Telocity",
+[2][0x14 - 1] = "Delkin Devices",
+[2][0x15 - 1] = "Symagery Microsystems",
+[2][0x16 - 1] = "C-Port Corporation",
+[2][0x17 - 1] = "SiberCore Technologies",
+[2][0x18 - 1] = "Southland Microsystems",
+[2][0x19 - 1] = "Malleable Technologies",
+[2][0x1a - 1] = "Kendin Communications",
+[2][0x1b - 1] = "Great Technology Microcomputer",
+[2][0x1c - 1] = "Sanmina Corporation",
+[2][0x1d - 1] = "HADCO Corporation",
+[2][0x1e - 1] = "Corsair",
+[2][0x1f - 1] = "Actrans System Inc.",
+[2][0x20 - 1] = "ALPHA Technologies",
+[2][0x21 - 1] = "Silicon Laboratories, Inc. (Cygnal)",
+[2][0x22 - 1] = "Artesyn Technologies",
+[2][0x23 - 1] = "Align Manufacturing",
+[2][0x24 - 1] = "Peregrine Semiconductor",
+[2][0x25 - 1] = "Chameleon Systems",
+[2][0x26 - 1] = "Aplus Flash Technology",
+[2][0x27 - 1] = "MIPS Technologies",
+[2][0x28 - 1] = "Chrysalis ITS",
+[2][0x29 - 1] = "ADTEC Corporation",
+[2][0x2a - 1] = "Kentron Technologies",
+[2][0x2b - 1] = "Win Technologies",
+[2][0x2c - 1] = "Tezzaron Semiconductor",
+[2][0x2d - 1] = "Extreme Packet Devices",
+[2][0x2e - 1] = "RF Micro Devices",
+[2][0x2f - 1] = "Siemens AG",
+[2][0x30 - 1] = "Sarnoff Corporation",
+[2][0x31 - 1] = "Itautec SA",
+[2][0x32 - 1] = "Radiata Inc.",
+[2][0x33 - 1] = "Benchmark Elect. (AVEX)",
+[2][0x34 - 1] = "Legend",
+[2][0x35 - 1] = "SpecTek Incorporated",
+[2][0x36 - 1] = "Hi/fn",
+[2][0x37 - 1] = "Enikia Incorporated",
+[2][0x38 - 1] = "SwitchOn Networks",
+[2][0x39 - 1] = "AANetcom Incorporated",
+[2][0x3a - 1] = "Micro Memory Bank",
+[2][0x3b - 1] = "ESS Technology",
+[2][0x3c - 1] = "Virata Corporation",
+[2][0x3d - 1] = "Excess Bandwidth",
+[2][0x3e - 1] = "West Bay Semiconductor",
+[2][0x3f - 1] = "DSP Group",
+[2][0x40 - 1] = "Newport Communications",
+[2][0x41 - 1] = "Chip2Chip Incorporated",
+[2][0x42 - 1] = "Phobos Corporation",
+[2][0x43 - 1] = "Intellitech Corporation",
+[2][0x44 - 1] = "Nordic VLSI ASA",
+[2][0x45 - 1] = "Ishoni Networks",
+[2][0x46 - 1] = "Silicon Spice",
+[2][0x47 - 1] = "Alchemy Semiconductor",
+[2][0x48 - 1] = "Agilent Technologies",
+[2][0x49 - 1] = "Centillium Communications",
+[2][0x4a - 1] = "W.L. Gore",
+[2][0x4b - 1] = "HanBit Electronics",
+[2][0x4c - 1] = "GlobeSpan",
+[2][0x4d - 1] = "Element 14",
+[2][0x4e - 1] = "Pycon",
+[2][0x4f - 1] = "Saifun Semiconductors",
+[2][0x50 - 1] = "Sibyte, Incorporated",
+[2][0x51 - 1] = "MetaLink Technologies",
+[2][0x52 - 1] = "Feiya Technology",
+[2][0x53 - 1] = "I & C Technology",
+[2][0x54 - 1] = "Shikatronics",
+[2][0x55 - 1] = "Elektrobit",
+[2][0x56 - 1] = "Megic",
+[2][0x57 - 1] = "Com-Tier",
+[2][0x58 - 1] = "Malaysia Micro Solutions",
+[2][0x59 - 1] = "Hyperchip",
+[2][0x5a - 1] = "Gemstone Communications",
+[2][0x5b - 1] = "Anadigm (Anadyne)",
+[2][0x5c - 1] = "3ParData",
+[2][0x5d - 1] = "Mellanox Technologies",
+[2][0x5e - 1] = "Tenx Technologies",
+[2][0x5f - 1] = "Helix AG",
+[2][0x60 - 1] = "Domosys",
+[2][0x61 - 1] = "Skyup Technology",
+[2][0x62 - 1] = "HiNT Corporation",
+[2][0x63 - 1] = "Chiaro",
+[2][0x64 - 1] = "MDT Technologies GmbH",
+[2][0x65 - 1] = "Exbit Technology A/S",
+[2][0x66 - 1] = "Integrated Technology Express",
+[2][0x67 - 1] = "AVED Memory",
+[2][0x68 - 1] = "Legerity",
+[2][0x69 - 1] = "Jasmine Networks",
+[2][0x6a - 1] = "Caspian Networks",
+[2][0x6b - 1] = "nCUBE",
+[2][0x6c - 1] = "Silicon Access Networks",
+[2][0x6d - 1] = "FDK Corporation",
+[2][0x6e - 1] = "High Bandwidth Access",
+[2][0x6f - 1] = "MultiLink Technology",
+[2][0x70 - 1] = "BRECIS",
+[2][0x71 - 1] = "World Wide Packets",
+[2][0x72 - 1] = "APW",
+[2][0x73 - 1] = "Chicory Systems",
+[2][0x74 - 1] = "Xstream Logic",
+[2][0x75 - 1] = "Fast-Chip",
+[2][0x76 - 1] = "Zucotto Wireless",
+[2][0x77 - 1] = "Realchip",
+[2][0x78 - 1] = "Galaxy Power",
+[2][0x79 - 1] = "eSilicon",
+[2][0x7a - 1] = "Morphics Technology",
+[2][0x7b - 1] = "Accelerant Networks",
+[2][0x7c - 1] = "Silicon Wave",
+[2][0x7d - 1] = "SandCraft",
+[2][0x7e - 1] = "Elpida",
+[3][0x01 - 1] = "Solectron",
+[3][0x02 - 1] = "Optosys Technologies",
+[3][0x03 - 1] = "Buffalo (Formerly Melco)",
+[3][0x04 - 1] = "TriMedia Technologies",
+[3][0x05 - 1] = "Cyan Technologies",
+[3][0x06 - 1] = "Global Locate",
+[3][0x07 - 1] = "Optillion",
+[3][0x08 - 1] = "Terago Communications",
+[3][0x09 - 1] = "Ikanos Communications",
+[3][0x0a - 1] = "Princeton Technology",
+[3][0x0b - 1] = "Nanya Technology",
+[3][0x0c - 1] = "Elite Flash Storage",
+[3][0x0d - 1] = "Mysticom",
+[3][0x0e - 1] = "LightSand Communications",
+[3][0x0f - 1] = "ATI Technologies",
+[3][0x10 - 1] = "Agere Systems",
+[3][0x11 - 1] = "NeoMagic",
+[3][0x12 - 1] = "AuroraNetics",
+[3][0x13 - 1] = "Golden Empire",
+[3][0x14 - 1] = "Mushkin",
+[3][0x15 - 1] = "Tioga Technologies",
+[3][0x16 - 1] = "Netlist",
+[3][0x17 - 1] = "TeraLogic",
+[3][0x18 - 1] = "Cicada Semiconductor",
+[3][0x19 - 1] = "Centon Electronics",
+[3][0x1a - 1] = "Tyco Electronics",
+[3][0x1b - 1] = "Magis Works",
+[3][0x1c - 1] = "Zettacom",
+[3][0x1d - 1] = "Cogency Semiconductor",
+[3][0x1e - 1] = "Chipcon AS",
+[3][0x1f - 1] = "Aspex Technology",
+[3][0x20 - 1] = "F5 Networks",
+[3][0x21 - 1] = "Programmable Silicon Solutions",
+[3][0x22 - 1] = "ChipWrights",
+[3][0x23 - 1] = "Acorn Networks",
+[3][0x24 - 1] = "Quicklogic",
+[3][0x25 - 1] = "Kingmax Semiconductor",
+[3][0x26 - 1] = "BOPS",
+[3][0x27 - 1] = "Flasys",
+[3][0x28 - 1] = "BitBlitz Communications",
+[3][0x29 - 1] = "eMemory Technology",
+[3][0x2a - 1] = "Procket Networks",
+[3][0x2b - 1] = "Purple Ray",
+[3][0x2c - 1] = "Trebia Networks",
+[3][0x2d - 1] = "Delta Electronics",
+[3][0x2e - 1] = "Onex Communications",
+[3][0x2f - 1] = "Ample Communications",
+[3][0x30 - 1] = "Memory Experts Intl",
+[3][0x31 - 1] = "Astute Networks",
+[3][0x32 - 1] = "Azanda Network Devices",
+[3][0x33 - 1] = "Dibcom",
+[3][0x34 - 1] = "Tekmos",
+[3][0x35 - 1] = "API NetWorks",
+[3][0x36 - 1] = "Bay Microsystems",
+[3][0x37 - 1] = "Firecron Ltd",
+[3][0x38 - 1] = "Resonext Communications",
+[3][0x39 - 1] = "Tachys Technologies",
+[3][0x3a - 1] = "Equator Technology",
+[3][0x3b - 1] = "Concept Computer",
+[3][0x3c - 1] = "SILCOM",
+[3][0x3d - 1] = "3Dlabs",
+[3][0x3e - 1] = "c’t Magazine",
+[3][0x3f - 1] = "Sanera Systems",
+[3][0x40 - 1] = "Silicon Packets",
+[3][0x41 - 1] = "Viasystems Group",
+[3][0x42 - 1] = "Simtek",
+[3][0x43 - 1] = "Semicon Devices Singapore",
+[3][0x44 - 1] = "Satron Handelsges",
+[3][0x45 - 1] = "Improv Systems",
+[3][0x46 - 1] = "INDUSYS GmbH",
+[3][0x47 - 1] = "Corrent",
+[3][0x48 - 1] = "Infrant Technologies",
+[3][0x49 - 1] = "Ritek Corp",
+[3][0x4a - 1] = "empowerTel Networks",
+[3][0x4b - 1] = "Hypertec",
+[3][0x4c - 1] = "Cavium Networks",
+[3][0x4d - 1] = "PLX Technology",
+[3][0x4e - 1] = "Massana Design",
+[3][0x4f - 1] = "Intrinsity",
+[3][0x50 - 1] = "Valence Semiconductor",
+[3][0x51 - 1] = "Terawave Communications",
+[3][0x52 - 1] = "IceFyre Semiconductor",
+[3][0x53 - 1] = "Primarion",
+[3][0x54 - 1] = "Picochip Designs Ltd",
+[3][0x55 - 1] = "Silverback Systems",
+[3][0x56 - 1] = "Jade Star Technologies",
+[3][0x57 - 1] = "Pijnenburg Securealink",
+[3][0x58 - 1] = "takeMS - Ultron AG",
+[3][0x59 - 1] = "Cambridge Silicon Radio",
+[3][0x5a - 1] = "Swissbit",
+[3][0x5b - 1] = "Nazomi Communications",
+[3][0x5c - 1] = "eWave System",
+[3][0x5d - 1] = "Rockwell Collins",
+[3][0x5e - 1] = "Picocel Co. Ltd. (Paion)",
+[3][0x5f - 1] = "Alphamosaic Ltd",
+[3][0x60 - 1] = "Sandburst",
+[3][0x61 - 1] = "SiCon Video",
+[3][0x62 - 1] = "NanoAmp Solutions",
+[3][0x63 - 1] = "Ericsson Technology",
+[3][0x64 - 1] = "PrairieComm",
+[3][0x65 - 1] = "Mitac International",
+[3][0x66 - 1] = "Layer N Networks",
+[3][0x67 - 1] = "MtekVision (Atsana)",
+[3][0x68 - 1] = "Allegro Networks",
+[3][0x69 - 1] = "Marvell Semiconductors",
+[3][0x6a - 1] = "Netergy Microelectronic",
+[3][0x6b - 1] = "NVIDIA",
+[3][0x6c - 1] = "Internet Machines",
+[3][0x6d - 1] = "Memorysolution GmbH",
+[3][0x6e - 1] = "Litchfield Communication",
+[3][0x6f - 1] = "Accton Technology",
+[3][0x70 - 1] = "Teradiant Networks",
+[3][0x71 - 1] = "Scaleo Chip",
+[3][0x72 - 1] = "Cortina Systems",
+[3][0x73 - 1] = "RAM Components",
+[3][0x74 - 1] = "Raqia Networks",
+[3][0x75 - 1] = "ClearSpeed",
+[3][0x76 - 1] = "Matsushita Battery",
+[3][0x77 - 1] = "Xelerated",
+[3][0x78 - 1] = "SimpleTech",
+[3][0x79 - 1] = "Utron Technology",
+[3][0x7a - 1] = "Astec International",
+[3][0x7b - 1] = "AVM gmbH",
+[3][0x7c - 1] = "Redux Communications",
+[3][0x7d - 1] = "Dot Hill Systems",
+[3][0x7e - 1] = "TeraChip",
+[4][0x01 - 1] = "T-RAM Incorporated",
+[4][0x02 - 1] = "Innovics Wireless",
+[4][0x03 - 1] = "Teknovus",
+[4][0x04 - 1] = "KeyEye Communications",
+[4][0x05 - 1] = "Runcom Technologies",
+[4][0x06 - 1] = "RedSwitch",
+[4][0x07 - 1] = "Dotcast",
+[4][0x08 - 1] = "Silicon Mountain Memory",
+[4][0x09 - 1] = "Signia Technologies",
+[4][0x0a - 1] = "Pixim",
+[4][0x0b - 1] = "Galazar Networks",
+[4][0x0c - 1] = "White Electronic Designs",
+[4][0x0d - 1] = "Patriot Scientific",
+[4][0x0e - 1] = "Neoaxiom Corporation",
+[4][0x0f - 1] = "3Y Power Technology",
+[4][0x10 - 1] = "Scaleo Chip",
+[4][0x11 - 1] = "Potentia Power Systems",
+[4][0x12 - 1] = "C-guys Incorporated",
+[4][0x13 - 1] = "Digital Communications Technology",
+[4][0x14 - 1] = "Silicon-Based Technology",
+[4][0x15 - 1] = "Fulcrum Microsystems",
+[4][0x16 - 1] = "Positivo Informatica Ltd",
+[4][0x17 - 1] = "XIOtech Corporation",
+[4][0x18 - 1] = "PortalPlayer",
+[4][0x19 - 1] = "Zhiying Software",
+[4][0x1a - 1] = "ParkerVision, Inc.",
+[4][0x1b - 1] = "Phonex Broadband",
+[4][0x1c - 1] = "Skyworks Solutions",
+[4][0x1d - 1] = "Entropic Communications",
+[4][0x1e - 1] = "I’M Intelligent Memory Ltd.",
+[4][0x1f - 1] = "Zensys A/S",
+[4][0x20 - 1] = "Legend Silicon Corp.",
+[4][0x21 - 1] = "Sci-worx GmbH",
+[4][0x22 - 1] = "SMSC (Standard Microsystems)",
+[4][0x23 - 1] = "Renesas Electronics",
+[4][0x24 - 1] = "Raza Microelectronics",
+[4][0x25 - 1] = "Phyworks",
+[4][0x26 - 1] = "MediaTek",
+[4][0x27 - 1] = "Non-cents Productions",
+[4][0x28 - 1] = "US Modular",
+[4][0x29 - 1] = "Wintegra Ltd.",
+[4][0x2a - 1] = "Mathstar",
+[4][0x2b - 1] = "StarCore",
+[4][0x2c - 1] = "Oplus Technologies",
+[4][0x2d - 1] = "Mindspeed",
+[4][0x2e - 1] = "Just Young Computer",
+[4][0x2f - 1] = "Radia Communications",
+[4][0x30 - 1] = "OCZ",
+[4][0x31 - 1] = "Emuzed",
+[4][0x32 - 1] = "LOGIC Devices",
+[4][0x33 - 1] = "Inphi Corporation",
+[4][0x34 - 1] = "Quake Technologies",
+[4][0x35 - 1] = "Vixel",
+[4][0x36 - 1] = "SolusTek",
+[4][0x37 - 1] = "Kongsberg Maritime",
+[4][0x38 - 1] = "Faraday Technology",
+[4][0x39 - 1] = "Altium Ltd.",
+[4][0x3a - 1] = "Insyte",
+[4][0x3b - 1] = "ARM Ltd.",
+[4][0x3c - 1] = "DigiVision",
+[4][0x3d - 1] = "Vativ Technologies",
+[4][0x3e - 1] = "Endicott Interconnect Technologies",
+[4][0x3f - 1] = "Pericom",
+[4][0x40 - 1] = "Bandspeed",
+[4][0x41 - 1] = "LeWiz Communications",
+[4][0x42 - 1] = "CPU Technology",
+[4][0x43 - 1] = "Ramaxel Technology",
+[4][0x44 - 1] = "DSP Group",
+[4][0x45 - 1] = "Axis Communications",
+[4][0x46 - 1] = "Legacy Electronics",
+[4][0x47 - 1] = "Chrontel",
+[4][0x48 - 1] = "Powerchip Semiconductor",
+[4][0x49 - 1] = "MobilEye Technologies",
+[4][0x4a - 1] = "Excel Semiconductor",
+[4][0x4b - 1] = "A-DATA Technology",
+[4][0x4c - 1] = "VirtualDigm",
+[4][0x4d - 1] = "G Skill Intl",
+[4][0x4e - 1] = "Quanta Computer",
+[4][0x4f - 1] = "Yield Microelectronics",
+[4][0x50 - 1] = "Afa Technologies",
+[4][0x51 - 1] = "KINGBOX Technology Co. Ltd.",
+[4][0x52 - 1] = "Ceva",
+[4][0x53 - 1] = "iStor Networks",
+[4][0x54 - 1] = "Advance Modules",
+[4][0x55 - 1] = "Microsoft",
+[4][0x56 - 1] = "Open-Silicon",
+[4][0x57 - 1] = "Goal Semiconductor",
+[4][0x58 - 1] = "ARC International",
+[4][0x59 - 1] = "Simmtec",
+[4][0x5a - 1] = "Metanoia",
+[4][0x5b - 1] = "Key Stream",
+[4][0x5c - 1] = "Lowrance Electronics",
+[4][0x5d - 1] = "Adimos",
+[4][0x5e - 1] = "SiGe Semiconductor",
+[4][0x5f - 1] = "Fodus Communications",
+[4][0x60 - 1] = "Credence Systems Corp.",
+[4][0x61 - 1] = "Genesis Microchip Inc.",
+[4][0x62 - 1] = "Vihana, Inc.",
+[4][0x63 - 1] = "WIS Technologies",
+[4][0x64 - 1] = "GateChange Technologies",
+[4][0x65 - 1] = "High Density Devices AS",
+[4][0x66 - 1] = "Synopsys",
+[4][0x67 - 1] = "Gigaram",
+[4][0x68 - 1] = "Enigma Semiconductor Inc.",
+[4][0x69 - 1] = "Century Micro Inc.",
+[4][0x6a - 1] = "Icera Semiconductor",
+[4][0x6b - 1] = "Mediaworks Integrated Systems",
+[4][0x6c - 1] = "O’Neil Product Development",
+[4][0x6d - 1] = "Supreme Top Technology Ltd.",
+[4][0x6e - 1] = "MicroDisplay Corporation",
+[4][0x6f - 1] = "Team Group Inc.",
+[4][0x70 - 1] = "Sinett Corporation",
+[4][0x71 - 1] = "Toshiba Corporation",
+[4][0x72 - 1] = "Tensilica",
+[4][0x73 - 1] = "SiRF Technology",
+[4][0x74 - 1] = "Bacoc Inc.",
+[4][0x75 - 1] = "SMaL Camera Technologies",
+[4][0x76 - 1] = "Thomson SC",
+[4][0x77 - 1] = "Airgo Networks",
+[4][0x78 - 1] = "Wisair Ltd.",
+[4][0x79 - 1] = "SigmaTel",
+[4][0x7a - 1] = "Arkados",
+[4][0x7b - 1] = "Compete IT gmbH Co. KG",
+[4][0x7c - 1] = "Eudar Technology Inc.",
+[4][0x7d - 1] = "Focus Enhancements",
+[4][0x7e - 1] = "Xyratex",
+[5][0x01 - 1] = "Specular Networks",
+[5][0x02 - 1] = "Patriot Memory (PDP Systems)",
+[5][0x03 - 1] = "U-Chip Technology Corp.",
+[5][0x04 - 1] = "Silicon Optix",
+[5][0x05 - 1] = "Greenfield Networks",
+[5][0x06 - 1] = "CompuRAM GmbH",
+[5][0x07 - 1] = "Stargen, Inc.",
+[5][0x08 - 1] = "NetCell Corporation",
+[5][0x09 - 1] = "Excalibrus Technologies Ltd",
+[5][0x0a - 1] = "SCM Microsystems",
+[5][0x0b - 1] = "Xsigo Systems, Inc.",
+[5][0x0c - 1] = "CHIPS & Systems Inc",
+[5][0x0d - 1] = "Tier 1 Multichip Solutions",
+[5][0x0e - 1] = "CWRL Labs",
+[5][0x0f - 1] = "Teradici",
+[5][0x10 - 1] = "Gigaram, Inc.",
+[5][0x11 - 1] = "g2 Microsystems",
+[5][0x12 - 1] = "PowerFlash Semiconductor",
+[5][0x13 - 1] = "P.A. Semi, Inc.",
+[5][0x14 - 1] = "NovaTech Solutions, S.A.",
+[5][0x15 - 1] = "c2 Microsystems, Inc.",
+[5][0x16 - 1] = "Level5 Networks",
+[5][0x17 - 1] = "COS Memory AG",
+[5][0x18 - 1] = "Innovasic Semiconductor",
+[5][0x19 - 1] = "02IC Co. Ltd",
+[5][0x1a - 1] = "Tabula, Inc.",
+[5][0x1b - 1] = "Crucial Technology",
+[5][0x1c - 1] = "Chelsio Communications",
+[5][0x1d - 1] = "Solarflare Communications",
+[5][0x1e - 1] = "Xambala Inc.",
+[5][0x1f - 1] = "EADS Astrium",
+[5][0x20 - 1] = "Terra Semiconductor, Inc.",
+[5][0x21 - 1] = "Imaging Works, Inc.",
+[5][0x22 - 1] = "Astute Networks, Inc.",
+[5][0x23 - 1] = "Tzero",
+[5][0x24 - 1] = "Emulex",
+[5][0x25 - 1] = "Power-One",
+[5][0x26 - 1] = "Pulse~LINK Inc.",
+[5][0x27 - 1] = "Hon Hai Precision Industry",
+[5][0x28 - 1] = "White Rock Networks Inc.",
+[5][0x29 - 1] = "Telegent Systems USA, Inc.",
+[5][0x2a - 1] = "Atrua Technologies, Inc.",
+[5][0x2b - 1] = "Acbel Polytech Inc.",
+[5][0x2c - 1] = "eRide Inc.",
+[5][0x2d - 1] = "ULi Electronics Inc.",
+[5][0x2e - 1] = "Magnum Semiconductor Inc.",
+[5][0x2f - 1] = "neoOne Technology, Inc.",
+[5][0x30 - 1] = "Connex Technology, Inc.",
+[5][0x31 - 1] = "Stream Processors, Inc.",
+[5][0x32 - 1] = "Focus Enhancements",
+[5][0x33 - 1] = "Telecis Wireless, Inc.",
+[5][0x34 - 1] = "uNav Microelectronics",
+[5][0x35 - 1] = "Tarari, Inc.",
+[5][0x36 - 1] = "Ambric, Inc.",
+[5][0x37 - 1] = "Newport Media, Inc.",
+[5][0x38 - 1] = "VMTS",
+[5][0x39 - 1] = "Enuclia Semiconductor, Inc.",
+[5][0x3a - 1] = "Virtium Technology Inc.",
+[5][0x3b - 1] = "Solid State System Co., Ltd.",
+[5][0x3c - 1] = "Kian Tech LLC",
+[5][0x3d - 1] = "Artimi",
+[5][0x3e - 1] = "Power Quotient International",
+[5][0x3f - 1] = "Avago Technologies",
+[5][0x40 - 1] = "ADTechnology",
+[5][0x41 - 1] = "Sigma Designs",
+[5][0x42 - 1] = "SiCortex, Inc.",
+[5][0x43 - 1] = "Ventura Technology Group",
+[5][0x44 - 1] = "eASIC",
+[5][0x45 - 1] = "M.H.S. SAS",
+[5][0x46 - 1] = "Micro Star International",
+[5][0x47 - 1] = "Rapport Inc.",
+[5][0x48 - 1] = "Makway International",
+[5][0x49 - 1] = "Broad Reach Engineering Co.",
+[5][0x4a - 1] = "Semiconductor Mfg Intl Corp",
+[5][0x4b - 1] = "SiConnect",
+[5][0x4c - 1] = "FCI USA Inc.",
+[5][0x4d - 1] = "Validity Sensors",
+[5][0x4e - 1] = "Coney Technology Co. Ltd.",
+[5][0x4f - 1] = "Spans Logic",
+[5][0x50 - 1] = "Neterion Inc.",
+[5][0x51 - 1] = "Qimonda",
+[5][0x52 - 1] = "New Japan Radio Co. Ltd.",
+[5][0x53 - 1] = "Velogix",
+[5][0x54 - 1] = "Montalvo Systems",
+[5][0x55 - 1] = "iVivity Inc.",
+[5][0x56 - 1] = "Walton Chaintech",
+[5][0x57 - 1] = "AENEON",
+[5][0x58 - 1] = "Lorom Industrial Co. Ltd.",
+[5][0x59 - 1] = "Radiospire Networks",
+[5][0x5a - 1] = "Sensio Technologies, Inc.",
+[5][0x5b - 1] = "Nethra Imaging",
+[5][0x5c - 1] = "Hexon Technology Pte Ltd",
+[5][0x5d - 1] = "CompuStocx (CSX)",
+[5][0x5e - 1] = "Methode Electronics, Inc.",
+[5][0x5f - 1] = "Connect One Ltd.",
+[5][0x60 - 1] = "Opulan Technologies",
+[5][0x61 - 1] = "Septentrio NV",
+[5][0x62 - 1] = "Goldenmars Technology Inc.",
+[5][0x63 - 1] = "Kreton Corporation",
+[5][0x64 - 1] = "Cochlear Ltd.",
+[5][0x65 - 1] = "Altair Semiconductor",
+[5][0x66 - 1] = "NetEffect, Inc.",
+[5][0x67 - 1] = "Spansion, Inc.",
+[5][0x68 - 1] = "Taiwan Semiconductor Mfg",
+[5][0x69 - 1] = "Emphany Systems Inc.",
+[5][0x6a - 1] = "ApaceWave Technologies",
+[5][0x6b - 1] = "Mobilygen Corporation",
+[5][0x6c - 1] = "Tego",
+[5][0x6d - 1] = "Cswitch Corporation",
+[5][0x6e - 1] = "Haier (Beijing) IC Design Co.",
+[5][0x6f - 1] = "MetaRAM",
+[5][0x70 - 1] = "Axel Electronics Co. Ltd.",
+[5][0x71 - 1] = "Tilera Corporation",
+[5][0x72 - 1] = "Aquantia",
+[5][0x73 - 1] = "Vivace Semiconductor",
+[5][0x74 - 1] = "Redpine Signals",
+[5][0x75 - 1] = "Octalica",
+[5][0x76 - 1] = "InterDigital Communications",
+[5][0x77 - 1] = "Avant Technology",
+[5][0x78 - 1] = "Asrock, Inc.",
+[5][0x79 - 1] = "Availink",
+[5][0x7a - 1] = "Quartics, Inc.",
+[5][0x7b - 1] = "Element CXI",
+[5][0x7c - 1] = "Innovaciones Microelectronicas",
+[5][0x7d - 1] = "VeriSilicon Microelectronics",
+[5][0x7e - 1] = "W5 Networks",
+[6][0x01 - 1] = "MOVEKING",
+[6][0x02 - 1] = "Mavrix Technology, Inc.",
+[6][0x03 - 1] = "CellGuide Ltd.",
+[6][0x04 - 1] = "Faraday Technology",
+[6][0x05 - 1] = "Diablo Technologies, Inc.",
+[6][0x06 - 1] = "Jennic",
+[6][0x07 - 1] = "Octasic",
+[6][0x08 - 1] = "Molex Incorporated",
+[6][0x09 - 1] = "3Leaf Networks",
+[6][0x0a - 1] = "Bright Micron Technology",
+[6][0x0b - 1] = "Netxen",
+[6][0x0c - 1] = "NextWave Broadband Inc.",
+[6][0x0d - 1] = "DisplayLink",
+[6][0x0e - 1] = "ZMOS Technology",
+[6][0x0f - 1] = "Tec-Hill",
+[6][0x10 - 1] = "Multigig, Inc.",
+[6][0x11 - 1] = "Amimon",
+[6][0x12 - 1] = "Euphonic Technologies, Inc.",
+[6][0x13 - 1] = "BRN Phoenix",
+[6][0x14 - 1] = "InSilica",
+[6][0x15 - 1] = "Ember Corporation",
+[6][0x16 - 1] = "Avexir Technologies Corporation",
+[6][0x17 - 1] = "Echelon Corporation",
+[6][0x18 - 1] = "Edgewater Computer Systems",
+[6][0x19 - 1] = "XMOS Semiconductor Ltd.",
+[6][0x1a - 1] = "GENUSION, Inc.",
+[6][0x1b - 1] = "Memory Corp NV",
+[6][0x1c - 1] = "SiliconBlue Technologies",
+[6][0x1d - 1] = "Rambus Inc.",
+[6][0x1e - 1] = "Andes Technology Corporation",
+[6][0x1f - 1] = "Coronis Systems",
+[6][0x20 - 1] = "Achronix Semiconductor",
+[6][0x21 - 1] = "Siano Mobile Silicon Ltd.",
+[6][0x22 - 1] = "Semtech Corporation",
+[6][0x23 - 1] = "Pixelworks Inc.",
+[6][0x24 - 1] = "Gaisler Research AB",
+[6][0x25 - 1] = "Teranetics",
+[6][0x26 - 1] = "Toppan Printing Co. Ltd.",
+[6][0x27 - 1] = "Kingxcon",
+[6][0x28 - 1] = "Silicon Integrated Systems",
+[6][0x29 - 1] = "I-O Data Device, Inc.",
+[6][0x2a - 1] = "NDS Americas Inc.",
+[6][0x2b - 1] = "Solomon Systech Limited",
+[6][0x2c - 1] = "On Demand Microelectronics",
+[6][0x2d - 1] = "Amicus Wireless Inc.",
+[6][0x2e - 1] = "SMARDTV SNC",
+[6][0x2f - 1] = "Comsys Communication Ltd.",
+[6][0x30 - 1] = "Movidia Ltd.",
+[6][0x31 - 1] = "Javad GNSS, Inc.",
+[6][0x32 - 1] = "Montage Technology Group",
+[6][0x33 - 1] = "Trident Microsystems",
+[6][0x34 - 1] = "Super Talent",
+[6][0x35 - 1] = "Optichron, Inc.",
+[6][0x36 - 1] = "Future Waves UK Ltd.",
+[6][0x37 - 1] = "SiBEAM, Inc.",
+[6][0x38 - 1] = "Inicore,Inc.",
+[6][0x39 - 1] = "Virident Systems",
+[6][0x3a - 1] = "M2000, Inc.",
+[6][0x3b - 1] = "ZeroG Wireless, Inc.",
+[6][0x3c - 1] = "Gingle Technology Co. Ltd.",
+[6][0x3d - 1] = "Space Micro Inc.",
+[6][0x3e - 1] = "Wilocity",
+[6][0x3f - 1] = "Novafora, Inc.",
+[6][0x40 - 1] = "iKoa Corporation",
+[6][0x41 - 1] = "ASint Technology",
+[6][0x42 - 1] = "Ramtron",
+[6][0x43 - 1] = "Plato Networks Inc.",
+[6][0x44 - 1] = "IPtronics AS",
+[6][0x45 - 1] = "Infinite-Memories",
+[6][0x46 - 1] = "Parade Technologies Inc.",
+[6][0x47 - 1] = "Dune Networks",
+[6][0x48 - 1] = "GigaDevice Semiconductor",
+[6][0x49 - 1] = "Modu Ltd.",
+[6][0x4a - 1] = "CEITEC",
+[6][0x4b - 1] = "Northrop Grumman",
+[6][0x4c - 1] = "XRONET Corporation",
+[6][0x4d - 1] = "Sicon Semiconductor AB",
+[6][0x4e - 1] = "Atla Electronics Co. Ltd.",
+[6][0x4f - 1] = "TOPRAM Technology",
+[6][0x50 - 1] = "Silego Technology Inc.",
+[6][0x51 - 1] = "Kinglife",
+[6][0x52 - 1] = "Ability Industries Ltd.",
+[6][0x53 - 1] = "Silicon Power Computer &",
+[6][0x54 - 1] = "Augusta Technology, Inc.",
+[6][0x55 - 1] = "Nantronics Semiconductors",
+[6][0x56 - 1] = "Hilscher Gesellschaft",
+[6][0x57 - 1] = "Quixant Ltd.",
+[6][0x58 - 1] = "Percello Ltd.",
+[6][0x59 - 1] = "NextIO Inc.",
+[6][0x5a - 1] = "Scanimetrics Inc.",
+[6][0x5b - 1] = "FS-Semi Company Ltd.",
+[6][0x5c - 1] = "Infinera Corporation",
+[6][0x5d - 1] = "SandForce Inc.",
+[6][0x5e - 1] = "Lexar Media",
+[6][0x5f - 1] = "Teradyne Inc.",
+[6][0x60 - 1] = "Memory Exchange Corp.",
+[6][0x61 - 1] = "Suzhou Smartek Electronics",
+[6][0x62 - 1] = "Avantium Corporation",
+[6][0x63 - 1] = "ATP Electronics Inc.",
+[6][0x64 - 1] = "Valens Semiconductor Ltd",
+[6][0x65 - 1] = "Agate Logic, Inc.",
+[6][0x66 - 1] = "Netronome",
+[6][0x67 - 1] = "Zenverge, Inc.",
+[6][0x68 - 1] = "N-trig Ltd",
+[6][0x69 - 1] = "SanMax Technologies Inc.",
+[6][0x6a - 1] = "Contour Semiconductor Inc.",
+[6][0x6b - 1] = "TwinMOS",
+[6][0x6c - 1] = "Silicon Systems, Inc.",
+[6][0x6d - 1] = "V-Color Technology Inc.",
+[6][0x6e - 1] = "Certicom Corporation",
+[6][0x6f - 1] = "JSC ICC Milandr",
+[6][0x70 - 1] = "PhotoFast Global Inc.",
+[6][0x71 - 1] = "InnoDisk Corporation",
+[6][0x72 - 1] = "Muscle Power",
+[6][0x73 - 1] = "Energy Micro",
+[6][0x74 - 1] = "Innofidei",
+[6][0x75 - 1] = "CopperGate Communications",
+[6][0x76 - 1] = "Holtek Semiconductor Inc.",
+[6][0x77 - 1] = "Myson Century, Inc.",
+[6][0x78 - 1] = "FIDELIX",
+[6][0x79 - 1] = "Red Digital Cinema",
+[6][0x7a - 1] = "Densbits Technology",
+[6][0x7b - 1] = "Zempro",
+[6][0x7c - 1] = "MoSys",
+[6][0x7d - 1] = "Provigent",
+[6][0x7e - 1] = "Triad Semiconductor, Inc.",
+[7][0x01 - 1] = "Siklu Communication Ltd.",
+[7][0x02 - 1] = "A Force Manufacturing Ltd.",
+[7][0x03 - 1] = "Strontium",
+[7][0x04 - 1] = "ALi Corp (Abilis Systems)",
+[7][0x05 - 1] = "Siglead, Inc.",
+[7][0x06 - 1] = "Ubicom, Inc.",
+[7][0x07 - 1] = "Unifosa Corporation",
+[7][0x08 - 1] = "Stretch, Inc.",
+[7][0x09 - 1] = "Lantiq Deutschland GmbH",
+[7][0x0a - 1] = "Visipro.",
+[7][0x0b - 1] = "EKMemory",
+[7][0x0c - 1] = "Microelectronics Institute ZTE",
+[7][0x0d - 1] = "u-blox AG",
+[7][0x0e - 1] = "Carry Technology Co. Ltd.",
+[7][0x0f - 1] = "Nokia",
+[7][0x10 - 1] = "King Tiger Technology",
+[7][0x11 - 1] = "Sierra Wireless",
+[7][0x12 - 1] = "HT Micron",
+[7][0x13 - 1] = "Albatron Technology Co. Ltd.",
+[7][0x14 - 1] = "Leica Geosystems AG",
+[7][0x15 - 1] = "BroadLight",
+[7][0x16 - 1] = "AEXEA",
+[7][0x17 - 1] = "ClariPhy Communications, Inc.",
+[7][0x18 - 1] = "Green Plug",
+[7][0x19 - 1] = "Design Art Networks",
+[7][0x1a - 1] = "Mach Xtreme Technology Ltd.",
+[7][0x1b - 1] = "ATO Solutions Co. Ltd.",
+[7][0x1c - 1] = "Ramsta",
+[7][0x1d - 1] = "Greenliant Systems, Ltd.",
+[7][0x1e - 1] = "Teikon",
+[7][0x1f - 1] = "Antec Hadron",
+[7][0x20 - 1] = "NavCom Technology, Inc.",
+[7][0x21 - 1] = "Shanghai Fudan Microelectronics",
+[7][0x22 - 1] = "Calxeda, Inc.",
+[7][0x23 - 1] = "JSC EDC Electronics",
+[7][0x24 - 1] = "Kandit Technology Co. Ltd.",
+[7][0x25 - 1] = "Ramos Technology",
+[7][0x26 - 1] = "Goldenmars Technology",
+[7][0x27 - 1] = "XeL Technology Inc.",
+[7][0x28 - 1] = "Newzone Corporation",
+[7][0x29 - 1] = "ShenZhen MercyPower Tech",
+[7][0x2a - 1] = "Nanjing Yihuo Technology",
+[7][0x2b - 1] = "Nethra Imaging Inc.",
+[7][0x2c - 1] = "SiTel Semiconductor BV",
+[7][0x2d - 1] = "SolidGear Corporation",
+[7][0x2e - 1] = "Topower Computer Ind Co Ltd.",
+[7][0x2f - 1] = "Wilocity",
+[7][0x30 - 1] = "Profichip GmbH",
+[7][0x31 - 1] = "Gerad Technologies",
+[7][0x32 - 1] = "Ritek Corporation",
+[7][0x33 - 1] = "Gomos Technology Limited",
+[7][0x34 - 1] = "Memoright Corporation",
+[7][0x35 - 1] = "D-Broad, Inc.",
+[7][0x36 - 1] = "HiSilicon Technologies",
+[7][0x37 - 1] = "Syndiant Inc..",
+[7][0x38 - 1] = "Enverv Inc.",
+[7][0x39 - 1] = "Cognex",
+[7][0x3a - 1] = "Xinnova Technology Inc.",
+[7][0x3b - 1] = "Ultron AG",
+[7][0x3c - 1] = "Concord Idea Corporation",
+[7][0x3d - 1] = "AIM Corporation",
+[7][0x3e - 1] = "Lifetime Memory Products",
+[7][0x3f - 1] = "Ramsway",
+[7][0x40 - 1] = "Recore Systems B.V.",
+[7][0x41 - 1] = "Haotian Jinshibo Science Tech",
+[7][0x42 - 1] = "Being Advanced Memory",
+[7][0x43 - 1] = "Adesto Technologies",
+[7][0x44 - 1] = "Giantec Semiconductor, Inc.",
+[7][0x45 - 1] = "HMD Electronics AG",
+[7][0x46 - 1] = "Gloway International (HK)",
+[7][0x47 - 1] = "Kingcore",
+[7][0x48 - 1] = "Anucell Technology Holding",
+[7][0x49 - 1] = "Accord Software & Systems Pvt. Ltd.",
+[7][0x4a - 1] = "Active-Semi Inc.",
+[7][0x4b - 1] = "Denso Corporation",
+[7][0x4c - 1] = "TLSI Inc.",
+[7][0x4d - 1] = "Qidan",
+[7][0x4e - 1] = "Mustang",
+[7][0x4f - 1] = "Orca Systems",
+[7][0x50 - 1] = "Passif Semiconductor",
+[7][0x51 - 1] = "GigaDevice Semiconductor (Beijing)",
+[7][0x52 - 1] = "Memphis Electronic",
+[7][0x53 - 1] = "Beckhoff Automation GmbH",
+[7][0x54 - 1] = "Harmony Semiconductor Corp",
+[7][0x55 - 1] = "Air Computers SRL",
+[7][0x56 - 1] = "TMT Memory",
+[7][0x57 - 1] = "Eorex Corporation",
+[7][0x58 - 1] = "Xingtera",
+[7][0x59 - 1] = "Netsol",
+[7][0x5a - 1] = "Bestdon Technology Co. Ltd.",
+[7][0x5b - 1] = "Baysand Inc.",
+[7][0x5c - 1] = "Uroad Technology Co. Ltd.",
+[7][0x5d - 1] = "Wilk Elektronik S.A.",
+[7][0x5e - 1] = "AAI",
+[7][0x5f - 1] = "Harman",
+[7][0x60 - 1] = "Berg Microelectronics Inc.",
+[7][0x61 - 1] = "ASSIA, Inc.",
+[7][0x62 - 1] = "Visiontek Products LLC",
+[7][0x63 - 1] = "OCMEMORY",
+[7][0x64 - 1] = "Welink Solution Inc.",
+[7][0x65 - 1] = "Shark Gaming",
+[7][0x66 - 1] = "Avalanche Technology",
+[7][0x67 - 1] = "R&D Center ELVEES OJSC",
+[7][0x68 - 1] = "KingboMars Technology Co. Ltd.",
+[7][0x69 - 1] = "High Bridge Solutions Industria",
+[7][0x6a - 1] = "Transcend Technology Co. Ltd.",
+[7][0x6b - 1] = "Everspin Technologies",
+[7][0x6c - 1] = "Hon-Hai Precision",
+[7][0x6d - 1] = "Smart Storage Systems",
+[7][0x6e - 1] = "Toumaz Group",
+[7][0x6f - 1] = "Zentel Electronics Corporation",
+[7][0x70 - 1] = "Panram International Corporation",
+[7][0x71 - 1] = "Silicon Space Technology",
+[7][0x72 - 1] = "LITE-ON IT Corporation",
+[7][0x73 - 1] = "Inuitive",
+[7][0x74 - 1] = "HMicro",
+[7][0x75 - 1] = "BittWare, Inc.",
+[7][0x76 - 1] = "GLOBALFOUNDRIES",
+[7][0x77 - 1] = "ACPI Digital Co. Ltd.",
+[7][0x78 - 1] = "Annapurna Labs",
+[7][0x79 - 1] = "AcSiP Technology Corporation",
+[7][0x7a - 1] = "Idea! Electronic Systems",
+[7][0x7b - 1] = "Gowe Technology Co. Ltd.",
+[7][0x7c - 1] = "Hermes Testing Solutions, Inc.",
+[7][0x7d - 1] = "Positivo BGH",
+[7][0x7e - 1] = "Intelligence Silicon Technology",
+[8][0x01 - 1] = "3D PLUS",
+[8][0x02 - 1] = "Diehl Aerospace",
+[8][0x03 - 1] = "Fairchild",
+[8][0x04 - 1] = "Mercury Systems",
+[8][0x05 - 1] = "Sonics, Inc.",
+[8][0x06 - 1] = "GE Intelligent Platforms GmbH & Co.",
+[8][0x07 - 1] = "Shenzhen Jinge Information Co. Ltd.",
+[8][0x08 - 1] = "SCWW",
+[8][0x09 - 1] = "Silicon Motion Inc.",
+[8][0x0a - 1] = "Anurag",
+[8][0x0b - 1] = "King Kong",
+[8][0x0c - 1] = "FROM30 Co. Ltd.",
+[8][0x0d - 1] = "Gowin Semiconductor Corp",
+[8][0x0e - 1] = "Fremont Micro Devices Ltd.",
+[8][0x0f - 1] = "Ericsson Modems",
+[8][0x10 - 1] = "Exelis",
+[8][0x11 - 1] = "Satixfy Ltd.",
+[8][0x12 - 1] = "Galaxy Microsystems Ltd.",
+[8][0x13 - 1] = "Gloway International Co. Ltd.",
+[8][0x14 - 1] = "Lab",
+[8][0x15 - 1] = "Smart Energy Instruments",
+[8][0x16 - 1] = "Approved Memory Corporation",
+[8][0x17 - 1] = "Axell Corporation",
+[8][0x18 - 1] = "Essencore Limited",
+[8][0x19 - 1] = "Phytium",
+[8][0x1a - 1] = "Xi’an SinoChip Semiconductor",
+[8][0x1b - 1] = "Ambiq Micro",
+[8][0x1c - 1] = "eveRAM Technology, Inc.",
+[8][0x1d - 1] = "Infomax",
+[8][0x1e - 1] = "Butterfly Network, Inc.",
+[8][0x1f - 1] = "Shenzhen City Gcai Electronics",
+[8][0x20 - 1] = "Stack Devices Corporation",
+[8][0x21 - 1] = "ADK Media Group",
+[8][0x22 - 1] = "TSP Global Co., Ltd.",
+[8][0x23 - 1] = "HighX",
+[8][0x24 - 1] = "Shenzhen Elicks Technology",
+[8][0x25 - 1] = "ISSI/Chingis",
+[8][0x26 - 1] = "Google, Inc.",
+[8][0x27 - 1] = "Dasima International Development",
+[8][0x28 - 1] = "Leahkinn Technology Limited",
+[8][0x29 - 1] = "HIMA Paul Hildebrandt GmbH Co KG",
+[8][0x2a - 1] = "Keysight Technologies",
+[8][0x2b - 1] = "Techcomp International (Fastable)",
+[8][0x2c - 1] = "Ancore Technology Corporation",
+[8][0x2d - 1] = "Nuvoton",
+[8][0x2e - 1] = "Korea Uhbele International Group Ltd.",
+[8][0x2f - 1] = "Ikegami Tsushinki Co Ltd.",
+[8][0x30 - 1] = "RelChip, Inc.",
+[8][0x31 - 1] = "Baikal Electronics",
+[8][0x32 - 1] = "Nemostech Inc.",
+[8][0x33 - 1] = "Memorysolution GmbH",
+[8][0x34 - 1] = "Silicon Integrated Systems Corporation",
+[8][0x35 - 1] = "Xiede",
+[8][0x36 - 1] = "Multilaser Components",
+[8][0x37 - 1] = "Flash Chi",
+[8][0x38 - 1] = "Jone",
+[8][0x39 - 1] = "GCT Semiconductor Inc.",
+[8][0x3a - 1] = "Hong Kong Zetta Device Technology",
+[8][0x3b - 1] = "Unimemory Technology(s) Pte Ltd.",
+[8][0x3c - 1] = "Cuso",
+[8][0x3d - 1] = "Kuso",
+[8][0x3e - 1] = "Uniquify Inc.",
+[8][0x3f - 1] = "Skymedi Corporation",
+[8][0x40 - 1] = "Core Chance Co. Ltd.",
+[8][0x41 - 1] = "Tekism Co. Ltd.",
+[8][0x42 - 1] = "Seagate Technology PLC",
+[8][0x43 - 1] = "Hong Kong Gaia Group Co. Limited",
+[8][0x44 - 1] = "Gigacom Semiconductor LLC",
+[8][0x45 - 1] = "V2 Technologies",
+[8][0x46 - 1] = "TLi",
+[8][0x47 - 1] = "Neotion",
+[8][0x48 - 1] = "Lenovo",
+[8][0x49 - 1] = "Shenzhen Zhongteng Electronic Corp. Ltd.",
+[8][0x4a - 1] = "Compound Photonics",
+[8][0x4b - 1] = "in2H2 inc",
+[8][0x4c - 1] = "Shenzhen Pango Microsystems Co. Ltd",
+[8][0x4d - 1] = "Vasekey",
+[8][0x4e - 1] = "Cal-Comp Industria de Semicondutores",
+[8][0x4f - 1] = "Eyenix Co., Ltd.",
+[8][0x50 - 1] = "Heoriady",
+[8][0x51 - 1] = "Accelerated Memory Production Inc.",
+[8][0x52 - 1] = "INVECAS, Inc.",
+[8][0x53 - 1] = "AP Memory",
+[8][0x54 - 1] = "Douqi Technology",
+[8][0x55 - 1] = "Etron Technology, Inc.",
+[8][0x56 - 1] = "Indie Semiconductor",
+[8][0x57 - 1] = "Socionext Inc.",
+[8][0x58 - 1] = "HGST",
+[8][0x59 - 1] = "EVGA",
+[8][0x5a - 1] = "Audience Inc.",
+[8][0x5b - 1] = "EpicGear",
+[8][0x5c - 1] = "Vitesse Enterprise Co.",
+[8][0x5d - 1] = "Foxtronn International Corporation",
+[8][0x5e - 1] = "Bretelon Inc.",
+[8][0x5f - 1] = "Graphcore",
+[8][0x60 - 1] = "Eoplex Inc",
+[8][0x61 - 1] = "MaxLinear, Inc.",
+[8][0x62 - 1] = "ETA Devices",
+[8][0x63 - 1] = "LOKI",
+[8][0x64 - 1] = "IMS Electronics Co., Ltd.",
+[8][0x65 - 1] = "Dosilicon Co., Ltd.",
+[8][0x66 - 1] = "Dolphin Integration",
+[8][0x67 - 1] = "Shenzhen Mic Electronics Technology",
+[8][0x68 - 1] = "Boya Microelectronics Inc.",
+[8][0x69 - 1] = "Geniachip (Roche)",
+[8][0x6a - 1] = "Axign",
+[8][0x6b - 1] = "Kingred Electronic Technology Ltd.",
+[8][0x6c - 1] = "Chao Yue Zhuo Computer Business Dept.",
+[8][0x6d - 1] = "Guangzhou Si Nuo Electronic Technology.",
+[8][0x6e - 1] = "Crocus Technology Inc.",
+[8][0x6f - 1] = "Creative Chips GmbH",
+[8][0x70 - 1] = "GE Aviation Systems LLC.",
+[8][0x71 - 1] = "Asgard",
+[8][0x72 - 1] = "Good Wealth Technology Ltd.",
+[8][0x73 - 1] = "TriCor Technologies",
+[8][0x74 - 1] = "Nova-Systems GmbH",
+[8][0x75 - 1] = "JUHOR",
+[8][0x76 - 1] = "Zhuhai Douke Commerce Co. Ltd.",
+[8][0x77 - 1] = "DSL Memory",
+[8][0x78 - 1] = "Anvo-Systems Dresden GmbH",
+[8][0x79 - 1] = "Realtek",
+[8][0x7a - 1] = "AltoBeam",
+[8][0x7b - 1] = "Wave Computing",
+[8][0x7c - 1] = "Beijing TrustNet Technology Co. Ltd.",
+[8][0x7d - 1] = "Innovium, Inc.",
+[8][0x7e - 1] = "Starsway Technology Limited",
+[9][0x01 - 1] = "Weltronics Co. LTD",
+[9][0x02 - 1] = "VMware, Inc.",
+[9][0x03 - 1] = "Hewlett Packard Enterprise",
+[9][0x04 - 1] = "INTENSO",
+[9][0x05 - 1] = "Puya Semiconductor",
+[9][0x06 - 1] = "MEMORFI",
+[9][0x07 - 1] = "MSC Technologies GmbH",
+[9][0x08 - 1] = "Txrui",
+[9][0x09 - 1] = "SiFive, Inc.",
+[9][0x0a - 1] = "Spreadtrum Communications",
+[9][0x0b - 1] = "Paragon Technology (Shenzhen) Ltd.",
+[9][0x0c - 1] = "UMAX Technology",
+[9][0x0d - 1] = "Shenzhen Yong Sheng Technology",
+[9][0x0e - 1] = "SNOAMOO (Shenzhen Kai Zhuo Yue)",
+[9][0x0f - 1] = "Daten Tecnologia LTDA",
+[9][0x10 - 1] = "Shenzhen XinRuiYan Electronics",
+[9][0x11 - 1] = "Eta Compute",
+[9][0x12 - 1] = "Energous",
+[9][0x13 - 1] = "Raspberry Pi Trading Ltd.",
+[9][0x14 - 1] = "Shenzhen Chixingzhe Tech Co. Ltd.",
+/* EOF */
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index 4602a8db..d13bdfba 100644
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -205,7 +205,7 @@ int Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere)
 		return JIM_ERR;
 }
 
-int Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len)
+int Jim_GetOpt_String(Jim_GetOptInfo *goi, const char **puthere, int *len)
 {
 	int r;
 	Jim_Obj *o;
@@ -215,8 +215,7 @@ int Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len)
 	if (r == JIM_OK) {
 		cp = Jim_GetString(o, len);
 		if (puthere) {
-			/* remove const */
-			*puthere = (char *)(cp);
+			*puthere = cp;
 		}
 	}
 	return r;
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 05d79c4a..7b4a491d 100644
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -41,8 +41,8 @@
  * official policies, either expressed or implied, of the Jim Tcl Project.
  */
 
-#ifndef JIM_NVP_H
-#define JIM_NVP_H
+#ifndef OPENOCD_HELPER_JIM_NVP_H
+#define OPENOCD_HELPER_JIM_NVP_H
 
 #include <jim.h>
 
@@ -245,7 +245,7 @@ int Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere);
  * \param puthere - where param is put
  * \param len     - return its length
  */
-int Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len);
+int Jim_GetOpt_String(Jim_GetOptInfo *goi, const char **puthere, int *len);
 
 /** Remove argv[0] as double.
  *
@@ -326,4 +326,4 @@ void Jim_GetOpt_NvpUnknown(Jim_GetOptInfo *goi, const Jim_Nvp *lookup, int hadpr
  */
 int Jim_GetOpt_Enum(Jim_GetOptInfo *goi, const char *const *lookup, int *puthere);
 
-#endif
+#endif /* OPENOCD_HELPER_JIM_NVP_H */
diff --git a/src/helper/list.h b/src/helper/list.h
index 302b9109..6fd0e7ca 100644
--- a/src/helper/list.h
+++ b/src/helper/list.h
@@ -1,5 +1,5 @@
-#ifndef _LINUX_LIST_H
-#define _LINUX_LIST_H
+#ifndef OPENOCD_HELPER_LIST_H
+#define OPENOCD_HELPER_LIST_H
 
 /* begin local changes */
 #include <helper/types.h>
@@ -734,4 +734,4 @@ static inline void hlist_move_list(struct hlist_head *old,
 	     ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1; }); \
 	     pos = n)
 
-#endif
+#endif /* OPENOCD_HELPER_LIST_H */
diff --git a/src/helper/log.c b/src/helper/log.c
index b70524b7..78093cb9 100644
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -47,16 +45,17 @@ int debug_level = -1;
 static FILE *log_output;
 static struct log_callback *log_callbacks;
 
-static long long last_time;
-static long long current_time;
+static int64_t last_time;
+static int64_t current_time;
 
-static long long start;
+static int64_t start;
 
-static const char * const log_strings[5] = {
+static const char * const log_strings[6] = {
 	"User : ",
 	"Error: ",
 	"Warn : ",	/* want a space after each colon, all same width, colons aligned */
 	"Info : ",
+	"Debug: ",
 	"Debug: "
 };
 
@@ -105,7 +104,7 @@ static void log_forward(const char *file, unsigned line, const char *function, c
 	}
 }
 
-/* The log_puts() serves to somewhat different goals:
+/* The log_puts() serves two somewhat different goals:
  *
  * - logging
  * - feeding low-level info to the user in GDB or Telnet
@@ -136,12 +135,12 @@ static void log_puts(enum log_levels level,
 	if (strlen(string) > 0) {
 		if (debug_level >= LOG_LVL_DEBUG) {
 			/* print with count and time information */
-			int t = (int)(timeval_ms()-start);
+			int64_t t = timeval_ms() - start;
 #ifdef _DEBUG_FREE_SPACE_
 			struct mallinfo info;
 			info = mallinfo();
 #endif
-			fprintf(log_output, "%s%d %d %s:%d %s()"
+			fprintf(log_output, "%s%d %" PRId64 " %s:%d %s()"
 #ifdef _DEBUG_FREE_SPACE_
 				" %d"
 #endif
@@ -193,6 +192,30 @@ void log_printf(enum log_levels level,
 	va_end(ap);
 }
 
+void log_vprintf_lf(enum log_levels level, const char *file, unsigned line,
+		const char *function, const char *format, va_list args)
+{
+	char *tmp;
+
+	count++;
+
+	if (level > debug_level)
+		return;
+
+	tmp = alloc_vprintf(format, args);
+
+	if (!tmp)
+		return;
+
+	/*
+	 * Note: alloc_vprintf() guarantees that the buffer is at least one
+	 * character longer.
+	 */
+	strcat(tmp, "\n");
+	log_puts(level, file, line, function, tmp);
+	free(tmp);
+}
+
 void log_printf_lf(enum log_levels level,
 	const char *file,
 	unsigned line,
@@ -200,23 +223,10 @@ void log_printf_lf(enum log_levels level,
 	const char *format,
 	...)
 {
-	char *string;
 	va_list ap;
 
-	count++;
-	if (level > debug_level)
-		return;
-
 	va_start(ap, format);
-
-	string = alloc_vprintf(format, ap);
-	if (string != NULL) {
-		strcat(string, "\n");	/* alloc_vprintf guaranteed the buffer to be at least one
-					 *char longer */
-		log_puts(level, file, line, function, string);
-		free(string);
-	}
-
+	log_vprintf_lf(level, file, line, function, format, ap);
 	va_end(ap);
 }
 
@@ -225,8 +235,8 @@ COMMAND_HANDLER(handle_debug_level_command)
 	if (CMD_ARGC == 1) {
 		int new_level;
 		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], new_level);
-		if ((new_level > LOG_LVL_DEBUG) || (new_level < LOG_LVL_SILENT)) {
-			LOG_ERROR("level must be between %d and %d", LOG_LVL_SILENT, LOG_LVL_DEBUG);
+		if ((new_level > LOG_LVL_DEBUG_IO) || (new_level < LOG_LVL_SILENT)) {
+			LOG_ERROR("level must be between %d and %d", LOG_LVL_SILENT, LOG_LVL_DEBUG_IO);
 			return ERROR_COMMAND_SYNTAX_ERROR;
 		}
 		debug_level = new_level;
@@ -242,9 +252,15 @@ COMMAND_HANDLER(handle_log_output_command)
 {
 	if (CMD_ARGC == 1) {
 		FILE *file = fopen(CMD_ARGV[0], "w");
-
-		if (file)
-			log_output = file;
+		if (file == NULL) {
+			LOG_ERROR("failed to open output log '%s'", CMD_ARGV[0]);
+			return ERROR_FAIL;
+		}
+		if (log_output != stderr && log_output != NULL) {
+			/* Close previous log file, if it was open and wasn't stderr. */
+			fclose(log_output);
+		}
+		log_output = file;
 	}
 
 	return ERROR_OK;
@@ -264,7 +280,8 @@ static struct command_registration log_command_handlers[] = {
 		.mode = COMMAND_ANY,
 		.help = "Sets the verbosity level of debugging output. "
 			"0 shows errors only; 1 adds warnings; "
-			"2 (default) adds other info; 3 adds debugging.",
+			"2 (default) adds other info; 3 adds debugging; "
+			"4 adds extra verbose debugging.",
 		.usage = "number",
 	},
 	COMMAND_REGISTRATION_DONE
@@ -288,7 +305,7 @@ void log_init(void)
 		int retval = parse_int(debug_env, &value);
 		if (ERROR_OK == retval &&
 				debug_level >= LOG_LVL_SILENT &&
-				debug_level <= LOG_LVL_DEBUG)
+				debug_level <= LOG_LVL_DEBUG_IO)
 				debug_level = value;
 	}
 
@@ -412,12 +429,12 @@ void keep_alive()
 		if (gdb_actual_connections)
 			LOG_WARNING("keep_alive() was not invoked in the "
 				"1000ms timelimit. GDB alive packet not "
-				"sent! (%lld). Workaround: increase "
+				"sent! (%" PRId64 "). Workaround: increase "
 				"\"set remotetimeout\" in GDB",
 				current_time-last_time);
 		else
 			LOG_DEBUG("keep_alive() was not invoked in the "
-				"1000ms timelimit (%lld). This may cause "
+				"1000ms timelimit (%" PRId64 "). This may cause "
 				"trouble with GDB connections.",
 				current_time-last_time);
 	}
diff --git a/src/helper/log.h b/src/helper/log.h
index 79f3110b..512bcc51 100644
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -19,19 +19,22 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ERROR_H
-#define ERROR_H
+#ifndef OPENOCD_HELPER_LOG_H
+#define OPENOCD_HELPER_LOG_H
 
 #include <helper/command.h>
 
 /* To achieve C99 printf compatibility in MinGW, gnu_printf should be
  * used for __attribute__((format( ... ))), with GCC v4.4 or later
  */
+#if (defined(IS_MINGW) && (((__GNUC__ << 16) + __GNUC_MINOR__) >= 0x00040004))
+#define PRINTF_ATTRIBUTE_FORMAT gnu_printf
+#else
+#define PRINTF_ATTRIBUTE_FORMAT printf
+#endif
 
 /* logging priorities
  * LOG_LVL_SILENT - turn off all output. In lieu of try + catch this can be used as a
@@ -43,6 +46,7 @@
  * LOG_LVL_WARNING - non-fatal errors, that may be resolved later
  * LOG_LVL_INFO - state information, etc.
  * LOG_LVL_DEBUG - debug statements, execution trace
+ * LOG_LVL_DEBUG_IO - verbose debug, low-level I/O trace
  */
 enum log_levels {
 	LOG_LVL_SILENT = -3,
@@ -51,12 +55,15 @@ enum log_levels {
 	LOG_LVL_ERROR = 0,
 	LOG_LVL_WARNING = 1,
 	LOG_LVL_INFO = 2,
-	LOG_LVL_DEBUG = 3
+	LOG_LVL_DEBUG = 3,
+	LOG_LVL_DEBUG_IO = 4,
 };
 
 void log_printf(enum log_levels level, const char *file, unsigned line,
 		const char *function, const char *format, ...)
 __attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 5, 6)));
+void log_vprintf_lf(enum log_levels level, const char *file, unsigned line,
+		const char *function, const char *format, va_list args);
 void log_printf_lf(enum log_levels level, const char *file, unsigned line,
 		const char *function, const char *format, ...)
 __attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 5, 6)));
@@ -97,6 +104,14 @@ extern int debug_level;
 
 #define LOG_LEVEL_IS(FOO)  ((debug_level) >= (FOO))
 
+#define LOG_DEBUG_IO(expr ...) \
+	do { \
+		if (debug_level >= LOG_LVL_DEBUG_IO) \
+			log_printf_lf(LOG_LVL_DEBUG, \
+				__FILE__, __LINE__, __func__, \
+				expr); \
+	} while (0)
+
 #define LOG_DEBUG(expr ...) \
 	do { \
 		if (debug_level >= LOG_LVL_DEBUG) \
@@ -136,4 +151,4 @@ extern int debug_level;
 #define ERROR_WAIT						(-5)
 
 
-#endif	/* LOG_H */
+#endif /* OPENOCD_HELPER_LOG_H */
diff --git a/src/helper/options.c b/src/helper/options.c
index b13d466d..12755e01 100644
--- a/src/helper/options.c
+++ b/src/helper/options.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -31,6 +29,18 @@
 
 #include <getopt.h>
 
+#include <limits.h>
+#include <stdlib.h>
+#if IS_DARWIN
+#include <libproc.h>
+#endif
+#ifdef HAVE_SYS_SYSCTL_H
+#include <sys/sysctl.h>
+#endif
+#if IS_WIN32 && !IS_CYGWIN
+#include <windows.h>
+#endif
+
 static int help_flag, version_flag;
 
 static const struct option long_options[] = {
@@ -52,52 +62,129 @@ int configuration_output_handler(struct command_context *context, const char *li
 	return ERROR_OK;
 }
 
-#ifdef _WIN32
-static char *find_suffix(const char *text, const char *suffix)
+/* Return the canonical path to the directory the openocd executable is in.
+ * The path should be absolute, use / as path separator and have all symlinks
+ * resolved. The returned string is malloc'd. */
+static char *find_exe_path(void)
 {
-	size_t text_len = strlen(text);
-	size_t suffix_len = strlen(suffix);
+	char *exepath = NULL;
 
-	if (suffix_len == 0)
-		return (char *)text + text_len;
+	do {
+#if IS_WIN32 && !IS_CYGWIN
+		exepath = malloc(MAX_PATH);
+		if (exepath == NULL)
+			break;
+		GetModuleFileName(NULL, exepath, MAX_PATH);
 
-	if (suffix_len > text_len || strncmp(text + text_len - suffix_len, suffix, suffix_len) != 0)
-		return NULL; /* Not a suffix of text */
+		/* Convert path separators to UNIX style, should work on Windows also. */
+		for (char *p = exepath; *p; p++) {
+			if (*p == '\\')
+				*p = '/';
+		}
 
-	return (char *)text + text_len - suffix_len;
-}
+#elif IS_DARWIN
+		exepath = malloc(PROC_PIDPATHINFO_MAXSIZE);
+		if (exepath == NULL)
+			break;
+		if (proc_pidpath(getpid(), exepath, PROC_PIDPATHINFO_MAXSIZE) <= 0) {
+			free(exepath);
+			exepath = NULL;
+		}
+
+#elif defined(CTL_KERN) && defined(KERN_PROC) && defined(KERN_PROC_PATHNAME) /* *BSD */
+#ifndef PATH_MAX
+#define PATH_MAX 1024
 #endif
+		char *path = malloc(PATH_MAX);
+		if (path == NULL)
+			break;
+		int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
+		size_t size = PATH_MAX;
 
-static void add_default_dirs(void)
-{
-	const char *run_prefix;
-	char *path;
+		if (sysctl(mib, (u_int)ARRAY_SIZE(mib), path, &size, NULL, 0) != 0)
+			break;
 
-#ifdef _WIN32
-	char strExePath[MAX_PATH];
-	GetModuleFileName(NULL, strExePath, MAX_PATH);
+#ifdef HAVE_REALPATH
+		exepath = realpath(path, NULL);
+		free(path);
+#else
+		exepath = path;
+#endif
+
+#elif defined(HAVE_REALPATH) /* Assume POSIX.1-2008 */
+		/* Try Unices in order of likelihood. */
+		exepath = realpath("/proc/self/exe", NULL); /* Linux/Cygwin */
+		if (exepath == NULL)
+			exepath = realpath("/proc/self/path/a.out", NULL); /* Solaris */
+		if (exepath == NULL)
+			exepath = realpath("/proc/curproc/file", NULL); /* FreeBSD (Should be covered above) */
+#endif
+	} while (0);
+
+	if (exepath != NULL) {
+		/* Strip executable file name, leaving path */
+		*strrchr(exepath, '/') = '\0';
+	} else {
+		LOG_WARNING("Could not determine executable path, using configured BINDIR.");
+		LOG_DEBUG("BINDIR = %s", BINDIR);
+#ifdef HAVE_REALPATH
+		exepath = realpath(BINDIR, NULL);
+#else
+		exepath = strdup(BINDIR);
+#endif
+	}
 
-	/* Strip executable file name, leaving path */
-	*strrchr(strExePath, '\\') = '\0';
+	return exepath;
+}
 
-	/* Convert path separators to UNIX style, should work on Windows also. */
-	for (char *p = strExePath; *p; p++) {
-		if (*p == '\\')
-			*p = '/';
+static char *find_relative_path(const char *from, const char *to)
+{
+	size_t i;
+
+	/* Skip common /-separated parts of from and to */
+	i = 0;
+	for (size_t n = 0; from[n] == to[n]; n++) {
+		if (from[n] == '\0') {
+			i = n;
+			break;
+		}
+		if (from[n] == '/')
+			i = n + 1;
+	}
+	from += i;
+	to += i;
+
+	/* Count number of /-separated non-empty parts of from */
+	i = 0;
+	while (from[0] != '\0') {
+		if (from[0] != '/')
+			i++;
+		char *next = strchr(from, '/');
+		if (next == NULL)
+			break;
+		from = next + 1;
 	}
 
-	char *end_of_prefix = find_suffix(strExePath, BINDIR);
-	if (end_of_prefix != NULL)
-		*end_of_prefix = '\0';
+	/* Prepend that number of ../ in front of to */
+	char *relpath = malloc(i * 3 + strlen(to) + 1);
+	relpath[0] = '\0';
+	for (size_t n = 0; n < i; n++)
+		strcat(relpath, "../");
+	strcat(relpath, to);
 
-	run_prefix = strExePath;
-#else
-	run_prefix = "";
-#endif
+	return relpath;
+}
+
+static void add_default_dirs(void)
+{
+	char *path;
+	char *exepath = find_exe_path();
+	char *bin2data = find_relative_path(BINDIR, PKGDATADIR);
 
 	LOG_DEBUG("bindir=%s", BINDIR);
 	LOG_DEBUG("pkgdatadir=%s", PKGDATADIR);
-	LOG_DEBUG("run_prefix=%s", run_prefix);
+	LOG_DEBUG("exepath=%s", exepath);
+	LOG_DEBUG("bin2data=%s", bin2data);
 
 	/*
 	 * The directory containing OpenOCD-supplied scripts should be
@@ -131,17 +218,20 @@ static void add_default_dirs(void)
 	}
 #endif
 
-	path = alloc_printf("%s%s%s", run_prefix, PKGDATADIR, "/site");
+	path = alloc_printf("%s/%s/%s", exepath, bin2data, "site");
 	if (path) {
 		add_script_search_dir(path);
 		free(path);
 	}
 
-	path = alloc_printf("%s%s%s", run_prefix, PKGDATADIR, "/scripts");
+	path = alloc_printf("%s/%s/%s", exepath, bin2data, "scripts");
 	if (path) {
 		add_script_search_dir(path);
 		free(path);
 	}
+
+	free(exepath);
+	free(bin2data);
 }
 
 int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
@@ -180,8 +270,10 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 			case 'd':		/* --debug | -d */
 			{
 				char *command = alloc_printf("debug_level %s", optarg ? optarg : "3");
-				command_run_line(cmd_ctx, command);
+				int retval = command_run_line(cmd_ctx, command);
 				free(command);
+				if (retval != ERROR_OK)
+					return retval;
 				break;
 			}
 			case 'l':		/* --log_output | -l */
@@ -202,16 +294,26 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 				LOG_WARNING("deprecated option: -p/--pipe. Use '-c \"gdb_port pipe; "
 						"log_output openocd.log\"' instead.");
 				break;
+			default:  /* '?' */
+				/* getopt will emit an error message, all we have to do is bail. */
+				return ERROR_FAIL;
 		}
 	}
 
+	if (optind < argc) {
+		/* Catch extra arguments on the command line. */
+		LOG_OUTPUT("Unexpected command line argument: %s\n", argv[optind]);
+		return ERROR_FAIL;
+	}
+
 	if (help_flag) {
 		LOG_OUTPUT("Open On-Chip Debugger\nLicensed under GNU GPL v2\n");
 		LOG_OUTPUT("--help       | -h\tdisplay this help\n");
 		LOG_OUTPUT("--version    | -v\tdisplay OpenOCD version\n");
 		LOG_OUTPUT("--file       | -f\tuse configuration file <name>\n");
 		LOG_OUTPUT("--search     | -s\tdir to search for config files and scripts\n");
-		LOG_OUTPUT("--debug      | -d\tset debug level <0-3>\n");
+		LOG_OUTPUT("--debug      | -d\tset debug level to 3\n");
+		LOG_OUTPUT("             | -d<n>\tset debug level to <level>\n");
 		LOG_OUTPUT("--log_output | -l\tredirect log output to file <name>\n");
 		LOG_OUTPUT("--command    | -c\trun <command>\n");
 		exit(-1);
diff --git a/src/helper/replacements.c b/src/helper/replacements.c
index bb23dd92..b4bb94f0 100644
--- a/src/helper/replacements.c
+++ b/src/helper/replacements.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 /* DANGER!!!! These must be defined *BEFORE* replacements.h and the malloc() macro!!!! */
 
diff --git a/src/helper/replacements.h b/src/helper/replacements.h
index 9a54f579..62fa3f9b 100644
--- a/src/helper/replacements.h
+++ b/src/helper/replacements.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef REPLACEMENTS_H
-#define REPLACEMENTS_H
+#ifndef OPENOCD_HELPER_REPLACEMENTS_H
+#define OPENOCD_HELPER_REPLACEMENTS_H
 
 /* MIN,MAX macros */
 #ifndef MIN
@@ -295,4 +293,4 @@ typedef struct {
 const char *libusb_error_name(int error_code);
 #endif /* defined HAVE_LIBUSB1 && !defined HAVE_LIBUSB_ERROR_NAME */
 
-#endif	/* REPLACEMENTS_H */
+#endif /* OPENOCD_HELPER_REPLACEMENTS_H */
diff --git a/src/helper/system.h b/src/helper/system.h
index a6dfd7ec..97b3443b 100644
--- a/src/helper/system.h
+++ b/src/helper/system.h
@@ -15,13 +15,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef SYSTEM_H
-#define SYSTEM_H
+#ifndef OPENOCD_HELPER_SYSTEM_H
+#define OPENOCD_HELPER_SYSTEM_H
 
 /* standard C library header files */
 #include <stdio.h>
@@ -88,4 +86,4 @@
 #define false   0
 #endif
 
-#endif	/* SYSTEM_H */
+#endif /* OPENOCD_HELPER_SYSTEM_H */
diff --git a/src/helper/time_support.c b/src/helper/time_support.c
index c5978b42..8337e73b 100644
--- a/src/helper/time_support.c
+++ b/src/helper/time_support.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -78,14 +76,14 @@ int duration_measure(struct duration *duration)
 	return retval;
 }
 
-float duration_elapsed(struct duration *duration)
+float duration_elapsed(const struct duration *duration)
 {
 	float t = duration->elapsed.tv_sec;
 	t += (float)duration->elapsed.tv_usec / 1000000.0;
 	return t;
 }
 
-float duration_kbps(struct duration *duration, size_t count)
+float duration_kbps(const struct duration *duration, size_t count)
 {
 	return count / (1024.0 * duration_elapsed(duration));
 }
diff --git a/src/helper/time_support.h b/src/helper/time_support.h
index ab839826..58c8c48b 100644
--- a/src/helper/time_support.h
+++ b/src/helper/time_support.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef TIME_SUPPORT_H
-#define TIME_SUPPORT_H
+#ifndef OPENOCD_HELPER_TIME_SUPPORT_H
+#define OPENOCD_HELPER_TIME_SUPPORT_H
 
 #ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
@@ -55,8 +53,8 @@ int duration_start(struct duration *duration);
 int duration_measure(struct duration *duration);
 
 /** @returns Elapsed time in seconds. */
-float duration_elapsed(struct duration *duration);
+float duration_elapsed(const struct duration *duration);
 /** @returns KB/sec for the elapsed @a duration and @a count bytes. */
-float duration_kbps(struct duration *duration, size_t count);
+float duration_kbps(const struct duration *duration, size_t count);
 
-#endif	/* TIME_SUPPORT_H */
+#endif /* OPENOCD_HELPER_TIME_SUPPORT_H */
diff --git a/src/helper/time_support_common.c b/src/helper/time_support_common.c
index fd564e33..b733c270 100644
--- a/src/helper/time_support_common.c
+++ b/src/helper/time_support_common.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -33,7 +31,7 @@
 /* simple and low overhead fetching of ms counter. Use only
  * the difference between ms counters returned from this fn.
  */
-int64_t timeval_ms()
+int64_t timeval_ms(void)
 {
 	struct timeval now;
 	int retval = gettimeofday(&now, NULL);
diff --git a/src/helper/types.h b/src/helper/types.h
index 3f0724c3..58c9e724 100644
--- a/src/helper/types.h
+++ b/src/helper/types.h
@@ -16,12 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef TYPES_H
-#define TYPES_H
+
+#ifndef OPENOCD_HELPER_TYPES_H
+#define OPENOCD_HELPER_TYPES_H
 
 #include <stddef.h>
 #ifdef HAVE_SYS_TYPES_H
@@ -297,14 +296,21 @@ static inline int parity_u32(uint32_t x)
  */
 
 #if !defined(_STDINT_H)
-#define PRIx32 "x"
 #define PRId32 "d"
-#define SCNx32 "x"
 #define PRIi32 "i"
+#define PRIo32 "o"
 #define PRIu32 "u"
+#define PRIx32 "x"
+#define PRIX32 "X"
+#define SCNx32 "x"
 #define PRId8 PRId32
 #define SCNx64 "llx"
+#define PRId64 "lld"
+#define PRIi64 "lli"
+#define PRIo64 "llo"
+#define PRIu64 "llu"
 #define PRIx64 "llx"
+#define PRIX64 "llX"
 
 typedef CYG_ADDRWORD intptr_t;
 typedef int64_t intmax_t;
@@ -338,4 +344,23 @@ typedef uint64_t uintmax_t;
 
 #endif
 
-#endif /* TYPES_H */
+#if BUILD_TARGET64
+typedef uint64_t target_addr_t;
+#define TARGET_ADDR_MAX UINT64_MAX
+#define TARGET_PRIdADDR PRId64
+#define TARGET_PRIuADDR PRIu64
+#define TARGET_PRIoADDR PRIo64
+#define TARGET_PRIxADDR PRIx64
+#define TARGET_PRIXADDR PRIX64
+#else
+typedef uint32_t target_addr_t;
+#define TARGET_ADDR_MAX UINT32_MAX
+#define TARGET_PRIdADDR PRId32
+#define TARGET_PRIuADDR PRIu32
+#define TARGET_PRIoADDR PRIo32
+#define TARGET_PRIxADDR PRIx32
+#define TARGET_PRIXADDR PRIX32
+#endif
+#define TARGET_ADDR_FMT "0x%8.8" TARGET_PRIxADDR
+
+#endif /* OPENOCD_HELPER_TYPES_H */
diff --git a/src/helper/update_jep106.pl b/src/helper/update_jep106.pl
new file mode 100755
index 00000000..caec0664
--- /dev/null
+++ b/src/helper/update_jep106.pl
@@ -0,0 +1,35 @@
+#!/usr/bin/perl
+use strict;
+use warnings;
+use File::Basename;
+
+if (@ARGV != 1) {
+	die "Usage: $0 <JEP106 PDF document>\n\n"
+	. "Convert the JEDEC document containing manufacturer identification codes\n"
+	. "to an array initializer suitable for incusion into jep106.c. The latest\n"
+	. "version of the document can be found here:\n"
+	. "http://www.jedec.org/standards-documents/results/jep106\n";
+};
+
+my $outfile = dirname($0) . "/jep106.inc";
+
+open(my $out, ">", $outfile) || die "Cannot open $outfile: $!\n";
+open(my $pdftotext, "pdftotext -layout $ARGV[0] - |") || die "Cannot fork: $!\n";
+
+print $out "/* Autogenerated with " . basename($0) . "*/\n";
+
+my $bank = -1;
+
+while (<$pdftotext>) {
+	if (/^[0-9]+[[:space:]]+(.*?)[[:space:]]+([01][[:space:]]+){8}([0-9A-F]{2})$/) {
+		if ($3 eq "01") {
+			$bank++
+		}
+		my $id=sprintf("0x%02x",hex($3)&0x7f);
+		print $out "[$bank][$id - 1] = \"$1\",\n";
+	}
+}
+
+close $pdftotext || die "Error: $! $?\n";
+
+print $out "/* EOF */\n";
diff --git a/src/helper/util.c b/src/helper/util.c
index 55b92a75..56baf95d 100644
--- a/src/helper/util.c
+++ b/src/helper/util.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* this file contains various functionality useful to standalone systems */
diff --git a/src/helper/util.h b/src/helper/util.h
index 48db725c..c9a11dda 100644
--- a/src/helper/util.h
+++ b/src/helper/util.h
@@ -12,16 +12,14 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef HELPER_UTILS_H
-#define HELPER_UTILS_H
+#ifndef OPENOCD_HELPER_UTIL_H
+#define OPENOCD_HELPER_UTIL_H
 
 struct command_context;
 
 int util_init(struct command_context *cmd_ctx);
 
-#endif	/* HELPER_UTILS_H */
+#endif /* OPENOCD_HELPER_UTIL_H */
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index db3e6ff2..50ee263d 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -1,86 +1,72 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libjtag.la
 
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libjtag.la
+JTAG_SRCS =
+%C%_libjtag_la_LIBADD =
 
-SUBDIRS =
-DRIVERFILES =
-libjtag_la_LIBADD =
-
-CLEANFILES =
-
-BUILT_SOURCES =
-
-BUILT_SOURCES += minidriver_imp.h
-CLEANFILES += minidriver_imp.h
+BUILT_SOURCES += %D%/minidriver_imp.h
+CLEANFILES += %D%/minidriver_imp.h
 
 if MINIDRIVER
 
 if ZY1000
-DRIVERFILES += zy1000/zy1000.c
-JTAG_MINIDRIVER_DIR = $(srcdir)/zy1000
+JTAG_SRCS += %D%/zy1000/zy1000.c
+JTAG_MINIDRIVER_DIR = %D%/zy1000
 endif
 if MINIDRIVER_DUMMY
-DRIVERFILES += minidummy/minidummy.c commands.c
-JTAG_MINIDRIVER_DIR = $(srcdir)/minidummy
+JTAG_SRCS += %D%/minidummy/minidummy.c %D%/commands.c
+JTAG_MINIDRIVER_DIR = %D%/minidummy
 endif
 
-MINIDRIVER_IMP_DIR = $(srcdir)/minidriver
+MINIDRIVER_IMP_DIR = %D%/minidriver
 
-jtag_minidriver.h: $(JTAG_MINIDRIVER_DIR)/jtag_minidriver.h
+%D%/jtag_minidriver.h: $(JTAG_MINIDRIVER_DIR)/jtag_minidriver.h
 	cp $< $@
 
-BUILT_SOURCES += jtag_minidriver.h
+BUILT_SOURCES += %D%/jtag_minidriver.h
 
-CLEANFILES += jtag_minidriver.h
+CLEANFILES += %D%/jtag_minidriver.h
 
 else
 
-MINIDRIVER_IMP_DIR = $(srcdir)/drivers
-DRIVERFILES += commands.c
+MINIDRIVER_IMP_DIR = %D%/drivers
+JTAG_SRCS += %D%/commands.c
 
 if HLADAPTER
-SUBDIRS += hla
-libjtag_la_LIBADD += $(top_builddir)/src/jtag/hla/libocdhla.la
+include %D%/hla/Makefile.am
+%C%_libjtag_la_LIBADD += $(top_builddir)/%D%/hla/libocdhla.la
 endif
 
 if AICE
-SUBDIRS += aice
-libjtag_la_LIBADD += $(top_builddir)/src/jtag/aice/libocdaice.la
+include %D%/aice/Makefile.am
+%C%_libjtag_la_LIBADD += $(top_builddir)/%D%/aice/libocdaice.la
 endif
 
-SUBDIRS += drivers
-libjtag_la_LIBADD += $(top_builddir)/src/jtag/drivers/libocdjtagdrivers.la
-
+include %D%/drivers/Makefile.am
+%C%_libjtag_la_LIBADD += $(top_builddir)/%D%/drivers/libocdjtagdrivers.la
 
 endif
-
 # endif // MINIDRIVER
 
-minidriver_imp.h: $(MINIDRIVER_IMP_DIR)/minidriver_imp.h
+%D%/minidriver_imp.h: $(MINIDRIVER_IMP_DIR)/minidriver_imp.h
 	cp $< $@
 
 
-libjtag_la_SOURCES = \
-	adapter.c \
-	core.c \
-	interface.c \
-	interfaces.c \
-	tcl.c \
-	$(DRIVERFILES)
-
-noinst_HEADERS = \
-	commands.h \
-	driver.h \
-	interface.h \
-	interfaces.h \
-	minidriver.h \
-	jtag.h \
-	minidriver/minidriver_imp.h \
-	minidummy/jtag_minidriver.h \
-	swd.h \
-	tcl.h
-
-EXTRA_DIST = startup.tcl
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+%C%_libjtag_la_SOURCES = \
+	%D%/adapter.c \
+	%D%/core.c \
+	%D%/interface.c \
+	%D%/interfaces.c \
+	%D%/tcl.c \
+	%D%/commands.h \
+	%D%/driver.h \
+	%D%/interface.h \
+	%D%/interfaces.h \
+	%D%/minidriver.h \
+	%D%/jtag.h \
+	%D%/minidriver/minidriver_imp.h \
+	%D%/minidummy/jtag_minidriver.h \
+	%D%/swd.h \
+	%D%/tcl.h \
+	$(JTAG_SRCS)
+
+STARTUP_TCL_SRCS += %D%/startup.tcl
diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 2f5f6b43..5953de7e 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/aice/Makefile.am b/src/jtag/aice/Makefile.am
index 7b9469d8..97e38258 100644
--- a/src/jtag/aice/Makefile.am
+++ b/src/jtag/aice/Makefile.am
@@ -1,27 +1,14 @@
-include $(top_srcdir)/common.mk
-
-AM_CPPFLAGS += -I$(top_srcdir)/src/jtag/drivers $(LIBUSB1_CFLAGS) $(LIBUSB0_CFLAGS)
-
-noinst_LTLIBRARIES = libocdaice.la
-
-libocdaice_la_SOURCES = \
-	$(AICEFILES)
-
-AICEFILES =
-
-if AICE
-AICEFILES += aice_transport.c
-AICEFILES += aice_interface.c
-AICEFILES += aice_port.c
-AICEFILES += aice_usb.c
-AICEFILES += aice_pipe.c
-endif
-
-noinst_HEADERS = \
-	aice_transport.h \
-	aice_interface.h \
-	aice_port.h \
-	aice_usb.h \
-	aice_pipe.h
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+noinst_LTLIBRARIES += %D%/libocdaice.la
+
+%C%_libocdaice_la_CPPFLAGS = -I$(top_srcdir)/src/jtag/drivers $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS) $(LIBUSB0_CFLAGS)
+%C%_libocdaice_la_SOURCES = \
+	%D%/aice_transport.c \
+	%D%/aice_interface.c \
+	%D%/aice_port.c \
+	%D%/aice_usb.c \
+	%D%/aice_pipe.c \
+	%D%/aice_transport.h \
+	%D%/aice_interface.h \
+	%D%/aice_port.h \
+	%D%/aice_usb.h \
+	%D%/aice_pipe.h
diff --git a/src/jtag/aice/aice_interface.c b/src/jtag/aice/aice_interface.c
index 363b208a..20f1f07f 100644
--- a/src/jtag/aice/aice_interface.c
+++ b/src/jtag/aice/aice_interface.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/aice/aice_interface.h b/src/jtag/aice/aice_interface.h
index ddb6ad41..0e3f1083 100644
--- a/src/jtag/aice/aice_interface.h
+++ b/src/jtag/aice/aice_interface.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __AICE_INTERFACE_H__
-#define __AICE_INTERFACE_H__
+
+#ifndef OPENOCD_JTAG_AICE_AICE_INTERFACE_H
+#define OPENOCD_JTAG_AICE_AICE_INTERFACE_H
 
 struct aice_interface_param_s {
 	/** */
@@ -33,4 +32,4 @@ struct aice_interface_param_s {
 
 int aice_init_targets(void);
 
-#endif
+#endif /* OPENOCD_JTAG_AICE_AICE_INTERFACE_H */
diff --git a/src/jtag/aice/aice_pipe.c b/src/jtag/aice/aice_pipe.c
index 3180ad00..bdc8c090 100644
--- a/src/jtag/aice/aice_pipe.c
+++ b/src/jtag/aice/aice_pipe.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -176,7 +174,7 @@ static int aice_pipe_write(const void *buffer, int count)
 static int aice_pipe_read(void *buffer, int count)
 {
 	int n;
-	long long then, cur;
+	int64_t then, cur;
 
 	then = timeval_ms();
 
@@ -788,8 +786,8 @@ static int aice_pipe_memory_mode(uint32_t coreid, enum nds_memory_select mem_sel
 		return ERROR_FAIL;
 }
 
-static int aice_pipe_read_tlb(uint32_t coreid, uint32_t virtual_address,
-		uint32_t *physical_address)
+static int aice_pipe_read_tlb(uint32_t coreid, target_addr_t virtual_address,
+		target_addr_t *physical_address)
 {
 	char line[AICE_PIPE_MAXLINE];
 	char command[AICE_PIPE_MAXLINE];
diff --git a/src/jtag/aice/aice_pipe.h b/src/jtag/aice/aice_pipe.h
index 48b0c491..467ad0ad 100644
--- a/src/jtag/aice/aice_pipe.h
+++ b/src/jtag/aice/aice_pipe.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef _AICE_PIPE_H_
-#define _AICE_PIPE_H_
+
+#ifndef OPENOCD_JTAG_AICE_AICE_PIPE_H
+#define OPENOCD_JTAG_AICE_AICE_PIPE_H
 
 #include <helper/types.h>
 
@@ -29,4 +28,4 @@
 
 extern struct aice_port_api_s aice_pipe;
 
-#endif
+#endif /* OPENOCD_JTAG_AICE_AICE_PIPE_H */
diff --git a/src/jtag/aice/aice_port.c b/src/jtag/aice/aice_port.c
index b61275c8..2fa346ca 100644
--- a/src/jtag/aice/aice_port.c
+++ b/src/jtag/aice/aice_port.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
diff --git a/src/jtag/aice/aice_port.h b/src/jtag/aice/aice_port.h
index d29e9e14..d3d6a1a2 100644
--- a/src/jtag/aice/aice_port.h
+++ b/src/jtag/aice/aice_port.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef _AICE_PORT_H_
-#define _AICE_PORT_H_
+
+#ifndef OPENOCD_JTAG_AICE_AICE_PORT_H
+#define OPENOCD_JTAG_AICE_AICE_PORT_H
 
 #include <target/nds32_edm.h>
 
@@ -181,7 +180,7 @@ struct aice_port_api_s {
 	int (*memory_mode)(uint32_t coreid, enum nds_memory_select mem_select);
 
 	/** */
-	int (*read_tlb)(uint32_t coreid, uint32_t virtual_address, uint32_t *physical_address);
+	int (*read_tlb)(uint32_t coreid, target_addr_t virtual_address, target_addr_t *physical_address);
 
 	/** */
 	int (*cache_ctl)(uint32_t coreid, uint32_t subtype, uint32_t address);
@@ -235,4 +234,4 @@ struct aice_port {
 /** */
 const struct aice_port *aice_port_get_list(void);
 
-#endif
+#endif /* OPENOCD_JTAG_AICE_AICE_PORT_H */
diff --git a/src/jtag/aice/aice_transport.c b/src/jtag/aice/aice_transport.c
index f3012bb2..9f079468 100644
--- a/src/jtag/aice/aice_transport.c
+++ b/src/jtag/aice/aice_transport.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -90,11 +88,13 @@ static int jim_aice_newtap_cmd(Jim_GetOptInfo *goi)
 		free(pTap);
 		return JIM_ERR;
 	}
-	Jim_GetOpt_String(goi, &cp, NULL);
-	pTap->chip = strdup(cp);
 
-	Jim_GetOpt_String(goi, &cp, NULL);
-	pTap->tapname = strdup(cp);
+	const char *tmp;
+	Jim_GetOpt_String(goi, &tmp, NULL);
+	pTap->chip = strdup(tmp);
+
+	Jim_GetOpt_String(goi, &tmp, NULL);
+	pTap->tapname = strdup(tmp);
 
 	/* name + dot + name + null */
 	x = strlen(pTap->chip) + 1 + strlen(pTap->tapname) + 1;
diff --git a/src/jtag/aice/aice_transport.h b/src/jtag/aice/aice_transport.h
index e93d1312..3af8bc2e 100644
--- a/src/jtag/aice/aice_transport.h
+++ b/src/jtag/aice/aice_transport.h
@@ -13,14 +13,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _AICE_TRANSPORT_
-#define _AICE_TRANSPORT_
+#ifndef OPENOCD_JTAG_AICE_AICE_TRANSPORT_H
+#define OPENOCD_JTAG_AICE_AICE_TRANSPORT_H
 
 extern const char *aice_transports[];
 
-#endif
+#endif /* OPENOCD_JTAG_AICE_AICE_TRANSPORT_H */
diff --git a/src/jtag/aice/aice_usb.c b/src/jtag/aice/aice_usb.c
index 86d9fc4c..7b761d71 100644
--- a/src/jtag/aice/aice_usb.c
+++ b/src/jtag/aice/aice_usb.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -1858,7 +1856,7 @@ static int aice_check_dbger(uint32_t coreid, uint32_t expect_status)
 		if ((i % 30) == 0)
 			keep_alive();
 
-		long long then = 0;
+		int64_t then = 0;
 		if (i == aice_count_to_check_dbger)
 			then = timeval_ms();
 		if (i >= aice_count_to_check_dbger) {
@@ -2137,10 +2135,16 @@ static int aice_usb_open(struct aice_port_param_s *param)
 
 	/* usb_set_configuration required under win32 */
 	jtag_libusb_set_configuration(devh, 0);
+	jtag_libusb_claim_interface(devh, 0);
 
 	unsigned int aice_read_ep;
 	unsigned int aice_write_ep;
-	jtag_libusb_choose_interface(devh, &aice_read_ep, &aice_write_ep, -1, -1, -1);
+#ifdef HAVE_LIBUSB1
+	jtag_libusb_choose_interface(devh, &aice_read_ep, &aice_write_ep, -1, -1, -1, LIBUSB_TRANSFER_TYPE_BULK);
+#else
+	jtag_libusb_choose_interface(devh, &aice_read_ep, &aice_write_ep, -1, -1, -1, USB_ENDPOINT_TYPE_BULK);
+#endif
+	LOG_DEBUG("aice_read_ep=0x%x, aice_write_ep=0x%x", aice_read_ep, aice_write_ep);
 
 	aice_handler.usb_read_ep = aice_read_ep;
 	aice_handler.usb_write_ep = aice_write_ep;
@@ -2999,7 +3003,7 @@ static int aice_usb_step(uint32_t coreid)
 		if (AICE_TARGET_HALTED == state)
 			break;
 
-		long long then = 0;
+		int64_t then = 0;
 		if (i == 30)
 			then = timeval_ms();
 
@@ -3426,10 +3430,10 @@ static int aice_usb_memory_mode(uint32_t coreid, enum nds_memory_select mem_sele
 	return ERROR_OK;
 }
 
-static int aice_usb_read_tlb(uint32_t coreid, uint32_t virtual_address,
-		uint32_t *physical_address)
+static int aice_usb_read_tlb(uint32_t coreid, target_addr_t virtual_address,
+		target_addr_t *physical_address)
 {
-	LOG_DEBUG("aice_usb_read_tlb, virtual address: 0x%08" PRIx32, virtual_address);
+	LOG_DEBUG("aice_usb_read_tlb, virtual address: 0x%08" TARGET_PRIxADDR, virtual_address);
 
 	uint32_t instructions[4];
 	uint32_t probe_result;
diff --git a/src/jtag/aice/aice_usb.h b/src/jtag/aice/aice_usb.h
index adb027ea..2911ae56 100644
--- a/src/jtag/aice/aice_usb.h
+++ b/src/jtag/aice/aice_usb.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __AICE_USB_H__
-#define __AICE_USB_H__
+
+#ifndef OPENOCD_JTAG_AICE_AICE_USB_H
+#define OPENOCD_JTAG_AICE_AICE_USB_H
 
 #include "aice_port.h"
 
@@ -130,4 +129,4 @@ extern struct aice_port_api_s aice_usb_api;
 int aice_read_ctrl(uint32_t address, uint32_t *data);
 int aice_write_ctrl(uint32_t address, uint32_t data);
 
-#endif
+#endif /* OPENOCD_JTAG_AICE_AICE_USB_H */
diff --git a/src/jtag/commands.c b/src/jtag/commands.c
index 750ebab0..ed40755b 100644
--- a/src/jtag/commands.c
+++ b/src/jtag/commands.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/commands.h b/src/jtag/commands.h
index 06ec2483..947c9472 100644
--- a/src/jtag/commands.h
+++ b/src/jtag/commands.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef JTAG_COMMANDS_H
-#define JTAG_COMMANDS_H
+#ifndef OPENOCD_JTAG_COMMANDS_H
+#define OPENOCD_JTAG_COMMANDS_H
 
 /**
  * The inferred type of a scan_command_s structure, indicating whether
@@ -175,4 +173,4 @@ int jtag_scan_size(const struct scan_command *cmd);
 int jtag_read_buffer(uint8_t *buffer, const struct scan_command *cmd);
 int jtag_build_buffer(const struct scan_command *cmd, uint8_t **buffer);
 
-#endif /* JTAG_COMMANDS_H */
+#endif /* OPENOCD_JTAG_COMMANDS_H */
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 9b2a82ec..a6e96095 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -36,6 +34,7 @@
 #include "swd.h"
 #include "interface.h"
 #include <transport/transport.h>
+#include <helper/jep106.h>
 
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
@@ -894,6 +893,8 @@ void jtag_sleep(uint32_t us)
 
 #define JTAG_MAX_AUTO_TAPS 20
 
+#define EXTRACT_JEP106_BANK(X) (((X) & 0xf00) >> 8)
+#define EXTRACT_JEP106_ID(X)   (((X) & 0xfe) >> 1)
 #define EXTRACT_MFG(X)  (((X) & 0xffe) >> 1)
 #define EXTRACT_PART(X) (((X) & 0xffff000) >> 12)
 #define EXTRACT_VER(X)  (((X) & 0xf0000000) >> 28)
@@ -957,10 +958,11 @@ static void jtag_examine_chain_display(enum log_levels level, const char *msg,
 {
 	log_printf_lf(level, __FILE__, __LINE__, __func__,
 		"JTAG tap: %s %16.16s: 0x%08x "
-		"(mfg: 0x%3.3x, part: 0x%4.4x, ver: 0x%1.1x)",
+		"(mfg: 0x%3.3x (%s), part: 0x%4.4x, ver: 0x%1.1x)",
 		name, msg,
 		(unsigned int)idcode,
 		(unsigned int)EXTRACT_MFG(idcode),
+		jep106_manufacturer(EXTRACT_JEP106_BANK(idcode), EXTRACT_JEP106_ID(idcode)),
 		(unsigned int)EXTRACT_PART(idcode),
 		(unsigned int)EXTRACT_VER(idcode));
 }
@@ -1708,11 +1710,11 @@ void jtag_set_reset_config(enum reset_types type)
 
 int jtag_get_trst(void)
 {
-	return jtag_trst;
+	return jtag_trst == 1;
 }
 int jtag_get_srst(void)
 {
-	return jtag_srst;
+	return jtag_srst == 1;
 }
 
 void jtag_set_nsrst_delay(unsigned delay)
diff --git a/src/jtag/driver.h b/src/jtag/driver.h
index 5a7b4edf..ae00414c 100644
--- a/src/jtag/driver.h
+++ b/src/jtag/driver.h
@@ -13,16 +13,14 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef JTAG_DRIVER_H
-#define JTAG_DRIVER_H
+#ifndef OPENOCD_JTAG_DRIVER_H
+#define OPENOCD_JTAG_DRIVER_H
 
 struct command_context;
 
 int interface_register_commands(struct command_context *ctx);
 
-#endif /* JTAG_DRIVER_H */
+#endif /* OPENOCD_JTAG_DRIVER_H */
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index 2aaf8fd8..911f20a8 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -1,173 +1,178 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libocdjtagdrivers.la
+%C%_libocdjtagdrivers_la_LIBADD =
 
-noinst_LTLIBRARIES = libocdjtagdrivers.la
-libocdjtagdrivers_la_LIBADD =
+%C%_libocdjtagdrivers_la_SOURCES = \
+	$(DRIVERFILES) \
+	$(DRIVERHEADERS)
 
-libocdjtagdrivers_la_SOURCES = \
-	$(DRIVERFILES)
+%C%_libocdjtagdrivers_la_CPPFLAGS = $(AM_CPPFLAGS)
 
-libocdjtagdrivers_la_CPPFLAGS = $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS) \
-	$(LIBUSB0_CFLAGS) $(HIDAPI_CFLAGS) $(LIBFTDI_CFLAGS)
+ULINK_FIRMWARE = %D%/OpenULINK
 
-ULINK_FIRMWARE = $(srcdir)/OpenULINK
-
-EXTRA_DIST = $(ULINK_FIRMWARE) \
-	usb_blaster/README.CheapClone \
-	Makefile.rlink \
-	rlink_call.m4 \
-	rlink_init.m4
+EXTRA_DIST += $(ULINK_FIRMWARE) \
+	%D%/usb_blaster/README.CheapClone \
+	%D%/Makefile.rlink \
+	%D%/rlink_call.m4 \
+	%D%/rlink_init.m4
 
 DRIVERFILES =
-SUBDIRS=
 
-if JLINK
-if INTERNAL_LIBJAYLINK
-SUBDIRS += libjaylink
+# Standard Driver: common files
+DRIVERFILES += %D%/driver.c
 
-libjaylink_internal_la_SOURCES = jlink.c
-libjaylink_internal_la_LIBADD = libjaylink/libjaylink/libjaylink.la
-libjaylink_internal_la_CPPFLAGS = -I$(builddir)/libjaylink/libjaylink \
-	-I$(srcdir)/libjaylink $(AM_CPPFLAGS)
+if USE_LIBUSB1
+DRIVERFILES += %D%/libusb1_common.c
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBUSB1_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBUSB1_LIBS)
+endif
 
-noinst_LTLIBRARIES += libjaylink_internal.la
-libocdjtagdrivers_la_LIBADD += libjaylink_internal.la
-else
-DRIVERFILES += jlink.c
+if USE_LIBUSB0
+DRIVERFILES += %D%/usb_common.c
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBUSB0_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBUSB0_LIBS)
+if !USE_LIBUSB1
+DRIVERFILES += %D%/libusb0_common.c
 endif
 endif
 
-# Standard Driver: common files
-DRIVERFILES += driver.c
+if USE_LIBFTDI
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBFTDI_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBFTDI_LIBS)
+endif
 
-if USE_LIBUSB1
-DRIVERFILES += libusb1_common.c
+if USE_HIDAPI
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(HIDAPI_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(HIDAPI_LIBS)
 endif
 
-if USE_LIBUSB0
-DRIVERFILES += usb_common.c
-if !USE_LIBUSB1
-DRIVERFILES += libusb0_common.c
+if USE_LIBJAYLINK
+%C%_libocdjtagdrivers_la_CPPFLAGS += $(LIBJAYLINK_CFLAGS)
+%C%_libocdjtagdrivers_la_LIBADD += $(LIBJAYLINK_LIBS)
+endif
+
+if JLINK
+DRIVERFILES += %D%/jlink.c
+if INTERNAL_LIBJAYLINK
+SUBDIRS += %D%/libjaylink
+DIST_SUBDIRS += %D%/libjaylink
+
+%C%_libocdjtagdrivers_la_LIBADD += %D%/libjaylink/libjaylink/libjaylink.la
+%C%_libocdjtagdrivers_la_CPPFLAGS += -I$(builddir)/%D%/libjaylink/libjaylink -I$(srcdir)/%D%/libjaylink
 endif
 endif
 
 if BITBANG
-DRIVERFILES += bitbang.c
+DRIVERFILES += %D%/bitbang.c
 endif
 if PARPORT
-DRIVERFILES += parport.c
+DRIVERFILES += %D%/parport.c
 endif
 if DUMMY
-DRIVERFILES += dummy.c
-endif
-if FT2232_DRIVER
-DRIVERFILES += ft2232.c
+DRIVERFILES += %D%/dummy.c
 endif
 if FTDI
-DRIVERFILES += ftdi.c mpsse.c
+DRIVERFILES += %D%/ftdi.c %D%/mpsse.c
 endif
 if JTAG_VPI
-DRIVERFILES += jtag_vpi.c
+DRIVERFILES += %D%/jtag_vpi.c
 endif
 if USB_BLASTER_DRIVER
-SUBDIRS += usb_blaster
-libocdjtagdrivers_la_LIBADD += $(top_builddir)/src/jtag/drivers/usb_blaster/libocdusbblaster.la
+%C%_libocdjtagdrivers_la_LIBADD += %D%/usb_blaster/libocdusbblaster.la
+include %D%/usb_blaster/Makefile.am
 endif
 if AMTJTAGACCEL
-DRIVERFILES += amt_jtagaccel.c
+DRIVERFILES += %D%/amt_jtagaccel.c
 endif
 if EP93XX
-DRIVERFILES += ep93xx.c
+DRIVERFILES += %D%/ep93xx.c
 endif
 if AT91RM9200
-DRIVERFILES += at91rm9200.c
+DRIVERFILES += %D%/at91rm9200.c
 endif
 if GW16012
-DRIVERFILES += gw16012.c
+DRIVERFILES += %D%/gw16012.c
 endif
 if BITQ
-DRIVERFILES += bitq.c
+DRIVERFILES += %D%/bitq.c
 endif
-if PRESTO_DRIVER
-DRIVERFILES += presto.c
+if PRESTO
+DRIVERFILES += %D%/presto.c
 endif
 if USBPROG
-DRIVERFILES += usbprog.c
+DRIVERFILES += %D%/usbprog.c
 endif
 if RLINK
-DRIVERFILES += rlink.c rlink_speed_table.c
+DRIVERFILES += %D%/rlink.c %D%/rlink_speed_table.c
 endif
 if ULINK
-DRIVERFILES += ulink.c
+DRIVERFILES += %D%/ulink.c
 ulinkdir = $(pkgdatadir)/OpenULINK
 dist_ulink_DATA = $(ULINK_FIRMWARE)/ulink_firmware.hex
+%C%_libocdjtagdrivers_la_LIBADD += -lm
 endif
 if VSLLINK
-DRIVERFILES += versaloon/usbtoxxx/usbtogpio.c
-DRIVERFILES += versaloon/usbtoxxx/usbtojtagraw.c
-DRIVERFILES += versaloon/usbtoxxx/usbtoswd.c
-DRIVERFILES += versaloon/usbtoxxx/usbtopwr.c
-DRIVERFILES += versaloon/usbtoxxx/usbtoxxx.c
-DRIVERFILES += versaloon/versaloon.c
-DRIVERFILES += vsllink.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtogpio.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtojtagraw.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtoswd.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtopwr.c
+DRIVERFILES += %D%/versaloon/usbtoxxx/usbtoxxx.c
+DRIVERFILES += %D%/versaloon/versaloon.c
+DRIVERFILES += %D%/vsllink.c
 endif
 if ARMJTAGEW
-DRIVERFILES += arm-jtag-ew.c
+DRIVERFILES += %D%/arm-jtag-ew.c
 endif
 if BUSPIRATE
-DRIVERFILES += buspirate.c
+DRIVERFILES += %D%/buspirate.c
 endif
 if REMOTE_BITBANG
-DRIVERFILES += remote_bitbang.c
+DRIVERFILES += %D%/remote_bitbang.c
 endif
 if HLADAPTER
-DRIVERFILES += stlink_usb.c
-DRIVERFILES += ti_icdi_usb.c
+DRIVERFILES += %D%/stlink_usb.c
+DRIVERFILES += %D%/ti_icdi_usb.c
 endif
 if OSBDM
-DRIVERFILES += osbdm.c
+DRIVERFILES += %D%/osbdm.c
 endif
 if OPENDOUS
-DRIVERFILES += opendous.c
+DRIVERFILES += %D%/opendous.c
 endif
 if SYSFSGPIO
-DRIVERFILES += sysfsgpio.c
+DRIVERFILES += %D%/sysfsgpio.c
 endif
 if BCM2835GPIO
-DRIVERFILES += bcm2835gpio.c
+DRIVERFILES += %D%/bcm2835gpio.c
 endif
-
 if OPENJTAG
-DRIVERFILES += openjtag.c
+DRIVERFILES += %D%/openjtag.c
 endif
-
 if CMSIS_DAP
-DRIVERFILES += cmsis_dap_usb.c
-endif
-
-noinst_HEADERS = \
-	bitbang.h \
-	bitq.h \
-	ftd2xx_common.h \
-	libusb0_common.h \
-	libusb1_common.h \
-	libusb_common.h \
-	minidriver_imp.h \
-	mpsse.h \
-	rlink.h \
-	rlink_dtc_cmd.h \
-	rlink_ep1_cmd.h \
-	rlink_st7.h \
-	usb_common.h \
-	versaloon/usbtoxxx/usbtoxxx.h \
-	versaloon/usbtoxxx/usbtoxxx_internal.h \
-	versaloon/versaloon.h \
-	versaloon/versaloon_include.h \
-	versaloon/versaloon_internal.h
-
-DIST_SUBDIRS = usb_blaster
-
-if INTERNAL_LIBJAYLINK
-DIST_SUBDIRS += libjaylink
-endif
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+DRIVERFILES += %D%/cmsis_dap_usb.c
+endif
+if IMX_GPIO
+DRIVERFILES += %D%/imx_gpio.c
+endif
+
+if KITPROG
+DRIVERFILES += %D%/kitprog.c
+endif
+
+DRIVERHEADERS = \
+	%D%/bitbang.h \
+	%D%/bitq.h \
+	%D%/libusb0_common.h \
+	%D%/libusb1_common.h \
+	%D%/libusb_common.h \
+	%D%/minidriver_imp.h \
+	%D%/mpsse.h \
+	%D%/rlink.h \
+	%D%/rlink_dtc_cmd.h \
+	%D%/rlink_ep1_cmd.h \
+	%D%/rlink_st7.h \
+	%D%/usb_common.h \
+	%D%/versaloon/usbtoxxx/usbtoxxx.h \
+	%D%/versaloon/usbtoxxx/usbtoxxx_internal.h \
+	%D%/versaloon/versaloon.h \
+	%D%/versaloon/versaloon_include.h \
+	%D%/versaloon/versaloon_internal.h
diff --git a/src/jtag/drivers/Makefile.rlink b/src/jtag/drivers/Makefile.rlink
index 6a7638e7..6168332c 100644
--- a/src/jtag/drivers/Makefile.rlink
+++ b/src/jtag/drivers/Makefile.rlink
@@ -13,9 +13,7 @@
 #*   GNU General Public License for more details.                          *
 #*                                                                         *
 #*   You should have received a copy of the GNU General Public License     *
-#*   along with this program; if not, write to the                         *
-#*   Free Software Foundation, Inc.,                                       *
-#*   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+#*   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 #***************************************************************************
 
 TOP = ../../..
diff --git a/src/jtag/drivers/OpenULINK/Makefile b/src/jtag/drivers/OpenULINK/Makefile
index 8ef2d03f..9f6acc66 100644
--- a/src/jtag/drivers/OpenULINK/Makefile
+++ b/src/jtag/drivers/OpenULINK/Makefile
@@ -13,9 +13,7 @@
 #    GNU General Public License for more details.                          #
 #                                                                          #
 #    You should have received a copy of the GNU General Public License     #
-#    along with this program; if not, write to the                         #
-#    Free Software Foundation, Inc.,                                       #
-#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           #
+#    along with this program.  If not, see <http://www.gnu.org/licenses/>. #
 ############################################################################
 
 # Define the name of our tools. Some distributions (e. g. Fedora) prefix
diff --git a/src/jtag/drivers/OpenULINK/include/common.h b/src/jtag/drivers/OpenULINK/include/common.h
index b4f6df9a..56222fe6 100644
--- a/src/jtag/drivers/OpenULINK/include/common.h
+++ b/src/jtag/drivers/OpenULINK/include/common.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __COMMON_H
diff --git a/src/jtag/drivers/OpenULINK/include/delay.h b/src/jtag/drivers/OpenULINK/include/delay.h
index 59fb49fa..ed454be9 100644
--- a/src/jtag/drivers/OpenULINK/include/delay.h
+++ b/src/jtag/drivers/OpenULINK/include/delay.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __DELAY_H
diff --git a/src/jtag/drivers/OpenULINK/include/io.h b/src/jtag/drivers/OpenULINK/include/io.h
index 8077d325..a4a8b8ac 100644
--- a/src/jtag/drivers/OpenULINK/include/io.h
+++ b/src/jtag/drivers/OpenULINK/include/io.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __IO_H
diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
index ee2457e1..fa492b9e 100644
--- a/src/jtag/drivers/OpenULINK/include/jtag.h
+++ b/src/jtag/drivers/OpenULINK/include/jtag.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __JTAG_H
diff --git a/src/jtag/drivers/OpenULINK/include/main.h b/src/jtag/drivers/OpenULINK/include/main.h
index 5f7418f6..9e7dd5a8 100644
--- a/src/jtag/drivers/OpenULINK/include/main.h
+++ b/src/jtag/drivers/OpenULINK/include/main.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __MAIN_H
diff --git a/src/jtag/drivers/OpenULINK/include/msgtypes.h b/src/jtag/drivers/OpenULINK/include/msgtypes.h
index 9dbbeddd..f761a845 100644
--- a/src/jtag/drivers/OpenULINK/include/msgtypes.h
+++ b/src/jtag/drivers/OpenULINK/include/msgtypes.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /**
diff --git a/src/jtag/drivers/OpenULINK/include/protocol.h b/src/jtag/drivers/OpenULINK/include/protocol.h
index fbc1996d..0b6a7d67 100644
--- a/src/jtag/drivers/OpenULINK/include/protocol.h
+++ b/src/jtag/drivers/OpenULINK/include/protocol.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __PROTOCOL_H
diff --git a/src/jtag/drivers/OpenULINK/include/reg_ezusb.h b/src/jtag/drivers/OpenULINK/include/reg_ezusb.h
index 82f9451e..4988367d 100644
--- a/src/jtag/drivers/OpenULINK/include/reg_ezusb.h
+++ b/src/jtag/drivers/OpenULINK/include/reg_ezusb.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef REG_EZUSB_H
diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
index 182b7904..9a261fed 100644
--- a/src/jtag/drivers/OpenULINK/include/usb.h
+++ b/src/jtag/drivers/OpenULINK/include/usb.h
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef __USB_H
diff --git a/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51 b/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
index 8ddd6801..f10ad484 100644
--- a/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
+++ b/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
@@ -13,9 +13,7 @@
 ;    GNU General Public License for more details.                          ;
 ;                                                                          ;
 ;    You should have received a copy of the GNU General Public License     ;
-;    along with this program; if not, write to the                         ;
-;    Free Software Foundation, Inc.,                                       ;
-;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           ;
+;    along with this program.  If not, see <http://www.gnu.org/licenses/>. ;
 ;--------------------------------------------------------------------------;
 
 .module JUMPTABLE
diff --git a/src/jtag/drivers/OpenULINK/src/delay.c b/src/jtag/drivers/OpenULINK/src/delay.c
index 82569e29..32605676 100644
--- a/src/jtag/drivers/OpenULINK/src/delay.c
+++ b/src/jtag/drivers/OpenULINK/src/delay.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #include "delay.h"
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
index 9f45ea78..41394556 100644
--- a/src/jtag/drivers/OpenULINK/src/jtag.c
+++ b/src/jtag/drivers/OpenULINK/src/jtag.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #include "jtag.h"
diff --git a/src/jtag/drivers/OpenULINK/src/main.c b/src/jtag/drivers/OpenULINK/src/main.c
index e4865f8a..f331c9eb 100644
--- a/src/jtag/drivers/OpenULINK/src/main.c
+++ b/src/jtag/drivers/OpenULINK/src/main.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #include "main.h"
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
index 5f7f9842..901f5248 100644
--- a/src/jtag/drivers/OpenULINK/src/protocol.c
+++ b/src/jtag/drivers/OpenULINK/src/protocol.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #include "protocol.h"
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index 98ae67f7..fb77f648 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /**
diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index 5aacead4..57c0ce60 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index 4c4cc6de..d9ea367c 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/at91rm9200.c b/src/jtag/drivers/at91rm9200.c
index d7e11df2..8f65413a 100644
--- a/src/jtag/drivers/at91rm9200.c
+++ b/src/jtag/drivers/at91rm9200.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/bcm2835gpio.c b/src/jtag/drivers/bcm2835gpio.c
index e1cc56c2..a41caf07 100644
--- a/src/jtag/drivers/bcm2835gpio.c
+++ b/src/jtag/drivers/bcm2835gpio.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -470,8 +468,8 @@ static int bcm2835gpio_init(void)
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	/* set 16mA drive strength */
-	pads_base[BCM2835_PADS_GPIO_0_27_OFFSET] = 0x5a000018 + 7;
+	/* set 4mA drive strength, slew rate limited, hysteresis on */
+	pads_base[BCM2835_PADS_GPIO_0_27_OFFSET] = 0x5a000008 + 1;
 
 	tdo_gpio_mode = MODE_GPIO(tdo_gpio);
 	tdi_gpio_mode = MODE_GPIO(tdi_gpio);
diff --git a/src/jtag/drivers/bitbang.c b/src/jtag/drivers/bitbang.c
index 1a0fa1c9..c9ec9c9d 100644
--- a/src/jtag/drivers/bitbang.c
+++ b/src/jtag/drivers/bitbang.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* 2014-12: Addition of the SWD protocol support is based on the initial work
diff --git a/src/jtag/drivers/bitbang.h b/src/jtag/drivers/bitbang.h
index 1bdb8f5f..c5b44bfd 100644
--- a/src/jtag/drivers/bitbang.h
+++ b/src/jtag/drivers/bitbang.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef BITBANG_H
-#define BITBANG_H
+#ifndef OPENOCD_JTAG_DRIVERS_BITBANG_H
+#define OPENOCD_JTAG_DRIVERS_BITBANG_H
 
 #include <jtag/swd.h>
 
@@ -47,4 +45,4 @@ extern struct bitbang_interface *bitbang_interface;
 void bitbang_switch_to_swd(void);
 int bitbang_swd_switch_seq(enum swd_special_seq seq);
 
-#endif /* BITBANG_H */
+#endif /* OPENOCD_JTAG_DRIVERS_BITBANG_H */
diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
index 1d0ff09b..66285f70 100644
--- a/src/jtag/drivers/bitq.c
+++ b/src/jtag/drivers/bitq.c
@@ -13,9 +13,7 @@
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
-*   along with this program; if not, write to the                         *
-*   Free Software Foundation, Inc.,                                       *
-*   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/bitq.h b/src/jtag/drivers/bitq.h
index f54de951..df6a08d4 100644
--- a/src/jtag/drivers/bitq.h
+++ b/src/jtag/drivers/bitq.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef BITQ_H
-#define BITQ_H
+#ifndef OPENOCD_JTAG_DRIVERS_BITQ_H
+#define OPENOCD_JTAG_DRIVERS_BITQ_H
 
 #include <jtag/commands.h>
 
@@ -44,4 +42,4 @@ int bitq_execute_queue(void);
 
 void bitq_cleanup(void);
 
-#endif /* BITQ_H */
+#endif /* OPENOCD_JTAG_DRIVERS_BITQ_H */
diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index aeae2401..33585a67 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/cmsis_dap_usb.c b/src/jtag/drivers/cmsis_dap_usb.c
index ff8b8ffa..19c3b19c 100644
--- a/src/jtag/drivers/cmsis_dap_usb.c
+++ b/src/jtag/drivers/cmsis_dap_usb.c
@@ -1,4 +1,10 @@
 /***************************************************************************
+ *   Copyright (C) 2016 by Maksym Hilliaka                                 *
+ *   oter@frozen-team.com                                                  *
+ *                                                                         *
+ *   Copyright (C) 2016 by Phillip Pearson                                 *
+ *   pp@myelin.co.nz                                                       *
+ *                                                                         *
  *   Copyright (C) 2014 by Paul Fertser                                    *
  *   fercerpav@gmail.com                                                   *
  *                                                                         *
@@ -19,9 +25,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -114,6 +118,13 @@ static bool swd_mode;
  * Bit 7: nRESET
  */
 
+#define SWJ_PIN_TCK               (1<<0)
+#define SWJ_PIN_TMS               (1<<1)
+#define SWJ_PIN_TDI               (1<<2)
+#define SWJ_PIN_TDO               (1<<3)
+#define SWJ_PIN_TRST              (1<<5)
+#define SWJ_PIN_SRST              (1<<7)
+
 /* CMSIS-DAP SWD Commands */
 #define CMD_DAP_SWD_CONFIGURE     0x13
 
@@ -122,6 +133,15 @@ static bool swd_mode;
 #define CMD_DAP_JTAG_CONFIGURE    0x15
 #define CMD_DAP_JTAG_IDCODE       0x16
 
+/* CMSIS-DAP JTAG sequence info masks */
+/* Number of bits to clock through (0 means 64) */
+#define DAP_JTAG_SEQ_TCK          0x3F
+/* TMS will be set during the sequence if this bit is set */
+#define DAP_JTAG_SEQ_TMS          0x40
+/* TDO output will be captured if this bit is set */
+#define DAP_JTAG_SEQ_TDO          0x80
+
+
 /* CMSIS-DAP Transfer Commands */
 #define CMD_DAP_TFER_CONFIGURE    0x04
 #define CMD_DAP_TFER              0x05
@@ -158,9 +178,32 @@ struct pending_transfer_result {
 	void *buffer;
 };
 
+struct pending_scan_result {
+	/** Offset in bytes in the CMD_DAP_JTAG_SEQ response buffer. */
+	unsigned first;
+	/** Number of bits to read. */
+	unsigned length;
+	/** Location to store the result */
+	uint8_t *buffer;
+	/** Offset in the destination buffer */
+	unsigned buffer_offset;
+};
+
 static int pending_transfer_count, pending_queue_len;
 static struct pending_transfer_result *pending_transfers;
 
+/* pointers to buffers that will receive jtag scan results on the next flush */
+#define MAX_PENDING_SCAN_RESULTS 256
+static int pending_scan_result_count;
+static struct pending_scan_result pending_scan_results[MAX_PENDING_SCAN_RESULTS];
+
+/* queued JTAG sequences that will be executed on the next flush */
+#define QUEUED_SEQ_BUF_LEN (cmsis_dap_handle->packet_size - 3)
+static int queued_seq_count;
+static int queued_seq_buf_end;
+static int queued_seq_tdo_ptr;
+static uint8_t queued_seq_buf[1024]; /* TODO: make dynamic / move into cmsis object */
+
 static int queued_retval;
 
 static struct cmsis_dap *cmsis_dap_handle;
@@ -214,12 +257,14 @@ static int cmsis_dap_usb_open(void)
 			/* we have found an adapter, so exit further checks */
 			/* check serial number matches if given */
 			if (cmsis_dap_serial != NULL) {
-				if (wcscmp(cmsis_dap_serial, cur_dev->serial_number) == 0) {
+				if ((cur_dev->serial_number != NULL) && wcscmp(cmsis_dap_serial, cur_dev->serial_number) == 0) {
 					serial_found = true;
 					break;
 				}
 			} else
 				break;
+
+			found = false;
 		}
 
 		cur_dev = cur_dev->next;
@@ -271,9 +316,11 @@ static int cmsis_dap_usb_open(void)
 	int packet_size = PACKET_SIZE;
 
 	/* atmel cmsis-dap uses 512 byte reports */
+	/* except when it doesn't e.g. with mEDBG on SAMD10 Xplained
+	 * board */
 	/* TODO: HID report descriptor should be parsed instead of
 	 * hardcoding a match by VID */
-	if (target_vid == 0x03eb)
+	if (target_vid == 0x03eb && target_pid != 0x2145)
 		packet_size = 512 + 1;
 
 	cmsis_dap_handle->packet_buffer = malloc(packet_size);
@@ -306,6 +353,9 @@ static void cmsis_dap_usb_close(struct cmsis_dap *dap)
 /* Send a message and receive the reply */
 static int cmsis_dap_usb_xfer(struct cmsis_dap *dap, int txlen)
 {
+#ifdef CMSIS_DAP_JTAG_DEBUG
+	LOG_DEBUG("cmsis-dap usb xfer cmd=%02X", dap->packet_buffer[1]);
+#endif
 	/* Pad the rest of the TX buffer with 0's */
 	memset(dap->packet_buffer + txlen, 0, dap->packet_size - txlen);
 
@@ -375,6 +425,33 @@ static int cmsis_dap_cmd_DAP_SWJ_Clock(uint32_t swj_clock)
 	return ERROR_OK;
 }
 
+/* clock a sequence of bits out on TMS, to change JTAG states */
+static int cmsis_dap_cmd_DAP_SWJ_Sequence(uint8_t s_len, const uint8_t *sequence)
+{
+	int retval;
+	uint8_t *buffer = cmsis_dap_handle->packet_buffer;
+
+#ifdef CMSIS_DAP_JTAG_DEBUG
+	LOG_DEBUG("cmsis-dap TMS sequence: len=%d", s_len);
+	for (int i = 0; i < DIV_ROUND_UP(s_len, 8); ++i)
+		printf("%02X ", sequence[i]);
+
+	printf("\n");
+#endif
+
+	buffer[0] = 0;	/* report number */
+	buffer[1] = CMD_DAP_SWJ_SEQ;
+	buffer[2] = s_len;
+	bit_copy(&buffer[3], 0, sequence, 0, s_len);
+
+	retval = cmsis_dap_usb_xfer(cmsis_dap_handle, DIV_ROUND_UP(s_len, 8) + 3);
+
+	if (retval != ERROR_OK || buffer[1] != DAP_OK)
+		return ERROR_FAIL;
+
+	return ERROR_OK;
+}
+
 static int cmsis_dap_cmd_DAP_Info(uint8_t info, uint8_t **data)
 {
 	int retval;
@@ -519,7 +596,7 @@ static int cmsis_dap_swd_run_queue(void)
 {
 	uint8_t *buffer = cmsis_dap_handle->packet_buffer;
 
-	LOG_DEBUG("Executing %d queued transactions", pending_transfer_count);
+	LOG_DEBUG_IO("Executing %d queued transactions", pending_transfer_count);
 
 	if (queued_retval != ERROR_OK) {
 		LOG_DEBUG("Skipping due to previous errors: %d", queued_retval);
@@ -539,7 +616,7 @@ static int cmsis_dap_swd_run_queue(void)
 		uint8_t cmd = pending_transfers[i].cmd;
 		uint32_t data = pending_transfers[i].data;
 
-		LOG_DEBUG("%s %s reg %x %"PRIx32,
+		LOG_DEBUG_IO("%s %s reg %x %"PRIx32,
 				cmd & SWD_CMD_APnDP ? "AP" : "DP",
 				cmd & SWD_CMD_RnW ? "read" : "write",
 			  (cmd & SWD_CMD_A32) >> 1, data);
@@ -597,7 +674,7 @@ static int cmsis_dap_swd_run_queue(void)
 			uint32_t tmp = data;
 			idx += 4;
 
-			LOG_DEBUG("Read result: %"PRIx32, data);
+			LOG_DEBUG_IO("Read result: %"PRIx32, data);
 
 			/* Imitate posted AP reads */
 			if ((pending_transfers[i].cmd & SWD_CMD_APnDP) ||
@@ -696,12 +773,12 @@ static int cmsis_dap_get_status(void)
 
 	if (retval == ERROR_OK) {
 		LOG_INFO("SWCLK/TCK = %d SWDIO/TMS = %d TDI = %d TDO = %d nTRST = %d nRESET = %d",
-			(d & (0x01 << 0)) ? 1 : 0,	/* Bit 0: SWCLK/TCK */
-			(d & (0x01 << 1)) ? 1 : 0,	/* Bit 1: SWDIO/TMS */
-			(d & (0x01 << 2)) ? 1 : 0,	/* Bit 2: TDI */
-			(d & (0x01 << 3)) ? 1 : 0,	/* Bit 3: TDO */
-			(d & (0x01 << 5)) ? 1 : 0,	/* Bit 5: nTRST */
-			(d & (0x01 << 7)) ? 1 : 0);	/* Bit 7: nRESET */
+			(d & SWJ_PIN_TCK) ? 1 : 0,
+			(d & SWJ_PIN_TMS) ? 1 : 0,
+			(d & SWJ_PIN_TDI) ? 1 : 0,
+			(d & SWJ_PIN_TDO) ? 1 : 0,
+			(d & SWJ_PIN_TRST) ? 1 : 0,
+			(d & SWJ_PIN_SRST) ? 1 : 0);
 	}
 
 	return retval;
@@ -709,7 +786,6 @@ static int cmsis_dap_get_status(void)
 
 static int cmsis_dap_swd_switch_seq(enum swd_special_seq seq)
 {
-	uint8_t *buffer = cmsis_dap_handle->packet_buffer;
 	const uint8_t *s;
 	unsigned int s_len;
 	int retval;
@@ -745,17 +821,13 @@ static int cmsis_dap_swd_switch_seq(enum swd_special_seq seq)
 		return ERROR_FAIL;
 	}
 
-	buffer[0] = 0;	/* report number */
-	buffer[1] = CMD_DAP_SWJ_SEQ;
-	buffer[2] = s_len;
-	bit_copy(&buffer[3], 0, s, 0, s_len);
-
-	retval = cmsis_dap_usb_xfer(cmsis_dap_handle, DIV_ROUND_UP(s_len, 8) + 3);
-
-	if (retval != ERROR_OK || buffer[1] != DAP_OK)
-		return ERROR_FAIL;
+	retval = cmsis_dap_cmd_DAP_SWJ_Sequence(s_len, s);
+	if (retval != ERROR_OK)
+		return retval;
 
-	return ERROR_OK;
+	/* Atmel EDBG needs renew clock setting after SWJ_Sequence
+	 * otherwise default frequency is used */
+	return cmsis_dap_cmd_DAP_SWJ_Clock(jtag_get_speed_khz());
 }
 
 static int cmsis_dap_swd_open(void)
@@ -933,8 +1005,17 @@ static int cmsis_dap_quit(void)
 
 static void cmsis_dap_execute_reset(struct jtag_command *cmd)
 {
-	int retval = cmsis_dap_cmd_DAP_SWJ_Pins(cmd->cmd.reset->srst ? 0 : (1 << 7), \
-			(1 << 7), 0, NULL);
+	/* Set both TRST and SRST even if they're not enabled as
+	 * there's no way to tristate them */
+	uint8_t pins = 0;
+
+	if (!cmd->cmd.reset->srst)
+		pins |= SWJ_PIN_SRST;
+	if (!cmd->cmd.reset->trst)
+		pins |= SWJ_PIN_TRST;
+
+	int retval = cmsis_dap_cmd_DAP_SWJ_Pins(pins,
+			SWJ_PIN_TRST | SWJ_PIN_SRST, 0, NULL);
 	if (retval != ERROR_OK)
 		LOG_ERROR("CMSIS-DAP: Interface reset failed");
 }
@@ -948,17 +1029,456 @@ static void cmsis_dap_execute_sleep(struct jtag_command *cmd)
 		jtag_sleep(cmd->cmd.sleep->us);
 }
 
+/* Set TMS high for five TCK clocks, to move the TAP to the Test-Logic-Reset state */
+static int cmsis_dap_execute_tlr_reset(struct jtag_command *cmd)
+{
+	LOG_INFO("cmsis-dap JTAG TLR_RESET");
+	uint8_t seq = 0xff;
+	int ret = cmsis_dap_cmd_DAP_SWJ_Sequence(8, &seq);
+	if (ret == ERROR_OK)
+		tap_set_state(TAP_RESET);
+	return ret;
+}
+
+/* Set new end state */
+static void cmsis_dap_end_state(tap_state_t state)
+{
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
+	else {
+		LOG_ERROR("BUG: %i is not a valid end state", state);
+		exit(-1);
+	}
+}
+
+#ifdef SPRINT_BINARY
+static void sprint_binary(char *s, const uint8_t *buf, int offset, int len)
+{
+	if (!len)
+		return;
+
+	/*
+	buf = { 0x18 } len=5 should result in: 11000
+	buf = { 0xff 0x18 } len=13 should result in: 11111111 11000
+	buf = { 0xc0 0x18 } offset=3 len=10 should result in: 11000 11000
+		i=3 there means i/8 = 0 so c = 0xFF, and
+	*/
+	for (int i = offset; i < offset + len; ++i) {
+		uint8_t c = buf[i / 8], mask = 1 << (i % 8);
+		if ((i != offset) && !(i % 8))
+			putchar(' ');
+		*s++ = (c & mask) ? '1' : '0';
+	}
+	*s = 0;
+}
+#endif
+
+#ifdef CMSIS_DAP_JTAG_DEBUG
+static void debug_parse_cmsis_buf(const uint8_t *cmd, int cmdlen)
+{
+	/* cmd is a usb packet to go to the cmsis-dap interface */
+	printf("cmsis-dap buffer (%d b): ", cmdlen);
+	for (int i = 0; i < cmdlen; ++i)
+		printf(" %02x", cmd[i]);
+	printf("\n");
+	switch (cmd[1]) {
+		case CMD_DAP_JTAG_SEQ: {
+			printf("cmsis-dap jtag sequence command %02x (n=%d)\n", cmd[1], cmd[2]);
+			/*
+			 * #2 = number of sequences
+			 * #3 = sequence info 1
+			 * #4...4+n_bytes-1 = sequence 1
+			 * #4+n_bytes = sequence info 2
+			 * #5+n_bytes = sequence 2 (single bit)
+			 */
+			int pos = 3;
+			for (int seq = 0; seq < cmd[2]; ++seq) {
+				uint8_t info = cmd[pos++];
+				int len = info & DAP_JTAG_SEQ_TCK;
+				if (len == 0)
+					len = 64;
+				printf("  sequence %d starting %d: info %02x (len=%d tms=%d read_tdo=%d): ",
+					seq, pos, info, len, info & DAP_JTAG_SEQ_TMS, info & DAP_JTAG_SEQ_TDO);
+				for (int i = 0; i < DIV_ROUND_UP(len, 8); ++i)
+					printf(" %02x", cmd[pos+i]);
+				pos += DIV_ROUND_UP(len, 8);
+				printf("\n");
+			}
+			if (pos != cmdlen) {
+				printf("BUFFER LENGTH MISMATCH looks like %d but %d specified", pos, cmdlen);
+				exit(-1);
+			}
+
+			break;
+		}
+		default:
+			LOG_DEBUG("unknown cmsis-dap command %02x", cmd[1]);
+			break;
+	}
+}
+#endif
+
+static void cmsis_dap_flush(void)
+{
+	if (!queued_seq_count)
+		return;
+
+	DEBUG_JTAG_IO("Flushing %d queued sequences (%d bytes) with %d pending scan results to capture",
+		queued_seq_count, queued_seq_buf_end, pending_scan_result_count);
+
+	/* prep CMSIS-DAP packet */
+	uint8_t *buffer = cmsis_dap_handle->packet_buffer;
+	buffer[0] = 0;	/* report number */
+	buffer[1] = CMD_DAP_JTAG_SEQ;
+	buffer[2] = queued_seq_count;
+	memcpy(buffer + 3, queued_seq_buf, queued_seq_buf_end);
+
+#ifdef CMSIS_DAP_JTAG_DEBUG
+	debug_parse_cmsis_buf(buffer, queued_seq_buf_end + 3);
+#endif
+
+	/* send command to USB device */
+	int retval = cmsis_dap_usb_xfer(cmsis_dap_handle, queued_seq_buf_end + 3);
+	if (retval != ERROR_OK || buffer[1] != DAP_OK) {
+		LOG_ERROR("CMSIS-DAP command CMD_DAP_JTAG_SEQ failed.");
+		exit(-1);
+	}
+
+#ifdef CMSIS_DAP_JTAG_DEBUG
+	DEBUG_JTAG_IO("USB response buf:");
+	for (int c = 0; c < queued_seq_buf_end + 3; ++c)
+		printf("%02X ", buffer[c]);
+	printf("\n");
+#endif
+
+	/* copy scan results into client buffers */
+	for (int i = 0; i < pending_scan_result_count; ++i) {
+		struct pending_scan_result *scan = &pending_scan_results[i];
+		DEBUG_JTAG_IO("Copying pending_scan_result %d/%d: %d bits from byte %d -> buffer + %d bits",
+			i, pending_scan_result_count, scan->length, scan->first + 2, scan->buffer_offset);
+#ifdef CMSIS_DAP_JTAG_DEBUG
+		for (uint32_t b = 0; b < DIV_ROUND_UP(scan->length, 8); ++b)
+			printf("%02X ", buffer[2+scan->first+b]);
+		printf("\n");
+#endif
+		bit_copy(scan->buffer, scan->buffer_offset, buffer + 2 + scan->first, 0, scan->length);
+	}
+
+	/* reset */
+	queued_seq_count = 0;
+	queued_seq_buf_end = 0;
+	queued_seq_tdo_ptr = 0;
+	pending_scan_result_count = 0;
+}
+
+/* queue a sequence of bits to clock out TDI / in TDO, executing if the buffer is full.
+ *
+ * sequence=NULL means clock out zeros on TDI
+ * tdo_buffer=NULL means don't capture TDO
+ */
+static void cmsis_dap_add_jtag_sequence(int s_len, const uint8_t *sequence, int s_offset,
+					bool tms, uint8_t *tdo_buffer, int tdo_buffer_offset)
+{
+	DEBUG_JTAG_IO("[at %d] %d bits, tms %s, seq offset %d, tdo buf %p, tdo offset %d",
+		queued_seq_buf_end,
+		s_len, tms ? "HIGH" : "LOW", s_offset, tdo_buffer, tdo_buffer_offset);
+
+	if (s_len == 0)
+		return;
+
+	if (s_len > 64) {
+		DEBUG_JTAG_IO("START JTAG SEQ SPLIT");
+		for (int offset = 0; offset < s_len; offset += 64) {
+			int len = s_len - offset;
+			if (len > 64)
+				len = 64;
+			DEBUG_JTAG_IO("Splitting long jtag sequence: %d-bit chunk starting at offset %d", len, offset);
+			cmsis_dap_add_jtag_sequence(
+				len,
+				sequence,
+				s_offset + offset,
+				tms,
+				tdo_buffer,
+				tdo_buffer == NULL ? 0 : (tdo_buffer_offset + offset)
+				);
+		}
+		DEBUG_JTAG_IO("END JTAG SEQ SPLIT");
+		return;
+	}
+
+	int cmd_len = 1 + DIV_ROUND_UP(s_len, 8);
+	if (queued_seq_count >= 255 || queued_seq_buf_end + cmd_len > QUEUED_SEQ_BUF_LEN)
+		/* empty out the buffer */
+		cmsis_dap_flush();
+
+	++queued_seq_count;
+
+	/* control byte */
+	queued_seq_buf[queued_seq_buf_end] =
+		(tms ? DAP_JTAG_SEQ_TMS : 0) |
+		(tdo_buffer != NULL ? DAP_JTAG_SEQ_TDO : 0) |
+		(s_len == 64 ? 0 : s_len);
+
+	if (sequence != NULL)
+		bit_copy(&queued_seq_buf[queued_seq_buf_end + 1], 0, sequence, s_offset, s_len);
+	else
+		memset(&queued_seq_buf[queued_seq_buf_end + 1], 0, DIV_ROUND_UP(s_len, 8));
+
+	queued_seq_buf_end += cmd_len;
+
+	if (tdo_buffer != NULL) {
+		struct pending_scan_result *scan = &pending_scan_results[pending_scan_result_count++];
+		scan->first = queued_seq_tdo_ptr;
+		queued_seq_tdo_ptr += DIV_ROUND_UP(s_len, 8);
+		scan->length = s_len;
+		scan->buffer = tdo_buffer;
+		scan->buffer_offset = tdo_buffer_offset;
+	}
+}
+
+/* queue a sequence of bits to clock out TMS, executing if the buffer is full */
+static void cmsis_dap_add_tms_sequence(const uint8_t *sequence, int s_len)
+{
+	DEBUG_JTAG_IO("%d bits: %02X", s_len, *sequence);
+	/* we use a series of CMD_DAP_JTAG_SEQ commands to toggle TMS,
+	   because even though it seems ridiculously inefficient, it
+	   allows us to combine TMS and scan sequences into the same
+	   USB packet. */
+	/* TODO: combine runs of the same tms value */
+	for (int i = 0; i < s_len; ++i) {
+		bool bit = (sequence[i / 8] & (1 << (i % 8))) != 0;
+		cmsis_dap_add_jtag_sequence(1, NULL, 0, bit, NULL, 0);
+	}
+}
+
+/* Move to the end state by queuing a sequence to clock into TMS */
+static void cmsis_dap_state_move(void)
+{
+	uint8_t tms_scan;
+	uint8_t tms_scan_bits;
+
+	tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	tms_scan_bits = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+
+	DEBUG_JTAG_IO("state move from %s to %s: %d clocks, %02X on tms",
+		tap_state_name(tap_get_state()), tap_state_name(tap_get_end_state()),
+		tms_scan_bits, tms_scan);
+	cmsis_dap_add_tms_sequence(&tms_scan, tms_scan_bits);
+
+	tap_set_state(tap_get_end_state());
+}
+
+
+/* Execute a JTAG scan operation by queueing TMS and TDI/TDO sequences */
+static void cmsis_dap_execute_scan(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("%s type:%d", cmd->cmd.scan->ir_scan ? "IRSCAN" : "DRSCAN",
+		jtag_scan_type(cmd->cmd.scan));
+
+	/* Make sure there are no trailing fields with num_bits == 0, or the logic below will fail. */
+	while (cmd->cmd.scan->num_fields > 0
+			&& cmd->cmd.scan->fields[cmd->cmd.scan->num_fields - 1].num_bits == 0) {
+		cmd->cmd.scan->num_fields--;
+		LOG_DEBUG("discarding trailing empty field");
+	}
+
+	if (cmd->cmd.scan->num_fields == 0) {
+		LOG_DEBUG("empty scan, doing nothing");
+		return;
+	}
+
+	if (cmd->cmd.scan->ir_scan) {
+		if (tap_get_state() != TAP_IRSHIFT) {
+			cmsis_dap_end_state(TAP_IRSHIFT);
+			cmsis_dap_state_move();
+		}
+	} else {
+		if (tap_get_state() != TAP_DRSHIFT) {
+			cmsis_dap_end_state(TAP_DRSHIFT);
+			cmsis_dap_state_move();
+		}
+	}
+
+	cmsis_dap_end_state(cmd->cmd.scan->end_state);
+
+	struct scan_field *field = cmd->cmd.scan->fields;
+	unsigned scan_size = 0;
+
+	for (int i = 0; i < cmd->cmd.scan->num_fields; i++, field++) {
+		scan_size += field->num_bits;
+		DEBUG_JTAG_IO("%s%s field %d/%d %d bits",
+			field->in_value ? "in" : "",
+			field->out_value ? "out" : "",
+			i,
+			cmd->cmd.scan->num_fields,
+			field->num_bits);
+
+		if (i == cmd->cmd.scan->num_fields - 1 && tap_get_state() != tap_get_end_state()) {
+			DEBUG_JTAG_IO("Last field and have to move out of SHIFT state");
+			/* Last field, and we're leaving IRSHIFT/DRSHIFT. Clock last bit during tap
+			 * movement. This last field can't have length zero, it was checked above. */
+			cmsis_dap_add_jtag_sequence(
+				field->num_bits - 1, /* number of bits to clock */
+				field->out_value, /* output sequence */
+				0, /* output offset */
+				false, /* TMS low */
+				field->in_value,
+				0);
+
+			/* Clock the last bit out, with TMS high */
+			uint8_t last_bit = 0;
+			if (field->out_value)
+				bit_copy(&last_bit, 0, field->out_value, field->num_bits - 1, 1);
+			cmsis_dap_add_jtag_sequence(
+				1,
+				&last_bit,
+				0,
+				true,
+				field->in_value,
+				field->num_bits - 1);
+			tap_set_state(tap_state_transition(tap_get_state(), 1));
+
+			/* Now clock one more cycle, with TMS low, to get us into a PAUSE state */
+			cmsis_dap_add_jtag_sequence(
+				1,
+				&last_bit,
+				0,
+				false,
+				NULL,
+				0);
+			tap_set_state(tap_state_transition(tap_get_state(), 0));
+		} else {
+			DEBUG_JTAG_IO("Internal field, staying in SHIFT state afterwards");
+			/* Clocking part of a sequence into DR or IR with TMS=0,
+			   leaving TMS=0 at the end so we can continue later */
+			cmsis_dap_add_jtag_sequence(
+				field->num_bits,
+				field->out_value,
+				0,
+				false,
+				field->in_value,
+				0);
+		}
+	}
+
+	if (tap_get_state() != tap_get_end_state()) {
+		cmsis_dap_end_state(tap_get_end_state());
+		cmsis_dap_state_move();
+	}
+
+	DEBUG_JTAG_IO("%s scan, %i bits, end in %s",
+		(cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size,
+		tap_state_name(tap_get_end_state()));
+}
+
+static void cmsis_dap_pathmove(int num_states, tap_state_t *path)
+{
+	int i;
+	uint8_t tms0 = 0x00;
+	uint8_t tms1 = 0xff;
+
+	for (i = 0; i < num_states; i++) {
+		if (path[i] == tap_state_transition(tap_get_state(), false))
+			cmsis_dap_add_tms_sequence(&tms0, 1);
+		else if (path[i] == tap_state_transition(tap_get_state(), true))
+			cmsis_dap_add_tms_sequence(&tms1, 1);
+		else {
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition.",
+				  tap_state_name(tap_get_state()), tap_state_name(path[i]));
+			exit(-1);
+		}
+
+		tap_set_state(path[i]);
+	}
+
+	cmsis_dap_end_state(tap_get_state());
+}
+
+static void cmsis_dap_execute_pathmove(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("pathmove: %i states, end in %i",
+		      cmd->cmd.pathmove->num_states,
+	       cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]);
+
+	cmsis_dap_pathmove(cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path);
+}
+
+static void cmsis_dap_stableclocks(int num_cycles)
+{
+	int i;
+
+	uint8_t tms = tap_get_state() == TAP_RESET;
+	/* TODO: Perform optimizations? */
+	/* Execute num_cycles. */
+	for (i = 0; i < num_cycles; i++)
+		cmsis_dap_add_tms_sequence(&tms, 1);
+}
+
+static void cmsis_dap_runtest(int num_cycles)
+{
+	tap_state_t saved_end_state = tap_get_end_state();
+
+	/* Only do a state_move when we're not already in IDLE. */
+	if (tap_get_state() != TAP_IDLE) {
+		cmsis_dap_end_state(TAP_IDLE);
+		cmsis_dap_state_move();
+	}
+	cmsis_dap_stableclocks(num_cycles);
+
+	/* Finish in end_state. */
+	cmsis_dap_end_state(saved_end_state);
+
+	if (tap_get_state() != tap_get_end_state())
+		cmsis_dap_state_move();
+}
+
+static void cmsis_dap_execute_runtest(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles,
+		      cmd->cmd.runtest->end_state);
+
+	cmsis_dap_end_state(cmd->cmd.runtest->end_state);
+	cmsis_dap_runtest(cmd->cmd.runtest->num_cycles);
+}
+
+static void cmsis_dap_execute_stableclocks(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("stableclocks %i cycles", cmd->cmd.runtest->num_cycles);
+	cmsis_dap_stableclocks(cmd->cmd.runtest->num_cycles);
+}
+
+/* TODO: Is there need to call cmsis_dap_flush() for the JTAG_PATHMOVE,
+ * JTAG_RUNTEST, JTAG_STABLECLOCKS? */
 static void cmsis_dap_execute_command(struct jtag_command *cmd)
 {
 	switch (cmd->type) {
 		case JTAG_RESET:
+			cmsis_dap_flush();
 			cmsis_dap_execute_reset(cmd);
 			break;
 		case JTAG_SLEEP:
+			cmsis_dap_flush();
 			cmsis_dap_execute_sleep(cmd);
 			break;
+		case JTAG_TLR_RESET:
+			cmsis_dap_flush();
+			cmsis_dap_execute_tlr_reset(cmd);
+			break;
+		case JTAG_SCAN:
+			cmsis_dap_execute_scan(cmd);
+			break;
+		case JTAG_PATHMOVE:
+			cmsis_dap_execute_pathmove(cmd);
+			break;
+		case JTAG_RUNTEST:
+			cmsis_dap_execute_runtest(cmd);
+			break;
+		case JTAG_STABLECLOCKS:
+			cmsis_dap_execute_stableclocks(cmd);
+			break;
+		case JTAG_TMS:
 		default:
-			LOG_ERROR("BUG: unknown JTAG command type encountered");
+			LOG_ERROR("BUG: unknown JTAG command type 0x%X encountered", cmd->type);
 			exit(-1);
 	}
 }
@@ -972,18 +1492,18 @@ static int cmsis_dap_execute_queue(void)
 		cmd = cmd->next;
 	}
 
+	cmsis_dap_flush();
+
 	return ERROR_OK;
 }
 
 static int cmsis_dap_speed(int speed)
 {
-	if (speed > DAP_MAX_CLOCK) {
-		LOG_INFO("reduce speed request: %dkHz to %dkHz maximum", speed, DAP_MAX_CLOCK);
-		speed = DAP_MAX_CLOCK;
-	}
+	if (speed > DAP_MAX_CLOCK)
+		LOG_INFO("High speed (adapter_khz %d) may be limited by adapter firmware.", speed);
 
 	if (speed == 0) {
-		LOG_INFO("RTCK not supported");
+		LOG_ERROR("RTCK not supported. Set nonzero adapter_khz.");
 		return ERROR_JTAG_NOT_IMPLEMENTED;
 	}
 
@@ -1010,6 +1530,7 @@ static int_least32_t cmsis_dap_swd_frequency(int_least32_t hz)
 	return hz;
 }
 
+
 COMMAND_HANDLER(cmsis_dap_handle_info_command)
 {
 	if (cmsis_dap_get_version_info() == ERROR_OK)
@@ -1114,7 +1635,7 @@ static const struct swd_driver cmsis_dap_swd_driver = {
 	.run = cmsis_dap_swd_run_queue,
 };
 
-static const char * const cmsis_dap_transport[] = { "swd", NULL };
+static const char * const cmsis_dap_transport[] = { "swd", "jtag", NULL };
 
 struct jtag_interface cmsis_dap_interface = {
 	.name = "cmsis-dap",
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 75ec115e..daf7cd42 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/dummy.c b/src/jtag/drivers/dummy.c
index ddba976d..0f7c12dd 100644
--- a/src/jtag/drivers/dummy.c
+++ b/src/jtag/drivers/dummy.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/ep93xx.c b/src/jtag/drivers/ep93xx.c
index 8e12e172..ccd97950 100644
--- a/src/jtag/drivers/ep93xx.c
+++ b/src/jtag/drivers/ep93xx.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
deleted file mode 100644
index 2142145e..00000000
--- a/src/jtag/drivers/ft2232.c
+++ /dev/null
@@ -1,4378 +0,0 @@
-/**************************************************************************
-*   Copyright (C) 2009 by Øyvind Harboe                                   *
-*   Øyvind Harboe <oyvind.harboe@zylin.com>                               *
-*                                                                         *
-*   Copyright (C) 2009 by SoftPLC Corporation.  http://softplc.com        *
-*   Dick Hollenbeck <dick@softplc.com>                                    *
-*                                                                         *
-*   Copyright (C) 2012 by Evan Hunter                                     *
-*   ehunter@broadcom.com                                                  *
-*                                                                         *
-*   Copyright (C) 2004, 2006 by Dominic Rath                              *
-*   Dominic.Rath@gmx.de                                                   *
-*                                                                         *
-*   Copyright (C) 2008 by Spencer Oliver                                  *
-*   spen@spen-soft.co.uk                                                  *
-*                                                                         *
-*   This program is free software; you can redistribute it and/or modify  *
-*   it under the terms of the GNU General Public License as published by  *
-*   the Free Software Foundation; either version 2 of the License, or     *
-*   (at your option) any later version.                                   *
-*                                                                         *
-*   This program is distributed in the hope that it will be useful,       *
-*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
-*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
-*   GNU General Public License for more details.                          *
-*                                                                         *
-*   You should have received a copy of the GNU General Public License     *
-*   along with this program; if not, write to the                         *
-*   Free Software Foundation, Inc.,                                       *
-*   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
-***************************************************************************/
-
-/**
- * @file
- * JTAG adapters based on the FT2232 full and high speed USB parts are
- * popular low cost JTAG debug solutions.  Many FT2232 based JTAG adapters
- * are discrete, but development boards may integrate them as alternatives
- * to more capable (and expensive) third party JTAG pods.
- *
- * JTAG uses only one of the two communications channels ("MPSSE engines")
- * on these devices.  Adapters based on FT4232 parts have four ports/channels
- * (A/B/C/D), instead of just two (A/B).
- *
- * Especially on development boards integrating one of these chips (as
- * opposed to discrete pods/dongles), the additional channels can be used
- * for a variety of purposes, but OpenOCD only uses one channel at a time.
- *
- *  - As a USB-to-serial adapter for the target's console UART ...
- *    which may be able to support ROM boot loaders that load initial
- *    firmware images to flash (or SRAM).
- *
- *  - On systems which support ARM's SWD in addition to JTAG, or instead
- *    of it, that second port can be used for reading SWV/SWO trace data.
- *
- *  - Additional JTAG links, e.g. to a CPLD or * FPGA.
- *
- * FT2232 based JTAG adapters are "dumb" not "smart", because most JTAG
- * request/response interactions involve round trips over the USB link.
- * A "smart" JTAG adapter has intelligence close to the scan chain, so it
- * can for example poll quickly for a status change (usually taking on the
- * order of microseconds not milliseconds) before beginning a queued
- * transaction which require the previous one to have completed.
- *
- * There are dozens of adapters of this type, differing in details which
- * this driver needs to understand.  Those "layout" details are required
- * as part of FT2232 driver configuration.
- *
- * This code uses information contained in the MPSSE specification which was
- * found here:
- * http://www.ftdichip.com/Documents/AppNotes/AN2232C-01_MPSSE_Cmnd.pdf
- * Hereafter this is called the "MPSSE Spec".
- *
- * The datasheet for the ftdichip.com's FT2232D part is here:
- * http://www.ftdichip.com/Documents/DataSheets/DS_FT2232D.pdf
- *
- * Also note the issue with code 0x4b (clock data to TMS) noted in
- * http://developer.intra2net.com/mailarchive/html/libftdi/2009/msg00292.html
- * which can affect longer JTAG state paths.
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-/* project specific includes */
-#include <jtag/interface.h>
-#include <transport/transport.h>
-#include <helper/time_support.h>
-
-#if IS_CYGWIN == 1
-#include <windows.h>
-#endif
-
-#include <assert.h>
-
-#if (BUILD_FT2232_FTD2XX == 1 && BUILD_FT2232_LIBFTDI == 1)
-#error "BUILD_FT2232_FTD2XX && BUILD_FT2232_LIBFTDI are mutually exclusive"
-#elif (BUILD_FT2232_FTD2XX != 1 && BUILD_FT2232_LIBFTDI != 1)
-#error "BUILD_FT2232_FTD2XX || BUILD_FT2232_LIBFTDI must be chosen"
-#endif
-
-/* FT2232 access library includes */
-#if BUILD_FT2232_FTD2XX == 1
-#include <ftd2xx.h>
-#include "ftd2xx_common.h"
-
-enum ftdi_interface {
-	INTERFACE_ANY = 0,
-	INTERFACE_A   = 1,
-	INTERFACE_B   = 2,
-	INTERFACE_C   = 3,
-	INTERFACE_D   = 4
-};
-
-#elif BUILD_FT2232_LIBFTDI == 1
-#include <ftdi.h>
-#endif
-
-/* max TCK for the high speed devices 30000 kHz */
-#define	FTDI_x232H_MAX_TCK	30000
-/* max TCK for the full speed devices 6000 kHz */
-#define FTDI_2232C_MAX_TCK 6000
-/* this speed value tells that RTCK is requested */
-#define RTCK_SPEED -1
-
-/*
- * On my Athlon XP 1900+ EHCI host with FT2232H JTAG dongle I get read timeout
- * errors with a retry count of 100. Increasing it solves the problem for me.
- *	- Dimitar
- *
- * FIXME There's likely an issue with the usb_read_timeout from libftdi.
- * Fix that (libusb? kernel? libftdi? here?) and restore the retry count
- * to something sane.
- */
-#define LIBFTDI_READ_RETRY_COUNT		2000
-
-#ifndef BUILD_FT2232_HIGHSPEED
- #if BUILD_FT2232_FTD2XX == 1
-	enum { FT_DEVICE_2232H = 6, FT_DEVICE_4232H, FT_DEVICE_232H };
- #elif BUILD_FT2232_LIBFTDI == 1
-	enum ftdi_chip_type { TYPE_2232H = 4, TYPE_4232H = 5, TYPE_232H = 6 };
- #endif
-#endif
-
-/**
- * Send out \a num_cycles on the TCK line while the TAP(s) are in a
- * stable state.  Calling code must ensure that current state is stable,
- * that verification is not done in here.
- *
- * @param num_cycles The number of clocks cycles to send.
- * @param cmd The command to send.
- *
- * @returns ERROR_OK on success, or ERROR_JTAG_QUEUE_FAILED on failure.
- */
-static int ft2232_stableclocks(int num_cycles, struct jtag_command *cmd);
-
-static char *ft2232_device_desc_A;
-static char *ft2232_device_desc;
-static char *ft2232_serial;
-static uint8_t ft2232_latency = 2;
-static unsigned ft2232_max_tck = FTDI_2232C_MAX_TCK;
-static int ft2232_channel = INTERFACE_ANY;
-
-#define MAX_USB_IDS 8
-/* vid = pid = 0 marks the end of the list */
-static uint16_t ft2232_vid[MAX_USB_IDS + 1] = { 0x0403, 0 };
-static uint16_t ft2232_pid[MAX_USB_IDS + 1] = { 0x6010, 0 };
-
-typedef struct {
-	uint16_t mask;                       /** Pin mask CBus=high, DBus= low byte */
-	bool active_high;                    /** True=active high, false=active low */
-} ft2232_output_pin_t;
-
-typedef struct {
-	enum {
-		PUSH_PULL_ONLY,                  /** Pin has no pull-up/down resistor   */
-		PIN_DIRECTION,                   /** Use pin dir for open drain         */
-		OUTPUT_ENABLE_PIN,               /** Use second pin as Output Enable    */
-		EXTERNAL_OPEN_DRAIN,             /** Pin controls external open drain   */
-	} type;
-	ft2232_output_pin_t oe_pin;          /** Define Output enable if it exists  */
-} ft2232_control_pin_t;
-
-struct ft2232_layout {
-	const char *name;                    /** Layout name                        */
-	int (*init)(void);                   /** Custom initialization function     */
-	void (*reset)(int trst, int srst);   /** Custom reset function              */
-	void (*blink)(void);                 /** Custom LED blink function          */
-	int channel;                         /** FTDI channel ID                    */
-	ft2232_output_pin_t  TRST;           /** TRST pin location                  */
-	ft2232_control_pin_t TRST_ctrl;      /** Control method for TRST pin        */
-	ft2232_output_pin_t  SRST;           /** SRST pin location                  */
-	ft2232_control_pin_t SRST_ctrl;      /** Control method for SRST pin        */
-	ft2232_output_pin_t  blink_pins;     /** LED pins location                  */
-	uint16_t initial_output;             /** Initial pin output values          */
-	uint16_t initial_direction;          /** Initial pin directions, 1=output   */
-};
-
-/* Macros for setting pin states */
-#define PIN_OP_ACTIVE(pin, output)   (((pin).active_high) ? ((output) | (pin).mask)    : ((output) & (~(pin).mask)))
-#define PIN_OP_INACTIVE(pin, output) (((pin).active_high) ? ((output) & (~(pin).mask)) : ((output) | (pin).mask))
-#define PIN_OP_SET(pin, output, val) ((val) ? (PIN_OP_ACTIVE((pin), (output))) : (PIN_OP_INACTIVE((pin), (output))))
-
-/* Standard pin setups for JTAG */
-#define STANDARD_JTAG_OUTPUT    (0x0008)
-#define STANDARD_JTAG_DIRECTION (0x000B)
-
-/* Standard init/reset/blink functions
- * that cover the needs of most adapters
- */
-static int standard_init(void);
-static int standard_reset(int trst, int srst);
-static void standard_blink(void);
-
-/* Custom init/reset/blink procedures for unusual adapters */
-static int signalyzer_h_init(void);
-static void signalyzer_h_reset(int trst, int srst);
-static void signalyzer_h_blink(void);
-
-/* @TODO: The following adapter functions
- * should be removed in favour of pin definitions
- * within the layout like the olimex-jtag layout
- * This conversion should be straightforward, but
- * needs testing with the particular adapters.
- */
-static int usbjtag_init(void);
-static int lm3s811_jtag_init(void);
-static int icdi_jtag_init(void);
-static int flyswatter1_init(void);
-static int flyswatter2_init(void);
-static int minimodule_init(void);
-static int turtle_init(void);
-static int comstick_init(void);
-static int stm32stick_init(void);
-static int axm0432_jtag_init(void);
-static int sheevaplug_init(void);
-static int icebear_jtag_init(void);
-static int cortino_jtag_init(void);
-static int signalyzer_init(void);
-static int ktlink_init(void);
-static int redbee_init(void);
-static int lisa_l_init(void);
-static int flossjtag_init(void);
-static int xds100v2_init(void);
-static int digilent_hs1_init(void);
-static void ftx23_reset(int trst, int srst);
-static void flyswatter1_reset(int trst, int srst);
-static void flyswatter2_reset(int trst, int srst);
-static void minimodule_reset(int trst, int srst);
-static void turtle_reset(int trst, int srst);
-static void comstick_reset(int trst, int srst);
-static void stm32stick_reset(int trst, int srst);
-static void axm0432_jtag_reset(int trst, int srst);
-static void sheevaplug_reset(int trst, int srst);
-static void icebear_jtag_reset(int trst, int srst);
-static void ktlink_reset(int trst, int srst);
-static void redbee_reset(int trst, int srst);
-static void xds100v2_reset(int trst, int srst);
-static void digilent_hs1_reset(int trst, int srst);
-static void flyswatter1_jtag_blink(void);
-static void flyswatter2_jtag_blink(void);
-static void turtle_jtag_blink(void);
-static void ktlink_blink(void);
-static void lisa_l_blink(void);
-static void flossjtag_blink(void);
-
-/* common transport support options */
-
-/* static const char *jtag_and_swd[] = { "jtag", "swd", NULL }; */
-
-static const struct ft2232_layout  ft2232_layouts[] = {
-	{ .name = "usbjtag",
-		.init = usbjtag_init,
-		.reset = ftx23_reset,
-	},
-	{ .name = "jtagkey",
-		.TRST      = { .mask = 0x0100, .active_high = false },
-		.TRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0400, .active_high = false } },
-		.SRST      = { .mask = 0x0200, .active_high = false },
-		.SRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0800, .active_high = false } },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0f10 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "jtagkey_prototype_v1",
-		.TRST      = { .mask = 0x0200, .active_high = false },
-		.TRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0100, .active_high = false } },
-		.SRST      = { .mask = 0x0800, .active_high = false },
-		.SRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0400, .active_high = false } },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0f10 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "BCM9WCD1EVAL1",
-		.channel = INTERFACE_A,
-		.TRST      = { .mask = 0x0200, .active_high = false },
-		.TRST_ctrl = { .type = PUSH_PULL_ONLY },
-		.SRST      = { .mask = 0x0080, .active_high = false },
-		.SRST_ctrl = { .type = PUSH_PULL_ONLY },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0200 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "BCM9WCD1MFI_EVB",
-		.channel = INTERFACE_A,
-		.TRST      = { .mask = 0x0200, .active_high = false },
-		.TRST_ctrl = { .type = PUSH_PULL_ONLY },
-		.SRST      = { .mask = 0x0080, .active_high = false },
-		.SRST_ctrl = { .type = PUSH_PULL_ONLY },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0200 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "BCM9WCD1MFI_EVB_SWD",
-		.channel = INTERFACE_A,
-		.TRST      = { .mask = 0x0200, .active_high = false },
-		.TRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0100, .active_high = false } },
-		.SRST      = { .mask = 0x0080, .active_high = false },
-		.SRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0400, .active_high = false } },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0f00 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "oocdlink",
-		.TRST      = { .mask = 0x0200, .active_high = false },
-		.TRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0100, .active_high = false } },
-		.SRST      = { .mask = 0x0800, .active_high = false },
-		.SRST_ctrl = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0400, .active_high = false } },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0f10 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "signalyzer",
-		.init = signalyzer_init,
-		.reset = ftx23_reset,
-	},
-	{ .name = "evb_lm3s811",
-		.init = lm3s811_jtag_init,
-		.reset = ftx23_reset,
-	},
-	{ .name = "luminary_icdi",
-		.init = icdi_jtag_init,
-		.reset = ftx23_reset,
-	},
-	{ .name = "olimex-jtag",
-		.TRST       = { .mask = 0x0100, .active_high = false },
-		.TRST_ctrl  = { .type = OUTPUT_ENABLE_PIN, .oe_pin = { .mask = 0x0400, .active_high = false } },
-		.SRST       = { .mask = 0x0200, .active_high = true },
-		.SRST_ctrl  = { .type = EXTERNAL_OPEN_DRAIN },
-		.blink_pins = { .mask = 0x0800, .active_high = true },
-		.initial_output    = STANDARD_JTAG_OUTPUT,
-		.initial_direction = 0x0f10 | STANDARD_JTAG_DIRECTION,
-	},
-	{ .name = "flyswatter",
-		.init = flyswatter1_init,
-		.reset = flyswatter1_reset,
-		.blink = flyswatter1_jtag_blink
-	},
-	{ .name = "flyswatter2",
-		.init = flyswatter2_init,
-		.reset = flyswatter2_reset,
-		.blink = flyswatter2_jtag_blink
-	},
-	{ .name = "minimodule",
-		.init = minimodule_init,
-		.reset = minimodule_reset,
-	},
-	{ .name = "turtelizer2",
-		.init = turtle_init,
-		.reset = turtle_reset,
-		.blink = turtle_jtag_blink
-	},
-	{ .name = "comstick",
-		.init = comstick_init,
-		.reset = comstick_reset,
-	},
-	{ .name = "stm32stick",
-		.init = stm32stick_init,
-		.reset = stm32stick_reset,
-	},
-	{ .name = "axm0432_jtag",
-		.init = axm0432_jtag_init,
-		.reset = axm0432_jtag_reset,
-	},
-	{ .name = "sheevaplug",
-		.init = sheevaplug_init,
-		.reset = sheevaplug_reset,
-	},
-	{ .name = "icebear",
-		.init = icebear_jtag_init,
-		.reset = icebear_jtag_reset,
-	},
-	{ .name = "cortino",
-		.init = cortino_jtag_init,
-		.reset = comstick_reset,
-	},
-	{ .name = "signalyzer-h",
-		.init = signalyzer_h_init,
-		.reset = signalyzer_h_reset,
-		.blink = signalyzer_h_blink
-	},
-	{ .name = "ktlink",
-		.init = ktlink_init,
-		.reset = ktlink_reset,
-		.blink = ktlink_blink
-	},
-	{ .name = "redbee-econotag",
-		.init = redbee_init,
-		.reset = redbee_reset,
-	},
-	{ .name = "redbee-usb",
-		.init = redbee_init,
-		.reset = redbee_reset,
-		.channel = INTERFACE_B,
-	},
-	{ .name = "lisa-l",
-		.init = lisa_l_init,
-		.reset = ftx23_reset,
-		.blink = lisa_l_blink,
-		.channel = INTERFACE_B,
-	},
-	{ .name = "flossjtag",
-		.init = flossjtag_init,
-		.reset = ftx23_reset,
-		.blink = flossjtag_blink,
-	},
-	{ .name = "xds100v2",
-		.init = xds100v2_init,
-		.reset = xds100v2_reset,
-	},
-	{ .name = "digilent-hs1",
-		.init = digilent_hs1_init,
-		.reset = digilent_hs1_reset,
-		.channel = INTERFACE_A,
-	},
-	{ .name = NULL, /* END OF TABLE */ },
-};
-
-/* bitmask used to drive nTRST; usually a GPIOLx signal */
-static uint8_t nTRST;
-static uint8_t nTRSTnOE;
-/* bitmask used to drive nSRST; usually a GPIOLx signal */
-static uint8_t nSRST;
-static uint8_t nSRSTnOE;
-
-/** the layout being used with this debug session */
-static const struct ft2232_layout *layout;
-
-/** default bitmask values driven on DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
-static uint8_t low_output;
-
-/* note that direction bit == 1 means that signal is an output */
-
-/** default direction bitmask for DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
-static uint8_t low_direction;
-/** default value bitmask for CBUS GPIOH(0..4) */
-static uint8_t high_output;
-/** default direction bitmask for CBUS GPIOH(0..4) */
-static uint8_t high_direction;
-
-static void get_curr_output_direction(uint16_t *output, uint16_t *direction);
-
-#if BUILD_FT2232_FTD2XX == 1
-static FT_HANDLE ftdih;
-static FT_DEVICE ftdi_device;
-#elif BUILD_FT2232_LIBFTDI == 1
-static struct ftdi_context ftdic;
-static enum ftdi_chip_type ftdi_device;
-#endif
-
-static struct jtag_command *first_unsent;	/* next command that has to be sent */
-static int require_send;
-
-/*	http://urjtag.wiki.sourceforge.net/Cable + FT2232 says:
-
-	"There is a significant difference between libftdi and libftd2xx. The latter
-	one allows to schedule up to 64*64 bytes of result data while libftdi fails
-	with more than 4*64. As a consequence, the FT2232 driver is forced to
-	perform around 16x more USB transactions for long command streams with TDO
-	capture when running with libftdi."
-
-	No idea how we get
-	#define FT2232_BUFFER_SIZE 131072
-	a comment would have been nice.
-*/
-
-#if BUILD_FT2232_FTD2XX == 1
-#define FT2232_BUFFER_READ_QUEUE_SIZE (64*64)
-#else
-#define FT2232_BUFFER_READ_QUEUE_SIZE (64*4)
-#endif
-
-#define FT2232_BUFFER_SIZE 131072
-
-static uint8_t *ft2232_buffer;
-static int ft2232_buffer_size;
-static int ft2232_read_pointer;
-static int ft2232_expect_read;
-
-/**
- * Function buffer_write
- * writes a byte into the byte buffer, "ft2232_buffer", which must be sent later.
- * @param val is the byte to send.
- */
-static inline void buffer_write(uint8_t val)
-{
-	assert(ft2232_buffer);
-	assert((unsigned) ft2232_buffer_size < (unsigned) FT2232_BUFFER_SIZE);
-	ft2232_buffer[ft2232_buffer_size++] = val;
-}
-
-/**
- * Function buffer_read
- * returns a byte from the byte buffer.
- */
-static inline uint8_t buffer_read(void)
-{
-	assert(ft2232_buffer);
-	assert(ft2232_read_pointer < ft2232_buffer_size);
-	return ft2232_buffer[ft2232_read_pointer++];
-}
-
-/**
- * Clocks out \a bit_count bits on the TMS line, starting with the least
- * significant bit of tms_bits and progressing to more significant bits.
- * Rigorous state transition logging is done here via tap_set_state().
- *
- * @param mpsse_cmd One of the MPSSE TMS oriented commands such as
- *	0x4b or 0x6b.  See the MPSSE spec referenced above for their
- *	functionality. The MPSSE command "Clock Data to TMS/CS Pin (no Read)"
- *	is often used for this, 0x4b.
- *
- * @param tms_bits Holds the sequence of bits to send.
- * @param tms_count Tells how many bits in the sequence.
- * @param tdi_bit A single bit to pass on to TDI before the first TCK
- *	cycle and held static for the duration of TMS clocking.
- *
- * See the MPSSE spec referenced above.
- */
-static void clock_tms(uint8_t mpsse_cmd, int tms_bits, int tms_count, bool tdi_bit)
-{
-	uint8_t tms_byte;
-	int i;
-	int tms_ndx;	/* bit index into tms_byte */
-
-	assert(tms_count > 0);
-
-	DEBUG_JTAG_IO("mpsse cmd=%02x, tms_bits = 0x%08x, bit_count=%d",
-		mpsse_cmd, tms_bits, tms_count);
-
-	for (tms_byte = tms_ndx = i = 0; i < tms_count; ++i, tms_bits >>= 1) {
-		bool bit = tms_bits & 1;
-
-		if (bit)
-			tms_byte |= (1 << tms_ndx);
-
-		/* always do state transitions in public view */
-		tap_set_state(tap_state_transition(tap_get_state(), bit));
-
-		/*	we wrote a bit to tms_byte just above, increment bit index.  if bit was zero
-		 * also increment.
-		*/
-		++tms_ndx;
-
-		if (tms_ndx == 7 || i == tms_count-1) {
-			buffer_write(mpsse_cmd);
-			buffer_write(tms_ndx - 1);
-
-			/*	Bit 7 of the byte is passed on to TDI/DO before the first TCK/SK of
-			 * TMS/CS and is held static for the duration of TMS/CS clocking.
-			*/
-			buffer_write(tms_byte | (tdi_bit << 7));
-		}
-	}
-}
-
-/**
- * Function get_tms_buffer_requirements
- * returns what clock_tms() will consume if called with
- * same \a bit_count.
- */
-static inline int get_tms_buffer_requirements(int bit_count)
-{
-	return ((bit_count + 6)/7) * 3;
-}
-
-/**
- * Function move_to_state
- * moves the TAP controller from the current state to a
- * \a goal_state through a path given by tap_get_tms_path().  State transition
- * logging is performed by delegation to clock_tms().
- *
- * @param goal_state is the destination state for the move.
- */
-static void move_to_state(tap_state_t goal_state)
-{
-	tap_state_t start_state = tap_get_state();
-
-	/*	goal_state is 1/2 of a tuple/pair of states which allow convenient
-	 * lookup of the required TMS pattern to move to this state from the start state.
-	*/
-
-	/* do the 2 lookups */
-	int tms_bits  = tap_get_tms_path(start_state, goal_state);
-	int tms_count = tap_get_tms_path_len(start_state, goal_state);
-
-	DEBUG_JTAG_IO("start=%s goal=%s", tap_state_name(start_state), tap_state_name(goal_state));
-
-	clock_tms(0x4b,  tms_bits, tms_count, 0);
-}
-
-static int ft2232_write(uint8_t *buf, int size, uint32_t *bytes_written)
-{
-#if BUILD_FT2232_FTD2XX == 1
-	FT_STATUS status;
-	DWORD dw_bytes_written = 0;
-	status = FT_Write(ftdih, buf, size, &dw_bytes_written);
-	if (status != FT_OK) {
-		*bytes_written = dw_bytes_written;
-		LOG_ERROR("FT_Write returned: %s", ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	} else
-		*bytes_written = dw_bytes_written;
-
-#elif BUILD_FT2232_LIBFTDI == 1
-	int retval = ftdi_write_data(&ftdic, buf, size);
-	if (retval < 0) {
-		*bytes_written = 0;
-		LOG_ERROR("ftdi_write_data: %s", ftdi_get_error_string(&ftdic));
-		return ERROR_JTAG_DEVICE_ERROR;
-	} else
-		*bytes_written = retval;
-
-#endif
-
-	if (*bytes_written != (uint32_t)size)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	return ERROR_OK;
-}
-
-static int ft2232_read(uint8_t *buf, uint32_t size, uint32_t *bytes_read)
-{
-#if BUILD_FT2232_FTD2XX == 1
-	DWORD dw_bytes_read;
-	FT_STATUS status;
-	int timeout = 5;
-	*bytes_read = 0;
-
-	while ((*bytes_read < size) && timeout--) {
-		status = FT_Read(ftdih, buf + *bytes_read, size -
-				*bytes_read, &dw_bytes_read);
-		if (status != FT_OK) {
-			*bytes_read = 0;
-			LOG_ERROR("FT_Read returned: %s", ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-		*bytes_read += dw_bytes_read;
-	}
-
-#elif BUILD_FT2232_LIBFTDI == 1
-	int retval;
-	int timeout = LIBFTDI_READ_RETRY_COUNT;
-	*bytes_read = 0;
-
-	while ((*bytes_read < size) && timeout--) {
-		retval = ftdi_read_data(&ftdic, buf + *bytes_read, size - *bytes_read);
-		if (retval < 0) {
-			*bytes_read = 0;
-			LOG_ERROR("ftdi_read_data: %s", ftdi_get_error_string(&ftdic));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-		*bytes_read += retval;
-	}
-
-#endif
-
-	if (*bytes_read < size) {
-		LOG_ERROR("couldn't read enough bytes from "
-			"FT2232 device (%i < %i)",
-			(unsigned)*bytes_read,
-			(unsigned)size);
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-static bool ft2232_device_is_highspeed(void)
-{
-#if BUILD_FT2232_FTD2XX == 1
-	return (ftdi_device == FT_DEVICE_2232H) || (ftdi_device == FT_DEVICE_4232H)
- #ifdef HAS_ENUM_FT232H
-		|| (ftdi_device == FT_DEVICE_232H)
- #endif
-	;
-#elif BUILD_FT2232_LIBFTDI == 1
-	return (ftdi_device == TYPE_2232H || ftdi_device == TYPE_4232H
- #ifdef HAS_ENUM_FT232H
-		|| ftdi_device == TYPE_232H
- #endif
-	);
-#endif
-}
-
-/*
- * Commands that only apply to the highspeed FTx232H devices (FT2232H, FT4232H, FT232H).
- * See chapter 6 in http://www.ftdichip.com/Documents/AppNotes/
- * AN_108_Command_Processor_for_MPSSE_and_MCU_Host_Bus_Emulation_Modes.pdf
- */
-
-static int ftx232h_adaptive_clocking(bool enable)
-{
-	uint8_t buf = enable ? 0x96 : 0x97;
-	LOG_DEBUG("%2.2x", buf);
-
-	uint32_t bytes_written;
-	int retval;
-
-	retval = ft2232_write(&buf, sizeof(buf), &bytes_written);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("couldn't write command to %s adaptive clocking"
-			, enable ? "enable" : "disable");
-		return retval;
-	}
-
-	return ERROR_OK;
-}
-
-/**
- * Enable/disable the clk divide by 5 of the 60MHz master clock.
- * This result in a JTAG clock speed range of 91.553Hz-6MHz
- * respective 457.763Hz-30MHz.
- */
-static int ftx232h_clk_divide_by_5(bool enable)
-{
-	uint32_t bytes_written;
-	uint8_t buf = enable ?  0x8b : 0x8a;
-
-	if (ft2232_write(&buf, sizeof(buf), &bytes_written) != ERROR_OK) {
-		LOG_ERROR("couldn't write command to %s clk divide by 5"
-			, enable ? "enable" : "disable");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-	ft2232_max_tck = enable ? FTDI_2232C_MAX_TCK : FTDI_x232H_MAX_TCK;
-	LOG_INFO("max TCK change to: %u kHz", ft2232_max_tck);
-
-	return ERROR_OK;
-}
-
-static int ft2232_speed(int speed)
-{
-	uint8_t buf[3];
-	int retval;
-	uint32_t bytes_written;
-
-	retval = ERROR_OK;
-	bool enable_adaptive_clocking = (RTCK_SPEED == speed);
-	if (ft2232_device_is_highspeed())
-		retval = ftx232h_adaptive_clocking(enable_adaptive_clocking);
-	else if (enable_adaptive_clocking) {
-		LOG_ERROR("ft2232 device %lu does not support RTCK"
-			, (long unsigned int)ftdi_device);
-		return ERROR_FAIL;
-	}
-
-	if ((enable_adaptive_clocking) || (ERROR_OK != retval))
-		return retval;
-
-	buf[0] = 0x86;					/* command "set divisor" */
-	buf[1] = speed & 0xff;			/* valueL (0 = 6MHz, 1 = 3MHz, 2 = 2.0MHz, ...*/
-	buf[2] = (speed >> 8) & 0xff;	/* valueH */
-
-	retval = ft2232_write(buf, sizeof(buf), &bytes_written);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("couldn't set FT2232 TCK speed");
-		return retval;
-	}
-
-	return ERROR_OK;
-}
-
-static int ft2232_speed_div(int speed, int *khz)
-{
-	/* Take a look in the FT2232 manual,
-	 * AN2232C-01 Command Processor for
-	 * MPSSE and MCU Host Bus. Chapter 3.8 */
-
-	*khz = (RTCK_SPEED == speed) ? 0 : ft2232_max_tck / (1 + speed);
-
-	return ERROR_OK;
-}
-
-static int ft2232_khz(int khz, int *jtag_speed)
-{
-	if (khz == 0) {
-		if (ft2232_device_is_highspeed()) {
-			*jtag_speed = RTCK_SPEED;
-			return ERROR_OK;
-		} else {
-			LOG_DEBUG("RCLK not supported");
-			return ERROR_FAIL;
-		}
-	}
-
-	/* Take a look in the FT2232 manual,
-	 * AN2232C-01 Command Processor for
-	 * MPSSE and MCU Host Bus. Chapter 3.8
-	 *
-	 * We will calc here with a multiplier
-	 * of 10 for better rounding later. */
-
-	/* Calc speed, (ft2232_max_tck / khz) - 1
-	 * Use 65000 for better rounding */
-	*jtag_speed = ((ft2232_max_tck*10) / khz) - 10;
-
-	/* Add 0.9 for rounding */
-	*jtag_speed += 9;
-
-	/* Calc real speed */
-	*jtag_speed = *jtag_speed / 10;
-
-	/* Check if speed is greater than 0 */
-	if (*jtag_speed < 0)
-		*jtag_speed = 0;
-
-	/* Check max value */
-	if (*jtag_speed > 0xFFFF)
-		*jtag_speed = 0xFFFF;
-
-	return ERROR_OK;
-}
-
-static void ft2232_end_state(tap_state_t state)
-{
-	if (tap_is_state_stable(state))
-		tap_set_end_state(state);
-	else {
-		LOG_ERROR("BUG: %s is not a stable end state", tap_state_name(state));
-		exit(-1);
-	}
-}
-
-static void ft2232_read_scan(enum scan_type type, uint8_t *buffer, int scan_size)
-{
-	int num_bytes = (scan_size + 7) / 8;
-	int bits_left = scan_size;
-	int cur_byte  = 0;
-
-	while (num_bytes-- > 1) {
-		buffer[cur_byte++] = buffer_read();
-		bits_left -= 8;
-	}
-
-	buffer[cur_byte] = 0x0;
-
-	/* There is one more partial byte left from the clock data in/out instructions */
-	if (bits_left > 1)
-		buffer[cur_byte] = buffer_read() >> 1;
-	/* This shift depends on the length of the
-	 *clock data to tms instruction, insterted
-	 *at end of the scan, now fixed to a two
-	 *step transition in ft2232_add_scan */
-	buffer[cur_byte] = (buffer[cur_byte] | (((buffer_read()) << 1) & 0x80)) >> (8 - bits_left);
-}
-
-static void ft2232_debug_dump_buffer(void)
-{
-	int i;
-	char line[256];
-	char *line_p = line;
-
-	for (i = 0; i < ft2232_buffer_size; i++) {
-		line_p += snprintf(line_p,
-				sizeof(line) - (line_p - line),
-				"%2.2x ",
-				ft2232_buffer[i]);
-		if (i % 16 == 15) {
-			LOG_DEBUG("%s", line);
-			line_p = line;
-		}
-	}
-
-	if (line_p != line)
-		LOG_DEBUG("%s", line);
-}
-
-static int ft2232_send_and_recv(struct jtag_command *first, struct jtag_command *last)
-{
-	struct jtag_command *cmd;
-	uint8_t *buffer;
-	int scan_size;
-	enum scan_type type;
-	int retval;
-	uint32_t bytes_written = 0;
-	uint32_t bytes_read = 0;
-
-#ifdef _DEBUG_USB_IO_
-	struct timeval start, inter, inter2, end;
-	struct timeval d_inter, d_inter2, d_end;
-#endif
-
-#ifdef _DEBUG_USB_COMMS_
-	LOG_DEBUG("write buffer (size %i):", ft2232_buffer_size);
-	ft2232_debug_dump_buffer();
-#endif
-
-#ifdef _DEBUG_USB_IO_
-	gettimeofday(&start, NULL);
-#endif
-
-	retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &bytes_written);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("couldn't write MPSSE commands to FT2232");
-		return retval;
-	}
-
-#ifdef _DEBUG_USB_IO_
-	gettimeofday(&inter, NULL);
-#endif
-
-	if (ft2232_expect_read) {
-		/* FIXME this "timeout" is never changed ... */
-		int timeout = LIBFTDI_READ_RETRY_COUNT;
-		ft2232_buffer_size = 0;
-
-#ifdef _DEBUG_USB_IO_
-		gettimeofday(&inter2, NULL);
-#endif
-
-		retval = ft2232_read(ft2232_buffer, ft2232_expect_read, &bytes_read);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("couldn't read from FT2232");
-			return retval;
-		}
-
-#ifdef _DEBUG_USB_IO_
-		gettimeofday(&end, NULL);
-
-		timeval_subtract(&d_inter, &inter, &start);
-		timeval_subtract(&d_inter2, &inter2, &start);
-		timeval_subtract(&d_end, &end, &start);
-
-		LOG_INFO("inter: %u.%06u, inter2: %u.%06u end: %u.%06u",
-			(unsigned)d_inter.tv_sec, (unsigned)d_inter.tv_usec,
-			(unsigned)d_inter2.tv_sec, (unsigned)d_inter2.tv_usec,
-			(unsigned)d_end.tv_sec, (unsigned)d_end.tv_usec);
-#endif
-
-		ft2232_buffer_size = bytes_read;
-
-		if (ft2232_expect_read != ft2232_buffer_size) {
-			LOG_ERROR("ft2232_expect_read (%i) != "
-				"ft2232_buffer_size (%i) "
-				"(%i retries)",
-				ft2232_expect_read,
-				ft2232_buffer_size,
-				LIBFTDI_READ_RETRY_COUNT - timeout);
-			ft2232_debug_dump_buffer();
-
-			exit(-1);
-		}
-
-#ifdef _DEBUG_USB_COMMS_
-		LOG_DEBUG("read buffer (%i retries): %i bytes",
-			LIBFTDI_READ_RETRY_COUNT - timeout,
-			ft2232_buffer_size);
-		ft2232_debug_dump_buffer();
-#endif
-	}
-
-	ft2232_expect_read  = 0;
-	ft2232_read_pointer = 0;
-
-	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
-	 * that wasn't handled by a caller-provided error handler
-	 */
-	retval = ERROR_OK;
-
-	cmd = first;
-	while (cmd != last) {
-		switch (cmd->type) {
-			case JTAG_SCAN:
-				type = jtag_scan_type(cmd->cmd.scan);
-				if (type != SCAN_OUT) {
-					scan_size = jtag_scan_size(cmd->cmd.scan);
-					buffer = calloc(DIV_ROUND_UP(scan_size, 8), 1);
-					ft2232_read_scan(type, buffer, scan_size);
-					if (jtag_read_buffer(buffer, cmd->cmd.scan) != ERROR_OK)
-						retval = ERROR_JTAG_QUEUE_FAILED;
-					free(buffer);
-				}
-				break;
-
-			default:
-				break;
-		}
-
-		cmd = cmd->next;
-	}
-
-	ft2232_buffer_size = 0;
-
-	return retval;
-}
-
-/**
- * Function ft2232_add_pathmove
- * moves the TAP controller from the current state to a new state through the
- * given path, where path is an array of tap_state_t's.
- *
- * @param path is an array of tap_stat_t which gives the states to traverse through
- *   ending with the last state at path[num_states-1]
- * @param num_states is the count of state steps to move through
- */
-static void ft2232_add_pathmove(tap_state_t *path, int num_states)
-{
-	int state_count = 0;
-
-	assert((unsigned) num_states <= 32u);		/* tms_bits only holds 32 bits */
-
-	DEBUG_JTAG_IO("-");
-
-	/* this loop verifies that the path is legal and logs each state in the path */
-	while (num_states) {
-		unsigned char tms_byte = 0;		/* zero this on each MPSSE batch */
-		int bit_count = 0;
-		int num_states_batch = num_states > 7 ? 7 : num_states;
-
-		/* command "Clock Data to TMS/CS Pin (no Read)" */
-		buffer_write(0x4b);
-
-		/* number of states remaining */
-		buffer_write(num_states_batch - 1);
-
-		while (num_states_batch--) {
-			/* either TMS=0 or TMS=1 must work ... */
-			if (tap_state_transition(tap_get_state(), false) == path[state_count])
-				buf_set_u32(&tms_byte, bit_count++, 1, 0x0);
-			else if (tap_state_transition(tap_get_state(), true) == path[state_count])
-				buf_set_u32(&tms_byte, bit_count++, 1, 0x1);
-
-			/* ... or else the caller goofed BADLY */
-			else {
-				LOG_ERROR("BUG: %s -> %s isn't a valid "
-					"TAP state transition",
-					tap_state_name(tap_get_state()),
-					tap_state_name(path[state_count]));
-				exit(-1);
-			}
-
-			tap_set_state(path[state_count]);
-			state_count++;
-			num_states--;
-		}
-
-		buffer_write(tms_byte);
-	}
-	tap_set_end_state(tap_get_state());
-}
-
-static void ft2232_add_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size)
-{
-	int num_bytes = (scan_size + 7) / 8;
-	int bits_left = scan_size;
-	int cur_byte  = 0;
-	int last_bit;
-
-	if (!ir_scan) {
-		if (tap_get_state() != TAP_DRSHIFT)
-			move_to_state(TAP_DRSHIFT);
-	} else {
-		if (tap_get_state() != TAP_IRSHIFT)
-			move_to_state(TAP_IRSHIFT);
-	}
-
-	/* add command for complete bytes */
-	while (num_bytes > 1) {
-		int thisrun_bytes;
-		if (type == SCAN_IO) {
-			/* Clock Data Bytes In and Out LSB First */
-			buffer_write(0x39);
-			/* LOG_DEBUG("added TDI bytes (io %i)", num_bytes); */
-		} else if (type == SCAN_OUT) {
-			/* Clock Data Bytes Out on -ve Clock Edge LSB First (no Read) */
-			buffer_write(0x19);
-			/* LOG_DEBUG("added TDI bytes (o)"); */
-		} else if (type == SCAN_IN) {
-			/* Clock Data Bytes In on +ve Clock Edge LSB First (no Write) */
-			buffer_write(0x28);
-			/* LOG_DEBUG("added TDI bytes (i %i)", num_bytes); */
-		}
-
-		thisrun_bytes = (num_bytes > 65537) ? 65536 : (num_bytes - 1);
-		num_bytes -= thisrun_bytes;
-
-		buffer_write((uint8_t) (thisrun_bytes - 1));
-		buffer_write((uint8_t) ((thisrun_bytes - 1) >> 8));
-
-		if (type != SCAN_IN) {
-			/* add complete bytes */
-			while (thisrun_bytes-- > 0) {
-				buffer_write(buffer[cur_byte++]);
-				bits_left -= 8;
-			}
-		} else /* (type == SCAN_IN) */
-			bits_left -= 8 * (thisrun_bytes);
-	}
-
-	/* the most signifcant bit is scanned during TAP movement */
-	if (type != SCAN_IN)
-		last_bit = (buffer[cur_byte] >> (bits_left - 1)) & 0x1;
-	else
-		last_bit = 0;
-
-	/* process remaining bits but the last one */
-	if (bits_left > 1) {
-		if (type == SCAN_IO) {
-			/* Clock Data Bits In and Out LSB First */
-			buffer_write(0x3b);
-			/* LOG_DEBUG("added TDI bits (io) %i", bits_left - 1); */
-		} else if (type == SCAN_OUT) {
-			/* Clock Data Bits Out on -ve Clock Edge LSB First (no Read) */
-			buffer_write(0x1b);
-			/* LOG_DEBUG("added TDI bits (o)"); */
-		} else if (type == SCAN_IN) {
-			/* Clock Data Bits In on +ve Clock Edge LSB First (no Write) */
-			buffer_write(0x2a);
-			/* LOG_DEBUG("added TDI bits (i %i)", bits_left - 1); */
-		}
-
-		buffer_write(bits_left - 2);
-		if (type != SCAN_IN)
-			buffer_write(buffer[cur_byte]);
-	}
-
-	if ((ir_scan && (tap_get_end_state() == TAP_IRSHIFT))
-			|| (!ir_scan && (tap_get_end_state() == TAP_DRSHIFT))) {
-		if (type == SCAN_IO) {
-			/* Clock Data Bits In and Out LSB First */
-			buffer_write(0x3b);
-			/* LOG_DEBUG("added TDI bits (io) %i", bits_left - 1); */
-		} else if (type == SCAN_OUT) {
-			/* Clock Data Bits Out on -ve Clock Edge LSB First (no Read) */
-			buffer_write(0x1b);
-			/* LOG_DEBUG("added TDI bits (o)"); */
-		} else if (type == SCAN_IN) {
-			/* Clock Data Bits In on +ve Clock Edge LSB First (no Write) */
-			buffer_write(0x2a);
-			/* LOG_DEBUG("added TDI bits (i %i)", bits_left - 1); */
-		}
-		buffer_write(0x0);
-		if (type != SCAN_IN)
-			buffer_write(last_bit);
-	} else {
-		int tms_bits;
-		int tms_count;
-		uint8_t mpsse_cmd;
-
-		/* move from Shift-IR/DR to end state */
-		if (type != SCAN_OUT) {
-			/* We always go to the PAUSE state in two step at the end of an IN or IO
-			 *scan
-			 * This must be coordinated with the bit shifts in ft2232_read_scan    */
-			tms_bits  = 0x01;
-			tms_count = 2;
-			/* Clock Data to TMS/CS Pin with Read */
-			mpsse_cmd = 0x6b;
-		} else {
-			tms_bits  = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-			tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
-			/* Clock Data to TMS/CS Pin (no Read) */
-			mpsse_cmd = 0x4b;
-		}
-
-		DEBUG_JTAG_IO("finish %s", (type == SCAN_OUT) ? "without read" : "via PAUSE");
-		clock_tms(mpsse_cmd, tms_bits, tms_count, last_bit);
-	}
-
-	if (tap_get_state() != tap_get_end_state())
-		move_to_state(tap_get_end_state());
-}
-
-static int ft2232_large_scan(struct scan_command *cmd,
-	enum scan_type type,
-	uint8_t *buffer,
-	int scan_size)
-{
-	int num_bytes = (scan_size + 7) / 8;
-	int bits_left = scan_size;
-	int cur_byte  = 0;
-	int last_bit;
-	uint8_t *receive_buffer  = malloc(DIV_ROUND_UP(scan_size, 8));
-	uint8_t *receive_pointer = receive_buffer;
-	uint32_t bytes_written;
-	uint32_t bytes_read;
-	int retval;
-	int thisrun_read = 0;
-
-	if (!receive_buffer) {
-		LOG_ERROR("failed to allocate memory");
-		exit(-1);
-	}
-
-	if (cmd->ir_scan) {
-		LOG_ERROR("BUG: large IR scans are not supported");
-		exit(-1);
-	}
-
-	if (tap_get_state() != TAP_DRSHIFT)
-		move_to_state(TAP_DRSHIFT);
-
-	retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &bytes_written);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("couldn't write MPSSE commands to FT2232");
-		exit(-1);
-	}
-	LOG_DEBUG("ft2232_buffer_size: %i, bytes_written: %i",
-		ft2232_buffer_size, (int)bytes_written);
-	ft2232_buffer_size = 0;
-
-	/* add command for complete bytes */
-	while (num_bytes > 1) {
-		int thisrun_bytes;
-
-		if (type == SCAN_IO) {
-			/* Clock Data Bytes In and Out LSB First */
-			buffer_write(0x39);
-			/* LOG_DEBUG("added TDI bytes (io %i)", num_bytes); */
-		} else if (type == SCAN_OUT) {
-			/* Clock Data Bytes Out on -ve Clock Edge LSB First (no Read) */
-			buffer_write(0x19);
-			/* LOG_DEBUG("added TDI bytes (o)"); */
-		} else if (type == SCAN_IN) {
-			/* Clock Data Bytes In on +ve Clock Edge LSB First (no Write) */
-			buffer_write(0x28);
-			/* LOG_DEBUG("added TDI bytes (i %i)", num_bytes); */
-		}
-
-		thisrun_bytes = (num_bytes > 65537) ? 65536 : (num_bytes - 1);
-		thisrun_read  = thisrun_bytes;
-		num_bytes    -= thisrun_bytes;
-		buffer_write((uint8_t) (thisrun_bytes - 1));
-		buffer_write((uint8_t) ((thisrun_bytes - 1) >> 8));
-
-		if (type != SCAN_IN) {
-			/* add complete bytes */
-			while (thisrun_bytes-- > 0) {
-				buffer_write(buffer[cur_byte]);
-				cur_byte++;
-				bits_left -= 8;
-			}
-		} else /* (type == SCAN_IN) */
-			bits_left -= 8 * (thisrun_bytes);
-
-		retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &bytes_written);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("couldn't write MPSSE commands to FT2232");
-			exit(-1);
-		}
-		LOG_DEBUG("ft2232_buffer_size: %i, bytes_written: %i",
-			ft2232_buffer_size,
-			(int)bytes_written);
-		ft2232_buffer_size = 0;
-
-		if (type != SCAN_OUT) {
-			retval = ft2232_read(receive_pointer, thisrun_read, &bytes_read);
-			if (retval != ERROR_OK) {
-				LOG_ERROR("couldn't read from FT2232");
-				exit(-1);
-			}
-			LOG_DEBUG("thisrun_read: %i, bytes_read: %i",
-				thisrun_read,
-				(int)bytes_read);
-			receive_pointer += bytes_read;
-		}
-	}
-
-	thisrun_read = 0;
-
-	/* the most signifcant bit is scanned during TAP movement */
-	if (type != SCAN_IN)
-		last_bit = (buffer[cur_byte] >> (bits_left - 1)) & 0x1;
-	else
-		last_bit = 0;
-
-	/* process remaining bits but the last one */
-	if (bits_left > 1) {
-		if (type == SCAN_IO) {
-			/* Clock Data Bits In and Out LSB First */
-			buffer_write(0x3b);
-			/* LOG_DEBUG("added TDI bits (io) %i", bits_left - 1); */
-		} else if (type == SCAN_OUT) {
-			/* Clock Data Bits Out on -ve Clock Edge LSB First (no Read) */
-			buffer_write(0x1b);
-			/* LOG_DEBUG("added TDI bits (o)"); */
-		} else if (type == SCAN_IN) {
-			/* Clock Data Bits In on +ve Clock Edge LSB First (no Write) */
-			buffer_write(0x2a);
-			/* LOG_DEBUG("added TDI bits (i %i)", bits_left - 1); */
-		}
-		buffer_write(bits_left - 2);
-		if (type != SCAN_IN)
-			buffer_write(buffer[cur_byte]);
-
-		if (type != SCAN_OUT)
-			thisrun_read += 2;
-	}
-
-	if (tap_get_end_state() == TAP_DRSHIFT) {
-		if (type == SCAN_IO) {
-			/* Clock Data Bits In and Out LSB First */
-			buffer_write(0x3b);
-			/* LOG_DEBUG("added TDI bits (io) %i", bits_left - 1); */
-		} else if (type == SCAN_OUT) {
-			/* Clock Data Bits Out on -ve Clock Edge LSB First (no Read) */
-			buffer_write(0x1b);
-			/* LOG_DEBUG("added TDI bits (o)"); */
-		} else if (type == SCAN_IN) {
-			/* Clock Data Bits In on +ve Clock Edge LSB First (no Write) */
-			buffer_write(0x2a);
-			/* LOG_DEBUG("added TDI bits (i %i)", bits_left - 1); */
-		}
-		buffer_write(0x0);
-		buffer_write(last_bit);
-	} else {
-		int tms_bits  = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-		int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
-		uint8_t mpsse_cmd;
-
-		/* move from Shift-IR/DR to end state */
-		if (type != SCAN_OUT) {
-			/* Clock Data to TMS/CS Pin with Read */
-			mpsse_cmd = 0x6b;
-			/* LOG_DEBUG("added TMS scan (read)"); */
-		} else {
-			/* Clock Data to TMS/CS Pin (no Read) */
-			mpsse_cmd = 0x4b;
-			/* LOG_DEBUG("added TMS scan (no read)"); */
-		}
-
-		DEBUG_JTAG_IO("finish, %s", (type == SCAN_OUT) ? "no read" : "read");
-		clock_tms(mpsse_cmd, tms_bits, tms_count, last_bit);
-	}
-
-	if (type != SCAN_OUT)
-		thisrun_read += 1;
-
-	retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &bytes_written);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("couldn't write MPSSE commands to FT2232");
-		exit(-1);
-	}
-	LOG_DEBUG("ft2232_buffer_size: %i, bytes_written: %i",
-		ft2232_buffer_size,
-		(int)bytes_written);
-	ft2232_buffer_size = 0;
-
-	if (type != SCAN_OUT) {
-		retval = ft2232_read(receive_pointer, thisrun_read, &bytes_read);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("couldn't read from FT2232");
-			exit(-1);
-		}
-		LOG_DEBUG("thisrun_read: %i, bytes_read: %i",
-			thisrun_read,
-			(int)bytes_read);
-	}
-
-	free(receive_buffer);
-
-	return ERROR_OK;
-}
-
-static int ft2232_predict_scan_out(int scan_size, enum scan_type type)
-{
-	int predicted_size = 3;
-	int num_bytes = (scan_size - 1) / 8;
-
-	if (tap_get_state() != TAP_DRSHIFT)
-		predicted_size += get_tms_buffer_requirements(
-				tap_get_tms_path_len(tap_get_state(), TAP_DRSHIFT));
-
-	if (type == SCAN_IN) {	/* only from device to host */
-		/* complete bytes */
-		predicted_size += DIV_ROUND_UP(num_bytes, 65536) * 3;
-
-		/* remaining bits - 1 (up to 7) */
-		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
-	} else {/* host to device, or bidirectional
-		 * complete bytes */
-		predicted_size += num_bytes + DIV_ROUND_UP(num_bytes, 65536) * 3;
-
-		/* remaining bits -1 (up to 7) */
-		predicted_size += ((scan_size - 1) % 8) ? 3 : 0;
-	}
-
-	return predicted_size;
-}
-
-static int ft2232_predict_scan_in(int scan_size, enum scan_type type)
-{
-	int predicted_size = 0;
-
-	if (type != SCAN_OUT) {
-		/* complete bytes */
-		predicted_size +=
-			(DIV_ROUND_UP(scan_size, 8) > 1) ? (DIV_ROUND_UP(scan_size, 8) - 1) : 0;
-
-		/* remaining bits - 1 */
-		predicted_size += ((scan_size - 1) % 8) ? 1 : 0;
-
-		/* last bit (from TMS scan) */
-		predicted_size += 1;
-	}
-
-	/* LOG_DEBUG("scan_size: %i, predicted_size: %i", scan_size, predicted_size); */
-
-	return predicted_size;
-}
-
-/* semi-generic FT2232/FT4232 reset code */
-static void ftx23_reset(int trst, int srst)
-{
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	if (trst == 1) {
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-			low_direction |= nTRSTnOE;	/* switch to output pin (output is low) */
-		else
-			low_output &= ~nTRST;		/* switch output low */
-	} else if (trst == 0) {
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-			low_direction &= ~nTRSTnOE;	/* switch to input pin (high-Z + internal
-							 *and external pullup) */
-		else
-			low_output |= nTRST;		/* switch output high */
-	}
-
-	if (srst == 1) {
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-			low_output &= ~nSRST;		/* switch output low */
-		else
-			low_direction |= nSRSTnOE;	/* switch to output pin (output is low) */
-	} else if (srst == 0) {
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-			low_output |= nSRST;		/* switch output high */
-		else
-			low_direction &= ~nSRSTnOE;	/* switch to input pin (high-Z) */
-	}
-
-	/* command "set data bits low byte" */
-	buffer_write(0x80);
-	buffer_write(low_output);
-	buffer_write(low_direction);
-}
-
-static void axm0432_jtag_reset(int trst, int srst)
-{
-	if (trst == 1) {
-		tap_set_state(TAP_RESET);
-		high_output &= ~nTRST;
-	} else if (trst == 0)
-		high_output |= nTRST;
-
-	if (srst == 1)
-		high_output &= ~nSRST;
-	else if (srst == 0)
-		high_output |= nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x",
-		trst,
-		srst,
-		high_output,
-		high_direction);
-}
-
-static void flyswatter_reset(int trst, int srst)
-{
-	if (trst == 1)
-		low_output &= ~nTRST;
-	else if (trst == 0)
-		low_output |= nTRST;
-
-	if (srst == 1)
-		low_output |= nSRST;
-	else if (srst == 0)
-		low_output &= ~nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x80);
-	buffer_write(low_output);
-	buffer_write(low_direction);
-	LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x",
-		trst,
-		srst,
-		low_output,
-		low_direction);
-}
-
-static void flyswatter1_reset(int trst, int srst)
-{
-	flyswatter_reset(trst, srst);
-}
-
-static void flyswatter2_reset(int trst, int srst)
-{
-	flyswatter_reset(trst, !srst);
-}
-
-static void minimodule_reset(int trst, int srst)
-{
-	if (srst == 1)
-		low_output &= ~nSRST;
-	else if (srst == 0)
-		low_output |= nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x80);
-	buffer_write(low_output);
-	buffer_write(low_direction);
-	LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x",
-		trst,
-		srst,
-		low_output,
-		low_direction);
-}
-
-static void turtle_reset(int trst, int srst)
-{
-	if (trst == 1)
-		LOG_ERROR("Can't assert TRST: the adapter lacks this signal");
-
-	if (srst == 1)
-		low_output |= nSRST;
-	else if (srst == 0)
-		low_output &= ~nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x80);
-	buffer_write(low_output);
-	buffer_write(low_direction);
-	LOG_DEBUG("srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x",
-		srst,
-		low_output,
-		low_direction);
-}
-
-static void comstick_reset(int trst, int srst)
-{
-	if (trst == 1)
-		high_output &= ~nTRST;
-	else if (trst == 0)
-		high_output |= nTRST;
-
-	if (srst == 1)
-		high_output &= ~nSRST;
-	else if (srst == 0)
-		high_output |= nSRST;
-
-	/* command "set data bits high byte" */
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x",
-		trst,
-		srst,
-		high_output,
-		high_direction);
-}
-
-static void stm32stick_reset(int trst, int srst)
-{
-	if (trst == 1)
-		high_output &= ~nTRST;
-	else if (trst == 0)
-		high_output |= nTRST;
-
-	if (srst == 1)
-		low_output &= ~nSRST;
-	else if (srst == 0)
-		low_output |= nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x80);
-	buffer_write(low_output);
-	buffer_write(low_direction);
-
-	/* command "set data bits high byte" */
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x",
-		trst,
-		srst,
-		high_output,
-		high_direction);
-}
-
-static void sheevaplug_reset(int trst, int srst)
-{
-	if (trst == 1)
-		high_output &= ~nTRST;
-	else if (trst == 0)
-		high_output |= nTRST;
-
-	if (srst == 1)
-		high_output &= ~nSRSTnOE;
-	else if (srst == 0)
-		high_output |= nSRSTnOE;
-
-	/* command "set data bits high byte" */
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x",
-		trst,
-		srst,
-		high_output,
-		high_direction);
-}
-
-static void redbee_reset(int trst, int srst)
-{
-	if (trst == 1) {
-		tap_set_state(TAP_RESET);
-		high_output &= ~nTRST;
-	} else if (trst == 0)
-		high_output |= nTRST;
-
-	if (srst == 1)
-		high_output &= ~nSRST;
-	else if (srst == 0)
-		high_output |= nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, "
-		"high_direction: 0x%2.2x", trst, srst, high_output,
-		high_direction);
-}
-
-static void xds100v2_reset(int trst, int srst)
-{
-	if (trst == 1) {
-		tap_set_state(TAP_RESET);
-		high_output &= ~nTRST;
-	} else if (trst == 0)
-		high_output |= nTRST;
-
-	if (srst == 1)
-		high_output |= nSRST;
-	else if (srst == 0)
-		high_output &= ~nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, "
-		"high_direction: 0x%2.2x", trst, srst, high_output,
-		high_direction);
-}
-
-static int ft2232_execute_runtest(struct jtag_command *cmd)
-{
-	int retval;
-	int i;
-	int predicted_size = 0;
-	retval = ERROR_OK;
-
-	DEBUG_JTAG_IO("runtest %i cycles, end in %s",
-		cmd->cmd.runtest->num_cycles,
-		tap_state_name(cmd->cmd.runtest->end_state));
-
-	/* only send the maximum buffer size that FT2232C can handle */
-	predicted_size = 0;
-	if (tap_get_state() != TAP_IDLE)
-		predicted_size += 3;
-	predicted_size += 3 * DIV_ROUND_UP(cmd->cmd.runtest->num_cycles, 7);
-	if (cmd->cmd.runtest->end_state != TAP_IDLE)
-		predicted_size += 3;
-	if (tap_get_end_state() != TAP_IDLE)
-		predicted_size += 3;
-	if (ft2232_buffer_size + predicted_size + 1 > FT2232_BUFFER_SIZE) {
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-		require_send = 0;
-		first_unsent = cmd;
-	}
-	if (tap_get_state() != TAP_IDLE) {
-		move_to_state(TAP_IDLE);
-		require_send = 1;
-	}
-	i = cmd->cmd.runtest->num_cycles;
-	while (i > 0) {
-		/* there are no state transitions in this code, so omit state tracking */
-
-		/* command "Clock Data to TMS/CS Pin (no Read)" */
-		buffer_write(0x4b);
-
-		/* scan 7 bits */
-		buffer_write((i > 7) ? 6 : (i - 1));
-
-		/* TMS data bits */
-		buffer_write(0x0);
-
-		i -= (i > 7) ? 7 : i;
-		/* LOG_DEBUG("added TMS scan (no read)"); */
-	}
-
-	ft2232_end_state(cmd->cmd.runtest->end_state);
-
-	if (tap_get_state() != tap_get_end_state())
-		move_to_state(tap_get_end_state());
-
-	require_send = 1;
-	DEBUG_JTAG_IO("runtest: %i, end in %s",
-		cmd->cmd.runtest->num_cycles,
-		tap_state_name(tap_get_end_state()));
-	return retval;
-}
-
-static int ft2232_execute_statemove(struct jtag_command *cmd)
-{
-	int predicted_size = 0;
-	int retval = ERROR_OK;
-
-	DEBUG_JTAG_IO("statemove end in %s",
-		tap_state_name(cmd->cmd.statemove->end_state));
-
-	/* only send the maximum buffer size that FT2232C can handle */
-	predicted_size = 3;
-	if (ft2232_buffer_size + predicted_size + 1 > FT2232_BUFFER_SIZE) {
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-		require_send = 0;
-		first_unsent = cmd;
-	}
-	ft2232_end_state(cmd->cmd.statemove->end_state);
-
-	/* For TAP_RESET, ignore the current recorded state.  It's often
-	 * wrong at server startup, and this transation is critical whenever
-	 * it's requested.
-	 */
-	if (tap_get_end_state() == TAP_RESET) {
-		clock_tms(0x4b,  0xff, 5, 0);
-		require_send = 1;
-
-		/* shortest-path move to desired end state */
-	} else if (tap_get_state() != tap_get_end_state()) {
-		move_to_state(tap_get_end_state());
-		require_send = 1;
-	}
-
-	return retval;
-}
-
-/**
- * Clock a bunch of TMS (or SWDIO) transitions, to change the JTAG
- * (or SWD) state machine.
- */
-static int ft2232_execute_tms(struct jtag_command *cmd)
-{
-	int retval = ERROR_OK;
-	unsigned num_bits = cmd->cmd.tms->num_bits;
-	const uint8_t *bits = cmd->cmd.tms->bits;
-	unsigned count;
-
-	DEBUG_JTAG_IO("TMS: %d bits", num_bits);
-
-	/* only send the maximum buffer size that FT2232C can handle */
-	count = 3 * DIV_ROUND_UP(num_bits, 4);
-	if (ft2232_buffer_size + 3*count + 1 > FT2232_BUFFER_SIZE) {
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-
-		require_send = 0;
-		first_unsent = cmd;
-	}
-
-	/* Shift out in batches of at most 6 bits; there's a report of an
-	 * FT2232 bug in this area, where shifting exactly 7 bits can make
-	 * problems with TMS signaling for the last clock cycle:
-	 *
-	 *    http://developer.intra2net.com/mailarchive/html/
-	 *		libftdi/2009/msg00292.html
-	 *
-	 * Command 0x4b is: "Clock Data to TMS/CS Pin (no Read)"
-	 *
-	 * Note that pathmoves in JTAG are not often seven bits, so that
-	 * isn't a particularly likely situation outside of "special"
-	 * signaling such as switching between JTAG and SWD modes.
-	 */
-	while (num_bits) {
-		if (num_bits <= 6) {
-			buffer_write(0x4b);
-			buffer_write(num_bits - 1);
-			buffer_write(*bits & 0x3f);
-			break;
-		}
-
-		/* Yes, this is lazy ... we COULD shift out more data
-		 * bits per operation, but doing it in nybbles is easy
-		 */
-		buffer_write(0x4b);
-		buffer_write(3);
-		buffer_write(*bits & 0xf);
-		num_bits -= 4;
-
-		count  = (num_bits > 4) ? 4 : num_bits;
-
-		buffer_write(0x4b);
-		buffer_write(count - 1);
-		buffer_write((*bits >> 4) & 0xf);
-		num_bits -= count;
-
-		bits++;
-	}
-
-	require_send = 1;
-	return retval;
-}
-
-static int ft2232_execute_pathmove(struct jtag_command *cmd)
-{
-	int predicted_size = 0;
-	int retval = ERROR_OK;
-
-	tap_state_t *path = cmd->cmd.pathmove->path;
-	int num_states    = cmd->cmd.pathmove->num_states;
-
-	DEBUG_JTAG_IO("pathmove: %i states, current: %s  end: %s", num_states,
-		tap_state_name(tap_get_state()),
-		tap_state_name(path[num_states-1]));
-
-	/* only send the maximum buffer size that FT2232C can handle */
-	predicted_size = 3 * DIV_ROUND_UP(num_states, 7);
-	if (ft2232_buffer_size + predicted_size + 1 > FT2232_BUFFER_SIZE) {
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-
-		require_send = 0;
-		first_unsent = cmd;
-	}
-
-	ft2232_add_pathmove(path, num_states);
-	require_send = 1;
-
-	return retval;
-}
-
-static int ft2232_execute_scan(struct jtag_command *cmd)
-{
-	uint8_t *buffer;
-	int scan_size;				/* size of IR or DR scan */
-	int predicted_size = 0;
-	int retval = ERROR_OK;
-
-	enum scan_type type = jtag_scan_type(cmd->cmd.scan);
-
-	DEBUG_JTAG_IO("%s type:%d", cmd->cmd.scan->ir_scan ? "IRSCAN" : "DRSCAN", type);
-
-	scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
-
-	predicted_size = ft2232_predict_scan_out(scan_size, type);
-	if ((predicted_size + 1) > FT2232_BUFFER_SIZE) {
-		LOG_DEBUG("oversized ft2232 scan (predicted_size > FT2232_BUFFER_SIZE)");
-		/* unsent commands before this */
-		if (first_unsent != cmd)
-			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-				retval = ERROR_JTAG_QUEUE_FAILED;
-
-		/* current command */
-		ft2232_end_state(cmd->cmd.scan->end_state);
-		ft2232_large_scan(cmd->cmd.scan, type, buffer, scan_size);
-		require_send = 0;
-		first_unsent = cmd->next;
-		if (buffer)
-			free(buffer);
-		return retval;
-	} else if (ft2232_buffer_size + predicted_size + 1 > FT2232_BUFFER_SIZE) {
-		LOG_DEBUG(
-			"ft2232 buffer size reached, sending queued commands (first_unsent: %p, cmd: %p)",
-			first_unsent,
-			cmd);
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-		require_send = 0;
-		first_unsent = cmd;
-	}
-	ft2232_expect_read += ft2232_predict_scan_in(scan_size, type);
-	/* LOG_DEBUG("new read size: %i", ft2232_expect_read); */
-	ft2232_end_state(cmd->cmd.scan->end_state);
-	ft2232_add_scan(cmd->cmd.scan->ir_scan, type, buffer, scan_size);
-	require_send = 1;
-	if (buffer)
-		free(buffer);
-	DEBUG_JTAG_IO("%s scan, %i bits, end in %s",
-		(cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size,
-		tap_state_name(tap_get_end_state()));
-	return retval;
-
-}
-
-static int ft2232_execute_reset(struct jtag_command *cmd)
-{
-	int retval;
-	int predicted_size = 0;
-	retval = ERROR_OK;
-
-	DEBUG_JTAG_IO("reset trst: %i srst %i",
-		cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-
-	/* only send the maximum buffer size that FT2232C can handle */
-	predicted_size = 3;
-	if (ft2232_buffer_size + predicted_size + 1 > FT2232_BUFFER_SIZE) {
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-		require_send = 0;
-		first_unsent = cmd;
-	}
-
-	if ((cmd->cmd.reset->trst == 1) ||
-	    (cmd->cmd.reset->srst && (jtag_get_reset_config() & RESET_SRST_PULLS_TRST)))
-		tap_set_state(TAP_RESET);
-
-	if (layout->reset) {
-		/* custom reset function */
-		layout->reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-	} else {
-		standard_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-	}
-	require_send = 1;
-
-	DEBUG_JTAG_IO("trst: %i, srst: %i",
-		cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-	return retval;
-}
-
-static int ft2232_execute_sleep(struct jtag_command *cmd)
-{
-	int retval;
-	retval = ERROR_OK;
-
-	DEBUG_JTAG_IO("sleep %" PRIi32, cmd->cmd.sleep->us);
-
-	if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-		retval = ERROR_JTAG_QUEUE_FAILED;
-	first_unsent = cmd->next;
-	jtag_sleep(cmd->cmd.sleep->us);
-	DEBUG_JTAG_IO("sleep %" PRIi32 " usec while in %s",
-		cmd->cmd.sleep->us,
-		tap_state_name(tap_get_state()));
-	return retval;
-}
-
-static int ft2232_execute_stableclocks(struct jtag_command *cmd)
-{
-	int retval;
-	retval = ERROR_OK;
-
-	/* this is only allowed while in a stable state.  A check for a stable
-	 * state was done in jtag_add_clocks()
-	 */
-	if (ft2232_stableclocks(cmd->cmd.stableclocks->num_cycles, cmd) != ERROR_OK)
-		retval = ERROR_JTAG_QUEUE_FAILED;
-	DEBUG_JTAG_IO("clocks %i while in %s",
-		cmd->cmd.stableclocks->num_cycles,
-		tap_state_name(tap_get_state()));
-	return retval;
-}
-
-static int ft2232_execute_command(struct jtag_command *cmd)
-{
-	int retval;
-
-	switch (cmd->type) {
-		case JTAG_RESET:
-			retval = ft2232_execute_reset(cmd);
-			break;
-		case JTAG_RUNTEST:
-			retval = ft2232_execute_runtest(cmd);
-			break;
-		case JTAG_TLR_RESET:
-			retval = ft2232_execute_statemove(cmd);
-			break;
-		case JTAG_PATHMOVE:
-			retval = ft2232_execute_pathmove(cmd);
-			break;
-		case JTAG_SCAN:
-			retval = ft2232_execute_scan(cmd);
-			break;
-		case JTAG_SLEEP:
-			retval = ft2232_execute_sleep(cmd);
-			break;
-		case JTAG_STABLECLOCKS:
-			retval = ft2232_execute_stableclocks(cmd);
-			break;
-		case JTAG_TMS:
-			retval = ft2232_execute_tms(cmd);
-			break;
-		default:
-			LOG_ERROR("BUG: unknown JTAG command type encountered");
-			retval = ERROR_JTAG_QUEUE_FAILED;
-			break;
-	}
-	return retval;
-}
-
-static int ft2232_execute_queue(void)
-{
-	struct jtag_command *cmd = jtag_command_queue;	/* currently processed command */
-	int retval;
-
-	first_unsent = cmd;		/* next command that has to be sent */
-	require_send = 0;
-
-	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed check
-	 * that wasn't handled by a caller-provided error handler
-	 */
-	retval = ERROR_OK;
-
-	ft2232_buffer_size = 0;
-	ft2232_expect_read = 0;
-
-	/* blink, if the current layout has that feature */
-	if (layout->blink)
-		layout->blink();
-	else
-		standard_blink();
-
-	while (cmd) {
-		/* fill the write buffer with the desired command */
-		if (ft2232_execute_command(cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-		/* Start reading input before FT2232 TX buffer fills up.
-		 * Sometimes this happens because we don't know the
-		 * length of the last command before we execute it. So
-		 * we simple inform the user.
-		 */
-		cmd = cmd->next;
-
-		if (ft2232_expect_read >= FT2232_BUFFER_READ_QUEUE_SIZE) {
-			if (ft2232_expect_read > (FT2232_BUFFER_READ_QUEUE_SIZE+1))
-				LOG_DEBUG("read buffer size looks too high %d/%d",
-					ft2232_expect_read,
-					(FT2232_BUFFER_READ_QUEUE_SIZE+1));
-			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-				retval = ERROR_JTAG_QUEUE_FAILED;
-			first_unsent = cmd;
-		}
-	}
-
-	if (require_send > 0)
-		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-			retval = ERROR_JTAG_QUEUE_FAILED;
-
-	return retval;
-}
-
-#if BUILD_FT2232_FTD2XX == 1
-static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int *try_more)
-{
-	FT_STATUS status;
-	DWORD deviceID;
-	char SerialNumber[16];
-	char Description[64];
-	DWORD openex_flags  = 0;
-	char *openex_string = NULL;
-	uint8_t latency_timer;
-
-	if (layout == NULL) {
-		LOG_WARNING("No ft2232 layout specified'");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	LOG_DEBUG("'ft2232' interface using FTD2XX with '%s' layout (%4.4x:%4.4x)",
-			layout->name, vid, pid);
-
-#if IS_WIN32 == 0
-	/* Add non-standard Vid/Pid to the linux driver */
-	status = FT_SetVIDPID(vid, pid);
-	if (status != FT_OK)
-		LOG_WARNING("couldn't add %4.4x:%4.4x", vid, pid);
-
-#endif
-
-	if (ft2232_device_desc && ft2232_serial) {
-		LOG_WARNING(
-			"can't open by device description and serial number, giving precedence to serial");
-		ft2232_device_desc = NULL;
-	}
-
-	if (ft2232_device_desc) {
-		openex_string = ft2232_device_desc;
-		openex_flags  = FT_OPEN_BY_DESCRIPTION;
-	} else if (ft2232_serial) {
-		openex_string = ft2232_serial;
-		openex_flags  = FT_OPEN_BY_SERIAL_NUMBER;
-	} else {
-		LOG_ERROR("neither device description nor serial number specified");
-		LOG_ERROR(
-			"please add \"ft2232_device_desc <string>\" or \"ft2232_serial <string>\" to your .cfg file");
-
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_OpenEx(openex_string, openex_flags, &ftdih);
-	if (status != FT_OK) {
-		/* under Win32, the FTD2XX driver appends an "A" to the end
-		 * of the description, if we tried by the desc, then
-		 * try by the alternate "A" description. */
-		if (openex_string == ft2232_device_desc) {
-			/* Try the alternate method. */
-			openex_string = ft2232_device_desc_A;
-			status = FT_OpenEx(openex_string, openex_flags, &ftdih);
-			if (status == FT_OK) {
-				/* yea, the "alternate" method worked! */
-			} else {
-				/* drat, give the user a meaningfull message.
-				 * telling the use we tried *BOTH* methods. */
-				LOG_WARNING("Unable to open FTDI Device tried: '%s' and '%s'",
-					ft2232_device_desc,
-					ft2232_device_desc_A);
-			}
-		}
-	}
-
-	if (status != FT_OK) {
-		DWORD num_devices;
-
-		if (more) {
-			LOG_WARNING("unable to open ftdi device (trying more): %s",
-				ftd2xx_status_string(status));
-			*try_more = 1;
-			return ERROR_JTAG_INIT_FAILED;
-		}
-		LOG_ERROR("unable to open ftdi device: %s",
-			ftd2xx_status_string(status));
-		status = FT_ListDevices(&num_devices, NULL, FT_LIST_NUMBER_ONLY);
-		if (status == FT_OK) {
-			char **desc_array = malloc(sizeof(char *) * (num_devices + 1));
-			uint32_t i;
-
-			for (i = 0; i < num_devices; i++)
-				desc_array[i] = malloc(64);
-
-			desc_array[num_devices] = NULL;
-
-			status = FT_ListDevices(desc_array, &num_devices, FT_LIST_ALL | openex_flags);
-
-			if (status == FT_OK) {
-				LOG_ERROR("ListDevices: %" PRIu32, (uint32_t)num_devices);
-				for (i = 0; i < num_devices; i++)
-					LOG_ERROR("%" PRIu32 ": \"%s\"", i, desc_array[i]);
-			}
-
-			for (i = 0; i < num_devices; i++)
-				free(desc_array[i]);
-
-			free(desc_array);
-		} else
-			LOG_ERROR("ListDevices: NONE");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_SetLatencyTimer(ftdih, ft2232_latency);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to set latency timer: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_GetLatencyTimer(ftdih, &latency_timer);
-	if (status != FT_OK) {
-		/* ftd2xx 1.04 (linux) has a bug when calling FT_GetLatencyTimer
-		 * so ignore errors if using this driver version */
-		DWORD dw_version;
-
-		status = FT_GetDriverVersion(ftdih, &dw_version);
-		LOG_ERROR("unable to get latency timer: %s",
-			ftd2xx_status_string(status));
-
-		if ((status == FT_OK) && (dw_version == 0x10004)) {
-			LOG_ERROR("ftd2xx 1.04 detected - this has known issues " \
-				"with FT_GetLatencyTimer, upgrade to a newer version");
-		} else
-			return ERROR_JTAG_INIT_FAILED;
-	} else
-		LOG_DEBUG("current latency timer: %i", latency_timer);
-
-	status = FT_SetTimeouts(ftdih, 5000, 5000);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to set timeouts: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_SetBitMode(ftdih, 0x0b, 2);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to enable bit i/o mode: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_GetDeviceInfo(ftdih, &ftdi_device, &deviceID,
-			SerialNumber, Description, NULL);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to get FT_GetDeviceInfo: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	} else {
-		static const char *type_str[] = {
-			"BM", "AM", "100AX", "UNKNOWN", "2232C", "232R", "2232H", "4232H", "232H"
-		};
-		unsigned no_of_known_types = ARRAY_SIZE(type_str) - 1;
-		unsigned type_index = ((unsigned)ftdi_device <= no_of_known_types)
-			? ftdi_device : FT_DEVICE_UNKNOWN;
-		LOG_INFO("device: %" PRIu32 " \"%s\"", (uint32_t)ftdi_device, type_str[type_index]);
-		LOG_INFO("deviceID: %" PRIu32, (uint32_t)deviceID);
-		LOG_INFO("SerialNumber: %s", SerialNumber);
-		LOG_INFO("Description: %s", Description);
-	}
-
-	return ERROR_OK;
-}
-
-static int ft2232_purge_ftd2xx(void)
-{
-	FT_STATUS status;
-
-	status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX);
-	if (status != FT_OK) {
-		LOG_ERROR("error purging ftd2xx device: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-#endif	/* BUILD_FT2232_FTD2XX == 1 */
-
-#if BUILD_FT2232_LIBFTDI == 1
-static int ft2232_init_libftdi(uint16_t vid, uint16_t pid, int more, int *try_more, int channel)
-{
-	uint8_t latency_timer;
-
-	if (layout == NULL) {
-		LOG_WARNING("No ft2232 layout specified'");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	LOG_DEBUG("'ft2232' interface using libftdi with '%s' layout (%4.4x:%4.4x)",
-		layout->name, vid, pid);
-
-	if (ftdi_init(&ftdic) < 0)
-		return ERROR_JTAG_INIT_FAILED;
-
-	/* default to INTERFACE_A */
-	if (channel == INTERFACE_ANY)
-		channel = INTERFACE_A;
-	if (ftdi_set_interface(&ftdic, channel) < 0) {
-		LOG_ERROR("unable to select FT2232 channel A: %s", ftdic.error_str);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	/* context, vendor id, product id */
-	if (ftdi_usb_open_desc(&ftdic, vid, pid, ft2232_device_desc, ft2232_serial) < 0) {
-		if (more)
-			LOG_WARNING("unable to open ftdi device (trying more): %s",
-				ftdic.error_str);
-		else
-			LOG_ERROR("unable to open ftdi device: %s", ftdic.error_str);
-		*try_more = 1;
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	/* There is already a reset in ftdi_usb_open_desc, this should be redundant */
-	if (ftdi_usb_reset(&ftdic) < 0) {
-		LOG_ERROR("unable to reset ftdi device");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	if (ftdi_set_latency_timer(&ftdic, ft2232_latency) < 0) {
-		LOG_ERROR("unable to set latency timer");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	if (ftdi_get_latency_timer(&ftdic, &latency_timer) < 0) {
-		LOG_ERROR("unable to get latency timer");
-		return ERROR_JTAG_INIT_FAILED;
-	} else
-		LOG_DEBUG("current latency timer: %i", latency_timer);
-
-	ftdi_set_bitmode(&ftdic, 0x0b, 2);	/* ctx, JTAG I/O mask */
-
-	ftdi_device = ftdic.type;
-	static const char *type_str[] = {
-		"AM", "BM", "2232C", "R", "2232H", "4232H", "232H", "Unknown"
-	};
-	unsigned no_of_known_types = ARRAY_SIZE(type_str) - 1;
-	unsigned type_index = ((unsigned)ftdi_device < no_of_known_types)
-		? ftdi_device : no_of_known_types;
-	LOG_DEBUG("FTDI chip type: %i \"%s\"", (int)ftdi_device, type_str[type_index]);
-	return ERROR_OK;
-}
-
-static int ft2232_purge_libftdi(void)
-{
-	if (ftdi_usb_purge_buffers(&ftdic) < 0) {
-		LOG_ERROR("ftdi_purge_buffers: %s", ftdic.error_str);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-#endif	/* BUILD_FT2232_LIBFTDI == 1 */
-
-static int ft2232_set_data_bits_low_byte(uint8_t value, uint8_t direction)
-{
-	uint8_t buf[3];
-	uint32_t bytes_written;
-
-	buf[0] = 0x80;		/* command "set data bits low byte" */
-	buf[1] = value;		/* value */
-	buf[2] = direction;	/* direction */
-
-	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize data bits low byte");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-	low_output = value;
-	low_direction = direction;
-	return ERROR_OK;
-}
-
-static int ft2232_set_data_bits_high_byte(uint8_t value, uint8_t direction)
-{
-	uint8_t buf[3];
-	uint32_t bytes_written;
-
-	buf[0] = 0x82;		/* command "set data bits high byte" */
-	buf[1] = value;		/* value */
-	buf[2] = direction;	/* direction */
-
-	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize data bits high byte");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-	high_output = value;
-	high_direction = direction;
-	return ERROR_OK;
-}
-
-static int ft2232_set_data_bits_both_bytes(uint16_t output, uint16_t direction)
-{
-	int retval = ft2232_set_data_bits_high_byte((output >> 8) & 0xff, (direction >> 8) & 0xff);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ft2232_set_data_bits_low_byte(output & 0xff, direction & 0xff);
-}
-
-static int ft2232_init(void)
-{
-	uint8_t buf[1];
-	int retval;
-	uint32_t bytes_written;
-
-	LOG_WARNING("Using DEPRECATED interface driver 'ft2232'");
-#if BUILD_FTDI
-	LOG_INFO("Consider using the 'ftdi' interface driver, with configuration files in interface/ftdi/...");
-#endif
-
-	if (tap_get_tms_path_len(TAP_IRPAUSE, TAP_IRPAUSE) == 7)
-		LOG_DEBUG("ft2232 interface using 7 step jtag state transitions");
-	else
-		LOG_DEBUG("ft2232 interface using shortest path jtag state transitions");
-	if (layout == NULL) {
-		LOG_WARNING("No ft2232 layout specified'");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	for (int i = 0; 1; i++) {
-		/*
-		 * "more indicates that there are more IDs to try, so we should
-		 * not print an error for an ID mismatch (but for anything
-		 * else, we should).
-		 *
-		 * try_more indicates that the error code returned indicates an
-		 * ID mismatch (and nothing else) and that we should proceeed
-		 * with the next ID pair.
-		 */
-		int more = ft2232_vid[i + 1] || ft2232_pid[i + 1];
-		int try_more = 0;
-
-#if BUILD_FT2232_FTD2XX == 1
-		retval = ft2232_init_ftd2xx(ft2232_vid[i], ft2232_pid[i],
-				more, &try_more);
-#elif BUILD_FT2232_LIBFTDI == 1
-		retval = ft2232_init_libftdi(ft2232_vid[i], ft2232_pid[i],
-				more, &try_more, ft2232_channel);
-#endif
-		if (retval >= 0)
-			break;
-		if (!more || !try_more)
-			return retval;
-	}
-
-	ft2232_buffer_size = 0;
-	ft2232_buffer = malloc(FT2232_BUFFER_SIZE);
-
-	if (layout->init) {
-		/* custom init function */
-		if (layout->init() != ERROR_OK)
-			return ERROR_JTAG_INIT_FAILED;
-	} else {
-		if (standard_init() != ERROR_OK)
-			return ERROR_JTAG_INIT_FAILED;
-	}
-
-	if (ft2232_device_is_highspeed()) {
-#ifndef BUILD_FT2232_HIGHSPEED
- #if BUILD_FT2232_FTD2XX == 1
-		LOG_WARNING(
-			"High Speed device found - You need a newer FTD2XX driver (version 2.04.16 or later)");
- #elif BUILD_FT2232_LIBFTDI == 1
-		LOG_WARNING(
-			"High Speed device found - You need a newer libftdi version (0.16 or later)");
- #endif
-#endif
-		/* make sure the legacy mode is disabled */
-		if (ftx232h_clk_divide_by_5(false) != ERROR_OK)
-			return ERROR_JTAG_INIT_FAILED;
-	}
-
-	buf[0] = 0x85;	/* Disconnect TDI/DO to TDO/DI for Loopback */
-	retval = ft2232_write(buf, 1, &bytes_written);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("couldn't write to FT2232 to disable loopback");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-#if BUILD_FT2232_FTD2XX == 1
-	return ft2232_purge_ftd2xx();
-#elif BUILD_FT2232_LIBFTDI == 1
-	return ft2232_purge_libftdi();
-#endif
-
-	return ERROR_OK;
-}
-
-static void standard_blink(void)
-{
-	uint16_t output;
-	uint16_t direction;
-	get_curr_output_direction(&output, &direction);
-
-	if (layout->blink_pins.mask != 0)
-		output ^= layout->blink_pins.mask;
-
-	/* Set FT2232 GPIO values */
-	if (ft2232_set_data_bits_both_bytes(output, direction) != ERROR_OK)
-		LOG_WARNING("couldn't blink LED on '%s' layout", layout->name);
-}
-
-static int standard_set_reset(bool rst_active,
-								bool open_drain,
-								ft2232_output_pin_t pin,
-								ft2232_control_pin_t ctrl,
-								char *name,
-								uint16_t *output,
-								uint16_t *direction)
-{
-	if (open_drain) {
-		switch (ctrl.type) {
-			case PUSH_PULL_ONLY:
-				LOG_ERROR("Layout %s does not support pin %s being open-drain", layout->name, name);
-				return ERROR_FAIL;
-			case PIN_DIRECTION:
-				/* Set pin to active state */
-				*output    = PIN_OP_ACTIVE(pin, *output);
-				if (rst_active) {
-					/* Set direction to output */
-					*direction |=  pin.mask;
-				} else {
-					/* Set to input (High-Z) */
-					*direction &=  (~pin.mask);
-				}
-				break;
-			case OUTPUT_ENABLE_PIN:
-				/* Set OE pin to requested active/inactive state */
-				*output = PIN_OP_SET(ctrl.oe_pin, *output, rst_active);
-				/* Fall through */
-			case EXTERNAL_OPEN_DRAIN:
-				/* Set pin to active state */
-				*output    = PIN_OP_SET(pin, *output, rst_active);
-				break;
-			default:
-				LOG_ERROR("Unknown %s pin type %d", name, ctrl.type);
-				return ERROR_FAIL;
-		}
-	} else {
-		/* Push pull specified */
-		switch (ctrl.type) {
-			case OUTPUT_ENABLE_PIN:
-				/* Set OE to active */
-				*output    = PIN_OP_ACTIVE(ctrl.oe_pin, *output);
-				 /* fall through */
-			case PUSH_PULL_ONLY: /* fall through */
-			case PIN_DIRECTION:
-				/* Set direction to output */
-				*direction |=  pin.mask;
-				/* Set pin to requested active/inactive state */
-				*output = PIN_OP_SET(pin, *output, rst_active);
-				break;
-			case EXTERNAL_OPEN_DRAIN:  /* Fall through */
-				LOG_ERROR("Layout %s does not support pin %s being push-pull", layout->name, name);
-				return ERROR_FAIL;
-			default:
-				LOG_ERROR("Unknown %s pin type %d", name, ctrl.type);
-				return ERROR_FAIL;
-		}
-	}
-	return ERROR_OK;
-}
-
-static int standard_set_resets(bool trst_active, bool srst_active, uint16_t *output, uint16_t *direction)
-{
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	int retval = ERROR_OK;
-	bool trst_opendrain = ((jtag_reset_config & RESET_TRST_OPEN_DRAIN) != 0);
-	bool srst_opendrain = ((jtag_reset_config & RESET_SRST_PUSH_PULL) == 0);
-
-	if (layout->TRST.mask) {
-		retval = standard_set_reset(trst_active, trst_opendrain, layout->TRST,
-								layout->TRST_ctrl, "TRST", output, direction);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	if (layout->SRST.mask)
-		retval = standard_set_reset(srst_active, srst_opendrain, layout->SRST,
-								layout->SRST_ctrl, "SRST", output, direction);
-
-	return retval;
-}
-
-static void get_curr_output_direction(uint16_t *output, uint16_t *direction)
-{
-	*output = low_output | (high_output << 8);
-	*direction = low_direction | (high_direction << 8);
-}
-
-static int standard_reset(int trst, int srst)
-{
-	int retval;
-	uint16_t output;
-	uint16_t direction;
-	get_curr_output_direction(&output, &direction);
-
-	retval = standard_set_resets(trst, srst, &output, &direction);
-	if (retval != ERROR_OK)
-			return ERROR_FAIL;
-
-	/* Initialize FT2232 GPIO values */
-	if (ft2232_set_data_bits_both_bytes(output, direction) != ERROR_OK) {
-		LOG_ERROR("Couldn't set resets for '%s' layout", layout->name);
-		return ERROR_FAIL;
-	}
-
-	LOG_DEBUG("trst: %i, srst: %i, output: 0x%04x, direction: 0x%04x",
-		trst,
-		srst,
-		output,
-		direction);
-
-	return ERROR_OK;
-}
-static int standard_init(void)
-{
-	int retval;
-	uint16_t output = layout->initial_output;
-	uint16_t direction = layout->initial_direction;
-
-	retval = standard_set_resets(false, false, &output, &direction);
-	if (retval != ERROR_OK)
-			return ERROR_JTAG_INIT_FAILED;
-
-	/* Initialize FT2232 GPIO values */
-	if (ft2232_set_data_bits_both_bytes(output, direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with '%s' layout", layout->name);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-
-}
-
-/** Updates defaults for DBUS signals:  the four JTAG signals
- * (TCK, TDI, TDO, TMS) and * the four GPIOL signals.
- */
-static inline void ftx232_dbus_init(void)
-{
-	low_output    = 0x08;
-	low_direction = 0x0b;
-}
-
-/** Initializes DBUS signals:  the four JTAG signals (TCK, TDI, TDO, TMS),
- * the four GPIOL signals.  Initialization covers value and direction,
- * as customized for each layout.
- */
-static int ftx232_dbus_write(void)
-{
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN) {
-		low_direction &= ~nTRSTnOE;	/* nTRST input */
-		low_output &= ~nTRST;	/* nTRST = 0 */
-	} else {
-		low_direction |= nTRSTnOE;	/* nTRST output */
-		low_output |= nTRST;		/* nTRST = 1 */
-	}
-
-	if (jtag_reset_config & RESET_SRST_PUSH_PULL) {
-		low_direction |= nSRSTnOE;	/* nSRST output */
-		low_output |= nSRST;		/* nSRST = 1 */
-	} else {
-		low_direction &= ~nSRSTnOE;	/* nSRST input */
-		low_output &= ~nSRST;	/* nSRST = 0 */
-	}
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 DBUS");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int usbjtag_init(void)
-{
-	/*
-	 * NOTE:  This is now _specific_ to the "usbjtag" layout.
-	 * Don't try cram any more layouts into this.
-	 */
-	ftx232_dbus_init();
-
-	nTRST    = 0x10;
-	nTRSTnOE = 0x10;
-	nSRST    = 0x40;
-	nSRSTnOE = 0x40;
-
-	return ftx232_dbus_write();
-}
-
-static int lm3s811_jtag_init(void)
-{
-	ftx232_dbus_init();
-
-	/* There are multiple revisions of LM3S811 eval boards:
-	 * - Rev B (and older?) boards have no SWO trace support.
-	 * - Rev C boards add ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN;
-	 *   they should use the "luminary_icdi" layout instead.
-	 */
-	nTRST = 0x0;
-	nTRSTnOE = 0x00;
-	nSRST = 0x20;
-	nSRSTnOE = 0x20;
-	low_output    = 0x88;
-	low_direction = 0x8b;
-
-	return ftx232_dbus_write();
-}
-
-static int icdi_jtag_init(void)
-{
-	ftx232_dbus_init();
-
-	/* Most Luminary eval boards support SWO trace output,
-	 * and should use this "luminary_icdi" layout.
-	 *
-	 * ADBUS 0..3 are used for JTAG as usual.  GPIOs are used
-	 * to switch between JTAG and SWD, or switch the ft2232 UART
-	 * on the second MPSSE channel/interface (BDBUS)
-	 * between (i) the stellaris UART (on Luminary boards)
-	 * or (ii) SWO trace data (generic).
-	 *
-	 * We come up in JTAG mode and may switch to SWD later (with
-	 * SWO/trace option if SWD is active).
-	 *
-	 * DBUS == GPIO-Lx
-	 * CBUS == GPIO-Hx
-	 */
-
-
-#define ICDI_JTAG_EN (1 << 7)		/* ADBUS 7 (a.k.a. DBGMOD) */
-#define ICDI_DBG_ENn (1 << 6)		/* ADBUS 6 */
-#define ICDI_SRST (1 << 5)		/* ADBUS 5 */
-
-
-	/* GPIOs on second channel/interface (UART) ... */
-#define ICDI_SWO_EN (1 << 4)		/* BDBUS 4 */
-#define ICDI_TX_SWO (1 << 1)		/* BDBUS 1 */
-#define ICDI_VCP_RX (1 << 0)		/* BDBUS 0 (to stellaris UART) */
-
-	nTRST = 0x0;
-	nTRSTnOE = 0x00;
-	nSRST = ICDI_SRST;
-	nSRSTnOE = ICDI_SRST;
-
-	low_direction |= ICDI_JTAG_EN | ICDI_DBG_ENn;
-	low_output    |= ICDI_JTAG_EN;
-	low_output    &= ~ICDI_DBG_ENn;
-
-	return ftx232_dbus_write();
-}
-
-static int signalyzer_init(void)
-{
-	ftx232_dbus_init();
-
-	nTRST    = 0x10;
-	nTRSTnOE = 0x10;
-	nSRST    = 0x20;
-	nSRSTnOE = 0x20;
-	return ftx232_dbus_write();
-}
-
-static int axm0432_jtag_init(void)
-{
-	low_output    = 0x08;
-	low_direction = 0x2b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'JTAGkey' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	if (strcmp(layout->name, "axm0432_jtag") == 0) {
-		nTRST    = 0x08;
-		nTRSTnOE = 0x0;		/* No output enable for TRST*/
-		nSRST    = 0x04;
-		nSRSTnOE = 0x0;		/* No output enable for SRST*/
-	} else {
-		LOG_ERROR("BUG: axm0432_jtag_init called for non axm0432 layout");
-		exit(-1);
-	}
-
-	high_output    = 0x0;
-	high_direction = 0x0c;
-
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-		LOG_ERROR("can't set nTRSTOE to push-pull on the Dicarlo jtag");
-	else
-		high_output |= nTRST;
-
-	if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-		LOG_ERROR("can't set nSRST to push-pull on the Dicarlo jtag");
-	else
-		high_output |= nSRST;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'Dicarlo' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int redbee_init(void)
-{
-	low_output    = 0x08;
-	low_direction = 0x2b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'redbee' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRST    = 0x08;
-	nTRSTnOE = 0x0;		/* No output enable for TRST*/
-	nSRST    = 0x04;
-	nSRSTnOE = 0x0;		/* No output enable for SRST*/
-
-	high_output    = 0x0;
-	high_direction = 0x0c;
-
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-		LOG_ERROR("can't set nTRSTOE to push-pull on redbee");
-	else
-		high_output |= nTRST;
-
-	if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-		LOG_ERROR("can't set nSRST to push-pull on redbee");
-	else
-		high_output |= nSRST;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'redbee' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int flyswatter_init(int rev)
-{
-	low_output    = 0x18;
-	low_direction = 0x7b;
-
-	if ((rev < 0) || (rev > 3)) {
-		LOG_ERROR("bogus 'flyswatter' revision supplied (%i)", rev);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	if (rev == 1)
-		low_direction |= 1 << 7;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'flyswatter' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRST    = 0x10;
-	nTRSTnOE = 0x0;		/* not output enable for nTRST */
-	nSRST    = 0x20;
-	nSRSTnOE = 0x00;	/* no output enable for nSRST */
-
-	high_output    = 0x00;
-
-	if (rev == 1)
-		high_direction = 0x0c;
-	else
-		high_direction = 0x01;
-
-	/* turn red LED3 on, LED2 off */
-	high_output |= 0x08;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'flyswatter' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int flyswatter1_init(void)
-{
-	return flyswatter_init(1);
-}
-
-static int flyswatter2_init(void)
-{
-	return flyswatter_init(2);
-}
-
-static int minimodule_init(void)
-{
-	low_output    = 0x18;	/* check if srst should be 1 or 0 initially. (0x08) (flyswatter was
-				 * 0x18) */
-	low_direction = 0xfb;	/* 0xfb; */
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'minimodule' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-
-	nSRST    = 0x20;
-
-	high_output    = 0x00;
-	high_direction = 0x05;
-
-	/* turn red LED3 on, LED2 off */
-	/* high_output |= 0x08; */
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'minimodule' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int turtle_init(void)
-{
-	low_output    = 0x08;
-	low_direction = 0x5b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'turtelizer2' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nSRST = 0x40;
-
-	high_output    = 0x00;
-	high_direction = 0x0C;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'turtelizer2' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int comstick_init(void)
-{
-	low_output    = 0x08;
-	low_direction = 0x0b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'comstick' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRST    = 0x01;
-	nTRSTnOE = 0x00;	/* no output enable for nTRST */
-	nSRST    = 0x02;
-	nSRSTnOE = 0x00;	/* no output enable for nSRST */
-
-	high_output    = 0x03;
-	high_direction = 0x03;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'comstick' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int stm32stick_init(void)
-{
-	low_output    = 0x88;
-	low_direction = 0x8b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'stm32stick' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRST    = 0x01;
-	nTRSTnOE = 0x00;	/* no output enable for nTRST */
-	nSRST    = 0x80;
-	nSRSTnOE = 0x00;	/* no output enable for nSRST */
-
-	high_output    = 0x01;
-	high_direction = 0x03;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'stm32stick' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int sheevaplug_init(void)
-{
-	low_output = 0x08;
-	low_direction = 0x1b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'sheevaplug' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRSTnOE = 0x1;
-	nTRST = 0x02;
-	nSRSTnOE = 0x4;
-	nSRST = 0x08;
-
-	high_output = 0x0;
-	high_direction = 0x0f;
-
-	/* nTRST is always push-pull */
-	high_output &= ~nTRSTnOE;
-	high_output |= nTRST;
-
-	/* nSRST is always open-drain */
-	high_output |= nSRSTnOE;
-	high_output &= ~nSRST;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'sheevaplug' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int cortino_jtag_init(void)
-{
-	low_output    = 0x08;
-	low_direction = 0x1b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'cortino' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRST    = 0x01;
-	nTRSTnOE = 0x00;	/* no output enable for nTRST */
-	nSRST    = 0x02;
-	nSRSTnOE = 0x00;	/* no output enable for nSRST */
-
-	high_output    = 0x03;
-	high_direction = 0x03;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'cortino' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static int lisa_l_init(void)
-{
-	ftx232_dbus_init();
-
-	nTRST    = 0x10;
-	nTRSTnOE = 0x10;
-	nSRST    = 0x40;
-	nSRSTnOE = 0x40;
-
-	high_output = 0x00;
-	high_direction = 0x18;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'lisa_l' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ftx232_dbus_write();
-}
-
-static int flossjtag_init(void)
-{
-	ftx232_dbus_init();
-
-	nTRST    = 0x10;
-	nTRSTnOE = 0x10;
-	nSRST    = 0x40;
-	nSRSTnOE = 0x40;
-
-	high_output = 0x00;
-	high_direction = 0x18;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'Floss-JTAG' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ftx232_dbus_write();
-}
-
-/*
- * The reference schematic from TI for the XDS100v2 has a CPLD on which opens
- * the door for a number of different configurations
- *
- * Known Implementations:
- * http://processors.wiki.ti.com/images/9/93/TMS570LS20216_USB_STICK_Schematic.pdf
- *
- * http://processors.wiki.ti.com/index.php/XDS100 (rev2)
- *	* CLPD logic: Rising edge to enable outputs (XDS100_PWR_RST)
- *		* ACBUS3 to transition 0->1 (OE rising edge)
- *	* CPLD logic: Put the EMU0/1 pins in Hi-Z:
- *		* ADBUS5/GPIOL1 = EMU_EN = 1
- *		* ADBUS6/GPIOL2 = EMU0 = 0
- *		* ACBUS4/SPARE0 = EMU1 = 0
- *	* CPLD logic: Disable loopback
- *		* ACBUS6/SPARE2 = LOOPBACK = 0
- */
-#define XDS100_nEMU_EN  (1<<5)
-#define XDS100_nEMU0    (1<<6)
-
-#define XDS100_PWR_RST  (1<<3)
-#define XDS100_nEMU1    (1<<4)
-#define XDS100_LOOPBACK (1<<6)
-static int xds100v2_init(void)
-{
-	/* These are in the lower byte */
-	nTRST    = 0x10;
-	nTRSTnOE = 0x10;
-
-	/* These aren't actually used on 14 pin connectors
-	 * These are in the upper byte */
-	nSRST    = 0x01;
-	nSRSTnOE = 0x01;
-
-	low_output    = 0x08 | nTRST | XDS100_nEMU_EN;
-	low_direction = 0x0b | nTRSTnOE | XDS100_nEMU_EN | XDS100_nEMU0;
-
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'xds100v2' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	high_output = 0;
-	high_direction = nSRSTnOE | XDS100_LOOPBACK | XDS100_PWR_RST | XDS100_nEMU1;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't put CPLD in to reset with 'xds100v2' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	high_output |= XDS100_PWR_RST;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't bring CPLD out of reset with 'xds100v2' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static void flyswatter_jtag_blink(unsigned char led)
-{
-	buffer_write(0x82);
-	buffer_write(high_output ^ led);
-	buffer_write(high_direction);
-}
-
-static void flyswatter1_jtag_blink(void)
-{
-	/*
-	 * Flyswatter has two LEDs connected to ACBUS2 and ACBUS3
-	 */
-	flyswatter_jtag_blink(0xc);
-}
-
-static void flyswatter2_jtag_blink(void)
-{
-	/*
-	 * Flyswatter2 only has one LED connected to ACBUS2
-	 */
-	flyswatter_jtag_blink(0x4);
-}
-
-static void turtle_jtag_blink(void)
-{
-	/*
-	 * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
-	 */
-	if (high_output & 0x08)
-		high_output = 0x04;
-	else
-		high_output = 0x08;
-
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-}
-
-static void lisa_l_blink(void)
-{
-	/*
-	 * Lisa/L has two LEDs connected to BCBUS3 and BCBUS4
-	 */
-	if (high_output & 0x10)
-		high_output = 0x08;
-	else
-		high_output = 0x10;
-
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-}
-
-static void flossjtag_blink(void)
-{
-	/*
-	 * Floss-JTAG has two LEDs connected to ACBUS3 and ACBUS4
-	 */
-	if (high_output & 0x10)
-		high_output = 0x08;
-	else
-		high_output = 0x10;
-
-	buffer_write(0x82);
-	buffer_write(high_output);
-	buffer_write(high_direction);
-}
-
-static int ft2232_quit(void)
-{
-#if BUILD_FT2232_FTD2XX == 1
-
-	FT_Close(ftdih);
-#elif BUILD_FT2232_LIBFTDI == 1
-	ftdi_usb_close(&ftdic);
-
-	ftdi_deinit(&ftdic);
-#endif
-
-	free(ft2232_buffer);
-	ft2232_buffer = NULL;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(ft2232_handle_device_desc_command)
-{
-	char *cp;
-	char buf[200];
-	if (CMD_ARGC == 1) {
-		ft2232_device_desc = strdup(CMD_ARGV[0]);
-		cp = strchr(ft2232_device_desc, 0);
-		/* under Win32, the FTD2XX driver appends an "A" to the end
-		 * of the description, this examines the given desc
-		 * and creates the 'missing' _A or non_A variable. */
-		if ((cp[-1] == 'A') && (cp[-2] == ' ')) {
-			/* it was, so make this the "A" version. */
-			ft2232_device_desc_A = ft2232_device_desc;
-			/* and *CREATE* the non-A version. */
-			strcpy(buf, ft2232_device_desc);
-			cp = strchr(buf, 0);
-			cp[-2] = 0;
-			ft2232_device_desc = strdup(buf);
-		} else {
-			/* <space > A not defined
-			 * so create it */
-			sprintf(buf, "%s A", ft2232_device_desc);
-			ft2232_device_desc_A = strdup(buf);
-		}
-	} else
-		LOG_ERROR("expected exactly one argument to ft2232_device_desc <description>");
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(ft2232_handle_serial_command)
-{
-	if (CMD_ARGC == 1)
-		ft2232_serial = strdup(CMD_ARGV[0]);
-	else
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(ft2232_handle_layout_command)
-{
-	if (CMD_ARGC != 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	if (layout) {
-		LOG_ERROR("already specified ft2232_layout %s",
-			layout->name);
-		return (strcmp(layout->name, CMD_ARGV[0]) != 0)
-		       ? ERROR_FAIL
-		       : ERROR_OK;
-	}
-
-	for (const struct ft2232_layout *l = ft2232_layouts; l->name; l++) {
-		if (strcmp(l->name, CMD_ARGV[0]) == 0) {
-			layout = l;
-			ft2232_channel = l->channel;
-			return ERROR_OK;
-		}
-	}
-
-	LOG_ERROR("No FT2232 layout '%s' found", CMD_ARGV[0]);
-	return ERROR_FAIL;
-}
-
-COMMAND_HANDLER(ft2232_handle_vid_pid_command)
-{
-	if (CMD_ARGC > MAX_USB_IDS * 2) {
-		LOG_WARNING("ignoring extra IDs in ft2232_vid_pid "
-			"(maximum is %d pairs)", MAX_USB_IDS);
-		CMD_ARGC = MAX_USB_IDS * 2;
-	}
-	if (CMD_ARGC < 2 || (CMD_ARGC & 1)) {
-		LOG_WARNING("incomplete ft2232_vid_pid configuration directive");
-		if (CMD_ARGC < 2)
-			return ERROR_COMMAND_SYNTAX_ERROR;
-		/* remove the incomplete trailing id */
-		CMD_ARGC -= 1;
-	}
-
-	unsigned i;
-	for (i = 0; i < CMD_ARGC; i += 2) {
-		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i], ft2232_vid[i >> 1]);
-		COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i + 1], ft2232_pid[i >> 1]);
-	}
-
-	/*
-	 * Explicitly terminate, in case there are multiples instances of
-	 * ft2232_vid_pid.
-	 */
-	ft2232_vid[i >> 1] = ft2232_pid[i >> 1] = 0;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(ft2232_handle_latency_command)
-{
-	if (CMD_ARGC == 1)
-		ft2232_latency = atoi(CMD_ARGV[0]);
-	else
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(ft2232_handle_channel_command)
-{
-	if (CMD_ARGC == 1) {
-		ft2232_channel = atoi(CMD_ARGV[0]);
-		if (ft2232_channel < 0 || ft2232_channel > 4)
-			LOG_ERROR("ft2232_channel must be in the 0 to 4 range");
-	} else
-		LOG_ERROR("expected exactly one argument to ft2232_channel <ch>");
-
-	return ERROR_OK;
-}
-
-static int ft2232_stableclocks(int num_cycles, struct jtag_command *cmd)
-{
-	int retval = 0;
-
-	/* 7 bits of either ones or zeros. */
-	uint8_t tms = (tap_get_state() == TAP_RESET ? 0x7F : 0x00);
-
-	while (num_cycles > 0) {
-		/* the command 0x4b, "Clock Data to TMS/CS Pin (no Read)" handles
-		 * at most 7 bits per invocation.  Here we invoke it potentially
-		 * several times.
-		 */
-		int bitcount_per_command = (num_cycles > 7) ? 7 : num_cycles;
-
-		if (ft2232_buffer_size + 3 >= FT2232_BUFFER_SIZE) {
-			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
-				retval = ERROR_JTAG_QUEUE_FAILED;
-
-			first_unsent = cmd;
-		}
-
-		/* there are no state transitions in this code, so omit state tracking */
-
-		/* command "Clock Data to TMS/CS Pin (no Read)" */
-		buffer_write(0x4b);
-
-		/* scan 7 bit */
-		buffer_write(bitcount_per_command - 1);
-
-		/* TMS data bits are either all zeros or ones to stay in the current stable state */
-		buffer_write(tms);
-
-		require_send = 1;
-
-		num_cycles -= bitcount_per_command;
-	}
-
-	return retval;
-}
-
-/* ---------------------------------------------------------------------
- * Support for IceBear JTAG adapter from Section5:
- *	http://section5.ch/icebear
- *
- * Author: Sten, debian@sansys-electronic.com
- */
-
-/* Icebear pin layout
- *
- * ADBUS5 (nEMU) nSRST	| 2   1|	GND (10k->VCC)
- * GND GND		| 4   3|	n.c.
- * ADBUS3 TMS		| 6   5|	ADBUS6 VCC
- * ADBUS0 TCK		| 8   7|	ADBUS7 (GND)
- * ADBUS4 nTRST		|10   9|	ACBUS0 (GND)
- * ADBUS1 TDI		|12  11|	ACBUS1 (GND)
- * ADBUS2 TDO		|14  13|	GND GND
- *
- * ADBUS0 O L TCK		ACBUS0 GND
- * ADBUS1 O L TDI		ACBUS1 GND
- * ADBUS2 I   TDO		ACBUS2 n.c.
- * ADBUS3 O H TMS		ACBUS3 n.c.
- * ADBUS4 O H nTRST
- * ADBUS5 O H nSRST
- * ADBUS6 -   VCC
- * ADBUS7 -   GND
- */
-static int icebear_jtag_init(void)
-{
-	low_direction   = 0x0b;	/* output: TCK TDI TMS; input: TDO */
-	low_output      = 0x08;	/* high: TMS; low: TCK TDI */
-	nTRST           = 0x10;
-	nSRST           = 0x20;
-
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	if ((jtag_reset_config & RESET_TRST_OPEN_DRAIN) != 0)
-		low_direction   &= ~nTRST;	/* nTRST high impedance */
-	else {
-		low_direction   |= nTRST;
-		low_output      |= nTRST;
-	}
-
-	low_direction   |= nSRST;
-	low_output      |= nSRST;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'IceBear' layout (low)");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	high_output    = 0x0;
-	high_direction = 0x00;
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'IceBear' layout (high)");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static void icebear_jtag_reset(int trst, int srst)
-{
-	if (trst == 1) {
-		low_direction   |= nTRST;
-		low_output      &= ~nTRST;
-	} else if (trst == 0) {
-		enum reset_types jtag_reset_config = jtag_get_reset_config();
-		if ((jtag_reset_config & RESET_TRST_OPEN_DRAIN) != 0)
-			low_direction   &= ~nTRST;
-		else
-			low_output      |= nTRST;
-	}
-
-	if (srst == 1)
-		low_output &= ~nSRST;
-	else if (srst == 0)
-		low_output |= nSRST;
-
-	/* command "set data bits low byte" */
-	buffer_write(0x80);
-	buffer_write(low_output);
-	buffer_write(low_direction);
-
-	LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x",
-		trst,
-		srst,
-		low_output,
-		low_direction);
-}
-
-/* ---------------------------------------------------------------------
- * Support for Signalyzer H2 and Signalyzer H4
- * JTAG adapter from Xverve Technologies Inc.
- * http://www.signalyzer.com or http://www.xverve.com
- *
- * Author: Oleg Seiljus, oleg@signalyzer.com
- */
-static unsigned char signalyzer_h_side;
-static unsigned int signalyzer_h_adapter_type;
-
-static int signalyzer_h_ctrl_write(int address, unsigned short value);
-
-#if BUILD_FT2232_FTD2XX == 1
-static int signalyzer_h_ctrl_read(int address, unsigned short *value);
-#endif
-
-#define SIGNALYZER_COMMAND_ADDR					128
-#define SIGNALYZER_DATA_BUFFER_ADDR				129
-
-#define SIGNALYZER_COMMAND_VERSION				0x41
-#define SIGNALYZER_COMMAND_RESET				0x42
-#define SIGNALYZER_COMMAND_POWERCONTROL_GET		0x50
-#define SIGNALYZER_COMMAND_POWERCONTROL_SET		0x51
-#define SIGNALYZER_COMMAND_PWM_SET				0x52
-#define SIGNALYZER_COMMAND_LED_SET				0x53
-#define SIGNALYZER_COMMAND_ADC					0x54
-#define SIGNALYZER_COMMAND_GPIO_STATE			0x55
-#define SIGNALYZER_COMMAND_GPIO_MODE			0x56
-#define SIGNALYZER_COMMAND_GPIO_PORT			0x57
-#define SIGNALYZER_COMMAND_I2C					0x58
-
-#define SIGNALYZER_CHAN_A						1
-#define SIGNALYZER_CHAN_B						2
-/* LEDS use channel C */
-#define SIGNALYZER_CHAN_C						4
-
-#define SIGNALYZER_LED_GREEN					1
-#define SIGNALYZER_LED_RED						2
-
-#define SIGNALYZER_MODULE_TYPE_EM_LT16_A		0x0301
-#define SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG		0x0302
-#define SIGNALYZER_MODULE_TYPE_EM_JTAG			0x0303
-#define SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG_P	0x0304
-#define SIGNALYZER_MODULE_TYPE_EM_JTAG_P		0x0305
-
-
-static int signalyzer_h_ctrl_write(int address, unsigned short value)
-{
-#if BUILD_FT2232_FTD2XX == 1
-	return FT_WriteEE(ftdih, address, value);
-#elif BUILD_FT2232_LIBFTDI == 1
-	return 0;
-#endif
-}
-
-#if BUILD_FT2232_FTD2XX == 1
-static int signalyzer_h_ctrl_read(int address, unsigned short *value)
-{
-	return FT_ReadEE(ftdih, address, value);
-}
-#endif
-
-static int signalyzer_h_led_set(unsigned char channel, unsigned char led,
-	int on_time_ms, int off_time_ms, unsigned char cycles)
-{
-	unsigned char on_time;
-	unsigned char off_time;
-
-	if (on_time_ms < 0xFFFF)
-		on_time = (unsigned char)(on_time_ms / 62);
-	else
-		on_time = 0xFF;
-
-	off_time = (unsigned char)(off_time_ms / 62);
-
-#if BUILD_FT2232_FTD2XX == 1
-	FT_STATUS status;
-
-	status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-			((uint32_t)(channel << 8) | led));
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write((SIGNALYZER_DATA_BUFFER_ADDR + 1),
-			((uint32_t)(on_time << 8) | off_time));
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write((SIGNALYZER_DATA_BUFFER_ADDR + 2),
-			((uint32_t)cycles));
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-				SIGNALYZER_COMMAND_LED_SET);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write  returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-#elif BUILD_FT2232_LIBFTDI == 1
-	int retval;
-
-	retval = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				((uint32_t)(channel << 8) | led));
-	if (retval < 0) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftdi_get_error_string(&ftdic));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	retval = signalyzer_h_ctrl_write((SIGNALYZER_DATA_BUFFER_ADDR + 1),
-			((uint32_t)(on_time << 8) | off_time));
-	if (retval < 0) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftdi_get_error_string(&ftdic));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	retval = signalyzer_h_ctrl_write((SIGNALYZER_DATA_BUFFER_ADDR + 2),
-			(uint32_t)cycles);
-	if (retval < 0) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftdi_get_error_string(&ftdic));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	retval = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-			SIGNALYZER_COMMAND_LED_SET);
-	if (retval < 0) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftdi_get_error_string(&ftdic));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-#endif
-}
-
-static int signalyzer_h_init(void)
-{
-#if BUILD_FT2232_FTD2XX == 1
-	FT_STATUS status;
-	int i;
-#endif
-
-	char *end_of_desc;
-
-	uint16_t read_buf[12] = { 0 };
-
-	/* turn on center green led */
-	signalyzer_h_led_set(SIGNALYZER_CHAN_C, SIGNALYZER_LED_GREEN,
-		0xFFFF, 0x00, 0x00);
-
-	/* determine what channel config wants to open
-	 * TODO: change me... current implementation is made to work
-	 * with openocd description parsing.
-	 */
-	end_of_desc = strrchr(ft2232_device_desc, 0x00);
-
-	if (end_of_desc) {
-		signalyzer_h_side = *(end_of_desc - 1);
-		if (signalyzer_h_side == 'B')
-			signalyzer_h_side = SIGNALYZER_CHAN_B;
-		else
-			signalyzer_h_side = SIGNALYZER_CHAN_A;
-	} else {
-		LOG_ERROR("No Channel was specified");
-		return ERROR_FAIL;
-	}
-
-	signalyzer_h_led_set(signalyzer_h_side, SIGNALYZER_LED_GREEN,
-		1000, 1000, 0xFF);
-
-#if BUILD_FT2232_FTD2XX == 1
-	/* read signalyzer versionining information */
-	status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-			SIGNALYZER_COMMAND_VERSION);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	for (i = 0; i < 10; i++) {
-		status = signalyzer_h_ctrl_read((SIGNALYZER_DATA_BUFFER_ADDR + i),
-				&read_buf[i]);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_read returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	LOG_INFO("Signalyzer: ID info: { %.4x %.4x %.4x %.4x %.4x %.4x %.4x }",
-		read_buf[0], read_buf[1], read_buf[2], read_buf[3],
-		read_buf[4], read_buf[5], read_buf[6]);
-
-	/* set gpio register */
-	status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-			(uint32_t)(signalyzer_h_side << 8));
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0404);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-			SIGNALYZER_COMMAND_GPIO_STATE);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	/* read adapter type information */
-	status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-			((uint32_t)(signalyzer_h_side << 8) | 0x01));
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write(
-			(SIGNALYZER_DATA_BUFFER_ADDR + 1), 0xA000);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write(
-			(SIGNALYZER_DATA_BUFFER_ADDR + 2), 0x0008);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-			SIGNALYZER_COMMAND_I2C);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	openocd_usleep(100000);
-
-	status = signalyzer_h_ctrl_read(SIGNALYZER_COMMAND_ADDR, &read_buf[0]);
-	if (status != FT_OK) {
-		LOG_ERROR("signalyzer_h_ctrl_read returned: %s",
-			ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	if (read_buf[0] != 0x0498)
-		signalyzer_h_adapter_type = 0x0000;
-	else {
-		for (i = 0; i < 4; i++) {
-			status = signalyzer_h_ctrl_read((SIGNALYZER_DATA_BUFFER_ADDR + i), &read_buf[i]);
-			if (status != FT_OK) {
-				LOG_ERROR("signalyzer_h_ctrl_read returned: %s",
-					ftd2xx_status_string(status));
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-		}
-
-		signalyzer_h_adapter_type = read_buf[0];
-	}
-
-#elif BUILD_FT2232_LIBFTDI == 1
-	/* currently libftdi does not allow reading individual eeprom
-	 * locations, therefore adapter type cannot be detected.
-	 * override with most common type
-	 */
-	signalyzer_h_adapter_type = SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG;
-#endif
-
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-
-	/* ADAPTOR: EM_LT16_A */
-	if (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_LT16_A) {
-		LOG_INFO("Signalyzer: EM-LT (16-channel level translator) "
-			"detected. (HW: %2x).", (read_buf[1] >> 8));
-
-		nTRST    = 0x10;
-		nTRSTnOE = 0x10;
-		nSRST    = 0x20;
-		nSRSTnOE = 0x20;
-
-		low_output     = 0x08;
-		low_direction  = 0x1b;
-
-		high_output    = 0x0;
-		high_direction = 0x0;
-
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN) {
-			low_direction &= ~nTRSTnOE;	/* nTRST input */
-			low_output    &= ~nTRST;	/* nTRST = 0 */
-		} else {
-			low_direction |= nTRSTnOE;	/* nTRST output */
-			low_output    |= nTRST;		/* nTRST = 1 */
-		}
-
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL) {
-			low_direction |= nSRSTnOE;	/* nSRST output */
-			low_output    |= nSRST;		/* nSRST = 1 */
-		} else {
-			low_direction &= ~nSRSTnOE;	/* nSRST input */
-			low_output    &= ~nSRST;	/* nSRST = 0 */
-		}
-
-#if BUILD_FT2232_FTD2XX == 1
-		/* enable power to the module */
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				((uint32_t)(signalyzer_h_side << 8) | 0x01));
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-				SIGNALYZER_COMMAND_POWERCONTROL_SET);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		/* set gpio mode register */
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				(uint32_t)(signalyzer_h_side << 8));
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0000);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR, SIGNALYZER_COMMAND_GPIO_MODE);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		/* set gpio register */
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				(uint32_t)(signalyzer_h_side << 8));
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x4040);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-				SIGNALYZER_COMMAND_GPIO_STATE);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-#endif
-	}
-	/* ADAPTOR: EM_ARM_JTAG, EM_ARM_JTAG_P, EM_JTAG, EM_JTAG_P */
-	else if ((signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG) ||
-		 (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG_P) ||
-		 (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_JTAG)  ||
-		 (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_JTAG_P)) {
-		if (signalyzer_h_adapter_type
-		    == SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG)
-			LOG_INFO("Signalyzer: EM-ARM-JTAG (ARM JTAG) "
-				"detected. (HW: %2x).", (read_buf[1] >> 8));
-		else if (signalyzer_h_adapter_type
-			 == SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG_P)
-			LOG_INFO("Signalyzer: EM-ARM-JTAG_P "
-				"(ARM JTAG with PSU) detected. (HW: %2x).",
-				(read_buf[1] >> 8));
-		else if (signalyzer_h_adapter_type
-			 == SIGNALYZER_MODULE_TYPE_EM_JTAG)
-			LOG_INFO("Signalyzer: EM-JTAG (Generic JTAG) "
-				"detected. (HW: %2x).", (read_buf[1] >> 8));
-		else if (signalyzer_h_adapter_type
-			 == SIGNALYZER_MODULE_TYPE_EM_JTAG_P)
-			LOG_INFO("Signalyzer: EM-JTAG-P "
-				"(Generic JTAG with PSU) detected. (HW: %2x).",
-				(read_buf[1] >> 8));
-
-		nTRST          = 0x02;
-		nTRSTnOE       = 0x04;
-		nSRST          = 0x08;
-		nSRSTnOE       = 0x10;
-
-		low_output     = 0x08;
-		low_direction  = 0x1b;
-
-		high_output    = 0x0;
-		high_direction = 0x1f;
-
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN) {
-			high_output |= nTRSTnOE;
-			high_output &= ~nTRST;
-		} else {
-			high_output &= ~nTRSTnOE;
-			high_output |= nTRST;
-		}
-
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL) {
-			high_output &= ~nSRSTnOE;
-			high_output |= nSRST;
-		} else {
-			high_output |= nSRSTnOE;
-			high_output &= ~nSRST;
-		}
-
-#if BUILD_FT2232_FTD2XX == 1
-		/* enable power to the module */
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				((uint32_t)(signalyzer_h_side << 8) | 0x01));
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR,
-				SIGNALYZER_COMMAND_POWERCONTROL_SET);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		/* set gpio mode register (IO_16 and IO_17 set as analog
-		 * inputs, other is gpio)
-		 */
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				(uint32_t)(signalyzer_h_side << 8));
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0060);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR, SIGNALYZER_COMMAND_GPIO_MODE);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		/* set gpio register (all inputs, for -P modules,
-		 * PSU will be turned off)
-		 */
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR,
-				(uint32_t)(signalyzer_h_side << 8));
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_DATA_BUFFER_ADDR + 1, 0x0000);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-
-		status = signalyzer_h_ctrl_write(SIGNALYZER_COMMAND_ADDR, SIGNALYZER_COMMAND_GPIO_STATE);
-		if (status != FT_OK) {
-			LOG_ERROR("signalyzer_h_ctrl_write returned: %s",
-				ftd2xx_status_string(status));
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-#endif
-	} else if (signalyzer_h_adapter_type == 0x0000) {
-		LOG_INFO("Signalyzer: No external modules were detected.");
-
-		nTRST    = 0x10;
-		nTRSTnOE = 0x10;
-		nSRST    = 0x20;
-		nSRSTnOE = 0x20;
-
-		low_output     = 0x08;
-		low_direction  = 0x1b;
-
-		high_output    = 0x0;
-		high_direction = 0x0;
-
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN) {
-			low_direction &= ~nTRSTnOE;	/* nTRST input */
-			low_output    &= ~nTRST;	/* nTRST = 0 */
-		} else {
-			low_direction |= nTRSTnOE;	/* nTRST output */
-			low_output    |= nTRST;		/* nTRST = 1 */
-		}
-
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL) {
-			low_direction |= nSRSTnOE;	/* nSRST output */
-			low_output    |= nSRST;		/* nSRST = 1 */
-		} else {
-			low_direction &= ~nSRSTnOE;	/* nSRST input */
-			low_output    &= ~nSRST;	/* nSRST = 0 */
-		}
-	} else {
-		LOG_ERROR("Unknown module type is detected: %.4x",
-			signalyzer_h_adapter_type);
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	/* initialize low byte of controller for jtag operation */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize Signalyzer-H layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-#if BUILD_FT2232_FTD2XX == 1
-	if (ftdi_device == FT_DEVICE_2232H) {
-		/* initialize high byte of controller for jtag operation */
-		if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-			LOG_ERROR("couldn't initialize Signalyzer-H layout");
-			return ERROR_JTAG_INIT_FAILED;
-		}
-	}
-#elif BUILD_FT2232_LIBFTDI == 1
-	if (ftdi_device == TYPE_2232H) {
-		/* initialize high byte of controller for jtag operation */
-		if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-			LOG_ERROR("couldn't initialize Signalyzer-H layout");
-			return ERROR_JTAG_INIT_FAILED;
-		}
-	}
-#endif
-	return ERROR_OK;
-}
-
-static void signalyzer_h_reset(int trst, int srst)
-{
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-
-	/* ADAPTOR: EM_LT16_A */
-	if (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_LT16_A) {
-		if (trst == 1) {
-			if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-				/* switch to output pin (output is low) */
-				low_direction |= nTRSTnOE;
-			else
-				/* switch output low */
-				low_output &= ~nTRST;
-		} else if (trst == 0) {
-			if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-				/* switch to input pin (high-Z + internal
-				 * and external pullup) */
-				low_direction &= ~nTRSTnOE;
-			else
-				/* switch output high */
-				low_output |= nTRST;
-		}
-
-		if (srst == 1) {
-			if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-				/* switch output low */
-				low_output &= ~nSRST;
-			else
-				/* switch to output pin (output is low) */
-				low_direction |= nSRSTnOE;
-		} else if (srst == 0) {
-			if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-				/* switch output high */
-				low_output |= nSRST;
-			else
-				/* switch to input pin (high-Z) */
-				low_direction &= ~nSRSTnOE;
-		}
-
-		/* command "set data bits low byte" */
-		buffer_write(0x80);
-		buffer_write(low_output);
-		buffer_write(low_direction);
-		LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, "
-			"low_direction: 0x%2.2x",
-			trst, srst, low_output, low_direction);
-	}
-	/* ADAPTOR: EM_ARM_JTAG,  EM_ARM_JTAG_P, EM_JTAG, EM_JTAG_P */
-	else if ((signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG) ||
-		 (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_ARM_JTAG_P) ||
-		 (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_JTAG)  ||
-		 (signalyzer_h_adapter_type == SIGNALYZER_MODULE_TYPE_EM_JTAG_P)) {
-		if (trst == 1) {
-			if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-				high_output &= ~nTRSTnOE;
-			else
-				high_output &= ~nTRST;
-		} else if (trst == 0) {
-			if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-				high_output |= nTRSTnOE;
-			else
-				high_output |= nTRST;
-		}
-
-		if (srst == 1) {
-			if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-				high_output &= ~nSRST;
-			else
-				high_output &= ~nSRSTnOE;
-		} else if (srst == 0) {
-			if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-				high_output |= nSRST;
-			else
-				high_output |= nSRSTnOE;
-		}
-
-		/* command "set data bits high byte" */
-		buffer_write(0x82);
-		buffer_write(high_output);
-		buffer_write(high_direction);
-		LOG_INFO("trst: %i, srst: %i, high_output: 0x%2.2x, "
-			"high_direction: 0x%2.2x",
-			trst, srst, high_output, high_direction);
-	} else if (signalyzer_h_adapter_type == 0x0000) {
-		if (trst == 1) {
-			if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-				/* switch to output pin (output is low) */
-				low_direction |= nTRSTnOE;
-			else
-				/* switch output low */
-				low_output &= ~nTRST;
-		} else if (trst == 0) {
-			if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-				/* switch to input pin (high-Z + internal
-				 * and external pullup) */
-				low_direction &= ~nTRSTnOE;
-			else
-				/* switch output high */
-				low_output |= nTRST;
-		}
-
-		if (srst == 1) {
-			if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-				/* switch output low */
-				low_output &= ~nSRST;
-			else
-				/* switch to output pin (output is low) */
-				low_direction |= nSRSTnOE;
-		} else if (srst == 0) {
-			if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-				/* switch output high */
-				low_output |= nSRST;
-			else
-				/* switch to input pin (high-Z) */
-				low_direction &= ~nSRSTnOE;
-		}
-
-		/* command "set data bits low byte" */
-		buffer_write(0x80);
-		buffer_write(low_output);
-		buffer_write(low_direction);
-		LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, "
-			"low_direction: 0x%2.2x",
-			trst, srst, low_output, low_direction);
-	}
-}
-
-static void signalyzer_h_blink(void)
-{
-	signalyzer_h_led_set(signalyzer_h_side, SIGNALYZER_LED_RED, 100, 0, 1);
-}
-
-/********************************************************************
- * Support for KT-LINK
- * JTAG adapter from KRISTECH
- * http://www.kristech.eu
- *******************************************************************/
-static int ktlink_init(void)
-{
-	uint8_t swd_en = 0x20;	/* 0x20 SWD disable, 0x00 SWD enable (ADBUS5) */
-
-	low_output    = 0x08 | swd_en;	/* value; TMS=1,TCK=0,TDI=0,SWD=swd_en */
-	low_direction = 0x3B;		/* out=1; TCK/TDI/TMS=out,TDO=in,SWD=out,RTCK=in,SRSTIN=in */
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'ktlink' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	nTRST    = 0x01;
-	nSRST    = 0x02;
-	nTRSTnOE = 0x04;
-	nSRSTnOE = 0x08;
-
-	high_output    = 0x80;	/* turn LED on */
-	high_direction = 0xFF;	/* all outputs */
-
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-
-	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN) {
-		high_output |= nTRSTnOE;
-		high_output &= ~nTRST;
-	} else {
-		high_output &= ~nTRSTnOE;
-		high_output |= nTRST;
-	}
-
-	if (jtag_reset_config & RESET_SRST_PUSH_PULL) {
-		high_output &= ~nSRSTnOE;
-		high_output |= nSRST;
-	} else {
-		high_output |= nSRSTnOE;
-		high_output &= ~nSRST;
-	}
-
-	/* initialize high byte for jtag */
-	if (ft2232_set_data_bits_high_byte(high_output, high_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'ktlink' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-static void ktlink_reset(int trst, int srst)
-{
-	enum reset_types jtag_reset_config = jtag_get_reset_config();
-
-	if (trst == 1) {
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-			high_output &= ~nTRSTnOE;
-		else
-			high_output &= ~nTRST;
-	} else if (trst == 0) {
-		if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
-			high_output |= nTRSTnOE;
-		else
-			high_output |= nTRST;
-	}
-
-	if (srst == 1) {
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-			high_output &= ~nSRST;
-		else
-			high_output &= ~nSRSTnOE;
-	} else if (srst == 0) {
-		if (jtag_reset_config & RESET_SRST_PUSH_PULL)
-			high_output |= nSRST;
-		else
-			high_output |= nSRSTnOE;
-	}
-
-	buffer_write(0x82);	/* command "set data bits high byte" */
-	buffer_write(high_output);
-	buffer_write(high_direction);
-	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x",
-		trst,
-		srst,
-		high_output,
-		high_direction);
-}
-
-static void ktlink_blink(void)
-{
-	/* LED connected to ACBUS7 */
-	high_output ^= 0x80;
-
-	buffer_write(0x82);	/* command "set data bits high byte" */
-	buffer_write(high_output);
-	buffer_write(high_direction);
-}
-
-/********************************************************************
- * Support for Digilent HS-1
- * JTAG adapter from Digilent
- * http://www.digilent.com
- * Author: Stephane Bonnet bonnetst@hds.utc.fr
- *******************************************************************/
-
-static int digilent_hs1_init(void)
-{
-	/* the adapter only supports the base JTAG signals, no nTRST
-	   nor nSRST */
-	low_output	= 0x88;
-	low_direction	= 0x8b;
-
-	/* initialize low byte for jtag */
-	if (ft2232_set_data_bits_low_byte(low_output, low_direction) != ERROR_OK) {
-		LOG_ERROR("couldn't initialize FT2232 with 'digilent_hs1' layout");
-		return ERROR_JTAG_INIT_FAILED;
-	}
-	return ERROR_OK;
-}
-
-static void digilent_hs1_reset(int trst, int srst)
-{
-	/* Dummy function, no reset signals supported. */
-}
-
-static const struct command_registration ft2232_command_handlers[] = {
-	{
-		.name = "ft2232_device_desc",
-		.handler = &ft2232_handle_device_desc_command,
-		.mode = COMMAND_CONFIG,
-		.help = "set the USB device description of the FTDI FT2232 device",
-		.usage = "description_string",
-	},
-	{
-		.name = "ft2232_serial",
-		.handler = &ft2232_handle_serial_command,
-		.mode = COMMAND_CONFIG,
-		.help = "set the serial number of the FTDI FT2232 device",
-		.usage = "serial_string",
-	},
-	{
-		.name = "ft2232_layout",
-		.handler = &ft2232_handle_layout_command,
-		.mode = COMMAND_CONFIG,
-		.help = "set the layout of the FT2232 GPIO signals used "
-			"to control output-enables and reset signals",
-		.usage = "layout_name",
-	},
-	{
-		.name = "ft2232_vid_pid",
-		.handler = &ft2232_handle_vid_pid_command,
-		.mode = COMMAND_CONFIG,
-		.help = "the vendor ID and product ID of the FTDI FT2232 device",
-		.usage = "(vid pid)* ",
-	},
-	{
-		.name = "ft2232_latency",
-		.handler = &ft2232_handle_latency_command,
-		.mode = COMMAND_CONFIG,
-		.help = "set the FT2232 latency timer to a new value",
-		.usage = "value",
-	},
-	{
-		.name = "ft2232_channel",
-		.handler = &ft2232_handle_channel_command,
-		.mode = COMMAND_CONFIG,
-		.help = "set the FT2232 channel to a new value",
-		.usage = "value",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-struct jtag_interface ft2232_interface = {
-	.name = "ft2232",
-	.supported = DEBUG_CAP_TMS_SEQ,
-	.commands = ft2232_command_handlers,
-	.transports = jtag_only,
-
-	.init = ft2232_init,
-	.quit = ft2232_quit,
-	.speed = ft2232_speed,
-	.speed_div = ft2232_speed_div,
-	.khz = ft2232_khz,
-	.execute_queue = ft2232_execute_queue,
-};
diff --git a/src/jtag/drivers/ftd2xx_common.h b/src/jtag/drivers/ftd2xx_common.h
deleted file mode 100644
index 53ed4258..00000000
--- a/src/jtag/drivers/ftd2xx_common.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2011 by Spencer Oliver <spen@spen-soft.co.uk>           *
- *                                                                         *
- *   Written by Arnim Laeuger, 2008 (from urjtag)                          *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
- ***************************************************************************/
-
-#ifndef _FTD2XX_COMMON_H
-#define _FTD2XX_COMMON_H
-
-#if ((BUILD_FT2232_FTD2XX == 1) || (BUILD_PRESTO_FTD2XX == 1) || (BUILD_USB_BLASTER_FTD2XX == 1))
-#include <ftd2xx.h>
-
-static const char *ftd2xx_status_string(FT_STATUS status)
-{
-	switch (status) {
-		case FT_OK:							return "OK";
-		case FT_INVALID_HANDLE:				return "invalid handle";
-		case FT_DEVICE_NOT_FOUND:			return "device not found";
-		case FT_DEVICE_NOT_OPENED:			return "device not opened";
-		case FT_IO_ERROR:					return "io error";
-		case FT_INSUFFICIENT_RESOURCES:		return "insufficient resources";
-		case FT_INVALID_PARAMETER:			return "invalid parameter";
-		case FT_INVALID_BAUD_RATE:			return "invalid baud rate";
-
-		case FT_DEVICE_NOT_OPENED_FOR_ERASE: return "device not opened for erase";
-		case FT_DEVICE_NOT_OPENED_FOR_WRITE: return "device not opened for write";
-		case FT_FAILED_TO_WRITE_DEVICE:		return "failed to write device";
-		case FT_EEPROM_READ_FAILED:			return "eeprom read failed";
-		case FT_EEPROM_WRITE_FAILED:		return "eeprom write failed";
-		case FT_EEPROM_ERASE_FAILED:		return "eeprom erase failed";
-		case FT_EEPROM_NOT_PRESENT:			return "eeprom not present";
-		case FT_EEPROM_NOT_PROGRAMMED:		return "eeprom not programmed";
-		case FT_INVALID_ARGS:				return "invalid args";
-		case FT_NOT_SUPPORTED:				return "not supported";
-		case FT_OTHER_ERROR:				return "other error";
-	}
-
-	return "undefined FTD2xx error";
-}
-
-#endif
-#endif /* _FTD2XX_COMMON_H */
diff --git a/src/jtag/drivers/ftdi.c b/src/jtag/drivers/ftdi.c
index d8c7d642..32876bac 100644
--- a/src/jtag/drivers/ftdi.c
+++ b/src/jtag/drivers/ftdi.c
@@ -13,9 +13,7 @@
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
-*   along with this program; if not, write to the                         *
-*   Free Software Foundation, Inc.,                                       *
-*   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/
 
 /**
@@ -86,11 +84,14 @@
 #include "mpsse.h"
 
 #define JTAG_MODE (LSB_FIRST | POS_EDGE_IN | NEG_EDGE_OUT)
+#define JTAG_MODE_ALT (LSB_FIRST | NEG_EDGE_IN | NEG_EDGE_OUT)
 #define SWD_MODE (LSB_FIRST | POS_EDGE_IN | NEG_EDGE_OUT)
 
 static char *ftdi_device_desc;
 static char *ftdi_serial;
+static char *ftdi_location;
 static uint8_t ftdi_channel;
+static uint8_t ftdi_jtag_mode = JTAG_MODE;
 
 static bool swd_mode;
 
@@ -104,8 +105,10 @@ static struct mpsse_ctx *mpsse_ctx;
 struct signal {
 	const char *name;
 	uint16_t data_mask;
+	uint16_t input_mask;
 	uint16_t oe_mask;
 	bool invert_data;
+	bool invert_input;
 	bool invert_oe;
 	struct signal *next;
 };
@@ -210,6 +213,32 @@ static int ftdi_set_signal(const struct signal *s, char value)
 	return ERROR_OK;
 }
 
+static int ftdi_get_signal(const struct signal *s, uint16_t * value_out)
+{
+	uint8_t data_low = 0;
+	uint8_t data_high = 0;
+
+	if (s->input_mask == 0) {
+		LOG_ERROR("interface doesn't provide signal '%s'", s->name);
+		return ERROR_FAIL;
+	}
+
+	if (s->input_mask & 0xff)
+		mpsse_read_data_bits_low_byte(mpsse_ctx, &data_low);
+	if (s->input_mask >> 8)
+		mpsse_read_data_bits_high_byte(mpsse_ctx, &data_high);
+
+	mpsse_flush(mpsse_ctx);
+
+	*value_out = (((uint16_t)data_high) << 8) | data_low;
+
+	if (s->invert_input)
+		*value_out = ~(*value_out);
+
+	*value_out &= s->input_mask;
+
+	return ERROR_OK;
+}
 
 /**
  * Function move_to_state
@@ -244,7 +273,7 @@ static void move_to_state(tap_state_t goal_state)
 		0,
 		tms_count,
 		false,
-		JTAG_MODE);
+		ftdi_jtag_mode);
 }
 
 static int ftdi_speed(int speed)
@@ -257,6 +286,9 @@ static int ftdi_speed(int speed)
 		return retval;
 	}
 
+	if (!swd_mode && speed >= 10000000 && ftdi_jtag_mode != JTAG_MODE_ALT)
+		LOG_INFO("ftdi: if you experience problems at higher adapter clocks, try "
+			 "the command \"ftdi_tdo_sample_edge falling\"");
 	return ERROR_OK;
 }
 
@@ -304,7 +336,7 @@ static void ftdi_execute_runtest(struct jtag_command *cmd)
 	while (i > 0) {
 		/* there are no state transitions in this code, so omit state tracking */
 		unsigned this_len = i > 7 ? 7 : i;
-		mpsse_clock_tms_cs_out(mpsse_ctx, &zero, 0, this_len, false, JTAG_MODE);
+		mpsse_clock_tms_cs_out(mpsse_ctx, &zero, 0, this_len, false, ftdi_jtag_mode);
 		i -= this_len;
 	}
 
@@ -344,7 +376,7 @@ static void ftdi_execute_tms(struct jtag_command *cmd)
 		0,
 		cmd->cmd.tms->num_bits,
 		false,
-		JTAG_MODE);
+		ftdi_jtag_mode);
 }
 
 static void ftdi_execute_pathmove(struct jtag_command *cmd)
@@ -391,7 +423,7 @@ static void ftdi_execute_pathmove(struct jtag_command *cmd)
 					0,
 					bit_count,
 					false,
-					JTAG_MODE);
+					ftdi_jtag_mode);
 			bit_count = 0;
 		}
 	}
@@ -446,7 +478,7 @@ static void ftdi_execute_scan(struct jtag_command *cmd)
 				field->in_value,
 				0,
 				field->num_bits - 1,
-				JTAG_MODE);
+				ftdi_jtag_mode);
 			uint8_t last_bit = 0;
 			if (field->out_value)
 				bit_copy(&last_bit, 0, field->out_value, field->num_bits - 1, 1);
@@ -458,14 +490,14 @@ static void ftdi_execute_scan(struct jtag_command *cmd)
 					field->num_bits - 1,
 					1,
 					last_bit,
-					JTAG_MODE);
+					ftdi_jtag_mode);
 			tap_set_state(tap_state_transition(tap_get_state(), 1));
 			mpsse_clock_tms_cs_out(mpsse_ctx,
 					&tms_bits,
 					1,
 					1,
 					last_bit,
-					JTAG_MODE);
+					ftdi_jtag_mode);
 			tap_set_state(tap_state_transition(tap_get_state(), 0));
 		} else
 			mpsse_clock_data(mpsse_ctx,
@@ -474,7 +506,7 @@ static void ftdi_execute_scan(struct jtag_command *cmd)
 				field->in_value,
 				0,
 				field->num_bits,
-				JTAG_MODE);
+				ftdi_jtag_mode);
 	}
 
 	if (tap_get_state() != tap_get_end_state())
@@ -553,7 +585,7 @@ static void ftdi_execute_stableclocks(struct jtag_command *cmd)
 	while (num_cycles > 0) {
 		/* there are no state transitions in this code, so omit state tracking */
 		unsigned this_len = num_cycles > 7 ? 7 : num_cycles;
-		mpsse_clock_tms_cs_out(mpsse_ctx, &tms, 0, this_len, false, JTAG_MODE);
+		mpsse_clock_tms_cs_out(mpsse_ctx, &tms, 0, this_len, false, ftdi_jtag_mode);
 		num_cycles -= this_len;
 	}
 
@@ -626,7 +658,7 @@ static int ftdi_initialize(void)
 
 	for (int i = 0; ftdi_vid[i] || ftdi_pid[i]; i++) {
 		mpsse_ctx = mpsse_open(&ftdi_vid[i], &ftdi_pid[i], ftdi_device_desc,
-				ftdi_serial, ftdi_channel);
+				ftdi_serial, ftdi_location, ftdi_channel);
 		if (mpsse_ctx)
 			break;
 	}
@@ -693,6 +725,21 @@ COMMAND_HANDLER(ftdi_handle_serial_command)
 	return ERROR_OK;
 }
 
+#ifdef HAVE_LIBUSB_GET_PORT_NUMBERS
+COMMAND_HANDLER(ftdi_handle_location_command)
+{
+	if (CMD_ARGC == 1) {
+		if (ftdi_location)
+			free(ftdi_location);
+		ftdi_location = strdup(CMD_ARGV[0]);
+	} else {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	return ERROR_OK;
+}
+#endif
+
 COMMAND_HANDLER(ftdi_handle_channel_command)
 {
 	if (CMD_ARGC == 1)
@@ -721,6 +768,8 @@ COMMAND_HANDLER(ftdi_handle_layout_signal_command)
 
 	bool invert_data = false;
 	uint16_t data_mask = 0;
+	bool invert_input = false;
+	uint16_t input_mask = 0;
 	bool invert_oe = false;
 	uint16_t oe_mask = 0;
 	for (unsigned i = 1; i < CMD_ARGC; i += 2) {
@@ -730,6 +779,12 @@ COMMAND_HANDLER(ftdi_handle_layout_signal_command)
 		} else if (strcmp("-ndata", CMD_ARGV[i]) == 0) {
 			invert_data = true;
 			COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i + 1], data_mask);
+		} else if (strcmp("-input", CMD_ARGV[i]) == 0) {
+			invert_input = false;
+			COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i + 1], input_mask);
+		} else if (strcmp("-ninput", CMD_ARGV[i]) == 0) {
+			invert_input = true;
+			COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i + 1], input_mask);
 		} else if (strcmp("-oe", CMD_ARGV[i]) == 0) {
 			invert_oe = false;
 			COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i + 1], oe_mask);
@@ -738,15 +793,19 @@ COMMAND_HANDLER(ftdi_handle_layout_signal_command)
 			COMMAND_PARSE_NUMBER(u16, CMD_ARGV[i + 1], oe_mask);
 		} else if (!strcmp("-alias", CMD_ARGV[i]) ||
 			   !strcmp("-nalias", CMD_ARGV[i])) {
-			if (!strcmp("-nalias", CMD_ARGV[i]))
+			if (!strcmp("-nalias", CMD_ARGV[i])) {
 				invert_data = true;
+				invert_input = true;
+			}
 			struct signal *sig = find_signal_by_name(CMD_ARGV[i + 1]);
 			if (!sig) {
 				LOG_ERROR("signal %s is not defined", CMD_ARGV[i + 1]);
 				return ERROR_FAIL;
 			}
 			data_mask = sig->data_mask;
+			input_mask = sig->input_mask;
 			oe_mask = sig->oe_mask;
+			invert_input ^= sig->invert_input;
 			invert_oe = sig->invert_oe;
 			invert_data ^= sig->invert_data;
 		} else {
@@ -766,6 +825,8 @@ COMMAND_HANDLER(ftdi_handle_layout_signal_command)
 
 	sig->invert_data = invert_data;
 	sig->data_mask = data_mask;
+	sig->invert_input = invert_input;
+	sig->input_mask = input_mask;
 	sig->invert_oe = invert_oe;
 	sig->oe_mask = oe_mask;
 
@@ -794,6 +855,7 @@ COMMAND_HANDLER(ftdi_handle_set_signal_command)
 			ftdi_set_signal(sig, *CMD_ARGV[1]);
 			break;
 		}
+		/* fallthrough */
 	default:
 		LOG_ERROR("unknown signal level '%s', use 0, 1 or z", CMD_ARGV[1]);
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -802,6 +864,28 @@ COMMAND_HANDLER(ftdi_handle_set_signal_command)
 	return mpsse_flush(mpsse_ctx);
 }
 
+COMMAND_HANDLER(ftdi_handle_get_signal_command)
+{
+	if (CMD_ARGC < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct signal *sig;
+	uint16_t sig_data = 0;
+	sig = find_signal_by_name(CMD_ARGV[0]);
+	if (!sig) {
+		LOG_ERROR("interface configuration doesn't define signal '%s'", CMD_ARGV[0]);
+		return ERROR_FAIL;
+	}
+
+	int ret = ftdi_get_signal(sig, &sig_data);
+	if (ret != ERROR_OK)
+		return ret;
+
+	LOG_USER("Signal %s = %#06x", sig->name, sig_data);
+
+	return ERROR_OK;
+}
+
 COMMAND_HANDLER(ftdi_handle_vid_pid_command)
 {
 	if (CMD_ARGC > MAX_USB_IDS * 2) {
@@ -832,6 +916,29 @@ COMMAND_HANDLER(ftdi_handle_vid_pid_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(ftdi_handle_tdo_sample_edge_command)
+{
+	Jim_Nvp *n;
+	static const Jim_Nvp nvp_ftdi_jtag_modes[] = {
+		{ .name = "rising", .value = JTAG_MODE },
+		{ .name = "falling", .value = JTAG_MODE_ALT },
+		{ .name = NULL, .value = -1 },
+	};
+
+	if (CMD_ARGC > 0) {
+		n = Jim_Nvp_name2value_simple(nvp_ftdi_jtag_modes, CMD_ARGV[0]);
+		if (n->name == NULL)
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		ftdi_jtag_mode = n->value;
+
+	}
+
+	n = Jim_Nvp_value2name_simple(nvp_ftdi_jtag_modes, ftdi_jtag_mode);
+	command_print(CMD_CTX, "ftdi samples TDO on %s edge of TCK", n->name);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration ftdi_command_handlers[] = {
 	{
 		.name = "ftdi_device_desc",
@@ -847,6 +954,15 @@ static const struct command_registration ftdi_command_handlers[] = {
 		.help = "set the serial number of the FTDI device",
 		.usage = "serial_string",
 	},
+#ifdef HAVE_LIBUSB_GET_PORT_NUMBERS
+	{
+		.name = "ftdi_location",
+		.handler = &ftdi_handle_location_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the USB bus location of the FTDI device",
+		.usage = "<bus>:port[,port]...",
+	},
+#endif
 	{
 		.name = "ftdi_channel",
 		.handler = &ftdi_handle_channel_command,
@@ -877,6 +993,13 @@ static const struct command_registration ftdi_command_handlers[] = {
 		.help = "control a layout-specific signal",
 		.usage = "name (1|0|z)",
 	},
+	{
+		.name = "ftdi_get_signal",
+		.handler = &ftdi_handle_get_signal_command,
+		.mode = COMMAND_EXEC,
+		.help = "read the value of a layout-specific signal",
+		.usage = "name",
+	},
 	{
 		.name = "ftdi_vid_pid",
 		.handler = &ftdi_handle_vid_pid_command,
@@ -884,6 +1007,15 @@ static const struct command_registration ftdi_command_handlers[] = {
 		.help = "the vendor ID and product ID of the FTDI device",
 		.usage = "(vid pid)* ",
 	},
+	{
+		.name = "ftdi_tdo_sample_edge",
+		.handler = &ftdi_handle_tdo_sample_edge_command,
+		.mode = COMMAND_ANY,
+		.help = "set which TCK clock edge is used for sampling TDO "
+			"- default is rising-edge (Setting to falling-edge may "
+			"allow signalling speed increase)",
+		.usage = "(rising|falling)",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -943,12 +1075,12 @@ static void ftdi_swd_swdio_en(bool enable)
  */
 static int ftdi_swd_run_queue(void)
 {
-	LOG_DEBUG("Executing %zu queued transactions", swd_cmd_queue_length);
+	LOG_DEBUG_IO("Executing %zu queued transactions", swd_cmd_queue_length);
 	int retval;
 	struct signal *led = find_signal_by_name("LED");
 
 	if (queued_retval != ERROR_OK) {
-		LOG_DEBUG("Skipping due to previous errors: %d", queued_retval);
+		LOG_DEBUG_IO("Skipping due to previous errors: %d", queued_retval);
 		goto skip;
 	}
 
@@ -969,7 +1101,7 @@ static int ftdi_swd_run_queue(void)
 	for (size_t i = 0; i < swd_cmd_queue_length; i++) {
 		int ack = buf_get_u32(swd_cmd_queue[i].trn_ack_data_parity_trn, 1, 3);
 
-		LOG_DEBUG("%s %s %s reg %X = %08"PRIx32,
+		LOG_DEBUG_IO("%s %s %s reg %X = %08"PRIx32,
 				ack == SWD_ACK_OK ? "OK" : ack == SWD_ACK_WAIT ? "WAIT" : ack == SWD_ACK_FAULT ? "FAULT" : "JUNK",
 				swd_cmd_queue[i].cmd & SWD_CMD_APnDP ? "AP" : "DP",
 				swd_cmd_queue[i].cmd & SWD_CMD_RnW ? "read" : "write",
@@ -1086,14 +1218,17 @@ static int ftdi_swd_switch_seq(enum swd_special_seq seq)
 	switch (seq) {
 	case LINE_RESET:
 		LOG_DEBUG("SWD line reset");
+		ftdi_swd_swdio_en(true);
 		mpsse_clock_data_out(mpsse_ctx, swd_seq_line_reset, 0, swd_seq_line_reset_len, SWD_MODE);
 		break;
 	case JTAG_TO_SWD:
 		LOG_DEBUG("JTAG-to-SWD");
+		ftdi_swd_swdio_en(true);
 		mpsse_clock_data_out(mpsse_ctx, swd_seq_jtag_to_swd, 0, swd_seq_jtag_to_swd_len, SWD_MODE);
 		break;
 	case SWD_TO_JTAG:
 		LOG_DEBUG("SWD-to-JTAG");
+		ftdi_swd_swdio_en(true);
 		mpsse_clock_data_out(mpsse_ctx, swd_seq_swd_to_jtag, 0, swd_seq_swd_to_jtag_len, SWD_MODE);
 		break;
 	default:
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
index 6f79f0cc..f6689969 100644
--- a/src/jtag/drivers/gw16012.c
+++ b/src/jtag/drivers/gw16012.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/imx_gpio.c b/src/jtag/drivers/imx_gpio.c
new file mode 100644
index 00000000..f33d1097
--- /dev/null
+++ b/src/jtag/drivers/imx_gpio.c
@@ -0,0 +1,552 @@
+/***************************************************************************
+ *   Copyright (C) 2017 by Grzegorz Kostka, kostka.grzegorz@gmail.com      *
+ *                                                                         *
+ *   Based on bcm2835gpio.c                                                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include "bitbang.h"
+
+#include <sys/mman.h>
+
+#define IMX_GPIO_BASE 0x0209c000
+#define IMX_GPIO_SIZE 0x00004000
+#define IMX_GPIO_REGS_COUNT 8
+
+static uint32_t imx_gpio_peri_base = IMX_GPIO_BASE;
+
+struct imx_gpio_regs {
+	uint32_t dr;
+	uint32_t gdir;
+	uint32_t psr;
+	uint32_t icr1;
+	uint32_t icr2;
+	uint32_t imr;
+	uint32_t isr;
+	uint32_t edge_sel;
+} __attribute__((aligned(IMX_GPIO_SIZE)));
+
+static int dev_mem_fd;
+static volatile struct imx_gpio_regs *pio_base;
+
+/* GPIO setup functions */
+static inline bool gpio_mode_get(int g)
+{
+	return pio_base[g / 32].gdir >> (g & 0x1F) & 1;
+}
+
+static inline void gpio_mode_input_set(int g)
+{
+	pio_base[g / 32].gdir &=  ~(1u << (g & 0x1F));
+}
+
+static inline void gpio_mode_output_set(int g)
+{
+	pio_base[g / 32].gdir |=  (1u << (g & 0x1F));
+}
+
+static inline void gpio_mode_set(int g, int m)
+{
+	(m) ? gpio_mode_output_set(g) : gpio_mode_input_set(g);
+}
+
+static inline void gpio_set(int g)
+{
+	pio_base[g / 32].dr |=  (1u << (g & 0x1F));
+}
+
+static inline void gpio_clear(int g)
+{
+	pio_base[g / 32].dr &=  ~(1u << (g & 0x1F));
+}
+
+static inline bool gpio_level(int g)
+{
+	return pio_base[g / 32].dr >> (g & 0x1F) & 1;
+}
+
+static int imx_gpio_read(void);
+static void imx_gpio_write(int tck, int tms, int tdi);
+static void imx_gpio_reset(int trst, int srst);
+
+static int imx_gpio_swdio_read(void);
+static void imx_gpio_swdio_drive(bool is_output);
+
+static int imx_gpio_init(void);
+static int imx_gpio_quit(void);
+
+static struct bitbang_interface imx_gpio_bitbang = {
+	.read = imx_gpio_read,
+	.write = imx_gpio_write,
+	.reset = imx_gpio_reset,
+	.swdio_read = imx_gpio_swdio_read,
+	.swdio_drive = imx_gpio_swdio_drive,
+	.blink = NULL
+};
+
+/* GPIO numbers for each signal. Negative values are invalid */
+static int tck_gpio = -1;
+static int tck_gpio_mode;
+static int tms_gpio = -1;
+static int tms_gpio_mode;
+static int tdi_gpio = -1;
+static int tdi_gpio_mode;
+static int tdo_gpio = -1;
+static int tdo_gpio_mode;
+static int trst_gpio = -1;
+static int trst_gpio_mode;
+static int srst_gpio = -1;
+static int srst_gpio_mode;
+static int swclk_gpio = -1;
+static int swclk_gpio_mode;
+static int swdio_gpio = -1;
+static int swdio_gpio_mode;
+
+/* Transition delay coefficients. Tuned for IMX6UL 528MHz. Adjusted
+ * experimentally for:10kHz, 100Khz, 500KHz. Speeds above 800Khz are impossible
+ * to reach via memory mapped method (at least for IMX6UL@528MHz).
+ * Measured mmap raw GPIO toggling speed on IMX6UL@528MHz: 1.3MHz.
+ */
+static int speed_coeff = 50000;
+static int speed_offset = 100;
+static unsigned int jtag_delay;
+
+static int imx_gpio_read(void)
+{
+	return gpio_level(tdo_gpio);
+}
+
+static void imx_gpio_write(int tck, int tms, int tdi)
+{
+	tms ? gpio_set(tms_gpio) : gpio_clear(tms_gpio);
+	tdi ? gpio_set(tdi_gpio) : gpio_clear(tdi_gpio);
+	tck ? gpio_set(tck_gpio) : gpio_clear(tck_gpio);
+
+	for (unsigned int i = 0; i < jtag_delay; i++)
+		asm volatile ("");
+}
+
+static void imx_gpio_swd_write(int tck, int tms, int tdi)
+{
+	tdi ? gpio_set(swdio_gpio) : gpio_clear(swdio_gpio);
+	tck ? gpio_set(swclk_gpio) : gpio_clear(swclk_gpio);
+
+	for (unsigned int i = 0; i < jtag_delay; i++)
+		asm volatile ("");
+}
+
+/* (1) assert or (0) deassert reset lines */
+static void imx_gpio_reset(int trst, int srst)
+{
+	if (trst_gpio != -1)
+		trst ? gpio_set(trst_gpio) : gpio_clear(trst_gpio);
+
+	if (srst_gpio != -1)
+		srst ? gpio_set(srst_gpio) : gpio_clear(srst_gpio);
+}
+
+static void imx_gpio_swdio_drive(bool is_output)
+{
+	if (is_output)
+		gpio_mode_output_set(swdio_gpio);
+	else
+		gpio_mode_input_set(swdio_gpio);
+}
+
+static int imx_gpio_swdio_read(void)
+{
+	return gpio_level(swdio_gpio);
+}
+
+static int imx_gpio_khz(int khz, int *jtag_speed)
+{
+	if (!khz) {
+		LOG_DEBUG("RCLK not supported");
+		return ERROR_FAIL;
+	}
+	*jtag_speed = speed_coeff/khz - speed_offset;
+	if (*jtag_speed < 0)
+		*jtag_speed = 0;
+	return ERROR_OK;
+}
+
+static int imx_gpio_speed_div(int speed, int *khz)
+{
+	*khz = speed_coeff/(speed + speed_offset);
+	return ERROR_OK;
+}
+
+static int imx_gpio_speed(int speed)
+{
+	jtag_delay = speed;
+	return ERROR_OK;
+}
+
+static int is_gpio_valid(int gpio)
+{
+	return gpio >= 0 && gpio < 32 * IMX_GPIO_REGS_COUNT;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionums)
+{
+	if (CMD_ARGC == 4) {
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tck_gpio);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], tms_gpio);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], tdi_gpio);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[3], tdo_gpio);
+	} else if (CMD_ARGC != 0) {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	command_print(CMD_CTX,
+			"imx_gpio GPIO config: tck = %d, tms = %d, tdi = %d, tdo = %d",
+			tck_gpio, tms_gpio, tdi_gpio, tdo_gpio);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionum_tck)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tck_gpio);
+
+	command_print(CMD_CTX, "imx_gpio GPIO config: tck = %d", tck_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionum_tms)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tms_gpio);
+
+	command_print(CMD_CTX, "imx_gpio GPIO config: tms = %d", tms_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionum_tdo)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tdo_gpio);
+
+	command_print(CMD_CTX, "imx_gpio GPIO config: tdo = %d", tdo_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionum_tdi)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], tdi_gpio);
+
+	command_print(CMD_CTX, "imx_gpio GPIO config: tdi = %d", tdi_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionum_srst)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], srst_gpio);
+
+	command_print(CMD_CTX, "imx_gpio GPIO config: srst = %d", srst_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_jtag_gpionum_trst)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], trst_gpio);
+
+	command_print(CMD_CTX, "imx_gpio GPIO config: trst = %d", trst_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_swd_gpionums)
+{
+	if (CMD_ARGC == 2) {
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swclk_gpio);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], swdio_gpio);
+	} else if (CMD_ARGC != 0) {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	command_print(CMD_CTX,
+			"imx_gpio GPIO nums: swclk = %d, swdio = %d",
+			swclk_gpio, swdio_gpio);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_swd_gpionum_swclk)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swclk_gpio);
+
+	command_print(CMD_CTX, "imx_gpio num: swclk = %d", swclk_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_swd_gpionum_swdio)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], swdio_gpio);
+
+	command_print(CMD_CTX, "imx_gpio num: swdio = %d", swdio_gpio);
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_speed_coeffs)
+{
+	if (CMD_ARGC == 2) {
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], speed_coeff);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], speed_offset);
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(imx_gpio_handle_peripheral_base)
+{
+	if (CMD_ARGC == 1)
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], imx_gpio_peri_base);
+	return ERROR_OK;
+}
+
+static const struct command_registration imx_gpio_command_handlers[] = {
+	{
+		.name = "imx_gpio_jtag_nums",
+		.handler = &imx_gpio_handle_jtag_gpionums,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio numbers for tck, tms, tdi, tdo. (in that order)",
+		.usage = "(tck tms tdi tdo)* ",
+	},
+	{
+		.name = "imx_gpio_tck_num",
+		.handler = &imx_gpio_handle_jtag_gpionum_tck,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for tck.",
+	},
+	{
+		.name = "imx_gpio_tms_num",
+		.handler = &imx_gpio_handle_jtag_gpionum_tms,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for tms.",
+	},
+	{
+		.name = "imx_gpio_tdo_num",
+		.handler = &imx_gpio_handle_jtag_gpionum_tdo,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for tdo.",
+	},
+	{
+		.name = "imx_gpio_tdi_num",
+		.handler = &imx_gpio_handle_jtag_gpionum_tdi,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for tdi.",
+	},
+	{
+		.name = "imx_gpio_swd_nums",
+		.handler = &imx_gpio_handle_swd_gpionums,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio numbers for swclk, swdio. (in that order)",
+		.usage = "(swclk swdio)* ",
+	},
+	{
+		.name = "imx_gpio_swclk_num",
+		.handler = &imx_gpio_handle_swd_gpionum_swclk,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for swclk.",
+	},
+	{
+		.name = "imx_gpio_swdio_num",
+		.handler = &imx_gpio_handle_swd_gpionum_swdio,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for swdio.",
+	},
+	{
+		.name = "imx_gpio_srst_num",
+		.handler = &imx_gpio_handle_jtag_gpionum_srst,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for srst.",
+	},
+	{
+		.name = "imx_gpio_trst_num",
+		.handler = &imx_gpio_handle_jtag_gpionum_trst,
+		.mode = COMMAND_CONFIG,
+		.help = "gpio number for trst.",
+	},
+	{
+		.name = "imx_gpio_speed_coeffs",
+		.handler = &imx_gpio_handle_speed_coeffs,
+		.mode = COMMAND_CONFIG,
+		.help = "SPEED_COEFF and SPEED_OFFSET for delay calculations.",
+	},
+	{
+		.name = "imx_gpio_peripheral_base",
+		.handler = &imx_gpio_handle_peripheral_base,
+		.mode = COMMAND_CONFIG,
+		.help = "peripheral base to access GPIOs (0x0209c000 for most IMX).",
+	},
+
+	COMMAND_REGISTRATION_DONE
+};
+
+static const char * const imx_gpio_transports[] = { "jtag", "swd", NULL };
+
+struct jtag_interface imx_gpio_interface = {
+	.name = "imx_gpio",
+	.supported = DEBUG_CAP_TMS_SEQ,
+	.execute_queue = bitbang_execute_queue,
+	.transports = imx_gpio_transports,
+	.swd = &bitbang_swd,
+	.speed = imx_gpio_speed,
+	.khz = imx_gpio_khz,
+	.speed_div = imx_gpio_speed_div,
+	.commands = imx_gpio_command_handlers,
+	.init = imx_gpio_init,
+	.quit = imx_gpio_quit,
+};
+
+static bool imx_gpio_jtag_mode_possible(void)
+{
+	if (!is_gpio_valid(tck_gpio))
+		return 0;
+	if (!is_gpio_valid(tms_gpio))
+		return 0;
+	if (!is_gpio_valid(tdi_gpio))
+		return 0;
+	if (!is_gpio_valid(tdo_gpio))
+		return 0;
+	return 1;
+}
+
+static bool imx_gpio_swd_mode_possible(void)
+{
+	if (!is_gpio_valid(swclk_gpio))
+		return 0;
+	if (!is_gpio_valid(swdio_gpio))
+		return 0;
+	return 1;
+}
+
+static int imx_gpio_init(void)
+{
+	bitbang_interface = &imx_gpio_bitbang;
+
+	LOG_INFO("imx_gpio GPIO JTAG/SWD bitbang driver");
+
+	if (imx_gpio_jtag_mode_possible()) {
+		if (imx_gpio_swd_mode_possible())
+			LOG_INFO("JTAG and SWD modes enabled");
+		else
+			LOG_INFO("JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)");
+	} else if (imx_gpio_swd_mode_possible()) {
+		LOG_INFO("SWD only mode enabled (specify tck, tms, tdi and tdo gpios to add JTAG mode)");
+	} else {
+		LOG_ERROR("Require tck, tms, tdi and tdo gpios for JTAG mode and/or swclk and swdio gpio for SWD mode");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	dev_mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
+	if (dev_mem_fd < 0) {
+		perror("open");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+
+	LOG_INFO("imx_gpio mmap: pagesize: %u, regionsize: %u",
+			sysconf(_SC_PAGE_SIZE), IMX_GPIO_REGS_COUNT * IMX_GPIO_SIZE);
+	pio_base = mmap(NULL, IMX_GPIO_REGS_COUNT * IMX_GPIO_SIZE,
+				PROT_READ | PROT_WRITE,
+				MAP_SHARED, dev_mem_fd, imx_gpio_peri_base);
+
+	if (pio_base == MAP_FAILED) {
+		perror("mmap");
+		close(dev_mem_fd);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	/*
+	 * Configure TDO as an input, and TDI, TCK, TMS, TRST, SRST
+	 * as outputs.  Drive TDI and TCK low, and TMS/TRST/SRST high.
+	 */
+	if (imx_gpio_jtag_mode_possible()) {
+		tdo_gpio_mode = gpio_mode_get(tdo_gpio);
+		tdi_gpio_mode = gpio_mode_get(tdi_gpio);
+		tck_gpio_mode = gpio_mode_get(tck_gpio);
+		tms_gpio_mode = gpio_mode_get(tms_gpio);
+
+		gpio_clear(tdi_gpio);
+		gpio_clear(tck_gpio);
+		gpio_set(tms_gpio);
+
+		gpio_mode_input_set(tdo_gpio);
+		gpio_mode_output_set(tdi_gpio);
+		gpio_mode_output_set(tck_gpio);
+		gpio_mode_output_set(tms_gpio);
+	}
+	if (imx_gpio_swd_mode_possible()) {
+		swclk_gpio_mode = gpio_mode_get(swclk_gpio);
+		swdio_gpio_mode = gpio_mode_get(swdio_gpio);
+
+		gpio_clear(swdio_gpio);
+		gpio_clear(swclk_gpio);
+		gpio_mode_output_set(swclk_gpio);
+		gpio_mode_output_set(swdio_gpio);
+	}
+	if (trst_gpio != -1) {
+		trst_gpio_mode = gpio_mode_get(trst_gpio);
+		gpio_set(trst_gpio);
+		gpio_mode_output_set(trst_gpio);
+	}
+	if (srst_gpio != -1) {
+		srst_gpio_mode = gpio_mode_get(srst_gpio);
+		gpio_set(srst_gpio);
+		gpio_mode_output_set(srst_gpio);
+	}
+
+	LOG_DEBUG("saved pinmux settings: tck %d tms %d tdi %d "
+		  "tdo %d trst %d srst %d", tck_gpio_mode, tms_gpio_mode,
+		  tdi_gpio_mode, tdo_gpio_mode, trst_gpio_mode, srst_gpio_mode);
+
+	if (swd_mode) {
+		imx_gpio_bitbang.write = imx_gpio_swd_write;
+		bitbang_switch_to_swd();
+	}
+
+	return ERROR_OK;
+}
+
+static int imx_gpio_quit(void)
+{
+	if (imx_gpio_jtag_mode_possible()) {
+		gpio_mode_set(tdo_gpio, tdo_gpio_mode);
+		gpio_mode_set(tdi_gpio, tdi_gpio_mode);
+		gpio_mode_set(tck_gpio, tck_gpio_mode);
+		gpio_mode_set(tms_gpio, tms_gpio_mode);
+	}
+	if (imx_gpio_swd_mode_possible()) {
+		gpio_mode_set(swclk_gpio, swclk_gpio_mode);
+		gpio_mode_set(swdio_gpio, swdio_gpio_mode);
+	}
+	if (trst_gpio != -1)
+		gpio_mode_set(trst_gpio, trst_gpio_mode);
+	if (srst_gpio != -1)
+		gpio_mode_set(srst_gpio, srst_gpio_mode);
+
+	return ERROR_OK;
+}
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 84127ab5..132ef06e 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -11,6 +11,9 @@
  *   Copyright (C) 2015 by Marc Schink                                     *
  *   openocd-dev@marcschink.de                                             *
  *                                                                         *
+ *   Copyright (C) 2015 by Paul Fertser                                    *
+ *   fercerpav@gmail.com                                                   *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -22,8 +25,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -48,9 +50,9 @@ static uint8_t caps[JAYLINK_DEV_EXT_CAPS_SIZE];
 
 static uint32_t serial_number;
 static bool use_serial_number;
-static uint8_t usb_address;
+static enum jaylink_usb_address usb_address;
 static bool use_usb_address;
-static uint8_t iface = JAYLINK_TIF_JTAG;
+static enum jaylink_target_interface iface = JAYLINK_TIF_JTAG;
 static bool trace_enabled;
 
 #define JLINK_MAX_SPEED			12000
@@ -83,9 +85,8 @@ static struct device_config tmp_config;
 static void jlink_end_state(tap_state_t state);
 static void jlink_state_move(void);
 static void jlink_path_move(int num_states, tap_state_t *path);
+static void jlink_stableclocks(int num_cycles);
 static void jlink_runtest(int num_cycles);
-static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
-		int scan_size, struct scan_command *command);
 static void jlink_reset(int trst, int srst);
 static int jlink_swd_run_queue(void);
 static void jlink_swd_queue_cmd(uint8_t cmd, uint32_t *dst, uint32_t data, uint32_t ap_delay_clk);
@@ -93,11 +94,25 @@ static int jlink_swd_switch_seq(enum swd_special_seq seq);
 
 /* J-Link tap buffer functions */
 static void jlink_tap_init(void);
-static int jlink_tap_execute(void);
-static void jlink_tap_ensure_space(int scans, int bits);
-static void jlink_tap_append_step(int tms, int tdi);
-static void jlink_tap_append_scan(int length, uint8_t *buffer,
-		struct scan_command *command);
+static int jlink_flush(void);
+/**
+ * Queue data to go out and in, flushing the queue as many times as
+ * necessary.
+ *
+ * @param out A pointer to TDI data, if NULL, old stale data will be used.
+ * @param out_offset A bit offset for TDI data.
+ * @param tms_out A pointer to TMS data, if NULL, zeroes will be emitted.
+ * @param tms_offset A bit offset for TMS data.
+ * @param in A pointer to store TDO data to, if NULL the data will be discarded.
+ * @param in_offset A bit offset for TDO data.
+ * @param length Amount of bits to transfer out and in.
+ *
+ * @retval This function doesn't return any value.
+ */
+static void jlink_clock_data(const uint8_t *out, unsigned out_offset,
+			     const uint8_t *tms_out, unsigned tms_offset,
+			     uint8_t *in, unsigned in_offset,
+			     unsigned length);
 
 static enum tap_state jlink_last_state = TAP_RESET;
 static int queued_retval;
@@ -105,6 +120,12 @@ static int queued_retval;
 /***************************************************************************/
 /* External interface implementation */
 
+static void jlink_execute_stableclocks(struct jtag_command *cmd)
+{
+	DEBUG_JTAG_IO("stableclocks %i cycles", cmd->cmd.runtest->num_cycles);
+	jlink_stableclocks(cmd->cmd.runtest->num_cycles);
+}
+
 static void jlink_execute_runtest(struct jtag_command *cmd)
 {
 	DEBUG_JTAG_IO("runtest %i cycles, end in %i", cmd->cmd.runtest->num_cycles,
@@ -133,19 +154,95 @@ static void jlink_execute_pathmove(struct jtag_command *cmd)
 
 static void jlink_execute_scan(struct jtag_command *cmd)
 {
-	int scan_size;
-	enum scan_type type;
-	uint8_t *buffer;
+	DEBUG_JTAG_IO("%s type:%d", cmd->cmd.scan->ir_scan ? "IRSCAN" : "DRSCAN",
+		jtag_scan_type(cmd->cmd.scan));
+
+	/* Make sure there are no trailing fields with num_bits == 0, or the logic below will fail. */
+	while (cmd->cmd.scan->num_fields > 0
+			&& cmd->cmd.scan->fields[cmd->cmd.scan->num_fields - 1].num_bits == 0) {
+		cmd->cmd.scan->num_fields--;
+		LOG_DEBUG("discarding trailing empty field");
+	}
 
-	DEBUG_JTAG_IO("scan end in %s", tap_state_name(cmd->cmd.scan->end_state));
+	if (cmd->cmd.scan->num_fields == 0) {
+		LOG_DEBUG("empty scan, doing nothing");
+		return;
+	}
+
+	if (cmd->cmd.scan->ir_scan) {
+		if (tap_get_state() != TAP_IRSHIFT) {
+			jlink_end_state(TAP_IRSHIFT);
+			jlink_state_move();
+		}
+	} else {
+		if (tap_get_state() != TAP_DRSHIFT) {
+			jlink_end_state(TAP_DRSHIFT);
+			jlink_state_move();
+		}
+	}
 
 	jlink_end_state(cmd->cmd.scan->end_state);
 
-	scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
-	DEBUG_JTAG_IO("scan input, length = %d", scan_size);
+	struct scan_field *field = cmd->cmd.scan->fields;
+	unsigned scan_size = 0;
+
+	for (int i = 0; i < cmd->cmd.scan->num_fields; i++, field++) {
+		scan_size += field->num_bits;
+		DEBUG_JTAG_IO("%s%s field %d/%d %d bits",
+			field->in_value ? "in" : "",
+			field->out_value ? "out" : "",
+			i,
+			cmd->cmd.scan->num_fields,
+			field->num_bits);
+
+		if (i == cmd->cmd.scan->num_fields - 1 && tap_get_state() != tap_get_end_state()) {
+			/* Last field, and we're leaving IRSHIFT/DRSHIFT. Clock last bit during tap
+			 * movement. This last field can't have length zero, it was checked above. */
+			jlink_clock_data(field->out_value,
+					 0,
+					 NULL,
+					 0,
+					 field->in_value,
+					 0,
+					 field->num_bits - 1);
+			uint8_t last_bit = 0;
+			if (field->out_value)
+				bit_copy(&last_bit, 0, field->out_value, field->num_bits - 1, 1);
+			uint8_t tms_bits = 0x01;
+			jlink_clock_data(&last_bit,
+					 0,
+					 &tms_bits,
+					 0,
+					 field->in_value,
+					 field->num_bits - 1,
+					 1);
+			tap_set_state(tap_state_transition(tap_get_state(), 1));
+			jlink_clock_data(NULL,
+					 0,
+					 &tms_bits,
+					 1,
+					 NULL,
+					 0,
+					 1);
+			tap_set_state(tap_state_transition(tap_get_state(), 0));
+		} else
+			jlink_clock_data(field->out_value,
+					 0,
+					 NULL,
+					 0,
+					 field->in_value,
+					 0,
+					 field->num_bits);
+	}
+
+	if (tap_get_state() != tap_get_end_state()) {
+		jlink_end_state(tap_get_end_state());
+		jlink_state_move();
+	}
 
-	type = jtag_scan_type(cmd->cmd.scan);
-	jlink_scan(cmd->cmd.scan->ir_scan, type, buffer, scan_size, cmd->cmd.scan);
+	DEBUG_JTAG_IO("%s scan, %i bits, end in %s",
+		(cmd->cmd.scan->ir_scan) ? "IR" : "DR", scan_size,
+		tap_state_name(tap_get_end_state()));
 }
 
 static void jlink_execute_reset(struct jtag_command *cmd)
@@ -153,21 +250,24 @@ static void jlink_execute_reset(struct jtag_command *cmd)
 	DEBUG_JTAG_IO("reset trst: %i srst %i", cmd->cmd.reset->trst,
 		cmd->cmd.reset->srst);
 
-	jlink_tap_execute();
+	jlink_flush();
 	jlink_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
-	jlink_tap_execute();
+	jlink_flush();
 }
 
 static void jlink_execute_sleep(struct jtag_command *cmd)
 {
 	DEBUG_JTAG_IO("sleep %" PRIi32 "", cmd->cmd.sleep->us);
-	jlink_tap_execute();
+	jlink_flush();
 	jtag_sleep(cmd->cmd.sleep->us);
 }
 
 static int jlink_execute_command(struct jtag_command *cmd)
 {
 	switch (cmd->type) {
+		case JTAG_STABLECLOCKS:
+			jlink_execute_stableclocks(cmd);
+			break;
 		case JTAG_RUNTEST:
 			jlink_execute_runtest(cmd);
 			break;
@@ -208,27 +308,26 @@ static int jlink_execute_queue(void)
 		cmd = cmd->next;
 	}
 
-	return jlink_tap_execute();
+	return jlink_flush();
 }
 
 static int jlink_speed(int speed)
 {
 	int ret;
-	uint32_t freq;
-	uint16_t divider;
+	struct jaylink_speed tmp;
 	int max_speed;
 
 	if (jaylink_has_cap(caps, JAYLINK_DEV_CAP_GET_SPEEDS)) {
-		ret = jaylink_get_speeds(devh, &freq, &divider);
+		ret = jaylink_get_speeds(devh, &tmp);
 
 		if (ret != JAYLINK_OK) {
 			LOG_ERROR("jaylink_get_speeds() failed: %s.",
-				jaylink_strerror_name(ret));
+				jaylink_strerror(ret));
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
-		freq = freq / 1000;
-		max_speed = freq / divider;
+		tmp.freq /= 1000;
+		max_speed = tmp.freq / tmp.div;
 	} else {
 		max_speed = JLINK_MAX_SPEED;
 	}
@@ -250,7 +349,7 @@ static int jlink_speed(int speed)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_set_speed() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -279,7 +378,7 @@ static bool read_device_config(struct device_config *cfg)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_read_raw_config() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return false;
 	}
 
@@ -310,7 +409,7 @@ static int select_interface(void)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_get_available_interfaces() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -319,11 +418,11 @@ static int select_interface(void)
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	ret = jaylink_select_interface(devh, iface);
+	ret = jaylink_select_interface(devh, iface, NULL);
 
 	if (ret < 0) {
 		LOG_ERROR("jaylink_select_interface() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -333,23 +432,23 @@ static int select_interface(void)
 static int jlink_register(void)
 {
 	int ret;
-	int i;
+	size_t i;
 	bool handle_found;
+	size_t count;
 
 	if (!jaylink_has_cap(caps, JAYLINK_DEV_CAP_REGISTER))
 		return ERROR_OK;
 
-	ret = jaylink_register(devh, &conn, connlist, NULL, NULL);
+	ret = jaylink_register(devh, &conn, connlist, &count);
 
-	if (ret < 0) {
-		LOG_ERROR("jaylink_register() failed: %s.",
-			jaylink_strerror_name(ret));
+	if (ret != JAYLINK_OK) {
+		LOG_ERROR("jaylink_register() failed: %s.", jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
 	handle_found = false;
 
-	for (i = 0; i < ret; i++) {
+	for (i = 0; i < count; i++) {
 		if (connlist[i].handle == conn.handle) {
 			handle_found = true;
 			break;
@@ -382,7 +481,7 @@ static bool adjust_swd_buffer_size(void)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_get_free_memory() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return false;
 	}
 
@@ -402,6 +501,39 @@ static bool adjust_swd_buffer_size(void)
 	return true;
 }
 
+static int jaylink_log_handler(const struct jaylink_context *ctx,
+		enum jaylink_log_level level, const char *format, va_list args,
+		void *user_data)
+{
+	enum log_levels tmp;
+
+	switch (level) {
+	case JAYLINK_LOG_LEVEL_ERROR:
+		tmp = LOG_LVL_ERROR;
+		break;
+	case JAYLINK_LOG_LEVEL_WARNING:
+		tmp = LOG_LVL_WARNING;
+		break;
+	/*
+	 * Forward info messages to the debug output because they are more verbose
+	 * than info messages of OpenOCD.
+	 */
+	case JAYLINK_LOG_LEVEL_INFO:
+	case JAYLINK_LOG_LEVEL_DEBUG:
+		tmp = LOG_LVL_DEBUG;
+		break;
+	case JAYLINK_LOG_LEVEL_DEBUG_IO:
+		tmp = LOG_LVL_DEBUG_IO;
+		break;
+	default:
+		tmp = LOG_LVL_WARNING;
+	}
+
+	log_vprintf_lf(tmp, __FILE__, __LINE__, __func__, format, args);
+
+	return 0;
+}
+
 static int jlink_init(void)
 {
 	int ret;
@@ -412,51 +544,108 @@ static int jlink_init(void)
 	char *firmware_version;
 	struct jaylink_hardware_version hwver;
 	struct jaylink_hardware_status hwstatus;
+	enum jaylink_usb_address address;
+	size_t length;
+	size_t num_devices;
+	uint32_t host_interfaces;
+
+	LOG_DEBUG("Using libjaylink %s (compiled with %s).",
+		jaylink_version_package_get_string(), JAYLINK_VERSION_PACKAGE_STRING);
+
+	if (!jaylink_library_has_cap(JAYLINK_CAP_HIF_USB) && use_usb_address) {
+		LOG_ERROR("J-Link driver does not support USB devices.");
+		return ERROR_JTAG_INIT_FAILED;
+	}
 
 	ret = jaylink_init(&jayctx);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_init() failed: %s.",
-			jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_init() failed: %s.", jaylink_strerror(ret));
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	ret = jaylink_get_device_list(jayctx, &devs);
+	ret = jaylink_log_set_callback(jayctx, &jaylink_log_handler, NULL);
 
-	if (ret < 0) {
-		LOG_ERROR("jaylink_get_device_list() failed: %s.",
-			jaylink_strerror_name(ret));
+	if (ret != JAYLINK_OK) {
+		LOG_ERROR("jaylink_log_set_callback() failed: %s.",
+			jaylink_strerror(ret));
 		jaylink_exit(jayctx);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	found_device = false;
+	host_interfaces = JAYLINK_HIF_USB;
+
+	if (use_serial_number)
+		host_interfaces |= JAYLINK_HIF_TCP;
 
-	if (!use_serial_number && !use_usb_address)
-		LOG_INFO("No device selected, using first device.");
+	ret = jaylink_discovery_scan(jayctx, host_interfaces);
+
+	if (ret != JAYLINK_OK) {
+		LOG_ERROR("jaylink_discovery_scan() failed: %s.",
+			jaylink_strerror(ret));
+		jaylink_exit(jayctx);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	ret = jaylink_get_devices(jayctx, &devs, &num_devices);
+
+	if (ret != JAYLINK_OK) {
+		LOG_ERROR("jaylink_get_devices() failed: %s.", jaylink_strerror(ret));
+		jaylink_exit(jayctx);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	if (!use_serial_number && !use_usb_address && num_devices > 1) {
+		LOG_ERROR("Multiple devices found, specify the desired device.");
+		jaylink_free_devices(devs, true);
+		jaylink_exit(jayctx);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	found_device = false;
 
 	for (i = 0; devs[i]; i++) {
-		jaylink_device_get_serial_number(devs[i], &tmp);
-		ret = jaylink_device_get_usb_address(devs[i]);
+		if (use_serial_number) {
+			ret = jaylink_device_get_serial_number(devs[i], &tmp);
+
+			if (ret == JAYLINK_ERR_NOT_AVAILABLE) {
+				continue;
+			} else if (ret != JAYLINK_OK) {
+				LOG_WARNING("jaylink_device_get_serial_number() failed: %s.",
+					jaylink_strerror(ret));
+				continue;
+			}
+
+			if (serial_number != tmp)
+				continue;
+		}
 
-		if (use_usb_address && usb_address != ret)
-			continue;
+		if (use_usb_address) {
+			ret = jaylink_device_get_usb_address(devs[i], &address);
 
-		if (use_serial_number && tmp != serial_number)
-			continue;
+			if (ret == JAYLINK_ERR_NOT_SUPPORTED) {
+				continue;
+			} else if (ret != JAYLINK_OK) {
+				LOG_WARNING("jaylink_device_get_usb_address() failed: %s.",
+					jaylink_strerror(ret));
+				continue;
+			}
+
+			if (usb_address != address)
+				continue;
+		}
 
 		ret = jaylink_open(devs[i], &devh);
 
-		if (ret != JAYLINK_OK) {
-			LOG_ERROR("Failed to open device: %s.", jaylink_strerror_name(ret));
-			continue;
+		if (ret == JAYLINK_OK) {
+			found_device = true;
+			break;
 		}
 
-		found_device = true;
-		break;
+		LOG_ERROR("Failed to open device: %s.", jaylink_strerror(ret));
 	}
 
-	jaylink_free_device_list(devs, 1);
+	jaylink_free_devices(devs, true);
 
 	if (!found_device) {
 		LOG_ERROR("No J-Link device found.");
@@ -469,26 +658,26 @@ static int jlink_init(void)
 	 * some devices are known to be sensitive regarding the order.
 	 */
 
-	ret = jaylink_get_firmware_version(devh, &firmware_version);
+	ret = jaylink_get_firmware_version(devh, &firmware_version, &length);
 
-	if (ret > 0) {
-		LOG_INFO("%s", firmware_version);
-		free(firmware_version);
-	} else if (!ret) {
-		LOG_WARNING("Device responds empty firmware version string.");
-	} else {
+	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_get_firmware_version() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		jaylink_close(devh);
 		jaylink_exit(jayctx);
 		return ERROR_JTAG_INIT_FAILED;
+	} else if (length > 0) {
+		LOG_INFO("%s", firmware_version);
+		free(firmware_version);
+	} else {
+		LOG_WARNING("Device responds empty firmware version string.");
 	}
 
 	memset(caps, 0, JAYLINK_DEV_EXT_CAPS_SIZE);
 	ret = jaylink_get_caps(devh, caps);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_get_caps() failed: %s.", jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_get_caps() failed: %s.", jaylink_strerror(ret));
 		jaylink_close(devh);
 		jaylink_exit(jayctx);
 		return ERROR_JTAG_INIT_FAILED;
@@ -499,21 +688,21 @@ static int jlink_init(void)
 
 		if (ret != JAYLINK_OK) {
 			LOG_ERROR("jaylink_get_extended_caps() failed:  %s.",
-				jaylink_strerror_name(ret));
+				jaylink_strerror(ret));
 			jaylink_close(devh);
 			jaylink_exit(jayctx);
 			return ERROR_JTAG_INIT_FAILED;
 		}
 	}
 
-	jtag_command_version = JAYLINK_JTAG_V2;
+	jtag_command_version = JAYLINK_JTAG_VERSION_2;
 
 	if (jaylink_has_cap(caps, JAYLINK_DEV_CAP_GET_HW_VERSION)) {
 		ret = jaylink_get_hardware_version(devh, &hwver);
 
 		if (ret != JAYLINK_OK) {
 			LOG_ERROR("Failed to retrieve hardware version: %s.",
-				jaylink_strerror_name(ret));
+				jaylink_strerror(ret));
 			jaylink_close(devh);
 			jaylink_exit(jayctx);
 			return ERROR_JTAG_INIT_FAILED;
@@ -522,7 +711,7 @@ static int jlink_init(void)
 		LOG_INFO("Hardware version: %u.%02u", hwver.major, hwver.minor);
 
 		if (hwver.major >= 5)
-			jtag_command_version = JAYLINK_JTAG_V3;
+			jtag_command_version = JAYLINK_JTAG_VERSION_3;
 	}
 
 	if (iface == JAYLINK_TIF_SWD) {
@@ -554,7 +743,7 @@ static int jlink_init(void)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_get_hardware_status() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		jaylink_close(devh);
 		jaylink_exit(jayctx);
 		return ERROR_JTAG_INIT_FAILED;
@@ -565,7 +754,7 @@ static int jlink_init(void)
 
 	conn.handle = 0;
 	conn.pid = 0;
-	conn.hid = 0;
+	strcpy(conn.hid, "0.0.0.0");
 	conn.iid = 0;
 	conn.cid = 0;
 
@@ -597,10 +786,10 @@ static int jlink_init(void)
 		 * if the first tap move is not divisible by 8, so we send a TLR on
 		 * first power up.
 		 */
-		for (i = 0; i < 8; i++)
-			jlink_tap_append_step(1, 0);
+		uint8_t tms = 0xff;
+		jlink_clock_data(NULL, 0, &tms, 0, NULL, 0, 8);
 
-		jlink_tap_execute();
+		jlink_flush();
 	}
 
 	return ERROR_OK;
@@ -609,21 +798,21 @@ static int jlink_init(void)
 static int jlink_quit(void)
 {
 	int ret;
+	size_t count;
 
 	if (trace_enabled) {
 		ret = jaylink_swo_stop(devh);
 
 		if (ret != JAYLINK_OK)
-			LOG_ERROR("jaylink_swo_stop() failed: %s.",
-				jaylink_strerror_name(ret));
+			LOG_ERROR("jaylink_swo_stop() failed: %s.", jaylink_strerror(ret));
 	}
 
 	if (jaylink_has_cap(caps, JAYLINK_DEV_CAP_REGISTER)) {
-		ret = jaylink_unregister(devh, &conn, connlist, NULL, NULL);
+		ret = jaylink_unregister(devh, &conn, connlist, &count);
 
-		if (ret < 0)
+		if (ret != JAYLINK_OK)
 			LOG_ERROR("jaylink_unregister() failed: %s.",
-				jaylink_strerror_name(ret));
+				jaylink_strerror(ret));
 	}
 
 	jaylink_close(devh);
@@ -648,18 +837,13 @@ static void jlink_end_state(tap_state_t state)
 /* Goes to the end state. */
 static void jlink_state_move(void)
 {
-	int i;
-	int tms = 0;
 	uint8_t tms_scan;
 	uint8_t tms_scan_bits;
 
 	tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	tms_scan_bits = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
-	for (i = 0; i < tms_scan_bits; i++) {
-		tms = (tms_scan >> i) & 1;
-		jlink_tap_append_step(tms, 0);
-	}
+	jlink_clock_data(NULL, 0, &tms_scan, 0, NULL, 0, tms_scan_bits);
 
 	tap_set_state(tap_get_end_state());
 }
@@ -667,12 +851,13 @@ static void jlink_state_move(void)
 static void jlink_path_move(int num_states, tap_state_t *path)
 {
 	int i;
+	uint8_t tms = 0xff;
 
 	for (i = 0; i < num_states; i++) {
 		if (path[i] == tap_state_transition(tap_get_state(), false))
-			jlink_tap_append_step(0, 0);
+			jlink_clock_data(NULL, 0, NULL, 0, NULL, 0, 1);
 		else if (path[i] == tap_state_transition(tap_get_state(), true))
-			jlink_tap_append_step(1, 0);
+			jlink_clock_data(NULL, 0, &tms, 0, NULL, 0, 1);
 		else {
 			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition.",
 				tap_state_name(tap_get_state()), tap_state_name(path[i]));
@@ -685,13 +870,19 @@ static void jlink_path_move(int num_states, tap_state_t *path)
 	tap_set_end_state(tap_get_state());
 }
 
-static void jlink_runtest(int num_cycles)
+static void jlink_stableclocks(int num_cycles)
 {
 	int i;
 
-	tap_state_t saved_end_state = tap_get_end_state();
+	uint8_t tms = tap_get_state() == TAP_RESET;
+	/* Execute num_cycles. */
+	for (i = 0; i < num_cycles; i++)
+		jlink_clock_data(NULL, 0, &tms, 0, NULL, 0, 1);
+}
 
-	jlink_tap_ensure_space(1, num_cycles + 16);
+static void jlink_runtest(int num_cycles)
+{
+	tap_state_t saved_end_state = tap_get_end_state();
 
 	/* Only do a state_move when we're not already in IDLE. */
 	if (tap_get_state() != TAP_IDLE) {
@@ -700,9 +891,7 @@ static void jlink_runtest(int num_cycles)
 		/* num_cycles--; */
 	}
 
-	/* Execute num_cycles. */
-	for (i = 0; i < num_cycles; i++)
-		jlink_tap_append_step(0, 0);
+	jlink_stableclocks(num_cycles);
 
 	/* Finish in end_state. */
 	jlink_end_state(saved_end_state);
@@ -711,36 +900,6 @@ static void jlink_runtest(int num_cycles)
 		jlink_state_move();
 }
 
-static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
-		int scan_size, struct scan_command *command)
-{
-	tap_state_t saved_end_state;
-
-	jlink_tap_ensure_space(1, scan_size + 16);
-
-	saved_end_state = tap_get_end_state();
-
-	/* Move to appropriate scan state. */
-	jlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-
-	/* Only move if we're not already there. */
-	if (tap_get_state() != tap_get_end_state())
-		jlink_state_move();
-
-	jlink_end_state(saved_end_state);
-
-	/* Scan. */
-	jlink_tap_append_scan(scan_size, buffer, command);
-
-	/* We are in Exit1, go to Pause. */
-	jlink_tap_append_step(0, 0);
-
-	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-
-	if (tap_get_state() != tap_get_end_state())
-		jlink_state_move();
-}
-
 static void jlink_reset(int trst, int srst)
 {
 	LOG_DEBUG("TRST: %i, SRST: %i.", trst, srst);
@@ -761,21 +920,25 @@ static void jlink_reset(int trst, int srst)
 
 COMMAND_HANDLER(jlink_usb_command)
 {
+	int tmp;
+
 	if (CMD_ARGC != 1) {
 		command_print(CMD_CTX, "Need exactly one argument for jlink usb.");
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	if (sscanf(CMD_ARGV[0], "%" SCNd8, &usb_address) != 1) {
+	if (sscanf(CMD_ARGV[0], "%i", &tmp) != 1) {
 		command_print(CMD_CTX, "Invalid USB address: %s.", CMD_ARGV[0]);
 		return ERROR_FAIL;
 	}
 
-	if (usb_address > JAYLINK_USB_ADDRESS_3) {
+	if (tmp < JAYLINK_USB_ADDRESS_0 || tmp > JAYLINK_USB_ADDRESS_3) {
 		command_print(CMD_CTX, "Invalid USB address: %s.", CMD_ARGV[0]);
 		return ERROR_FAIL;
 	}
 
+	usb_address = tmp;
+
 	use_serial_number = false;
 	use_usb_address = true;
 
@@ -784,14 +947,22 @@ COMMAND_HANDLER(jlink_usb_command)
 
 COMMAND_HANDLER(jlink_serial_command)
 {
+	int ret;
+
 	if (CMD_ARGC != 1) {
 		command_print(CMD_CTX, "Need exactly one argument for jlink serial.");
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	if (sscanf(CMD_ARGV[0], "%" SCNd32, &serial_number) != 1) {
+	ret = jaylink_parse_serial_number(CMD_ARGV[0], &serial_number);
+
+	if (ret == JAYLINK_ERR) {
 		command_print(CMD_CTX, "Invalid serial number: %s.", CMD_ARGV[0]);
 		return ERROR_FAIL;
+	} else if (ret != JAYLINK_OK) {
+		command_print(CMD_CTX, "jaylink_parse_serial_number() failed: %s.",
+			jaylink_strerror(ret));
+		return ERROR_FAIL;
 	}
 
 	use_serial_number = true;
@@ -809,7 +980,7 @@ COMMAND_HANDLER(jlink_handle_hwstatus_command)
 
 	if (ret != JAYLINK_OK) {
 		command_print(CMD_CTX, "jaylink_get_hardware_status() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -841,7 +1012,7 @@ COMMAND_HANDLER(jlink_handle_free_memory_command)
 
 	if (ret != JAYLINK_OK) {
 		command_print(CMD_CTX, "jaylink_get_free_memory() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -857,10 +1028,10 @@ COMMAND_HANDLER(jlink_handle_jlink_jtag_command)
 
 	if (!CMD_ARGC) {
 		switch (jtag_command_version) {
-			case JAYLINK_JTAG_V2:
+			case JAYLINK_JTAG_VERSION_2:
 				version = 2;
 				break;
-			case JAYLINK_JTAG_V3:
+			case JAYLINK_JTAG_VERSION_3:
 				version = 3;
 				break;
 			default:
@@ -876,10 +1047,10 @@ COMMAND_HANDLER(jlink_handle_jlink_jtag_command)
 
 		switch (tmp) {
 			case 2:
-				jtag_command_version = JAYLINK_JTAG_V2;
+				jtag_command_version = JAYLINK_JTAG_VERSION_2;
 				break;
 			case 3:
-				jtag_command_version = JAYLINK_JTAG_V3;
+				jtag_command_version = JAYLINK_JTAG_VERSION_3;
 				break;
 			default:
 				command_print(CMD_CTX, "Invalid argument: %s.", CMD_ARGV[0]);
@@ -923,7 +1094,7 @@ COMMAND_HANDLER(jlink_handle_target_power_command)
 
 	if (ret != JAYLINK_OK) {
 		command_print(CMD_CTX, "jaylink_set_target_power() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -1029,7 +1200,7 @@ static int poll_trace(uint8_t *buf, size_t *size)
 	ret = jaylink_swo_read(devh, buf, &length);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_swo_read() failed: %s.", jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_swo_read() failed: %s.", jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -1050,7 +1221,7 @@ static uint32_t calculate_trace_buffer_size(void)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_get_free_memory() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -1062,15 +1233,17 @@ static uint32_t calculate_trace_buffer_size(void)
 	return tmp & 0xffffff00;
 }
 
-static bool check_trace_freq(uint32_t freq, uint32_t divider, uint32_t trace_freq)
+static bool check_trace_freq(struct jaylink_swo_speed speed,
+		uint32_t trace_freq)
 {
 	double min;
 	double deviation;
+	uint32_t divider;
 
-	min = fabs(1.0 - (freq / ((double)trace_freq * divider)));
+	min = fabs(1.0 - (speed.freq / ((double)trace_freq * speed.min_div)));
 
-	while (freq / divider > 0) {
-		deviation = fabs(1.0 - (freq / ((double)trace_freq * divider)));
+	for (divider = speed.min_div; divider < speed.max_div; divider++) {
+		deviation = fabs(1.0 - (speed.freq / ((double)trace_freq * divider)));
 
 		if (deviation < 0.03) {
 			LOG_DEBUG("Found suitable frequency divider %u with deviation of "
@@ -1080,8 +1253,6 @@ static bool check_trace_freq(uint32_t freq, uint32_t divider, uint32_t trace_fre
 
 		if (deviation < min)
 			min = deviation;
-
-		divider++;
 	}
 
 	LOG_ERROR("Selected trace frequency is not supported by the device. "
@@ -1097,8 +1268,7 @@ static int config_trace(bool enabled, enum tpio_pin_protocol pin_protocol,
 {
 	int ret;
 	uint32_t buffer_size;
-	uint32_t freq;
-	uint32_t divider;
+	struct jaylink_swo_speed speed;
 
 	if (!jaylink_has_cap(caps, JAYLINK_DEV_CAP_SWO)) {
 		LOG_ERROR("Trace capturing is not supported by the device.");
@@ -1115,7 +1285,7 @@ static int config_trace(bool enabled, enum tpio_pin_protocol pin_protocol,
 	ret = jaylink_swo_stop(devh);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_swo_stop() failed: %s.", jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_swo_stop() failed: %s.", jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -1137,18 +1307,18 @@ static int config_trace(bool enabled, enum tpio_pin_protocol pin_protocol,
 		return ERROR_FAIL;
 	}
 
-	ret = jaylink_swo_get_speeds(devh, JAYLINK_SWO_MODE_UART, &freq, &divider);
+	ret = jaylink_swo_get_speeds(devh, JAYLINK_SWO_MODE_UART, &speed);
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_swo_get_speeds() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
 	if (!*trace_freq)
-		*trace_freq = freq / divider;
+		*trace_freq = speed.freq / speed.min_div;
 
-	if (!check_trace_freq(freq, divider, *trace_freq))
+	if (!check_trace_freq(speed, *trace_freq))
 		return ERROR_FAIL;
 
 	LOG_DEBUG("Using %u bytes device memory for trace capturing.", buffer_size);
@@ -1157,8 +1327,7 @@ static int config_trace(bool enabled, enum tpio_pin_protocol pin_protocol,
 		buffer_size);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_start_swo() failed: %s.",
-			jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_start_swo() failed: %s.", jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -1417,7 +1586,7 @@ COMMAND_HANDLER(jlink_handle_config_write_command)
 
 	if (ret != JAYLINK_OK) {
 		LOG_ERROR("jaylink_write_raw_config() failed: %s.",
-			jaylink_strerror_name(ret));
+			jaylink_strerror(ret));
 		return ERROR_FAIL;
 	}
 
@@ -1452,6 +1621,123 @@ COMMAND_HANDLER(jlink_handle_config_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(jlink_handle_emucom_write_command)
+{
+	int ret;
+	size_t tmp;
+	uint32_t channel;
+	uint32_t length;
+	uint8_t *buf;
+	size_t dummy;
+
+	if (CMD_ARGC != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (!jaylink_has_cap(caps, JAYLINK_DEV_CAP_EMUCOM)) {
+		LOG_ERROR("Device does not support EMUCOM.");
+		return ERROR_FAIL;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], channel);
+
+	tmp = strlen(CMD_ARGV[1]);
+
+	if (tmp % 2 != 0) {
+		LOG_ERROR("Data must be encoded as hexadecimal pairs.");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	buf = malloc(tmp / 2);
+
+	if (!buf) {
+		LOG_ERROR("Failed to allocate buffer.");
+		return ERROR_FAIL;
+	}
+
+	dummy = unhexify(buf, CMD_ARGV[1], tmp / 2);
+
+	if (dummy != (tmp / 2)) {
+		LOG_ERROR("Data must be encoded as hexadecimal pairs.");
+		free(buf);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	length = tmp / 2;
+	ret = jaylink_emucom_write(devh, channel, buf, &length);
+
+	free(buf);
+
+	if (ret == JAYLINK_ERR_DEV_NOT_SUPPORTED) {
+		LOG_ERROR("Channel not supported by the device.");
+		return ERROR_FAIL;
+	} else if (ret != JAYLINK_OK) {
+		LOG_ERROR("Failed to write to channel: %s.", jaylink_strerror(ret));
+		return ERROR_FAIL;
+	}
+
+	if (length != (tmp / 2))
+		LOG_WARNING("Only %" PRIu32 " bytes written to the channel.", length);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(jlink_handle_emucom_read_command)
+{
+	int ret;
+	uint32_t channel;
+	uint32_t length;
+	uint8_t *buf;
+	size_t tmp;
+
+	if (CMD_ARGC != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (!jaylink_has_cap(caps, JAYLINK_DEV_CAP_EMUCOM)) {
+		LOG_ERROR("Device does not support EMUCOM.");
+		return ERROR_FAIL;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], channel);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
+
+	buf = malloc(length * 3 + 1);
+
+	if (!buf) {
+		LOG_ERROR("Failed to allocate buffer.");
+		return ERROR_FAIL;
+	}
+
+	ret = jaylink_emucom_read(devh, channel, buf, &length);
+
+	if (ret == JAYLINK_ERR_DEV_NOT_SUPPORTED) {
+		LOG_ERROR("Channel is not supported by the device.");
+		free(buf);
+		return ERROR_FAIL;
+	} else if (ret == JAYLINK_ERR_DEV_NOT_AVAILABLE) {
+		LOG_ERROR("Channel is not available for the requested amount of data. "
+			"%" PRIu32 " bytes are avilable.", length);
+		free(buf);
+		return ERROR_FAIL;
+	} else if (ret != JAYLINK_OK) {
+		LOG_ERROR("Failed to read from channel: %s.", jaylink_strerror(ret));
+		free(buf);
+		return ERROR_FAIL;
+	}
+
+	tmp = hexify((char *)buf + length, buf, length, 2 * length + 1);
+
+	if (tmp != 2 * length) {
+		LOG_ERROR("Failed to convert data into hexadecimal string.");
+		free(buf);
+		return ERROR_FAIL;
+	}
+
+	command_print(CMD_CTX, "%s", buf + length);
+	free(buf);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration jlink_config_subcommand_handlers[] = {
 	{
 		.name = "usb",
@@ -1497,6 +1783,24 @@ static const struct command_registration jlink_config_subcommand_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static const struct command_registration jlink_emucom_subcommand_handlers[] = {
+	{
+		.name = "write",
+		.handler = &jlink_handle_emucom_write_command,
+		.mode = COMMAND_EXEC,
+		.help = "write to a channel",
+		.usage = "<channel> <data>",
+	},
+	{
+		.name = "read",
+		.handler = &jlink_handle_emucom_read_command,
+		.mode = COMMAND_EXEC,
+		.help = "read from a channel",
+		.usage = "<channel> <length>"
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 static const struct command_registration jlink_subcommand_handlers[] = {
 	{
 		.name = "jtag",
@@ -1546,6 +1850,12 @@ static const struct command_registration jlink_subcommand_handlers[] = {
 			"this will show the device configuration",
 		.chain = jlink_config_subcommand_handlers,
 	},
+	{
+		.name = "emucom",
+		.mode = COMMAND_EXEC,
+		.help = "access EMUCOM channel",
+		.chain = jlink_emucom_subcommand_handlers
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -1596,10 +1906,14 @@ static uint8_t tdi_buffer[JLINK_TAP_BUFFER_SIZE];
 static uint8_t tdo_buffer[JLINK_TAP_BUFFER_SIZE];
 
 struct pending_scan_result {
-	int first; /* First bit position in tdo_buffer to read. */
-	int length; /* Number of bits to read. */
-	struct scan_command *command; /* Corresponding scan command. */
+	/** First bit position in tdo_buffer to read. */
+	unsigned first;
+	/** Number of bits to read. */
+	unsigned length;
+	/** Location to store the result */
 	void *buffer;
+	/** Offset in the destination buffer */
+	unsigned buffer_offset;
 };
 
 #define MAX_PENDING_SCAN_RESULTS 256
@@ -1611,69 +1925,53 @@ static void jlink_tap_init(void)
 {
 	tap_length = 0;
 	pending_scan_results_length = 0;
+	memset(tms_buffer, 0, sizeof(tms_buffer));
+	memset(tdi_buffer, 0, sizeof(tdi_buffer));
 }
 
-static void jlink_tap_ensure_space(int scans, int bits)
+static void jlink_clock_data(const uint8_t *out, unsigned out_offset,
+			     const uint8_t *tms_out, unsigned tms_offset,
+			     uint8_t *in, unsigned in_offset,
+			     unsigned length)
 {
-	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
-	int available_bits = JLINK_TAP_BUFFER_SIZE * 8 - tap_length - 32;
-
-	if (scans > available_scans || bits > available_bits)
-		jlink_tap_execute();
-}
-
-static void jlink_tap_append_step(int tms, int tdi)
-{
-	int index_var = tap_length / 8;
-
-	assert(index_var < JLINK_TAP_BUFFER_SIZE);
-
-	int bit_index = tap_length % 8;
-	uint8_t bit = 1 << bit_index;
-
-	/* We do not pad TMS, so be sure to initialize all bits. */
-	if (0 == bit_index)
-		tms_buffer[index_var] = tdi_buffer[index_var] = 0;
-
-	if (tms)
-		tms_buffer[index_var] |= bit;
-	else
-		tms_buffer[index_var] &= ~bit;
-
-	if (tdi)
-		tdi_buffer[index_var] |= bit;
-	else
-		tdi_buffer[index_var] &= ~bit;
+	do {
+		unsigned available_length = JLINK_TAP_BUFFER_SIZE - tap_length / 8;
+
+		if (!available_length ||
+		    (in && pending_scan_results_length == MAX_PENDING_SCAN_RESULTS)) {
+			if (jlink_flush() != ERROR_OK)
+				return;
+			available_length = JLINK_TAP_BUFFER_SIZE;
+		}
 
-	tap_length++;
-}
+		struct pending_scan_result *pending_scan_result =
+			&pending_scan_results_buffer[pending_scan_results_length];
 
-static void jlink_tap_append_scan(int length, uint8_t *buffer,
-		struct scan_command *command)
-{
-	struct pending_scan_result *pending_scan_result =
-		&pending_scan_results_buffer[pending_scan_results_length];
-	int i;
+		unsigned scan_length = length > available_length ?
+			available_length : length;
 
-	pending_scan_result->first = tap_length;
-	pending_scan_result->length = length;
-	pending_scan_result->command = command;
-	pending_scan_result->buffer = buffer;
+		if (out)
+			buf_set_buf(out, out_offset, tdi_buffer, tap_length, scan_length);
+		if (tms_out)
+			buf_set_buf(tms_out, tms_offset, tms_buffer, tap_length, scan_length);
 
-	for (i = 0; i < length; i++) {
-		int tms = (i < (length - 1)) ? 0 : 1;
-		int tdi = (buffer[i / 8] & (1 << (i % 8))) != 0;
-		jlink_tap_append_step(tms, tdi);
-	}
+		if (in) {
+			pending_scan_result->first = tap_length;
+			pending_scan_result->length = scan_length;
+			pending_scan_result->buffer = in;
+			pending_scan_result->buffer_offset = in_offset;
+			pending_scan_results_length++;
+		}
 
-	pending_scan_results_length++;
+		tap_length += scan_length;
+		out_offset += scan_length;
+		tms_offset += scan_length;
+		in_offset += scan_length;
+		length -= scan_length;
+	} while (length > 0);
 }
 
-/*
- * Pad and send a tap sequence to the device, and receive the answer. For the
- * purpose of padding we assume that we are in idle or pause state.
- */
-static int jlink_tap_execute(void)
+static int jlink_flush(void)
 {
 	int i;
 	int ret;
@@ -1684,37 +1982,22 @@ static int jlink_tap_execute(void)
 	jlink_last_state = jtag_debug_state_machine(tms_buffer, tdi_buffer,
 		tap_length, jlink_last_state);
 
-	jlink_last_state = jtag_debug_state_machine(tms_buffer, tdi_buffer,
-		tap_length, jlink_last_state);
-
 	ret = jaylink_jtag_io(devh, tms_buffer, tdi_buffer, tdo_buffer,
 		tap_length, jtag_command_version);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_jtag_io() failed: %s.", jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_jtag_io() failed: %s.", jaylink_strerror(ret));
 		jlink_tap_init();
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
 
 	for (i = 0; i < pending_scan_results_length; i++) {
-		struct pending_scan_result *pending_scan_result = &pending_scan_results_buffer[i];
-		uint8_t *buffer = pending_scan_result->buffer;
-		int length = pending_scan_result->length;
-		int first = pending_scan_result->first;
-		struct scan_command *command = pending_scan_result->command;
-
-		/* Copy to buffer. */
-		buf_set_buf(tdo_buffer, first, buffer, 0, length);
+		struct pending_scan_result *p = &pending_scan_results_buffer[i];
 
-		DEBUG_JTAG_IO("Pending scan result, length = %d.", length);
-
-		if (jtag_read_buffer(buffer, command) != ERROR_OK) {
-			jlink_tap_init();
-			return ERROR_JTAG_QUEUE_FAILED;
-		}
+		buf_set_buf(tdo_buffer, p->first, p->buffer,
+			    p->buffer_offset, p->length);
 
-		if (pending_scan_result->buffer != NULL)
-			free(pending_scan_result->buffer);
+		DEBUG_JTAG_IO("Pending scan result, length = %d.", p->length);
 	}
 
 	jlink_tap_init();
@@ -1809,7 +2092,7 @@ static int jlink_swd_run_queue(void)
 	ret = jaylink_swd_io(devh, tms_buffer, tdi_buffer, tdo_buffer, tap_length);
 
 	if (ret != JAYLINK_OK) {
-		LOG_ERROR("jaylink_swd_io() failed: %s.", jaylink_strerror_name(ret));
+		LOG_ERROR("jaylink_swd_io() failed: %s.", jaylink_strerror(ret));
 		goto skip;
 	}
 
diff --git a/src/jtag/drivers/jtag_vpi.c b/src/jtag/drivers/jtag_vpi.c
index 7c42220d..a1787d49 100644
--- a/src/jtag/drivers/jtag_vpi.c
+++ b/src/jtag/drivers/jtag_vpi.c
@@ -16,6 +16,8 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/kitprog.c b/src/jtag/drivers/kitprog.c
new file mode 100644
index 00000000..584da8c9
--- /dev/null
+++ b/src/jtag/drivers/kitprog.c
@@ -0,0 +1,968 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Juergen Stuber <juergen@jstuber.net>            *
+ *   based on Dominic Rath's and Benedikt Sauter's usbprog.c               *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen@spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2011 by Jean-Christophe PLAGNIOL-VIILARD                *
+ *   plagnioj@jcrosoft.com                                                 *
+ *                                                                         *
+ *   Copyright (C) 2015 by Marc Schink                                     *
+ *   openocd-dev@marcschink.de                                             *
+ *                                                                         *
+ *   Copyright (C) 2015 by Paul Fertser                                    *
+ *   fercerpav@gmail.com                                                   *
+ *                                                                         *
+ *   Copyright (C) 2015-2017 by Forest Crossman                            *
+ *   cyrozap@gmail.com                                                     *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdint.h>
+
+#include <hidapi.h>
+
+#include <jtag/interface.h>
+#include <jtag/swd.h>
+#include <jtag/commands.h>
+
+#include "libusb_common.h"
+
+#define VID 0x04b4
+#define PID 0xf139
+
+#define BULK_EP_IN  1
+#define BULK_EP_OUT 2
+
+#define CONTROL_TYPE_READ  0x01
+#define CONTROL_TYPE_WRITE 0x02
+
+#define CONTROL_COMMAND_PROGRAM 0x07
+
+#define CONTROL_MODE_POLL_PROGRAMMER_STATUS  0x01
+#define CONTROL_MODE_RESET_TARGET            0x04
+#define CONTROL_MODE_SET_PROGRAMMER_PROTOCOL 0x40
+#define CONTROL_MODE_SYNCHRONIZE_TRANSFER    0x41
+#define CONTROL_MODE_ACQUIRE_SWD_TARGET      0x42
+#define CONTROL_MODE_SEND_SWD_SEQUENCE       0x43
+
+#define PROTOCOL_JTAG 0x00
+#define PROTOCOL_SWD  0x01
+
+#define DEVICE_PSOC4   0x00
+#define DEVICE_PSOC3   0x01
+#define DEVICE_UNKNOWN 0x02
+#define DEVICE_PSOC5   0x03
+
+#define ACQUIRE_MODE_RESET       0x00
+#define ACQUIRE_MODE_POWER_CYCLE 0x01
+
+#define SEQUENCE_LINE_RESET  0x00
+#define SEQUENCE_JTAG_TO_SWD 0x01
+
+#define PROGRAMMER_NOK_NACK 0x00
+#define PROGRAMMER_OK_ACK   0x01
+
+#define HID_TYPE_WRITE 0x00
+#define HID_TYPE_READ  0x01
+#define HID_TYPE_START 0x02
+
+#define HID_COMMAND_POWER      0x80
+#define HID_COMMAND_VERSION    0x81
+#define HID_COMMAND_RESET      0x82
+#define HID_COMMAND_CONFIGURE  0x8f
+#define HID_COMMAND_BOOTLOADER 0xa0
+
+/* 512 bytes seems to work reliably */
+#define SWD_MAX_BUFFER_LENGTH 512
+
+struct kitprog {
+	hid_device *hid_handle;
+	struct jtag_libusb_device_handle *usb_handle;
+	uint16_t packet_size;
+	uint16_t packet_index;
+	uint8_t *packet_buffer;
+	char *serial;
+	uint8_t hardware_version;
+	uint8_t minor_version;
+	uint8_t major_version;
+	uint16_t millivolts;
+
+	bool supports_jtag_to_swd;
+};
+
+struct pending_transfer_result {
+	uint8_t cmd;
+	uint32_t data;
+	void *buffer;
+};
+
+static char *kitprog_serial;
+static bool kitprog_init_acquire_psoc;
+
+static int pending_transfer_count, pending_queue_len;
+static struct pending_transfer_result *pending_transfers;
+
+static int queued_retval;
+
+static struct kitprog *kitprog_handle;
+
+static int kitprog_usb_open(void);
+static void kitprog_usb_close(void);
+
+static int kitprog_hid_command(uint8_t *command, size_t command_length,
+		uint8_t *data, size_t data_length);
+static int kitprog_get_version(void);
+static int kitprog_get_millivolts(void);
+static int kitprog_get_info(void);
+static int kitprog_set_protocol(uint8_t protocol);
+static int kitprog_get_status(void);
+static int kitprog_set_unknown(void);
+static int kitprog_acquire_psoc(uint8_t psoc_type, uint8_t acquire_mode,
+		uint8_t max_attempts);
+static int kitprog_reset_target(void);
+static int kitprog_swd_sync(void);
+static int kitprog_swd_seq(uint8_t seq_type);
+
+static int kitprog_generic_acquire(void);
+
+static int kitprog_swd_run_queue(void);
+static void kitprog_swd_queue_cmd(uint8_t cmd, uint32_t *dst, uint32_t data);
+static int kitprog_swd_switch_seq(enum swd_special_seq seq);
+
+
+static inline int mm_to_version(uint8_t major, uint8_t minor)
+{
+	return (major << 8) | minor;
+}
+
+static int kitprog_init(void)
+{
+	int retval;
+
+	kitprog_handle = malloc(sizeof(struct kitprog));
+	if (kitprog_handle == NULL) {
+		LOG_ERROR("Failed to allocate memory");
+		return ERROR_FAIL;
+	}
+
+	if (kitprog_usb_open() != ERROR_OK) {
+		LOG_ERROR("Can't find a KitProg device! Please check device connections and permissions.");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	/* Get the current KitProg version and target voltage */
+	if (kitprog_get_info() != ERROR_OK)
+		return ERROR_FAIL;
+
+	/* Compatibility check */
+	kitprog_handle->supports_jtag_to_swd = true;
+	int kitprog_version = mm_to_version(kitprog_handle->major_version, kitprog_handle->minor_version);
+	if (kitprog_version < mm_to_version(2, 14)) {
+		LOG_WARNING("KitProg firmware versions below v2.14 do not support sending JTAG to SWD sequences. These sequences will be substituted with SWD line resets.");
+		kitprog_handle->supports_jtag_to_swd = false;
+	}
+
+	/* I have no idea what this does */
+	if (kitprog_set_unknown() != ERROR_OK)
+		return ERROR_FAIL;
+
+	/* SWD won't work unless we do this */
+	if (kitprog_swd_sync() != ERROR_OK)
+		return ERROR_FAIL;
+
+	/* Set the protocol to SWD */
+	if (kitprog_set_protocol(PROTOCOL_SWD) != ERROR_OK)
+		return ERROR_FAIL;
+
+	/* Reset the SWD bus */
+	if (kitprog_swd_seq(SEQUENCE_LINE_RESET) != ERROR_OK)
+		return ERROR_FAIL;
+
+	if (kitprog_init_acquire_psoc) {
+		/* Try to acquire any device that will respond */
+		retval = kitprog_generic_acquire();
+		if (retval != ERROR_OK) {
+			LOG_ERROR("No PSoC devices found");
+			return retval;
+		}
+	}
+
+	/* Allocate packet buffers and queues */
+	kitprog_handle->packet_size = SWD_MAX_BUFFER_LENGTH;
+	kitprog_handle->packet_buffer = malloc(SWD_MAX_BUFFER_LENGTH);
+	if (kitprog_handle->packet_buffer == NULL) {
+		LOG_ERROR("Failed to allocate memory for the packet buffer");
+		return ERROR_FAIL;
+	}
+
+	pending_queue_len = SWD_MAX_BUFFER_LENGTH / 5;
+	pending_transfers = malloc(pending_queue_len * sizeof(*pending_transfers));
+	if (pending_transfers == NULL) {
+		LOG_ERROR("Failed to allocate memory for the SWD transfer queue");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_quit(void)
+{
+	kitprog_usb_close();
+
+	if (kitprog_handle->packet_buffer != NULL)
+		free(kitprog_handle->packet_buffer);
+	if (kitprog_handle->serial != NULL)
+		free(kitprog_handle->serial);
+	if (kitprog_handle != NULL)
+		free(kitprog_handle);
+
+	if (kitprog_serial != NULL)
+		free(kitprog_serial);
+
+	if (pending_transfers != NULL)
+		free(pending_transfers);
+
+	return ERROR_OK;
+}
+
+/*************** kitprog usb functions *********************/
+
+static int kitprog_get_usb_serial(void)
+{
+	int retval;
+	const uint8_t str_index = 128; /* This seems to be a constant */
+	char desc_string[256+1]; /* Max size of string descriptor */
+
+	retval = libusb_get_string_descriptor_ascii(kitprog_handle->usb_handle,
+			str_index, (unsigned char *)desc_string, sizeof(desc_string)-1);
+	if (retval < 0) {
+		LOG_ERROR("libusb_get_string_descriptor_ascii() failed with %d", retval);
+		return ERROR_FAIL;
+	}
+
+	/* Null terminate descriptor string */
+	desc_string[retval] = '\0';
+
+	/* Allocate memory for the serial number */
+	kitprog_handle->serial = calloc(retval + 1, sizeof(char));
+	if (kitprog_handle->serial == NULL) {
+		LOG_ERROR("Failed to allocate memory for the serial number");
+		return ERROR_FAIL;
+	}
+
+	/* Store the serial number */
+	strncpy(kitprog_handle->serial, desc_string, retval + 1);
+
+	return ERROR_OK;
+}
+
+static int kitprog_usb_open(void)
+{
+	const uint16_t vids[] = { VID, 0 };
+	const uint16_t pids[] = { PID, 0 };
+
+	if (jtag_libusb_open(vids, pids, kitprog_serial,
+			&kitprog_handle->usb_handle) != ERROR_OK) {
+		LOG_ERROR("Failed to open or find the device");
+		return ERROR_FAIL;
+	}
+
+	/* Get the serial number for the device */
+	if (kitprog_get_usb_serial() != ERROR_OK)
+		LOG_WARNING("Failed to get KitProg serial number");
+
+	/* Convert the ASCII serial number into a (wchar_t *) */
+	size_t len = strlen(kitprog_handle->serial);
+	wchar_t *hid_serial = calloc(len + 1, sizeof(wchar_t));
+	if (hid_serial == NULL) {
+		LOG_ERROR("Failed to allocate memory for the serial number");
+		return ERROR_FAIL;
+	}
+	if (mbstowcs(hid_serial, kitprog_handle->serial, len + 1) == (size_t)-1) {
+		free(hid_serial);
+		LOG_ERROR("Failed to convert serial number");
+		return ERROR_FAIL;
+	}
+
+	/* Use HID for the KitBridge interface */
+	kitprog_handle->hid_handle = hid_open(VID, PID, hid_serial);
+	free(hid_serial);
+	if (kitprog_handle->hid_handle == NULL) {
+		LOG_ERROR("Failed to open KitBridge (HID) interface");
+		return ERROR_FAIL;
+	}
+
+	/* Claim the KitProg Programmer (bulk transfer) interface */
+	if (jtag_libusb_claim_interface(kitprog_handle->usb_handle, 1) != ERROR_OK) {
+		LOG_ERROR("Failed to claim KitProg Programmer (bulk transfer) interface");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static void kitprog_usb_close(void)
+{
+	if (kitprog_handle->hid_handle != NULL) {
+		hid_close(kitprog_handle->hid_handle);
+		hid_exit();
+	}
+
+	jtag_libusb_close(kitprog_handle->usb_handle);
+}
+
+/*************** kitprog lowlevel functions *********************/
+
+static int kitprog_hid_command(uint8_t *command, size_t command_length,
+		uint8_t *data, size_t data_length)
+{
+	int ret;
+
+	ret = hid_write(kitprog_handle->hid_handle, command, command_length);
+	if (ret < 0) {
+		LOG_DEBUG("HID write returned %i", ret);
+		return ERROR_FAIL;
+	}
+
+	ret = hid_read(kitprog_handle->hid_handle, data, data_length);
+	if (ret < 0) {
+		LOG_DEBUG("HID read returned %i", ret);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_get_version(void)
+{
+	int ret;
+
+	unsigned char command[3] = {HID_TYPE_START | HID_TYPE_WRITE, 0x00, HID_COMMAND_VERSION};
+	unsigned char data[64];
+
+	ret = kitprog_hid_command(command, sizeof command, data, sizeof data);
+	if (ret != ERROR_OK)
+		return ret;
+
+	kitprog_handle->hardware_version = data[1];
+	kitprog_handle->minor_version = data[2];
+	kitprog_handle->major_version = data[3];
+
+	return ERROR_OK;
+}
+
+static int kitprog_get_millivolts(void)
+{
+	int ret;
+
+	unsigned char command[3] = {HID_TYPE_START | HID_TYPE_READ, 0x00, HID_COMMAND_POWER};
+	unsigned char data[64];
+
+	ret = kitprog_hid_command(command, sizeof command, data, sizeof data);
+	if (ret != ERROR_OK)
+		return ret;
+
+	kitprog_handle->millivolts = (data[4] << 8) | data[3];
+
+	return ERROR_OK;
+}
+
+static int kitprog_get_info(void)
+{
+	/* Get the device version information */
+	if (kitprog_get_version() == ERROR_OK) {
+		LOG_INFO("KitProg v%u.%02u",
+			kitprog_handle->major_version, kitprog_handle->minor_version);
+		LOG_INFO("Hardware version: %u",
+			kitprog_handle->hardware_version);
+	} else {
+		LOG_ERROR("Failed to get KitProg version");
+		return ERROR_FAIL;
+	}
+
+	/* Get the current reported target voltage */
+	if (kitprog_get_millivolts() == ERROR_OK) {
+		LOG_INFO("VTARG = %u.%03u V",
+			kitprog_handle->millivolts / 1000, kitprog_handle->millivolts % 1000);
+	} else {
+		LOG_ERROR("Failed to get target voltage");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_set_protocol(uint8_t protocol)
+{
+	int transferred;
+	char status = PROGRAMMER_NOK_NACK;
+
+	transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+		CONTROL_TYPE_WRITE,
+		(CONTROL_MODE_SET_PROGRAMMER_PROTOCOL << 8) | CONTROL_COMMAND_PROGRAM,
+		protocol, &status, 1, 0);
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_get_status(void)
+{
+	int transferred = 0;
+	char status = PROGRAMMER_NOK_NACK;
+
+	/* Try a maximum of three times */
+	for (int i = 0; (i < 3) && (transferred == 0); i++) {
+		transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+			LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+			CONTROL_TYPE_READ,
+			(CONTROL_MODE_POLL_PROGRAMMER_STATUS << 8) | CONTROL_COMMAND_PROGRAM,
+			0, &status, 1, 0);
+		jtag_sleep(1000);
+	}
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_set_unknown(void)
+{
+	int transferred;
+	char status = PROGRAMMER_NOK_NACK;
+
+	transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+		CONTROL_TYPE_WRITE,
+		(0x03 << 8) | 0x04,
+		0, &status, 1, 0);
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_acquire_psoc(uint8_t psoc_type, uint8_t acquire_mode,
+		uint8_t max_attempts)
+{
+	int transferred;
+	char status = PROGRAMMER_NOK_NACK;
+
+	transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+		CONTROL_TYPE_WRITE,
+		(CONTROL_MODE_ACQUIRE_SWD_TARGET << 8) | CONTROL_COMMAND_PROGRAM,
+		(max_attempts << 8) | (acquire_mode << 4) | psoc_type, &status, 1, 0);
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_reset_target(void)
+{
+	int transferred;
+	char status = PROGRAMMER_NOK_NACK;
+
+	transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+		CONTROL_TYPE_WRITE,
+		(CONTROL_MODE_RESET_TARGET << 8) | CONTROL_COMMAND_PROGRAM,
+		0, &status, 1, 0);
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_swd_sync(void)
+{
+	int transferred;
+	char status = PROGRAMMER_NOK_NACK;
+
+	transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+		CONTROL_TYPE_WRITE,
+		(CONTROL_MODE_SYNCHRONIZE_TRANSFER << 8) | CONTROL_COMMAND_PROGRAM,
+		0, &status, 1, 0);
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_swd_seq(uint8_t seq_type)
+{
+	int transferred;
+	char status = PROGRAMMER_NOK_NACK;
+
+	transferred = jtag_libusb_control_transfer(kitprog_handle->usb_handle,
+		LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_VENDOR | LIBUSB_RECIPIENT_DEVICE,
+		CONTROL_TYPE_WRITE,
+		(CONTROL_MODE_SEND_SWD_SEQUENCE << 8) | CONTROL_COMMAND_PROGRAM,
+		seq_type, &status, 1, 0);
+
+	if (transferred == 0) {
+		LOG_DEBUG("Zero bytes transferred");
+		return ERROR_FAIL;
+	}
+
+	if (status != PROGRAMMER_OK_ACK) {
+		LOG_DEBUG("Programmer did not respond OK");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_generic_acquire(void)
+{
+	const uint8_t devices[] = {DEVICE_PSOC4, DEVICE_PSOC3, DEVICE_PSOC5};
+
+	int retval;
+	int acquire_count = 0;
+
+	/* Due to the way the SWD port is shared between the Test Controller (TC)
+	 * and the Cortex-M3 DAP on the PSoC 5LP, the TC is the default SWD target
+	 * after power is applied. To access the DAP, the PSoC 5LP requires at least
+	 * one acquisition sequence to be run (which switches the SWD mux from the
+	 * TC to the DAP). However, after the mux is switched, the Cortex-M3 will be
+	 * held in reset until a series of registers are written to (see section 5.2
+	 * of the PSoC 5LP Device Programming Specifications for details).
+	 *
+	 * Instead of writing the registers in this function, we just do what the
+	 * Cypress tools do and run the acquisition sequence a second time. This
+	 * will take the Cortex-M3 out of reset and enable debugging.
+	 */
+	for (int i = 0; i < 2; i++) {
+		for (uint8_t j = 0; j < sizeof devices && acquire_count == i; j++) {
+			retval = kitprog_acquire_psoc(devices[j], ACQUIRE_MODE_RESET, 3);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("Aquisition function failed for device 0x%02x.", devices[j]);
+				return retval;
+			}
+
+			if (kitprog_get_status() == ERROR_OK)
+				acquire_count++;
+		}
+
+		jtag_sleep(10);
+	}
+
+	if (acquire_count < 2)
+		return ERROR_FAIL;
+
+	return ERROR_OK;
+}
+
+/*************** swd wrapper functions *********************/
+
+static int kitprog_swd_init(void)
+{
+	return ERROR_OK;
+}
+
+static void kitprog_swd_write_reg(uint8_t cmd, uint32_t value, uint32_t ap_delay_clk)
+{
+	assert(!(cmd & SWD_CMD_RnW));
+	kitprog_swd_queue_cmd(cmd, NULL, value);
+}
+
+static void kitprog_swd_read_reg(uint8_t cmd, uint32_t *value, uint32_t ap_delay_clk)
+{
+	assert(cmd & SWD_CMD_RnW);
+	kitprog_swd_queue_cmd(cmd, value, 0);
+}
+
+/*************** swd lowlevel functions ********************/
+
+static int kitprog_swd_switch_seq(enum swd_special_seq seq)
+{
+	switch (seq) {
+		case JTAG_TO_SWD:
+			if (kitprog_handle->supports_jtag_to_swd) {
+				LOG_DEBUG("JTAG to SWD");
+				if (kitprog_swd_seq(SEQUENCE_JTAG_TO_SWD) != ERROR_OK)
+					return ERROR_FAIL;
+				break;
+			} else {
+				LOG_DEBUG("JTAG to SWD not supported");
+				/* Fall through to fix target reset issue */
+			}
+			/* fallthrough */
+		case LINE_RESET:
+			LOG_DEBUG("SWD line reset");
+			if (kitprog_swd_seq(SEQUENCE_LINE_RESET) != ERROR_OK)
+				return ERROR_FAIL;
+			break;
+		default:
+			LOG_ERROR("Sequence %d not supported.", seq);
+			return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int kitprog_swd_run_queue(void)
+{
+	int ret;
+
+	size_t read_count = 0;
+	size_t read_index = 0;
+	size_t write_count = 0;
+	uint8_t *buffer = kitprog_handle->packet_buffer;
+
+	do {
+		LOG_DEBUG("Executing %d queued transactions", pending_transfer_count);
+
+		if (queued_retval != ERROR_OK) {
+			LOG_DEBUG("Skipping due to previous errors: %d", queued_retval);
+			break;
+		}
+
+		if (!pending_transfer_count)
+			break;
+
+		for (int i = 0; i < pending_transfer_count; i++) {
+			uint8_t cmd = pending_transfers[i].cmd;
+			uint32_t data = pending_transfers[i].data;
+
+			/* When proper WAIT handling is implemented in the
+			 * common SWD framework, this kludge can be
+			 * removed. However, this might lead to minor
+			 * performance degradation as the adapter wouldn't be
+			 * able to automatically retry anything (because ARM
+			 * has forgotten to implement sticky error flags
+			 * clearing). See also comments regarding
+			 * cmsis_dap_cmd_DAP_TFER_Configure() and
+			 * cmsis_dap_cmd_DAP_SWD_Configure() in
+			 * cmsis_dap_init().
+			 */
+			if (!(cmd & SWD_CMD_RnW) &&
+				!(cmd & SWD_CMD_APnDP) &&
+				(cmd & SWD_CMD_A32) >> 1 == DP_CTRL_STAT &&
+				(data & CORUNDETECT)) {
+				LOG_DEBUG("refusing to enable sticky overrun detection");
+				data &= ~CORUNDETECT;
+			}
+
+#if 0
+			LOG_DEBUG("%s %s reg %x %"PRIx32,
+					cmd & SWD_CMD_APnDP ? "AP" : "DP",
+					cmd & SWD_CMD_RnW ? "read" : "write",
+				  (cmd & SWD_CMD_A32) >> 1, data);
+#endif
+
+			buffer[write_count++] = (cmd | SWD_CMD_START | SWD_CMD_PARK) & ~SWD_CMD_STOP;
+			read_count++;
+			if (!(cmd & SWD_CMD_RnW)) {
+				buffer[write_count++] = (data) & 0xff;
+				buffer[write_count++] = (data >> 8) & 0xff;
+				buffer[write_count++] = (data >> 16) & 0xff;
+				buffer[write_count++] = (data >> 24) & 0xff;
+			} else {
+				read_count += 4;
+			}
+		}
+
+		ret = jtag_libusb_bulk_write(kitprog_handle->usb_handle,
+				BULK_EP_OUT, (char *)buffer, write_count, 0);
+		if (ret > 0) {
+			queued_retval = ERROR_OK;
+		} else {
+			LOG_ERROR("Bulk write failed");
+			queued_retval = ERROR_FAIL;
+			break;
+		}
+
+		/* We use the maximum buffer size here because the KitProg sometimes
+		 * doesn't like bulk reads of fewer than 62 bytes. (?!?!)
+		 */
+		ret = jtag_libusb_bulk_read(kitprog_handle->usb_handle,
+				BULK_EP_IN | LIBUSB_ENDPOINT_IN, (char *)buffer,
+				SWD_MAX_BUFFER_LENGTH, 0);
+		if (ret > 0) {
+			/* Handle garbage data by offsetting the initial read index */
+			if ((unsigned int)ret > read_count)
+				read_index = ret - read_count;
+			queued_retval = ERROR_OK;
+		} else {
+			LOG_ERROR("Bulk read failed");
+			queued_retval = ERROR_FAIL;
+			break;
+		}
+
+		for (int i = 0; i < pending_transfer_count; i++) {
+			if (pending_transfers[i].cmd & SWD_CMD_RnW) {
+				uint32_t data = le_to_h_u32(&buffer[read_index]);
+
+#if 0
+				LOG_DEBUG("Read result: %"PRIx32, data);
+#endif
+
+				if (pending_transfers[i].buffer)
+					*(uint32_t *)pending_transfers[i].buffer = data;
+
+				read_index += 4;
+			}
+
+			uint8_t ack = buffer[read_index] & 0x07;
+			if (ack != SWD_ACK_OK || (buffer[read_index] & 0x08)) {
+				LOG_DEBUG("SWD ack not OK: %d %s", i,
+					  ack == SWD_ACK_WAIT ? "WAIT" : ack == SWD_ACK_FAULT ? "FAULT" : "JUNK");
+				queued_retval = ack == SWD_ACK_WAIT ? ERROR_WAIT : ERROR_FAIL;
+				break;
+			}
+			read_index++;
+		}
+	} while (0);
+
+	pending_transfer_count = 0;
+	int retval = queued_retval;
+	queued_retval = ERROR_OK;
+
+	return retval;
+}
+
+static void kitprog_swd_queue_cmd(uint8_t cmd, uint32_t *dst, uint32_t data)
+{
+	if (pending_transfer_count == pending_queue_len) {
+		/* Not enough room in the queue. Run the queue. */
+		queued_retval = kitprog_swd_run_queue();
+	}
+
+	if (queued_retval != ERROR_OK)
+		return;
+
+	pending_transfers[pending_transfer_count].data = data;
+	pending_transfers[pending_transfer_count].cmd = cmd;
+	if (cmd & SWD_CMD_RnW) {
+		/* Queue a read transaction */
+		pending_transfers[pending_transfer_count].buffer = dst;
+	}
+	pending_transfer_count++;
+}
+
+/*************** jtag lowlevel functions ********************/
+
+static void kitprog_execute_reset(struct jtag_command *cmd)
+{
+	int retval = ERROR_OK;
+
+	if (cmd->cmd.reset->srst == 1) {
+		retval = kitprog_reset_target();
+		/* Since the previous command also disables SWCLK output, we need to send an
+		 * SWD bus reset command to re-enable it. For some reason, running
+		 * kitprog_swd_seq() immediately after kitprog_reset_target() won't
+		 * actually fix this. Instead, kitprog_swd_seq() will be run once OpenOCD
+		 * tries to send a JTAG-to-SWD sequence, which should happen during
+		 * swd_check_reconnect (see the JTAG_TO_SWD case in kitprog_swd_switch_seq).
+		 */
+	}
+
+	if (retval != ERROR_OK)
+		LOG_ERROR("KitProg: Interface reset failed");
+}
+
+static void kitprog_execute_sleep(struct jtag_command *cmd)
+{
+	jtag_sleep(cmd->cmd.sleep->us);
+}
+
+static void kitprog_execute_command(struct jtag_command *cmd)
+{
+	switch (cmd->type) {
+		case JTAG_RESET:
+			kitprog_execute_reset(cmd);
+			break;
+		case JTAG_SLEEP:
+			kitprog_execute_sleep(cmd);
+			break;
+		default:
+			LOG_ERROR("BUG: unknown JTAG command type encountered");
+			exit(-1);
+	}
+}
+
+static int kitprog_execute_queue(void)
+{
+	struct jtag_command *cmd = jtag_command_queue;
+
+	while (cmd != NULL) {
+		kitprog_execute_command(cmd);
+		cmd = cmd->next;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kitprog_handle_info_command)
+{
+	int retval = kitprog_get_info();
+
+	return retval;
+}
+
+
+COMMAND_HANDLER(kitprog_handle_acquire_psoc_command)
+{
+	int retval = kitprog_generic_acquire();
+
+	return retval;
+}
+
+COMMAND_HANDLER(kitprog_handle_serial_command)
+{
+	if (CMD_ARGC == 1) {
+		size_t len = strlen(CMD_ARGV[0]);
+		kitprog_serial = calloc(len + 1, sizeof(char));
+		if (kitprog_serial == NULL) {
+			LOG_ERROR("Failed to allocate memory for the serial number");
+			return ERROR_FAIL;
+		}
+		strncpy(kitprog_serial, CMD_ARGV[0], len + 1);
+	} else {
+		LOG_ERROR("expected exactly one argument to kitprog_serial <serial-number>");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(kitprog_handle_init_acquire_psoc_command)
+{
+	kitprog_init_acquire_psoc = true;
+
+	return ERROR_OK;
+}
+
+static const struct command_registration kitprog_subcommand_handlers[] = {
+	{
+		.name = "info",
+		.handler = &kitprog_handle_info_command,
+		.mode = COMMAND_EXEC,
+		.usage = "",
+		.help = "show KitProg info",
+	},
+	{
+		.name = "acquire_psoc",
+		.handler = &kitprog_handle_acquire_psoc_command,
+		.mode = COMMAND_EXEC,
+		.usage = "",
+		.help = "try to acquire a PSoC",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration kitprog_command_handlers[] = {
+	{
+		.name = "kitprog",
+		.mode = COMMAND_ANY,
+		.help = "perform KitProg management",
+		.usage = "<cmd>",
+		.chain = kitprog_subcommand_handlers,
+	},
+	{
+		.name = "kitprog_serial",
+		.handler = &kitprog_handle_serial_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the serial number of the adapter",
+		.usage = "serial_string",
+	},
+	{
+		.name = "kitprog_init_acquire_psoc",
+		.handler = &kitprog_handle_init_acquire_psoc_command,
+		.mode = COMMAND_CONFIG,
+		.help = "try to acquire a PSoC during init",
+		.usage = "",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct swd_driver kitprog_swd = {
+	.init = kitprog_swd_init,
+	.switch_seq = kitprog_swd_switch_seq,
+	.read_reg = kitprog_swd_read_reg,
+	.write_reg = kitprog_swd_write_reg,
+	.run = kitprog_swd_run_queue,
+};
+
+static const char * const kitprog_transports[] = { "swd", NULL };
+
+struct jtag_interface kitprog_interface = {
+	.name = "kitprog",
+	.commands = kitprog_command_handlers,
+	.transports = kitprog_transports,
+	.swd = &kitprog_swd,
+	.execute_queue = kitprog_execute_queue,
+	.init = kitprog_init,
+	.quit = kitprog_quit
+};
diff --git a/src/jtag/drivers/libjaylink b/src/jtag/drivers/libjaylink
index 83f6e7c4..8645845c 160000
--- a/src/jtag/drivers/libjaylink
+++ b/src/jtag/drivers/libjaylink
@@ -1 +1 @@
-Subproject commit 83f6e7c4d86035c848195817251320b4b81671b0
+Subproject commit 8645845c1abebd004e991ba9a7f808f4fd0c608b
diff --git a/src/jtag/drivers/libusb0_common.c b/src/jtag/drivers/libusb0_common.c
index 5b1248d2..1825543e 100644
--- a/src/jtag/drivers/libusb0_common.c
+++ b/src/jtag/drivers/libusb0_common.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -148,7 +146,7 @@ int jtag_libusb_set_configuration(jtag_libusb_device_handle *devh,
 int jtag_libusb_choose_interface(struct jtag_libusb_device_handle *devh,
 		unsigned int *usb_read_ep,
 		unsigned int *usb_write_ep,
-		int bclass, int subclass, int protocol)
+		int bclass, int subclass, int protocol, int trans_type)
 {
 	struct jtag_libusb_device *udev = jtag_libusb_get_device(devh);
 	struct usb_interface *iface = udev->config->interface;
@@ -159,7 +157,8 @@ int jtag_libusb_choose_interface(struct jtag_libusb_device_handle *devh,
 	for (int i = 0; i < desc->bNumEndpoints; i++) {
 		if ((bclass > 0 && desc->bInterfaceClass != bclass) ||
 		    (subclass > 0 && desc->bInterfaceSubClass != subclass) ||
-		    (protocol > 0 && desc->bInterfaceProtocol != protocol))
+		    (protocol > 0 && desc->bInterfaceProtocol != protocol) ||
+		    (trans_type > 0 && (desc->endpoint[i].bmAttributes & 0x3) != trans_type))
 			continue;
 
 		uint8_t epnum = desc->endpoint[i].bEndpointAddress;
diff --git a/src/jtag/drivers/libusb0_common.h b/src/jtag/drivers/libusb0_common.h
index ca372a08..baa9e3c5 100644
--- a/src/jtag/drivers/libusb0_common.h
+++ b/src/jtag/drivers/libusb0_common.h
@@ -14,13 +14,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef JTAG_LIBUSB_COMMON_H
-#define JTAG_LIBUSB_COMMON_H
+#ifndef OPENOCD_JTAG_DRIVERS_LIBUSB0_COMMON_H
+#define OPENOCD_JTAG_DRIVERS_LIBUSB0_COMMON_H
 
 #include <usb.h>
 
@@ -69,7 +67,7 @@ int jtag_libusb_set_configuration(jtag_libusb_device_handle *devh,
 int jtag_libusb_choose_interface(struct jtag_libusb_device_handle *devh,
 		unsigned int *usb_read_ep,
 		unsigned int *usb_write_ep,
-		int bclass, int subclass, int protocol);
+		int bclass, int subclass, int protocol, int trans_type);
 int jtag_libusb_get_pid(struct jtag_libusb_device *dev, uint16_t *pid);
 
-#endif /* JTAG_USB_COMMON_H */
+#endif /* OPENOCD_JTAG_DRIVERS_LIBUSB0_COMMON_H */
diff --git a/src/jtag/drivers/libusb1_common.c b/src/jtag/drivers/libusb1_common.c
index bda91ffb..89f80927 100644
--- a/src/jtag/drivers/libusb1_common.c
+++ b/src/jtag/drivers/libusb1_common.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -189,7 +187,7 @@ int jtag_libusb_set_configuration(jtag_libusb_device_handle *devh,
 int jtag_libusb_choose_interface(struct jtag_libusb_device_handle *devh,
 		unsigned int *usb_read_ep,
 		unsigned int *usb_write_ep,
-		int bclass, int subclass, int protocol)
+		int bclass, int subclass, int protocol, int trans_type)
 {
 	struct jtag_libusb_device *udev = jtag_libusb_get_device(devh);
 	const struct libusb_interface *inter;
@@ -212,6 +210,8 @@ int jtag_libusb_choose_interface(struct jtag_libusb_device_handle *devh,
 				continue;
 
 			epdesc = &interdesc->endpoint[k];
+			if (trans_type > 0 && (epdesc->bmAttributes & 0x3) != trans_type)
+				continue;
 
 			uint8_t epnum = epdesc->bEndpointAddress;
 			bool is_input = epnum & 0x80;
diff --git a/src/jtag/drivers/libusb1_common.h b/src/jtag/drivers/libusb1_common.h
index 4ef6bf73..7c73d29a 100644
--- a/src/jtag/drivers/libusb1_common.h
+++ b/src/jtag/drivers/libusb1_common.h
@@ -14,13 +14,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef JTAG_LIBUSB_COMMON_H
-#define JTAG_LIBUSB_COMMON_H
+#ifndef OPENOCD_JTAG_DRIVERS_LIBUSB1_COMMON_H
+#define OPENOCD_JTAG_DRIVERS_LIBUSB1_COMMON_H
 
 #include <libusb.h>
 
@@ -71,12 +69,13 @@ int jtag_libusb_set_configuration(jtag_libusb_device_handle *devh,
  * @param bclass `bInterfaceClass` to match, or -1 to ignore this field.
  * @param subclass `bInterfaceSubClass` to match, or -1 to ignore this field.
  * @param protocol `bInterfaceProtocol` to match, or -1 to ignore this field.
+ * @param trans_type `bmAttributes Bits 0..1 Transfer type` to match, or -1 to ignore this field.
  * @returns Returns ERROR_OK on success, ERROR_FAIL otherwise.
  */
 int jtag_libusb_choose_interface(struct jtag_libusb_device_handle *devh,
 		unsigned int *usb_read_ep,
 		unsigned int *usb_write_ep,
-		int bclass, int subclass, int protocol);
+		int bclass, int subclass, int protocol, int trans_type);
 int jtag_libusb_get_pid(struct jtag_libusb_device *dev, uint16_t *pid);
 
-#endif /* JTAG_USB_COMMON_H */
+#endif /* OPENOCD_JTAG_DRIVERS_LIBUSB1_COMMON_H */
diff --git a/src/jtag/drivers/libusb_common.h b/src/jtag/drivers/libusb_common.h
index bad6c8cc..599a0a9b 100644
--- a/src/jtag/drivers/libusb_common.h
+++ b/src/jtag/drivers/libusb_common.h
@@ -12,13 +12,16 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_JTAG_DRIVERS_LIBUSB_COMMON_H
+#define OPENOCD_JTAG_DRIVERS_LIBUSB_COMMON_H
+
 #ifdef HAVE_LIBUSB1
-#include <libusb1_common.h>
+#include "libusb1_common.h"
 #else
-#include <libusb0_common.h>
+#include "libusb0_common.h"
 #endif
+
+#endif /* OPENOCD_JTAG_DRIVERS_LIBUSB_COMMON_H */
diff --git a/src/jtag/drivers/minidriver_imp.h b/src/jtag/drivers/minidriver_imp.h
index b81368bd..cd59a74f 100644
--- a/src/jtag/drivers/minidriver_imp.h
+++ b/src/jtag/drivers/minidriver_imp.h
@@ -14,12 +14,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef MINIDRIVER_IMP_H
-#define MINIDRIVER_IMP_H
+
+#ifndef OPENOCD_JTAG_DRIVERS_MINIDRIVER_IMP_H
+#define OPENOCD_JTAG_DRIVERS_MINIDRIVER_IMP_H
 
 #include <jtag/commands.h>
 
@@ -39,4 +38,4 @@ void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
 			jtag_callback_data_t data1, jtag_callback_data_t data2,
 			jtag_callback_data_t data3);
 
-#endif	/* MINIDRIVER_IMP_H */
+#endif /* OPENOCD_JTAG_DRIVERS_MINIDRIVER_IMP_H */
diff --git a/src/jtag/drivers/mpsse.c b/src/jtag/drivers/mpsse.c
index d9f73a2a..924c9745 100644
--- a/src/jtag/drivers/mpsse.c
+++ b/src/jtag/drivers/mpsse.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -104,12 +102,67 @@ static bool string_descriptor_equal(libusb_device_handle *device, uint8_t str_in
 	return strncmp(string, desc_string, sizeof(desc_string)) == 0;
 }
 
+static bool device_location_equal(libusb_device *device, const char *location)
+{
+	bool result = false;
+#ifdef HAVE_LIBUSB_GET_PORT_NUMBERS
+	char *loc = strdup(location);
+	uint8_t port_path[7];
+	int path_step, path_len;
+	uint8_t dev_bus = libusb_get_bus_number(device);
+	char *ptr;
+
+	path_len = libusb_get_port_numbers(device, port_path, 7);
+	if (path_len == LIBUSB_ERROR_OVERFLOW) {
+		LOG_ERROR("cannot determine path to usb device! (more than 7 ports in path)");
+		goto done;
+	}
+
+	LOG_DEBUG("device path has %i steps", path_len);
+
+	ptr = strtok(loc, ":");
+	if (ptr == NULL) {
+		LOG_DEBUG("no ':' in path");
+		goto done;
+	}
+	if (atoi(ptr) != dev_bus) {
+		LOG_DEBUG("bus mismatch");
+		goto done;
+	}
+
+	path_step = 0;
+	while (path_step < 7) {
+		ptr = strtok(NULL, ",");
+		if (ptr == NULL) {
+			LOG_DEBUG("no more tokens in path at step %i", path_step);
+			break;
+		}
+
+		if (path_step < path_len
+			&& atoi(ptr) != port_path[path_step]) {
+			LOG_DEBUG("path mismatch at step %i", path_step);
+			break;
+		}
+
+		path_step++;
+	};
+
+	/* walked the full path, all elements match */
+	if (path_step == path_len)
+		result = true;
+
+ done:
+	free(loc);
+#endif
+	return result;
+}
+
 /* Helper to open a libusb device that matches vid, pid, product string and/or serial string.
  * Set any field to 0 as a wildcard. If the device is found true is returned, with ctx containing
  * the already opened handle. ctx->interface must be set to the desired interface (channel) number
  * prior to calling this function. */
 static bool open_matching_device(struct mpsse_ctx *ctx, const uint16_t *vid, const uint16_t *pid,
-	const char *product, const char *serial)
+	const char *product, const char *serial, const char *location)
 {
 	libusb_device **list;
 	struct libusb_device_descriptor desc;
@@ -141,6 +194,11 @@ static bool open_matching_device(struct mpsse_ctx *ctx, const uint16_t *vid, con
 			continue;
 		}
 
+		if (location && !device_location_equal(device, location)) {
+			libusb_close(ctx->usb_dev);
+			continue;
+		}
+
 		if (product && !string_descriptor_equal(ctx->usb_dev, desc.iProduct, product)) {
 			libusb_close(ctx->usb_dev);
 			continue;
@@ -189,8 +247,8 @@ static bool open_matching_device(struct mpsse_ctx *ctx, const uint16_t *vid, con
 	err = libusb_detach_kernel_driver(ctx->usb_dev, ctx->interface);
 	if (err != LIBUSB_SUCCESS && err != LIBUSB_ERROR_NOT_FOUND
 			&& err != LIBUSB_ERROR_NOT_SUPPORTED) {
-		LOG_ERROR("libusb_detach_kernel_driver() failed with %s", libusb_error_name(err));
-		goto error;
+		LOG_WARNING("libusb_detach_kernel_driver() failed with %s, trying to continue anyway",
+			libusb_error_name(err));
 	}
 
 	err = libusb_claim_interface(ctx->usb_dev, ctx->interface);
@@ -263,7 +321,7 @@ error:
 }
 
 struct mpsse_ctx *mpsse_open(const uint16_t *vid, const uint16_t *pid, const char *description,
-	const char *serial, int channel)
+	const char *serial, const char *location, int channel)
 {
 	struct mpsse_ctx *ctx = calloc(1, sizeof(*ctx));
 	int err;
@@ -292,16 +350,17 @@ struct mpsse_ctx *mpsse_open(const uint16_t *vid, const uint16_t *pid, const cha
 		goto error;
 	}
 
-	if (!open_matching_device(ctx, vid, pid, description, serial)) {
+	if (!open_matching_device(ctx, vid, pid, description, serial, location)) {
 		/* Four hex digits plus terminating zero each */
 		char vidstr[5];
 		char pidstr[5];
-		LOG_ERROR("unable to open ftdi device with vid %s, pid %s, description '%s' and "
-				"serial '%s'",
+		LOG_ERROR("unable to open ftdi device with vid %s, pid %s, description '%s', "
+				"serial '%s' at bus location '%s'",
 				vid ? sprintf(vidstr, "%04x", *vid), vidstr : "*",
 				pid ? sprintf(pidstr, "%04x", *pid), pidstr : "*",
 				description ? description : "*",
-				serial ? serial : "*");
+				serial ? serial : "*",
+				location ? location : "*");
 		ctx->usb_dev = 0;
 		goto error;
 	}
@@ -813,6 +872,8 @@ int mpsse_flush(struct mpsse_ctx *ctx)
 	libusb_fill_bulk_transfer(write_transfer, ctx->usb_dev, ctx->out_ep, ctx->write_buffer,
 		ctx->write_count, write_cb, &write_result, ctx->usb_write_timeout);
 	retval = libusb_submit_transfer(write_transfer);
+	if (retval != LIBUSB_SUCCESS)
+		goto error_check;
 
 	if (ctx->read_count) {
 		read_transfer = libusb_alloc_transfer(0);
@@ -820,22 +881,36 @@ int mpsse_flush(struct mpsse_ctx *ctx)
 			ctx->read_chunk_size, read_cb, &read_result,
 			ctx->usb_read_timeout);
 		retval = libusb_submit_transfer(read_transfer);
+		if (retval != LIBUSB_SUCCESS)
+			goto error_check;
 	}
 
 	/* Polling loop, more or less taken from libftdi */
 	while (!write_result.done || !read_result.done) {
-		retval = libusb_handle_events(ctx->usb_ctx);
+		struct timeval timeout_usb;
+
+		timeout_usb.tv_sec = 1;
+		timeout_usb.tv_usec = 0;
+
+		retval = libusb_handle_events_timeout_completed(ctx->usb_ctx, &timeout_usb, NULL);
 		keep_alive();
-		if (retval != LIBUSB_SUCCESS && retval != LIBUSB_ERROR_INTERRUPTED) {
+		if (retval == LIBUSB_ERROR_NO_DEVICE || retval == LIBUSB_ERROR_INTERRUPTED)
+			break;
+
+		if (retval != LIBUSB_SUCCESS) {
 			libusb_cancel_transfer(write_transfer);
 			if (read_transfer)
 				libusb_cancel_transfer(read_transfer);
-			while (!write_result.done || !read_result.done)
-				if (libusb_handle_events(ctx->usb_ctx) != LIBUSB_SUCCESS)
+			while (!write_result.done || !read_result.done) {
+				retval = libusb_handle_events_timeout_completed(ctx->usb_ctx,
+								&timeout_usb, NULL);
+				if (retval != LIBUSB_SUCCESS)
 					break;
+			}
 		}
 	}
 
+error_check:
 	if (retval != LIBUSB_SUCCESS) {
 		LOG_ERROR("libusb_handle_events() failed with %s", libusb_error_name(retval));
 		retval = ERROR_FAIL;
diff --git a/src/jtag/drivers/mpsse.h b/src/jtag/drivers/mpsse.h
index 3e287f75..651eef94 100644
--- a/src/jtag/drivers/mpsse.h
+++ b/src/jtag/drivers/mpsse.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MPSSE_H_
-#define MPSSE_H_
+#ifndef OPENOCD_JTAG_DRIVERS_MPSSE_H
+#define OPENOCD_JTAG_DRIVERS_MPSSE_H
 
 #include <stdbool.h>
 #include "helper/binarybuffer.h"
@@ -43,7 +41,7 @@ struct mpsse_ctx;
 
 /* Device handling */
 struct mpsse_ctx *mpsse_open(const uint16_t *vid, const uint16_t *pid, const char *description,
-	const char *serial, int channel);
+	const char *serial, const char *location, int channel);
 void mpsse_close(struct mpsse_ctx *ctx);
 bool mpsse_is_high_speed(struct mpsse_ctx *ctx);
 
@@ -77,4 +75,4 @@ int mpsse_set_frequency(struct mpsse_ctx *ctx, int frequency);
 int mpsse_flush(struct mpsse_ctx *ctx);
 void mpsse_purge(struct mpsse_ctx *ctx);
 
-#endif /* MPSSE_H_ */
+#endif /* OPENOCD_JTAG_DRIVERS_MPSSE_H */
diff --git a/src/jtag/drivers/opendous.c b/src/jtag/drivers/opendous.c
index deb6c7a8..458df34a 100644
--- a/src/jtag/drivers/opendous.c
+++ b/src/jtag/drivers/opendous.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/openjtag.c b/src/jtag/drivers/openjtag.c
index 85d17938..8f11b4ba 100644
--- a/src/jtag/drivers/openjtag.c
+++ b/src/jtag/drivers/openjtag.c
@@ -2,6 +2,10 @@
  *   Driver for OpenJTAG Project (www.openjtag.org)                            *
  *   Compatible with libftdi and ftd2xx drivers.                               *
  *                                                                             *
+ *   Cypress CY7C65215 support                                                 *
+ *   Copyright (C) 2015 Vianney le Clément de Saint-Marcq, Essensium NV        *
+ *                      <vianney.leclement@essensium.com>                      *
+ *                                                                             *
  *   Copyright (C) 2010 by Ivan Meleca <mileca@gmail.com>                      *
  *                                                                             *
  *   Copyright (C) 2013 by Ryan Corbin, GlueLogix Inc. <corbin.ryan@gmail.com> *
@@ -26,13 +30,11 @@
  *   GNU General Public License for more details.                              *
  *                                                                             *
  *   You should have received a copy of the GNU General Public License         *
- *   along with this program; if not, write to the                             *
- *   Free Software Foundation, Inc.,                                           *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.     *
  ***************************************************************************/
 
 /***************************************************************************
- * Version 1.0  Tested on a MCBSTM32 board using a Cortex M3 (stm32f103x), *
+ * Version 1.0  Tested on a MCBSTM32 board using a Cortex-M3 (stm32f103x), *
  *              GDB and Eclipse under Linux (Ubuntu 10.04)                 *
  *                                                                         *
  ***************************************************************************/
@@ -43,7 +45,18 @@
 
 #include <jtag/interface.h>
 #include <jtag/commands.h>
-#include "usb_common.h"
+#include "libusb_common.h"
+
+static enum {
+	OPENJTAG_VARIANT_STANDARD,
+	OPENJTAG_VARIANT_CY7C65215,
+} openjtag_variant = OPENJTAG_VARIANT_STANDARD;
+
+static const char * const openjtag_variant_names[] = {
+	"standard",
+	"cy7c65215",
+	NULL
+};
 
 /*
  * OpenJTAG-OpenOCD state conversion
@@ -68,19 +81,8 @@ typedef enum openjtag_tap_state {
 	OPENJTAG_TAP_UPDATE_IR  = 15,
 } openjtag_tap_state_t;
 
-#if (BUILD_OPENJTAG_FTD2XX == 1 && BUILD_OPENJTAG_LIBFTDI == 1)
-#error "BUILD_OPENJTAG_FTD2XX && BUILD_OPENJTAG_LIBFTDI "
-	   "are mutually exclusive"
-#elif (BUILD_OPENJTAG_FTD2XX != 1 && BUILD_OPENJTAG_LIBFTDI != 1)
-#error "BUILD_OPENJTAG_FTD2XX || BUILD_OPENJTAG_LIBFTDI must be chosen"
-#endif
-
 /* OPENJTAG access library includes */
-#if BUILD_OPENJTAG_FTD2XX == 1
-#include <ftd2xx.h>
-#elif BUILD_OPENJTAG_LIBFTDI == 1
 #include <ftdi.h>
-#endif
 
 /* OpenJTAG vid/pid */
 static uint16_t openjtag_vid = 0x0403;
@@ -88,12 +90,7 @@ static uint16_t openjtag_pid = 0x6001;
 
 static char *openjtag_device_desc;
 
-#if BUILD_OPENJTAG_FTD2XX == 1
-static FT_HANDLE ftdih;
-
-#elif BUILD_OPENJTAG_LIBFTDI == 1
 static struct ftdi_context ftdic;
-#endif
 
 #define OPENJTAG_BUFFER_SIZE        504
 #define OPENJTAG_MAX_PENDING_RESULTS    256
@@ -114,10 +111,24 @@ static uint8_t usb_rx_buf[OPENJTAG_BUFFER_SIZE];
 static struct openjtag_scan_result openjtag_scan_result_buffer[OPENJTAG_MAX_PENDING_RESULTS];
 static int openjtag_scan_result_count;
 
-/* Openocd usb handler */
-struct openocd {
-	struct usb_dev_handle *usb_handle;
-};
+static jtag_libusb_device_handle *usbh;
+
+/* CY7C65215 model only */
+#define CY7C65215_JTAG_REQUEST  0x40  /* bmRequestType: vendor host-to-device */
+#define CY7C65215_JTAG_ENABLE   0xD0  /* bRequest: enable JTAG */
+#define CY7C65215_JTAG_DISABLE  0xD1  /* bRequest: disable JTAG */
+#define CY7C65215_JTAG_READ     0xD2  /* bRequest: read buffer */
+#define CY7C65215_JTAG_WRITE    0xD3  /* bRequest: write buffer */
+
+#define CY7C65215_USB_TIMEOUT   100
+
+static const uint16_t cy7c65215_vids[] = {0x04b4, 0};
+static const uint16_t cy7c65215_pids[] = {0x0007, 0};
+
+#define CY7C65215_JTAG_CLASS     0xff
+#define CY7C65215_JTAG_SUBCLASS  0x04
+
+static unsigned int ep_in, ep_out;
 
 #ifdef _DEBUG_USB_COMMS_
 
@@ -203,26 +214,9 @@ static int8_t openjtag_get_tap_state(int8_t state)
 	}
 }
 
-static int openjtag_buf_write(
+static int openjtag_buf_write_standard(
 	uint8_t *buf, int size, uint32_t *bytes_written)
 {
-#if BUILD_OPENJTAG_FTD2XX == 1
-	FT_STATUS status;
-	DWORD dw_bytes_written;
-
-#ifdef _DEBUG_USB_COMMS_
-	openjtag_debug_buffer(buf, size, DEBUG_TYPE_WRITE);
-#endif
-
-	status = FT_Write(ftdih, buf, size, &dw_bytes_written);
-	if (status != FT_OK) {
-		*bytes_written = dw_bytes_written;
-		LOG_ERROR("FT_Write returned: %u", status);
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-	*bytes_written = dw_bytes_written;
-	return ERROR_OK;
-#elif BUILD_OPENJTAG_LIBFTDI == 1
 	int retval;
 #ifdef _DEBUG_USB_COMMS_
 	openjtag_debug_buffer(buf, size, DEBUG_TYPE_WRITE);
@@ -238,36 +232,56 @@ static int openjtag_buf_write(
 	*bytes_written += retval;
 
 	return ERROR_OK;
-#endif
 }
 
-static int openjtag_buf_read(uint8_t *buf, uint32_t qty, uint32_t *bytes_read)
+static int openjtag_buf_write_cy7c65215(
+	uint8_t *buf, int size, uint32_t *bytes_written)
 {
+	int ret;
 
-#if BUILD_OPENJTAG_FTD2XX == 1
-	DWORD dw_bytes_read;
-	FT_STATUS status;
-	int timeout = 50;
+#ifdef _DEBUG_USB_COMMS_
+	openjtag_debug_buffer(buf, size, DEBUG_TYPE_WRITE);
+#endif
 
-	*bytes_read = 0;
-	while (qty && (*bytes_read < qty) && timeout--) {
+	if (size == 0) {
+		*bytes_written = 0;
+		return ERROR_OK;
+	}
 
-		status = FT_Read(ftdih, buf + *bytes_read,
-				qty - *bytes_read, &dw_bytes_read);
-		if (status != FT_OK) {
-			*bytes_read = dw_bytes_read;
-			LOG_ERROR("FT_Read returned: %u", status);
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-		*bytes_read += dw_bytes_read;
+	ret = jtag_libusb_control_transfer(usbh, CY7C65215_JTAG_REQUEST,
+									   CY7C65215_JTAG_WRITE, size, 0,
+									   NULL, 0, CY7C65215_USB_TIMEOUT);
+	if (ret < 0) {
+		LOG_ERROR("vendor command failed, error %d", ret);
+		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
-#ifdef _DEBUG_USB_COMMS_
-	openjtag_debug_buffer(buf, *bytes_read, DEBUG_TYPE_READ);
-#endif
+	ret = jtag_libusb_bulk_write(usbh, ep_out, (char *)buf, size,
+								 CY7C65215_USB_TIMEOUT);
+	if (ret < 0) {
+		LOG_ERROR("bulk write failed, error %d", ret);
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+	*bytes_written = ret;
 
 	return ERROR_OK;
-#elif BUILD_OPENJTAG_LIBFTDI == 1
+}
+
+static int openjtag_buf_write(
+	uint8_t *buf, int size, uint32_t *bytes_written)
+{
+	switch (openjtag_variant) {
+	case OPENJTAG_VARIANT_CY7C65215:
+		return openjtag_buf_write_cy7c65215(buf, size, bytes_written);
+	default:
+		return openjtag_buf_write_standard(buf, size, bytes_written);
+	}
+}
+
+static int openjtag_buf_read_standard(
+	uint8_t *buf, uint32_t qty, uint32_t *bytes_read)
+{
+
 	int retval;
 	int timeout = 5;
 
@@ -289,10 +303,53 @@ static int openjtag_buf_read(uint8_t *buf, uint32_t qty, uint32_t *bytes_read)
 	openjtag_debug_buffer(buf, *bytes_read, DEBUG_TYPE_READ);
 #endif
 
+	return ERROR_OK;
+}
+
+static int openjtag_buf_read_cy7c65215(
+	uint8_t *buf, uint32_t qty, uint32_t *bytes_read)
+{
+	int ret;
+
+	if (qty == 0) {
+		*bytes_read = 0;
+		goto out;
+	}
+
+	ret = jtag_libusb_control_transfer(usbh, CY7C65215_JTAG_REQUEST,
+									   CY7C65215_JTAG_READ, qty, 0,
+									   NULL, 0, CY7C65215_USB_TIMEOUT);
+	if (ret < 0) {
+		LOG_ERROR("vendor command failed, error %d", ret);
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	ret = jtag_libusb_bulk_read(usbh, ep_in, (char *)buf, qty,
+								CY7C65215_USB_TIMEOUT);
+	if (ret < 0) {
+		LOG_ERROR("bulk read failed, error %d", ret);
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+	*bytes_read = ret;
+
+out:
+#ifdef _DEBUG_USB_COMMS_
+	openjtag_debug_buffer(buf, *bytes_read, DEBUG_TYPE_READ);
 #endif
+
 	return ERROR_OK;
 }
 
+static int openjtag_buf_read(uint8_t *buf, uint32_t qty, uint32_t *bytes_read)
+{
+	switch (openjtag_variant) {
+	case OPENJTAG_VARIANT_CY7C65215:
+		return openjtag_buf_read_cy7c65215(buf, qty, bytes_read);
+	default:
+		return openjtag_buf_read_standard(buf, qty, bytes_read);
+	}
+}
+
 static int openjtag_sendcommand(uint8_t cmd)
 {
 	uint32_t written;
@@ -337,109 +394,17 @@ static int openjtag_speed(int speed)
 	return ERROR_OK;
 }
 
-static int openjtag_init(void)
+static int openjtag_init_standard(void)
 {
 	uint8_t latency_timer;
 
-#if BUILD_OPENJTAG_FTD2XX == 1
-	FT_STATUS status;
-#endif
-
-usb_tx_buf_offs = 0;
-usb_rx_buf_len = 0;
-openjtag_scan_result_count = 0;
-
-#if BUILD_OPENJTAG_FTD2XX == 1
-	LOG_DEBUG("'openjtag' interface using FTD2XX");
-#elif BUILD_OPENJTAG_LIBFTDI == 1
-	LOG_DEBUG("'openjtag' interface using libftdi");
-#endif
-
-/* Open by device description */
-if (openjtag_device_desc == NULL) {
-	LOG_WARNING("no openjtag device description specified, "
+	/* Open by device description */
+	if (openjtag_device_desc == NULL) {
+		LOG_WARNING("no openjtag device description specified, "
 				"using default 'Open JTAG Project'");
-	openjtag_device_desc = "Open JTAG Project";
-}
-
-#if BUILD_OPENJTAG_FTD2XX == 1
-
-#if IS_WIN32 == 0
-	/* Add non-standard Vid/Pid to the linux driver */
-	status = FT_SetVIDPID(openjtag_vid, openjtag_pid);
-	if (status != FT_OK) {
-		LOG_WARNING("couldn't add %4.4x:%4.4x",
-			openjtag_vid, openjtag_pid);
+		openjtag_device_desc = "Open JTAG Project";
 	}
-#endif
 
-	status = FT_OpenEx(openjtag_device_desc, FT_OPEN_BY_DESCRIPTION,
-			&ftdih);
-	if (status != FT_OK) {
-		DWORD num_devices;
-
-		LOG_ERROR("unable to open ftdi device: %u", status);
-		status = FT_ListDevices(&num_devices, NULL,
-				FT_LIST_NUMBER_ONLY);
-		if (status == FT_OK) {
-			char **desc_array = malloc(sizeof(char *)
-						* (num_devices + 1));
-			unsigned int i;
-
-			for (i = 0; i < num_devices; i++)
-				desc_array[i] = malloc(64);
-			desc_array[num_devices] = NULL;
-
-			status = FT_ListDevices(desc_array, &num_devices,
-				FT_LIST_ALL | FT_OPEN_BY_DESCRIPTION);
-
-			if (status == FT_OK) {
-				LOG_ERROR("ListDevices: %u\n", num_devices);
-				for (i = 0; i < num_devices; i++)
-					LOG_ERROR("%i: %s", i, desc_array[i]);
-			}
-
-			for (i = 0; i < num_devices; i++)
-				free(desc_array[i]);
-			free(desc_array);
-		} else {
-			LOG_ERROR("ListDevices: NONE\n");
-		}
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_SetLatencyTimer(ftdih, 2);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to set latency timer: %u", status);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_GetLatencyTimer(ftdih, &latency_timer);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to get latency timer: %u", status);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-	LOG_DEBUG("current latency timer: %i", latency_timer);
-
-	status = FT_SetBitMode(ftdih, 0x00, 0x40);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to disable bit i/o mode: %u", status);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_SetTimeouts(ftdih, 50, 0);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to set timeouts: %u", status);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to FT_Purge() %u", status);
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-#elif BUILD_OPENJTAG_LIBFTDI == 1
 	if (ftdi_init(&ftdic) < 0)
 		return ERROR_JTAG_INIT_FAILED;
 
@@ -471,41 +436,110 @@ if (openjtag_device_desc == NULL) {
 		LOG_ERROR("Can't set baud rate to max: %s",
 			ftdi_get_error_string(&ftdic));
 		return ERROR_JTAG_DEVICE_ERROR;
-	};
-#endif
+	}
 
-#if BUILD_OPENJTAG_FTD2XX == 1
-	status = FT_Purge(ftdih, FT_PURGE_RX | FT_PURGE_TX);
-	if (status != FT_OK)
-		return ERROR_JTAG_INIT_FAILED;
-#elif BUILD_OPENJTAG_LIBFTDI == 1
 	if (ftdi_usb_purge_buffers(&ftdic) < 0) {
 		LOG_ERROR("ftdi_purge_buffers: %s", ftdic.error_str);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-#endif
 
-	/* OpenJTAG speed */
-	openjtag_sendcommand(0xE0); /*Start at slowest adapter speed*/
+	return ERROR_OK;
+}
+
+static int openjtag_init_cy7c65215(void)
+{
+	int ret;
+
+	usbh = NULL;
+	ret = jtag_libusb_open(cy7c65215_vids, cy7c65215_pids, NULL, &usbh);
+	if (ret != ERROR_OK) {
+		LOG_ERROR("unable to open cy7c65215 device");
+		goto err;
+	}
+
+	ret = jtag_libusb_choose_interface(usbh, &ep_in, &ep_out,
+									   CY7C65215_JTAG_CLASS,
+									   CY7C65215_JTAG_SUBCLASS, -1, LIBUSB_TRANSFER_TYPE_BULK);
+	if (ret != ERROR_OK) {
+		LOG_ERROR("unable to claim JTAG interface");
+		goto err;
+	}
 
-	/* MSB */
-	openjtag_sendcommand(0x75);
+	ret = jtag_libusb_control_transfer(usbh,
+									   CY7C65215_JTAG_REQUEST,
+									   CY7C65215_JTAG_ENABLE,
+									   0, 0, NULL, 0, CY7C65215_USB_TIMEOUT);
+	if (ret < 0) {
+		LOG_ERROR("could not enable JTAG module");
+		goto err;
+	}
 
 	return ERROR_OK;
+
+err:
+	if (usbh != NULL)
+		jtag_libusb_close(usbh);
+	return ERROR_JTAG_INIT_FAILED;
 }
 
-static int openjtag_quit(void)
+static int openjtag_init(void)
+{
+	int ret;
+
+	usb_tx_buf_offs = 0;
+	usb_rx_buf_len = 0;
+	openjtag_scan_result_count = 0;
+
+	switch (openjtag_variant) {
+	case OPENJTAG_VARIANT_CY7C65215:
+		ret = openjtag_init_cy7c65215();
+		break;
+	default:
+		ret = openjtag_init_standard();
+	}
+	if (ret != ERROR_OK)
+		return ret;
+
+	openjtag_speed(375); /* Start at slowest adapter speed */
+	openjtag_sendcommand(0x75); /* MSB */
+
+	return ERROR_OK;
+}
+
+static int openjtag_quit_standard(void)
 {
-#if BUILD_OPENJTAG_FTD2XX == 1
-	FT_Close(ftdih);
-#elif BUILD_OPENJTAG_LIBFTDI == 1
 	ftdi_usb_close(&ftdic);
 	ftdi_deinit(&ftdic);
-#endif
 
 	return ERROR_OK;
 }
 
+static int openjtag_quit_cy7c65215(void)
+{
+	int ret;
+
+	ret = jtag_libusb_control_transfer(usbh,
+									   CY7C65215_JTAG_REQUEST,
+									   CY7C65215_JTAG_DISABLE,
+									   0, 0, NULL, 0, CY7C65215_USB_TIMEOUT);
+	if (ret < 0)
+		LOG_WARNING("could not disable JTAG module");
+
+	jtag_libusb_close(usbh);
+
+	return ERROR_OK;
+}
+
+static int openjtag_quit(void)
+{
+	switch (openjtag_variant) {
+	case OPENJTAG_VARIANT_CY7C65215:
+		return openjtag_quit_cy7c65215();
+	default:
+		return openjtag_quit_standard();
+	}
+}
+
 static void openjtag_write_tap_buffer(void)
 {
 	uint32_t written;
@@ -538,8 +572,8 @@ static int openjtag_execute_tap_queue(void)
 
 			uint8_t *buffer = openjtag_scan_result_buffer[res_count].buffer;
 
-			while (len) {
-				if (len <= 8) {
+			while (len > 0) {
+				if (len <= 8 && openjtag_variant != OPENJTAG_VARIANT_CY7C65215) {
 					DEBUG_JTAG_IO("bits < 8 buf = 0x%X, will be 0x%X",
 						usb_rx_buf[rx_offs], usb_rx_buf[rx_offs] >> (8 - len));
 					buffer[count] = usb_rx_buf[rx_offs] >> (8 - len);
@@ -726,11 +760,14 @@ static void openjtag_execute_runtest(struct jtag_command *cmd)
 	if (cmd->cmd.runtest->num_cycles > 16)
 		LOG_WARNING("num_cycles > 16 on run test");
 
-	uint8_t command;
-	command = 7;
-	command |= ((cmd->cmd.runtest->num_cycles - 1) & 0x0F) << 4;
+	if (openjtag_variant != OPENJTAG_VARIANT_CY7C65215 ||
+		cmd->cmd.runtest->num_cycles) {
+		uint8_t command;
+		command = 7;
+		command |= ((cmd->cmd.runtest->num_cycles - 1) & 0x0F) << 4;
 
-	openjtag_add_byte(command);
+		openjtag_add_byte(command);
+	}
 
 	tap_set_end_state(end_state);
 	if (tap_get_end_state() != tap_get_state()) {
@@ -818,6 +855,24 @@ COMMAND_HANDLER(openjtag_handle_device_desc_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(openjtag_handle_variant_command)
+{
+	if (CMD_ARGC == 1) {
+		const char * const *name = openjtag_variant_names;
+		int variant = 0;
+		for (; *name; name++, variant++) {
+			if (strcasecmp(CMD_ARGV[0], *name) == 0) {
+				openjtag_variant = variant;
+				return ERROR_OK;
+			}
+		}
+		LOG_ERROR("unknown openjtag variant '%s'", CMD_ARGV[0]);
+	} else {
+		LOG_ERROR("require exactly one argument to "
+				"openjtag_variant <variant>");
+	}
+	return ERROR_OK;
+}
 
 static const struct command_registration openjtag_command_handlers[] = {
 	{
@@ -827,6 +882,13 @@ static const struct command_registration openjtag_command_handlers[] = {
 		.help = "set the USB device description of the OpenJTAG",
 		.usage = "description-string",
 	},
+	{
+		.name = "openjtag_variant",
+		.handler = openjtag_handle_variant_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the OpenJTAG variant",
+		.usage = "variant-string",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/jtag/drivers/osbdm.c b/src/jtag/drivers/osbdm.c
index d1eeedb3..5db36a12 100644
--- a/src/jtag/drivers/osbdm.c
+++ b/src/jtag/drivers/osbdm.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #	include "config.h"
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index ff758595..c9e33164 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index 30185340..49caa679 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /**
@@ -36,14 +34,7 @@
 #include "bitq.h"
 
 /* PRESTO access library includes */
-#if BUILD_PRESTO_FTD2XX == 1
-#include <ftd2xx.h>
-#include "ftd2xx_common.h"
-#elif BUILD_PRESTO_LIBFTDI == 1
 #include <ftdi.h>
-#else
-#error "BUG: either FTD2XX and LIBFTDI has to be used"
-#endif
 
 /* -------------------------------------------------------------------------- */
 
@@ -57,13 +48,8 @@
 #define BUFFER_SIZE (64*62)
 
 struct presto {
-#if BUILD_PRESTO_FTD2XX == 1
-	FT_HANDLE handle;
-	FT_STATUS status;
-#elif BUILD_PRESTO_LIBFTDI == 1
 	struct ftdi_context ftdic;
 	int retval;
-#endif
 
 	char serial[FT_DEVICE_SERNUM_LEN];
 
@@ -97,15 +83,6 @@ static uint8_t presto_init_seq[] = {
 
 static int presto_write(uint8_t *buf, uint32_t size)
 {
-#if BUILD_PRESTO_FTD2XX == 1
-	DWORD ftbytes;
-	presto->status = FT_Write(presto->handle, buf, size, &ftbytes);
-	if (presto->status != FT_OK) {
-		LOG_ERROR("FT_Write returned: %s", ftd2xx_status_string(presto->status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-#elif BUILD_PRESTO_LIBFTDI == 1
 	uint32_t ftbytes;
 	presto->retval = ftdi_write_data(&presto->ftdic, buf, size);
 	if (presto->retval < 0) {
@@ -113,7 +90,6 @@ static int presto_write(uint8_t *buf, uint32_t size)
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 	ftbytes = presto->retval;
-#endif
 
 	if (ftbytes != size) {
 		LOG_ERROR("couldn't write the requested number of bytes to PRESTO (%u < %u)",
@@ -126,15 +102,6 @@ static int presto_write(uint8_t *buf, uint32_t size)
 
 static int presto_read(uint8_t *buf, uint32_t size)
 {
-#if BUILD_PRESTO_FTD2XX == 1
-	DWORD ftbytes;
-	presto->status = FT_Read(presto->handle, buf, size, &ftbytes);
-	if (presto->status != FT_OK) {
-		LOG_ERROR("FT_Read returned: %s", ftd2xx_status_string(presto->status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-#elif BUILD_PRESTO_LIBFTDI == 1
 	uint32_t ftbytes = 0;
 
 	struct timeval timeout, now;
@@ -154,7 +121,6 @@ static int presto_read(uint8_t *buf, uint32_t size)
 				((now.tv_sec == timeout.tv_sec) && (now.tv_usec > timeout.tv_usec)))
 			break;
 	}
-#endif
 
 	if (ftbytes != size) {
 		/* this is just a warning, there might have been timeout when detecting PRESTO,
@@ -167,150 +133,6 @@ static int presto_read(uint8_t *buf, uint32_t size)
 	return ERROR_OK;
 }
 
-#if BUILD_PRESTO_FTD2XX == 1
-static int presto_open_ftd2xx(char *req_serial)
-{
-	uint32_t i;
-	DWORD numdevs;
-	DWORD vidpid;
-	char devname[FT_DEVICE_NAME_LEN];
-	FT_DEVICE device;
-
-	BYTE presto_data;
-	DWORD ftbytes;
-
-	presto->handle = (FT_HANDLE)INVALID_HANDLE_VALUE;
-
-#if IS_WIN32 == 0
-	/* Add non-standard Vid/Pid to the linux driver */
-	presto->status = FT_SetVIDPID(PRESTO_VID, PRESTO_PID);
-	if (presto->status != FT_OK) {
-		LOG_ERROR("couldn't add PRESTO VID/PID");
-		exit(-1);
-	}
-#endif
-
-	presto->status = FT_ListDevices(&numdevs, NULL, FT_LIST_NUMBER_ONLY);
-	if (presto->status != FT_OK) {
-		LOG_ERROR("FT_ListDevices failed: %s", ftd2xx_status_string(presto->status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	LOG_DEBUG("FTDI devices available: %" PRIu32, (uint32_t)numdevs);
-	for (i = 0; i < numdevs; i++) {
-		presto->status = FT_Open(i, &(presto->handle));
-		if (presto->status != FT_OK) {
-			/* this is not fatal, the device may be legitimately open by other process,
-			 *hence debug message only */
-			LOG_DEBUG("FT_Open failed: %s", ftd2xx_status_string(presto->status));
-			continue;
-		}
-		LOG_DEBUG("FTDI device %i open", (int)i);
-
-		presto->status = FT_GetDeviceInfo(presto->handle, &device,
-				&vidpid, presto->serial, devname, NULL);
-		if (presto->status == FT_OK) {
-			if (vidpid == PRESTO_VID_PID && (req_serial == NULL ||
-					!strcmp(presto->serial, req_serial)))
-				break;
-		} else
-			LOG_DEBUG("FT_GetDeviceInfo failed: %s", ftd2xx_status_string(
-					presto->status));
-
-		LOG_DEBUG("FTDI device %i does not match, closing", (int)i);
-		FT_Close(presto->handle);
-		presto->handle = (FT_HANDLE)INVALID_HANDLE_VALUE;
-	}
-
-	if (presto->handle == (FT_HANDLE)INVALID_HANDLE_VALUE)
-		return ERROR_JTAG_DEVICE_ERROR;	/* presto not open, return */
-
-	presto->status = FT_SetLatencyTimer(presto->handle, 1);
-	if (presto->status != FT_OK)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	presto->status = FT_SetTimeouts(presto->handle, 100, 0);
-	if (presto->status != FT_OK)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	presto->status = FT_Purge(presto->handle, FT_PURGE_TX | FT_PURGE_RX);
-	if (presto->status != FT_OK)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	presto_data = 0xD0;
-	presto->status = FT_Write(presto->handle, &presto_data, 1, &ftbytes);
-	if (presto->status != FT_OK)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	/* delay between first write/read turnaround (after purge?) necessary
-	 * under Linux for unknown reason,
-	 * probably a bug in library threading */
-	openocd_usleep(100000);
-	presto->status = FT_Read(presto->handle, &presto_data, 1, &ftbytes);
-	if (presto->status != FT_OK)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	if (ftbytes != 1) {
-		LOG_DEBUG("PRESTO reset");
-
-		presto->status = FT_Purge(presto->handle, FT_PURGE_TX | FT_PURGE_RX);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-		presto->status = FT_SetBitMode(presto->handle, 0x80, 1);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-		presto->status = FT_SetBaudRate(presto->handle, 9600);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-
-		presto_data = 0;
-		for (i = 0; i < 4 * 62; i++) {
-			presto->status = FT_Write(presto->handle, &presto_data, 1, &ftbytes);
-			if (presto->status != FT_OK)
-				return ERROR_JTAG_DEVICE_ERROR;
-		}
-		openocd_usleep(100000);
-
-		presto->status = FT_SetBitMode(presto->handle, 0x00, 0);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-
-		presto->status = FT_Purge(presto->handle, FT_PURGE_TX | FT_PURGE_RX);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-
-		presto_data = 0xD0;
-		presto->status = FT_Write(presto->handle, &presto_data, 1, &ftbytes);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-
-		/* delay between first write/read turnaround (after purge?) necessary under Linux for unknown reason,
-		   probably a bug in library threading */
-		openocd_usleep(100000);
-		presto->status = FT_Read(presto->handle, &presto_data, 1, &ftbytes);
-		if (presto->status != FT_OK)
-			return ERROR_JTAG_DEVICE_ERROR;
-
-		if (ftbytes != 1) {
-			LOG_DEBUG("PRESTO not responding");
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	presto->status = FT_SetTimeouts(presto->handle, 0, 0);
-	if (presto->status != FT_OK)
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	presto->status = FT_Write(presto->handle, &presto_init_seq,
-			sizeof(presto_init_seq), &ftbytes);
-
-	if (presto->status != FT_OK || ftbytes != sizeof(presto_init_seq))
-		return ERROR_JTAG_DEVICE_ERROR;
-
-	return ERROR_OK;
-}
-
-#elif BUILD_PRESTO_LIBFTDI == 1
 static int presto_open_libftdi(char *req_serial)
 {
 	uint8_t presto_data;
@@ -373,7 +195,6 @@ static int presto_open_libftdi(char *req_serial)
 
 	return ERROR_OK;
 }
-#endif	/* BUILD_PRESTO_LIBFTDI == 1 */
 
 static int presto_open(char *req_serial)
 {
@@ -393,11 +214,7 @@ static int presto_open(char *req_serial)
 
 	presto->jtag_speed = 0;
 
-#if BUILD_PRESTO_FTD2XX == 1
-	return presto_open_ftd2xx(req_serial);
-#elif BUILD_PRESTO_LIBFTDI == 1
 	return presto_open_libftdi(req_serial);
-#endif
 }
 
 static int presto_close(void)
@@ -405,35 +222,6 @@ static int presto_close(void)
 
 	int result = ERROR_OK;
 
-#if BUILD_PRESTO_FTD2XX == 1
-	DWORD ftbytes;
-
-	if (presto->handle == (FT_HANDLE)INVALID_HANDLE_VALUE)
-		return result;
-
-	presto->status = FT_Purge(presto->handle, FT_PURGE_TX | FT_PURGE_RX);
-	if (presto->status != FT_OK)
-		result = ERROR_JTAG_DEVICE_ERROR;
-
-	presto->status = FT_Write(presto->handle,
-			&presto_init_seq,
-			sizeof(presto_init_seq),
-			&ftbytes);
-	if (presto->status != FT_OK || ftbytes != sizeof(presto_init_seq))
-		result = ERROR_JTAG_DEVICE_ERROR;
-
-	presto->status = FT_SetLatencyTimer(presto->handle, 16);
-	if (presto->status != FT_OK)
-		result = ERROR_JTAG_DEVICE_ERROR;
-
-	presto->status = FT_Close(presto->handle);
-	if (presto->status != FT_OK)
-		result = ERROR_JTAG_DEVICE_ERROR;
-	else
-		presto->handle = (FT_HANDLE)INVALID_HANDLE_VALUE;
-
-#elif BUILD_PRESTO_LIBFTDI == 1
-
 	presto->retval = ftdi_write_data(&presto->ftdic, presto_init_seq, sizeof(presto_init_seq));
 	if (presto->retval != sizeof(presto_init_seq))
 		result = ERROR_JTAG_DEVICE_ERROR;
@@ -447,7 +235,6 @@ static int presto_close(void)
 		result = ERROR_JTAG_DEVICE_ERROR;
 	else
 		ftdi_deinit(&presto->ftdic);
-#endif
 
 	return result;
 }
@@ -457,11 +244,7 @@ static int presto_flush(void)
 	if (presto->buff_out_pos == 0)
 		return ERROR_OK;
 
-#if BUILD_PRESTO_FTD2XX == 1
-	if (presto->status != FT_OK) {
-#elif BUILD_PRESTO_LIBFTDI == 1
 	if (presto->retval < 0) {
-#endif
 		LOG_DEBUG("error in previous communication, canceling I/O operation");
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
@@ -504,13 +287,9 @@ static int presto_sendbyte(int data)
 	} else
 		return ERROR_JTAG_DEVICE_ERROR;
 
-#if BUILD_PRESTO_FTD2XX == 1
-	if (presto->buff_out_pos >= BUFFER_SIZE)
-#elif BUILD_PRESTO_LIBFTDI == 1
 	/* libftdi does not do background read, be sure that USB IN buffer does not overflow (128
 	 *bytes only!) */
 	if (presto->buff_out_pos >= BUFFER_SIZE || presto->buff_in_exp == 128)
-#endif
 		return presto_flush();
 
 	return ERROR_OK;
diff --git a/src/jtag/drivers/remote_bitbang.c b/src/jtag/drivers/remote_bitbang.c
index a1c11b24..c8d01366 100644
--- a/src/jtag/drivers/remote_bitbang.c
+++ b/src/jtag/drivers/remote_bitbang.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 3587a9d5..3f9e3326 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/rlink.h b/src/jtag/drivers/rlink.h
index 8f09f8ce..74b62580 100644
--- a/src/jtag/drivers/rlink.h
+++ b/src/jtag/drivers/rlink.h
@@ -13,11 +13,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_JTAG_DRIVERS_RLINK_H
+#define OPENOCD_JTAG_DRIVERS_RLINK_H
+
 struct rlink_speed_table {
 	uint8_t const *dtc;
 	uint16_t dtc_size;
@@ -27,3 +28,5 @@ struct rlink_speed_table {
 
 extern const struct rlink_speed_table rlink_speed_table[];
 extern const size_t rlink_speed_table_size;
+
+#endif /* OPENOCD_JTAG_DRIVERS_RLINK_H */
diff --git a/src/jtag/drivers/rlink_call.m4 b/src/jtag/drivers/rlink_call.m4
index 13e0fc2d..b27f3923 100644
--- a/src/jtag/drivers/rlink_call.m4
+++ b/src/jtag/drivers/rlink_call.m4
@@ -14,9 +14,7 @@ m4_divert(`-1')
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 m4_dnl Setup and hold times depend on SHIFTER_PRESCALER
diff --git a/src/jtag/drivers/rlink_dtc_cmd.h b/src/jtag/drivers/rlink_dtc_cmd.h
index faf41ce5..ff9e8b25 100644
--- a/src/jtag/drivers/rlink_dtc_cmd.h
+++ b/src/jtag/drivers/rlink_dtc_cmd.h
@@ -13,11 +13,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_JTAG_DRIVERS_RLINK_DTC_CMD_H
+#define OPENOCD_JTAG_DRIVERS_RLINK_DTC_CMD_H
+
 /* A command position with the high nybble of 0x0 is reserved for an error condition.
  * If executed, it stops the DTC and raises the ERROR flag */
 
@@ -71,3 +72,5 @@
 /* A shared status byte is updated with bit 0 set when this has happened,
  * and it is cleared when a new command buffer becomes ready.
  * The host can poll that byte to see when it is safe to read a reply. */
+
+#endif /* OPENOCD_JTAG_DRIVERS_RLINK_DTC_CMD_H */
diff --git a/src/jtag/drivers/rlink_ep1_cmd.h b/src/jtag/drivers/rlink_ep1_cmd.h
index 00b19eee..3f9f2b38 100644
--- a/src/jtag/drivers/rlink_ep1_cmd.h
+++ b/src/jtag/drivers/rlink_ep1_cmd.h
@@ -13,11 +13,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_JTAG_DRIVERS_RLINK_EP1_CMD_H
+#define OPENOCD_JTAG_DRIVERS_RLINK_EP1_CMD_H
+
 /*
  * Command opcodes that can be sent over endpoint 1.
  * This codifies information provided by Rob Brown <rob@cobbleware.com>.
@@ -55,3 +56,5 @@
 #define EP1_CMD_MEMORY_WRITE			(0x29)
 #define EP1_CMD_GET_FWREV				(0xfe)
 #define EP1_CMD_GET_SERIAL				(0xff)
+
+#endif /* OPENOCD_JTAG_DRIVERS_RLINK_EP1_CMD_H */
diff --git a/src/jtag/drivers/rlink_init.m4 b/src/jtag/drivers/rlink_init.m4
index b1340046..8ad2f51d 100644
--- a/src/jtag/drivers/rlink_init.m4
+++ b/src/jtag/drivers/rlink_init.m4
@@ -14,9 +14,7 @@ m4_divert(`-1')
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 m4_undefine(`CTRL_MPEG_L')
diff --git a/src/jtag/drivers/rlink_st7.h b/src/jtag/drivers/rlink_st7.h
index a30acb47..3d573e72 100644
--- a/src/jtag/drivers/rlink_st7.h
+++ b/src/jtag/drivers/rlink_st7.h
@@ -13,11 +13,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_JTAG_DRIVERS_RLINK_ST7_H
+#define OPENOCD_JTAG_DRIVERS_RLINK_ST7_H
+
 #define ST7_FOSC		(12 * 1000000)
 
 /* This is not a complete enumeration of ST7 registers, but it is sufficient for this interface driver. */
@@ -112,3 +113,5 @@
 #define ST7_PF5			(1 << 5)
 #define ST7_PF6			(1 << 6)
 #define ST7_PF7			(1 << 7)
+
+#endif /* OPENOCD_JTAG_DRIVERS_RLINK_ST7_H */
diff --git a/src/jtag/drivers/stlink_usb.c b/src/jtag/drivers/stlink_usb.c
index 9f07a5c1..8c5045b2 100644
--- a/src/jtag/drivers/stlink_usb.c
+++ b/src/jtag/drivers/stlink_usb.c
@@ -18,9 +18,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -135,9 +133,19 @@ struct stlink_usb_handle_s {
 #define STLINK_DEBUG_ERR_OK            0x80
 #define STLINK_DEBUG_ERR_FAULT         0x81
 #define STLINK_SWD_AP_WAIT             0x10
+#define STLINK_SWD_AP_FAULT            0x11
+#define STLINK_SWD_AP_ERROR            0x12
+#define STLINK_SWD_AP_PARITY_ERROR     0x13
 #define STLINK_JTAG_WRITE_ERROR        0x0c
 #define STLINK_JTAG_WRITE_VERIF_ERROR  0x0d
 #define STLINK_SWD_DP_WAIT             0x14
+#define STLINK_SWD_DP_FAULT            0x15
+#define STLINK_SWD_DP_ERROR            0x16
+#define STLINK_SWD_DP_PARITY_ERROR     0x17
+
+#define STLINK_SWD_AP_WDATA_ERROR      0x18
+#define STLINK_SWD_AP_STICKY_ERROR     0x19
+#define STLINK_SWD_AP_STICKYORUN_ERROR 0x1a
 
 #define STLINK_CORE_RUNNING            0x80
 #define STLINK_CORE_HALTED             0x81
@@ -208,7 +216,7 @@ struct stlink_usb_handle_s {
 #define STLINK_DEBUG_APIV2_DRIVE_NRST_HIGH  0x01
 #define STLINK_DEBUG_APIV2_DRIVE_NRST_PULSE 0x02
 
-#define STLINK_TRACE_SIZE               1024
+#define STLINK_TRACE_SIZE               4096
 #define STLINK_TRACE_MAX_HZ             2000000
 #define STLINK_TRACE_MIN_VERSION        13
 
@@ -398,6 +406,38 @@ static int stlink_usb_error_check(void *handle)
 		case STLINK_JTAG_WRITE_VERIF_ERROR:
 			LOG_DEBUG("Verify error");
 			return ERROR_FAIL;
+		case STLINK_SWD_AP_FAULT:
+			/* git://git.ac6.fr/openocd commit 657e3e885b9ee10
+			 * returns ERROR_OK with the comment:
+			 * Change in error status when reading outside RAM.
+			 * This fix allows CDT plugin to visualize memory.
+			 */
+			LOG_DEBUG("STLINK_SWD_AP_FAULT");
+			return ERROR_FAIL;
+		case STLINK_SWD_AP_ERROR:
+			LOG_DEBUG("STLINK_SWD_AP_ERROR");
+			return ERROR_FAIL;
+		case STLINK_SWD_AP_PARITY_ERROR:
+			LOG_DEBUG("STLINK_SWD_AP_PARITY_ERROR");
+			return ERROR_FAIL;
+		case STLINK_SWD_DP_FAULT:
+			LOG_DEBUG("STLINK_SWD_DP_FAULT");
+			return ERROR_FAIL;
+		case STLINK_SWD_DP_ERROR:
+			LOG_DEBUG("STLINK_SWD_DP_ERROR");
+			return ERROR_FAIL;
+		case STLINK_SWD_DP_PARITY_ERROR:
+			LOG_DEBUG("STLINK_SWD_DP_PARITY_ERROR");
+			return ERROR_FAIL;
+		case STLINK_SWD_AP_WDATA_ERROR:
+			LOG_DEBUG("STLINK_SWD_AP_WDATA_ERROR");
+			return ERROR_FAIL;
+		case STLINK_SWD_AP_STICKY_ERROR:
+			LOG_DEBUG("STLINK_SWD_AP_STICKY_ERROR");
+			return ERROR_FAIL;
+		case STLINK_SWD_AP_STICKYORUN_ERROR:
+			LOG_DEBUG("STLINK_SWD_AP_STICKYORUN_ERROR");
+			return ERROR_FAIL;
 		default:
 			LOG_DEBUG("unknown/unexpected STLINK status code 0x%x", h->databuf[0]);
 			return ERROR_FAIL;
@@ -1122,7 +1162,7 @@ static int stlink_usb_step(void *handle)
 
 	if (h->jtag_api == STLINK_JTAG_API_V2) {
 		/* TODO: this emulates the v1 api, it should really use a similar auto mask isr
-		 * that the cortex-m3 currently does. */
+		 * that the Cortex-M3 currently does. */
 		stlink_usb_write_debug_reg(handle, DCB_DHCSR, DBGKEY|C_HALT|C_MASKINTS|C_DEBUGEN);
 		stlink_usb_write_debug_reg(handle, DCB_DHCSR, DBGKEY|C_STEP|C_MASKINTS|C_DEBUGEN);
 		return stlink_usb_write_debug_reg(handle, DCB_DHCSR, DBGKEY|C_HALT|C_DEBUGEN);
diff --git a/src/jtag/drivers/sysfsgpio.c b/src/jtag/drivers/sysfsgpio.c
index fd613c2d..77b727c2 100644
--- a/src/jtag/drivers/sysfsgpio.c
+++ b/src/jtag/drivers/sysfsgpio.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* 2014-12: Addition of the SWD protocol support is based on the initial work
diff --git a/src/jtag/drivers/ti_icdi_usb.c b/src/jtag/drivers/ti_icdi_usb.c
index ac456623..171ac66c 100644
--- a/src/jtag/drivers/ti_icdi_usb.c
+++ b/src/jtag/drivers/ti_icdi_usb.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -244,7 +242,8 @@ static int icdi_send_remote_cmd(void *handle, const char *data)
 	struct icdi_usb_handle_s *h = handle;
 
 	size_t cmd_len = sprintf(h->write_buffer, PACKET_START "qRcmd,");
-	cmd_len += hexify(h->write_buffer + cmd_len, data, 0, h->max_packet - cmd_len);
+	cmd_len += hexify(h->write_buffer + cmd_len, (const uint8_t *)data,
+		strlen(data), h->max_packet - cmd_len);
 
 	return icdi_send_packet(handle, cmd_len);
 }
@@ -268,7 +267,7 @@ static int icdi_get_cmd_result(void *handle)
 
 	if (h->read_buffer[offset] == 'E') {
 		/* get error code */
-		char result;
+		uint8_t result;
 		if (unhexify(&result, h->read_buffer + offset + 1, 1) != 1)
 			return ERROR_FAIL;
 		return result;
@@ -330,7 +329,7 @@ static int icdi_usb_version(void *handle)
 	}
 
 	/* convert reply */
-	if (unhexify(version, h->read_buffer + 2, 4) != 4) {
+	if (unhexify((uint8_t *)version, h->read_buffer + 2, 4) != 4) {
 		LOG_WARNING("unable to get ICDI version");
 		return ERROR_OK;
 	}
@@ -497,7 +496,7 @@ static int icdi_usb_read_reg(void *handle, int num, uint32_t *val)
 
 	/* convert result */
 	uint8_t buf[4];
-	if (unhexify((char *)buf, h->read_buffer + 2, 4) != 4) {
+	if (unhexify(buf, h->read_buffer + 2, 4) != 4) {
 		LOG_ERROR("failed to convert result");
 		return ERROR_FAIL;
 	}
@@ -514,7 +513,7 @@ static int icdi_usb_write_reg(void *handle, int num, uint32_t val)
 	h_u32_to_le(buf, val);
 
 	int cmd_len = snprintf(cmd, sizeof(cmd), "P%x=", num);
-	hexify(cmd + cmd_len, (const char *)buf, 4, sizeof(cmd));
+	hexify(cmd + cmd_len, buf, 4, sizeof(cmd));
 
 	result = icdi_send_cmd(handle, cmd);
 	if (result != ERROR_OK)
diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index b98b278a..7fc847bf 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -193,6 +191,7 @@ int ulink_execute_queued_commands(struct ulink *device, int timeout);
 const char *ulink_cmd_id_string(uint8_t id);
 void ulink_print_command(struct ulink_cmd *ulink_cmd);
 void ulink_print_queue(struct ulink *device);
+static int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f);
 #endif
 
 int ulink_append_scan_cmd(struct ulink *device,
@@ -225,7 +224,6 @@ int ulink_append_test_cmd(struct ulink *device);
 
 /* OpenULINK TCK frequency helper functions */
 int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay);
-int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f);
 
 /* Interface between OpenULINK and OpenOCD */
 static void ulink_set_end_state(tap_state_t endstate);
@@ -1369,6 +1367,7 @@ int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay)
 	return ERROR_OK;
 }
 
+#ifdef _DEBUG_JTAG_IO_
 /**
  * Calculate frequency for a given delay value.
  *
@@ -1383,7 +1382,7 @@ int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f)
+static int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f)
 {
 	float t, f_float, f_rounded;
 
@@ -1432,6 +1431,7 @@ int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f)
 
 	return ERROR_OK;
 }
+#endif
 
 /******************* Interface between OpenULINK and OpenOCD ******************/
 
@@ -2066,7 +2066,7 @@ static int ulink_khz(int khz, int *jtag_speed)
 	}
 
 #ifdef _DEBUG_JTAG_IO_
-	long f_tck, f_tms, f_scan_in, f_scan_out, f_scan_io;
+	long f_tck = 0, f_tms = 0, f_scan_in = 0, f_scan_out = 0, f_scan_io = 0;
 
 	ulink_calculate_frequency(DELAY_CLOCK_TCK, ulink_handle->delay_clock_tck,
 		&f_tck);
diff --git a/src/jtag/drivers/usb_blaster/Makefile.am b/src/jtag/drivers/usb_blaster/Makefile.am
index 0fb47005..a6694c54 100644
--- a/src/jtag/drivers/usb_blaster/Makefile.am
+++ b/src/jtag/drivers/usb_blaster/Makefile.am
@@ -1,24 +1,13 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libocdusbblaster.la
+%C%_libocdusbblaster_la_SOURCES = $(USB_BLASTER_SRC)
+%C%_libocdusbblaster_la_CPPFLAGS = -I$(top_srcdir)/src/jtag/drivers $(AM_CPPFLAGS) $(LIBUSB1_CFLAGS) $(LIBFTDI_CFLAGS)
 
-AM_CPPFLAGS += -I$(top_srcdir)/src/jtag/drivers $(LIBUSB1_CFLAGS) $(LIBFTDI_CFLAGS)
+USB_BLASTER_SRC = %D%/usb_blaster.c %D%/ublast_access.h
 
-noinst_LTLIBRARIES = libocdusbblaster.la
-libocdusbblaster_la_SOURCES = $(USB_BLASTER_SRC)
-
-USB_BLASTER_SRC = usb_blaster.c
-
-if USB_BLASTER_LIBFTDI
-USB_BLASTER_SRC += ublast_access_ftdi.c
-endif
-
-if USB_BLASTER_FTD2XX
-USB_BLASTER_SRC += ublast_access_ftd2xx.c
+if USB_BLASTER
+USB_BLASTER_SRC += %D%/ublast_access_ftdi.c
 endif
 
 if USB_BLASTER_2
-USB_BLASTER_SRC += ublast2_access_libusb.c
+USB_BLASTER_SRC += %D%/ublast2_access_libusb.c
 endif
-
-noinst_HEADERS = ublast_access.h
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c b/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
index 343432b7..d1ea9b30 100644
--- a/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
+++ b/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
@@ -13,6 +13,9 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/usb_blaster/ublast_access.h b/src/jtag/drivers/usb_blaster/ublast_access.h
index 5bdc2573..252f003a 100644
--- a/src/jtag/drivers/usb_blaster/ublast_access.h
+++ b/src/jtag/drivers/usb_blaster/ublast_access.h
@@ -20,10 +20,13 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
  */
 
-#ifndef JTAG_UBLAST_ACCESS_H
-#define JTAG_UBLAST_ACCESS_H
+#ifndef OPENOCD_JTAG_DRIVERS_USB_BLASTER_UBLAST_ACCESS_H
+#define OPENOCD_JTAG_DRIVERS_USB_BLASTER_UBLAST_ACCESS_H
 
 #include <libusb_common.h>
 
@@ -53,19 +56,16 @@ struct ublast_lowlevel {
 
 /**
  * ublast_register_ftdi - get a lowlevel USB Blaster driver
- * ublast_register_ftd2xx - get a lowlevel USB Blaster driver
  * ublast2_register_libusb - get a lowlevel USB Blaster II driver
  *
- * Get a lowlevel USB-Blaster driver. In the current implementation, there are 3
+ * Get a lowlevel USB-Blaster driver. In the current implementation, there are 2
  * possible lowlevel drivers :
- *  - one based on libftdi from ftdichip.com
- *  - one based on libftdxx, the free alternative
+ *  - one based on libftdi,
  *  - one based on libusb, specific to the USB-Blaster II
  *
  * Returns the lowlevel driver structure.
  */
 extern struct ublast_lowlevel *ublast_register_ftdi(void);
-extern struct ublast_lowlevel *ublast_register_ftd2xx(void);
 extern struct ublast_lowlevel *ublast2_register_libusb(void);
 
-#endif /* JTAG_UBLAST_ACCESS_H */
+#endif /* OPENOCD_JTAG_DRIVERS_USB_BLASTER_UBLAST_ACCESS_H */
diff --git a/src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c b/src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c
deleted file mode 100644
index 14351fbd..00000000
--- a/src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- *   Driver for USB-JTAG, Altera USB-Blaster and compatibles
- *
- *   Inspired from original code from Kolja Waschk's USB-JTAG project
- *   (http://www.ixo.de/info/usb_jtag/), and from openocd project.
- *
- *   Copyright (C) 2012 Robert Jarzmik robert.jarzmik@free.fr
- *   Copyright (C) 2011 Ali Lown ali@lown.me.uk
- *   Copyright (C) 2009 Catalin Patulea cat@vv.carleton.ca
- *   Copyright (C) 2006 Kolja Waschk usbjtag@ixo.de
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-#include <jtag/interface.h>
-#include <jtag/commands.h>
-
-#include "ublast_access.h"
-
-#include <ftd2xx.h>
-#include "jtag/drivers/ftd2xx_common.h"
-
-static FT_HANDLE *ublast_getftdih(struct ublast_lowlevel *low)
-{
-	return low->priv;
-}
-
-static int ublast_ftd2xx_write(struct ublast_lowlevel *low, uint8_t *buf, int size,
-			      uint32_t *bytes_written)
-{
-	FT_STATUS status;
-	DWORD dw_bytes_written;
-	FT_HANDLE *ftdih = ublast_getftdih(low);
-
-	status = FT_Write(*ftdih, buf, size, &dw_bytes_written);
-	if (status != FT_OK) {
-		*bytes_written = dw_bytes_written;
-		LOG_ERROR("FT_Write returned: %s", ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-	*bytes_written = dw_bytes_written;
-	return ERROR_OK;
-}
-
-static int ublast_ftd2xx_read(struct ublast_lowlevel *low, uint8_t *buf,
-			     unsigned size, uint32_t *bytes_read)
-{
-	DWORD dw_bytes_read;
-	FT_STATUS status;
-	FT_HANDLE *ftdih = ublast_getftdih(low);
-
-	status = FT_Read(*ftdih, buf, size, &dw_bytes_read);
-	if (status != FT_OK) {
-		*bytes_read = dw_bytes_read;
-		LOG_ERROR("FT_Read returned: %s", ftd2xx_status_string(status));
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-	*bytes_read = dw_bytes_read;
-	return ERROR_OK;
-}
-
-static int ublast_ftd2xx_init(struct ublast_lowlevel *low)
-{
-	FT_STATUS status;
-	FT_HANDLE *ftdih = ublast_getftdih(low);
-	uint8_t latency_timer;
-
-	LOG_INFO("usb blaster interface using FTD2XX");
-	/* Open by device description */
-	if (low->ublast_device_desc == NULL) {
-		LOG_WARNING("no usb blaster device description specified, "
-			    "using default 'USB-Blaster'");
-		low->ublast_device_desc = "USB-Blaster";
-	}
-
-#if IS_WIN32 == 0
-	/* Add non-standard Vid/Pid to the linux driver */
-	status = FT_SetVIDPID(low->ublast_vid, low->ublast_pid);
-	if (status != FT_OK) {
-		LOG_WARNING("couldn't add %4.4x:%4.4x",
-			    low->ublast_vid, low->ublast_pid);
-	}
-#endif
-	status = FT_OpenEx(low->ublast_device_desc, FT_OPEN_BY_DESCRIPTION,
-			   ftdih);
-	if (status != FT_OK) {
-		DWORD num_devices;
-
-		LOG_ERROR("unable to open ftdi device: %s",
-			  ftd2xx_status_string(status));
-		status = FT_ListDevices(&num_devices, NULL, FT_LIST_NUMBER_ONLY);
-		if (status == FT_OK) {
-			char **desc_array =
-				malloc(sizeof(char *) * (num_devices + 1));
-			unsigned int i;
-
-			for (i = 0; i < num_devices; i++)
-				desc_array[i] = malloc(64);
-			desc_array[num_devices] = NULL;
-
-			status = FT_ListDevices(desc_array, &num_devices,
-						FT_LIST_ALL | FT_OPEN_BY_DESCRIPTION);
-
-			if (status == FT_OK) {
-				LOG_ERROR("ListDevices: %" PRIu32, (uint32_t)num_devices);
-				for (i = 0; i < num_devices; i++)
-					LOG_ERROR("%i: %s", i, desc_array[i]);
-			}
-
-			for (i = 0; i < num_devices; i++)
-				free(desc_array[i]);
-			free(desc_array);
-		} else {
-			printf("ListDevices: NONE\n");
-		}
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_SetLatencyTimer(*ftdih, 2);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to set latency timer: %s",
-				ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	}
-
-	status = FT_GetLatencyTimer(*ftdih, &latency_timer);
-	if (status != FT_OK)
-		LOG_ERROR("unable to get latency timer: %s",
-				ftd2xx_status_string(status));
-	else
-		LOG_DEBUG("current latency timer: %i", latency_timer);
-
-	status = FT_SetBitMode(*ftdih, 0x00, 0);
-	if (status != FT_OK) {
-		LOG_ERROR("unable to disable bit i/o mode: %s",
-				ftd2xx_status_string(status));
-		return ERROR_JTAG_INIT_FAILED;
-	}
-	return ERROR_OK;
-}
-
-static int ublast_ftd2xx_quit(struct ublast_lowlevel *low)
-{
-	FT_HANDLE *ftdih = ublast_getftdih(low);
-
-	FT_Close(*ftdih);
-	return ERROR_OK;
-}
-
-static struct ublast_lowlevel_priv {
-	FT_HANDLE ftdih;
-} info;
-
-static struct ublast_lowlevel low = {
-	.open = ublast_ftd2xx_init,
-	.close = ublast_ftd2xx_quit,
-	.read = ublast_ftd2xx_read,
-	.write = ublast_ftd2xx_write,
-	.priv = &info,
-};
-
-struct ublast_lowlevel *ublast_register_ftd2xx(void)
-{
-	return &low;
-}
diff --git a/src/jtag/drivers/usb_blaster/ublast_access_ftdi.c b/src/jtag/drivers/usb_blaster/ublast_access_ftdi.c
index 2527fe9a..cb442f2b 100644
--- a/src/jtag/drivers/usb_blaster/ublast_access_ftdi.c
+++ b/src/jtag/drivers/usb_blaster/ublast_access_ftdi.c
@@ -19,6 +19,9 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/usb_blaster/usb_blaster.c b/src/jtag/drivers/usb_blaster/usb_blaster.c
index 82e5537f..a975bd1e 100644
--- a/src/jtag/drivers/usb_blaster/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster/usb_blaster.c
@@ -20,6 +20,9 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
  */
 
 /*
@@ -144,12 +147,9 @@ struct drvs_map {
 };
 
 static struct drvs_map lowlevel_drivers_map[] = {
-#if BUILD_USB_BLASTER_LIBFTDI
+#if BUILD_USB_BLASTER
 	{ .name = "ftdi", .drv_register = ublast_register_ftdi },
 #endif
-#if BUILD_USB_BLASTER_FTD2XX
-	{ .name = "ftd2xx", .drv_register = ublast_register_ftd2xx },
-#endif
 #if BUILD_USB_BLASTER_2
 	{ .name = "ublast2", .drv_register = ublast2_register_libusb },
 #endif
@@ -1045,8 +1045,8 @@ static const struct command_registration ublast_command_handlers[] = {
 		.name = "usb_blaster_lowlevel_driver",
 		.handler = ublast_handle_lowlevel_drv_command,
 		.mode = COMMAND_CONFIG,
-		.help = "set the lowlevel access for the USB Blaster (ftdi, ftd2xx, ublast2)",
-		.usage = "(ftdi|ftd2xx|ublast2)",
+		.help = "set the lowlevel access for the USB Blaster (ftdi, ublast2)",
+		.usage = "(ftdi|ublast2)",
 	},
 	{
 		.name = "usb_blaster_pin",
diff --git a/src/jtag/drivers/usb_common.c b/src/jtag/drivers/usb_common.c
index 4f6a7229..54be6a62 100644
--- a/src/jtag/drivers/usb_common.c
+++ b/src/jtag/drivers/usb_common.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/usb_common.h b/src/jtag/drivers/usb_common.h
index d34c20b9..4d2bd268 100644
--- a/src/jtag/drivers/usb_common.h
+++ b/src/jtag/drivers/usb_common.h
@@ -12,17 +12,15 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef JTAG_USB_COMMON_H
-#define JTAG_USB_COMMON_H
+#ifndef OPENOCD_JTAG_DRIVERS_USB_COMMON_H
+#define OPENOCD_JTAG_DRIVERS_USB_COMMON_H
 
 #include <usb.h>
 
 int jtag_usb_open(const uint16_t vids[], const uint16_t pids[],
 		struct usb_dev_handle **out);
 
-#endif /* JTAG_USB_COMMON_H */
+#endif /* OPENOCD_JTAG_DRIVERS_USB_COMMON_H */
diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
index 070edf42..0ad4e2a8 100644
--- a/src/jtag/drivers/usbprog.c
+++ b/src/jtag/drivers/usbprog.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
index c3a09a2a..0d60725a 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
index c8684a77..f2ea175a 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
index a0dfb996..16433aff 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
index cd9d51c0..ef1b675f 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
index 65e54e4e..53a7e989 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
index fa53062b..98a056a8 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __USBTOXXX_H_INCLUDED__
-#define __USBTOXXX_H_INCLUDED__
+#ifndef OPENOCD_JTAG_DRIVERS_VERSALOON_USBTOXXX_USBTOXXX_H
+#define OPENOCD_JTAG_DRIVERS_VERSALOON_USBTOXXX_USBTOXXX_H
 
 RESULT usbtoxxx_init(void);
 RESULT usbtoxxx_fini(void);
@@ -236,4 +234,4 @@ RESULT usbtopwm_config(uint8_t interface_index, uint16_t kHz, uint8_t mode);
 RESULT usbtopwm_out(uint8_t interface_index, uint16_t count, uint16_t *rate);
 RESULT usbtopwm_in(uint8_t interface_index, uint16_t count, uint16_t *rate);
 
-#endif	/* __USBTOXXX_H_INCLUDED__ */
+#endif /* OPENOCD_JTAG_DRIVERS_VERSALOON_USBTOXXX_USBTOXXX_H */
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
index 4d8dfcf8..e40667e9 100644
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __USBTOXXX_INTERNAL_H_INCLUDED__
-#define __USBTOXXX_INTERNAL_H_INCLUDED__
+#ifndef OPENOCD_JTAG_DRIVERS_VERSALOON_USBTOXXX_USBTOXXX_INTERNAL_H
+#define OPENOCD_JTAG_DRIVERS_VERSALOON_USBTOXXX_USBTOXXX_INTERNAL_H
 
 /* USB_TO_XXX USB Commands */
 /* Page0 */
@@ -160,4 +158,4 @@ RESULT usbtoxxx_add_command(uint8_t type, uint8_t cmd, uint8_t *cmdbuf,
 /* USB_TO_GPIO */
 #define USB_TO_GPIO_DIR_MSK			0x01
 
-#endif	/* __USBTOXXX_INTERNAL_H_INCLUDED__ */
+#endif /* OPENOCD_JTAG_DRIVERS_VERSALOON_USBTOXXX_USBTOXXX_INTERNAL_H */
diff --git a/src/jtag/drivers/versaloon/versaloon.c b/src/jtag/drivers/versaloon/versaloon.c
index 04d73cf3..14638396 100644
--- a/src/jtag/drivers/versaloon/versaloon.c
+++ b/src/jtag/drivers/versaloon/versaloon.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/drivers/versaloon/versaloon.h b/src/jtag/drivers/versaloon/versaloon.h
index 46f5c319..9d92bcaa 100644
--- a/src/jtag/drivers/versaloon/versaloon.h
+++ b/src/jtag/drivers/versaloon/versaloon.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __VERSALOON_H_INCLUDED__
-#define __VERSALOON_H_INCLUDED__
+#ifndef OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_H
+#define OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_H
 
 #include <libusb.h>
 
@@ -111,5 +109,4 @@ struct versaloon_interface_t {
 extern struct versaloon_interface_t versaloon_interface;
 extern libusb_device_handle *versaloon_usb_device_handle;
 
-#endif /* __VERSALOON_H_INCLUDED__ */
-
+#endif /* OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_H */
diff --git a/src/jtag/drivers/versaloon/versaloon_include.h b/src/jtag/drivers/versaloon/versaloon_include.h
index 2eb374a7..089056d0 100644
--- a/src/jtag/drivers/versaloon/versaloon_include.h
+++ b/src/jtag/drivers/versaloon/versaloon_include.h
@@ -12,11 +12,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_INCLUDE_H
+#define OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_INCLUDE_H
+
 /* This file is used to include different header and macros */
 /* according to different platform */
 #include <jtag/interface.h>
@@ -97,3 +98,5 @@
 #define SET_LE_U32(p, v)			SET_U32_LSBFIRST(p, v)
 #define SET_BE_U16(p, v)			SET_U16_MSBFIRST(p, v)
 #define SET_BE_U32(p, v)			SET_U32_MSBFIRST(p, v)
+
+#endif /* OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_INCLUDE_H */
diff --git a/src/jtag/drivers/versaloon/versaloon_internal.h b/src/jtag/drivers/versaloon/versaloon_internal.h
index 66712dba..497b6b9c 100644
--- a/src/jtag/drivers/versaloon/versaloon_internal.h
+++ b/src/jtag/drivers/versaloon/versaloon_internal.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __VERSALOON_INTERNAL_H_INCLUDED__
-#define __VERSALOON_INTERNAL_H_INCLUDED__
+#ifndef OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_INTERNAL_H
+#define OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_INTERNAL_H
 
 #define VERSALOON_PRODUCTSTRING_INDEX	2
 #define VERSALOON_SERIALSTRING_INDEX	3
@@ -109,4 +107,4 @@ extern uint8_t *versaloon_buf;
 extern uint8_t *versaloon_cmd_buf;
 extern uint16_t versaloon_buf_size;
 
-#endif /* __VERSALOON_INTERNAL_H_INCLUDED__ */
+#endif /* OPENOCD_JTAG_DRIVERS_VERSALOON_VERSALOON_INTERNAL_H */
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 801de650..6f7e9cad 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* Versaloon is a programming tool for multiple MCUs.
diff --git a/src/jtag/hla/Makefile.am b/src/jtag/hla/Makefile.am
index 4fbc70e9..6bb2960e 100644
--- a/src/jtag/hla/Makefile.am
+++ b/src/jtag/hla/Makefile.am
@@ -1,23 +1,11 @@
-include $(top_srcdir)/common.mk
-
-noinst_LTLIBRARIES = libocdhla.la
-
-libocdhla_la_SOURCES = \
-	$(HLFILES)
-
-HLFILES =
-
-if HLADAPTER
-HLFILES += hla_transport.c
-HLFILES += hla_tcl.c
-HLFILES += hla_interface.c
-HLFILES += hla_layout.c
-endif
-
-noinst_HEADERS = \
-	hla_interface.h \
-	hla_layout.h \
-	hla_tcl.h \
-	hla_transport.h
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+noinst_LTLIBRARIES += %D%/libocdhla.la
+
+%C%_libocdhla_la_SOURCES = \
+	%D%/hla_transport.c \
+	%D%/hla_tcl.c \
+	%D%/hla_interface.c \
+	%D%/hla_layout.c \
+	%D%/hla_transport.h \
+	%D%/hla_interface.h \
+	%D%/hla_layout.h \
+	%D%/hla_tcl.h
diff --git a/src/jtag/hla/hla_interface.c b/src/jtag/hla/hla_interface.c
index a208e9fd..9217631b 100644
--- a/src/jtag/hla/hla_interface.c
+++ b/src/jtag/hla/hla_interface.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/hla/hla_interface.h b/src/jtag/hla/hla_interface.h
index a1559257..0992d1ca 100644
--- a/src/jtag/hla/hla_interface.h
+++ b/src/jtag/hla/hla_interface.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _HL_INTERFACE
-#define _HL_INTERFACE
+#ifndef OPENOCD_JTAG_HLA_HLA_INTERFACE_H
+#define OPENOCD_JTAG_HLA_HLA_INTERFACE_H
 
 /** */
 struct target;
@@ -67,4 +65,4 @@ int hl_interface_init_target(struct target *t);
 int hl_interface_init_reset(void);
 int hl_interface_override_target(const char **targetname);
 
-#endif /* _HL_INTERFACE */
+#endif /* OPENOCD_JTAG_HLA_HLA_INTERFACE_H */
diff --git a/src/jtag/hla/hla_layout.c b/src/jtag/hla/hla_layout.c
index 0a20fbd3..c5e35182 100644
--- a/src/jtag/hla/hla_layout.c
+++ b/src/jtag/hla/hla_layout.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/hla/hla_layout.h b/src/jtag/hla/hla_layout.h
index 8833d6c8..40c1321b 100644
--- a/src/jtag/hla/hla_layout.h
+++ b/src/jtag/hla/hla_layout.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _HL_LAYOUT_H
-#define _HL_LAYOUT_H
+#ifndef OPENOCD_JTAG_HLA_HLA_LAYOUT_H
+#define OPENOCD_JTAG_HLA_HLA_LAYOUT_H
 
 #include <target/armv7m_trace.h>
 
@@ -127,4 +125,4 @@ const struct hl_layout *hl_layout_get_list(void);
 /** */
 int hl_layout_init(struct hl_interface_s *adapter);
 
-#endif /* _HL_LAYOUT_H */
+#endif /* OPENOCD_JTAG_HLA_HLA_LAYOUT_H */
diff --git a/src/jtag/hla/hla_tcl.c b/src/jtag/hla/hla_tcl.c
index 20082f38..9378427b 100644
--- a/src/jtag/hla/hla_tcl.c
+++ b/src/jtag/hla/hla_tcl.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -100,11 +98,13 @@ static int jim_hl_newtap_cmd(Jim_GetOptInfo *goi)
 		free(pTap);
 		return JIM_ERR;
 	}
-	Jim_GetOpt_String(goi, &cp, NULL);
-	pTap->chip = strdup(cp);
 
-	Jim_GetOpt_String(goi, &cp, NULL);
-	pTap->tapname = strdup(cp);
+	const char *tmp;
+	Jim_GetOpt_String(goi, &tmp, NULL);
+	pTap->chip = strdup(tmp);
+
+	Jim_GetOpt_String(goi, &tmp, NULL);
+	pTap->tapname = strdup(tmp);
 
 	/* name + dot + name + null */
 	x = strlen(pTap->chip) + 1 + strlen(pTap->tapname) + 1;
diff --git a/src/jtag/hla/hla_tcl.h b/src/jtag/hla/hla_tcl.h
index 3ce3effa..ac00add5 100644
--- a/src/jtag/hla/hla_tcl.h
+++ b/src/jtag/hla/hla_tcl.h
@@ -16,15 +16,13 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _HL_TCL_
-#define _HL_TCL_
+#ifndef OPENOCD_JTAG_HLA_HLA_TCL_H
+#define OPENOCD_JTAG_HLA_HLA_TCL_H
 
 /** */
 int jim_hl_newtap(Jim_Interp *interp, int argc, Jim_Obj * const *argv);
 
-#endif /* _HL_TCL_ */
+#endif /* OPENOCD_JTAG_HLA_HLA_TCL_H */
diff --git a/src/jtag/hla/hla_transport.c b/src/jtag/hla/hla_transport.c
index ae7cbb1a..5a5671db 100644
--- a/src/jtag/hla/hla_transport.c
+++ b/src/jtag/hla/hla_transport.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/hla/hla_transport.h b/src/jtag/hla/hla_transport.h
index 09eece28..07eb751e 100644
--- a/src/jtag/hla/hla_transport.h
+++ b/src/jtag/hla/hla_transport.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _HL_TRANSPORT
-#define _HL_TRANSPORT
+#ifndef OPENOCD_JTAG_HLA_HLA_TRANSPORT_H
+#define OPENOCD_JTAG_HLA_HLA_TRANSPORT_H
 
 enum hl_transports {
 	HL_TRANSPORT_UNKNOWN = 0,
@@ -31,4 +29,4 @@ enum hl_transports {
 	HL_TRANSPORT_SWIM
 };
 
-#endif /* _HL_TRANSPORT */
+#endif /* OPENOCD_JTAG_HLA_HLA_TRANSPORT_H */
diff --git a/src/jtag/interface.c b/src/jtag/interface.c
index 19a0b052..e12b2aeb 100644
--- a/src/jtag/interface.c
+++ b/src/jtag/interface.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index e7b20148..cdfc676e 100644
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef OPENOCD_JTAG_INTERFACE_H
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index 62c5d459..174c63a3 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -53,16 +51,10 @@ extern struct jtag_interface parport_interface;
 #if BUILD_DUMMY == 1
 extern struct jtag_interface dummy_interface;
 #endif
-#if BUILD_FT2232_FTD2XX == 1
-extern struct jtag_interface ft2232_interface;
-#endif
-#if BUILD_FT2232_LIBFTDI == 1
-extern struct jtag_interface ft2232_interface;
-#endif
 #if BUILD_FTDI == 1
 extern struct jtag_interface ftdi_interface;
 #endif
-#if BUILD_USB_BLASTER_LIBFTDI == 1 || BUILD_USB_BLASTER_FTD2XX == 1 || BUILD_USB_BLASTER_2 == 1
+#if BUILD_USB_BLASTER == 1 || BUILD_USB_BLASTER_2 == 1
 extern struct jtag_interface usb_blaster_interface;
 #endif
 #if BUILD_JTAG_VPI == 1
@@ -80,7 +72,7 @@ extern struct jtag_interface at91rm9200_interface;
 #if BUILD_GW16012 == 1
 extern struct jtag_interface gw16012_interface;
 #endif
-#if BUILD_PRESTO_LIBFTDI == 1 || BUILD_PRESTO_FTD2XX == 1
+#if BUILD_PRESTO
 extern struct jtag_interface presto_interface;
 #endif
 #if BUILD_USBPROG == 1
@@ -131,6 +123,12 @@ extern struct jtag_interface bcm2835gpio_interface;
 #if BUILD_CMSIS_DAP == 1
 extern struct jtag_interface cmsis_dap_interface;
 #endif
+#if BUILD_KITPROG == 1
+extern struct jtag_interface kitprog_interface;
+#endif
+#if BUILD_IMX_GPIO == 1
+extern struct jtag_interface imx_gpio_interface;
+#endif
 #endif /* standard drivers */
 
 /**
@@ -152,16 +150,10 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_DUMMY == 1
 		&dummy_interface,
 #endif
-#if BUILD_FT2232_FTD2XX == 1
-		&ft2232_interface,
-#endif
-#if BUILD_FT2232_LIBFTDI == 1
-		&ft2232_interface,
-#endif
 #if BUILD_FTDI == 1
 		&ftdi_interface,
 #endif
-#if BUILD_USB_BLASTER_LIBFTDI == 1 || BUILD_USB_BLASTER_FTD2XX == 1 || BUILD_USB_BLASTER_2 == 1
+#if BUILD_USB_BLASTER || BUILD_USB_BLASTER_2 == 1
 		&usb_blaster_interface,
 #endif
 #if BUILD_JTAG_VPI == 1
@@ -179,7 +171,7 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_GW16012 == 1
 		&gw16012_interface,
 #endif
-#if BUILD_PRESTO_LIBFTDI == 1 || BUILD_PRESTO_FTD2XX == 1
+#if BUILD_PRESTO
 		&presto_interface,
 #endif
 #if BUILD_USBPROG == 1
@@ -230,6 +222,12 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_CMSIS_DAP == 1
 		&cmsis_dap_interface,
 #endif
+#if BUILD_KITPROG == 1
+		&kitprog_interface,
+#endif
+#if BUILD_IMX_GPIO == 1
+		&imx_gpio_interface,
+#endif
 #endif /* standard drivers */
 		NULL,
 	};
diff --git a/src/jtag/interfaces.h b/src/jtag/interfaces.h
index e17420f5..02d201b1 100644
--- a/src/jtag/interfaces.h
+++ b/src/jtag/interfaces.h
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifndef OPENOCD_JTAG_INTERFACES_H
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index eda4ccdd..7702d6ca 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -16,13 +16,11 @@
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
-*   along with this program; if not, write to the                         *
-*   Free Software Foundation, Inc.,                                       *
-*   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
 ***************************************************************************/
 
-#ifndef JTAG_H
-#define JTAG_H
+#ifndef OPENOCD_JTAG_JTAG_H
+#define OPENOCD_JTAG_JTAG_H
 
 #include <helper/binarybuffer.h>
 #include <helper/log.h>
@@ -107,7 +105,7 @@ extern tap_state_t cmd_queue_cur_state;
  * jtag_add_dr_scan_check() to validate the value that was scanned out.
  */
 struct scan_field {
-	/** The number of bits this field specifies (up to 32) */
+	/** The number of bits this field specifies */
 	int num_bits;
 	/** A pointer to value to be scanned into the device */
 	const uint8_t *out_value;
@@ -648,4 +646,4 @@ bool transport_is_jtag(void);
 
 int jim_jtag_newtap(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
 
-#endif /* JTAG_H */
+#endif /* OPENOCD_JTAG_JTAG_H */
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 0de87092..688c3963 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MINIDRIVER_H
-#define MINIDRIVER_H
+#ifndef OPENOCD_JTAG_MINIDRIVER_H
+#define OPENOCD_JTAG_MINIDRIVER_H
 
 /**
  * @page jtagminidriver JTAG Mini-Driver
@@ -89,4 +87,4 @@ int interface_jtag_execute_queue(void);
  */
 int default_interface_jtag_execute_queue(void);
 
-#endif /* MINIDRIVER_H */
+#endif /* OPENOCD_JTAG_MINIDRIVER_H */
diff --git a/src/jtag/minidriver/minidriver_imp.h b/src/jtag/minidriver/minidriver_imp.h
index 8ad992c1..11d0fae7 100644
--- a/src/jtag/minidriver/minidriver_imp.h
+++ b/src/jtag/minidriver/minidriver_imp.h
@@ -14,13 +14,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MINIDRIVER_IMP_H
-#define MINIDRIVER_IMP_H
+#ifndef OPENOCD_JTAG_MINIDRIVER_MINIDRIVER_IMP_H
+#define OPENOCD_JTAG_MINIDRIVER_MINIDRIVER_IMP_H
 
 #include <jtag/jtag_minidriver.h>
 
@@ -29,4 +27,4 @@
 #define jtag_add_callback4(callback, in, data1, data2, data3) \
 	interface_jtag_add_callback4(callback, in, data1, data2, data3)
 
-#endif /* MINIDRIVER_IMP_H */
+#endif /* OPENOCD_JTAG_MINIDRIVER_MINIDRIVER_IMP_H */
diff --git a/src/jtag/minidummy/jtag_minidriver.h b/src/jtag/minidummy/jtag_minidriver.h
index 452fbc8b..1708356a 100644
--- a/src/jtag/minidummy/jtag_minidriver.h
+++ b/src/jtag/minidummy/jtag_minidriver.h
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #define interface_jtag_add_callback(callback, in) callback(in)
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 4f04acde..b7c989fc 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/jtag/swd.h b/src/jtag/swd.h
index d208f393..c888cc07 100644
--- a/src/jtag/swd.h
+++ b/src/jtag/swd.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef SWD_H
-#define SWD_H
+#ifndef OPENOCD_JTAG_SWD_H
+#define OPENOCD_JTAG_SWD_H
 
 #include <target/arm_adi_v5.h>
 
@@ -215,4 +213,4 @@ void swd_add_reset(int req_srst);
 
 bool transport_is_swd(void);
 
-#endif /* SWD_H */
+#endif /* OPENOCD_JTAG_SWD_H */
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index c916fb1c..bc6bbf20 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -23,9 +23,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -533,11 +531,13 @@ static int jim_newtap_cmd(Jim_GetOptInfo *goi)
 		free(pTap);
 		return JIM_ERR;
 	}
-	Jim_GetOpt_String(goi, &cp, NULL);
-	pTap->chip = strdup(cp);
 
-	Jim_GetOpt_String(goi, &cp, NULL);
-	pTap->tapname = strdup(cp);
+	const char *tmp;
+	Jim_GetOpt_String(goi, &tmp, NULL);
+	pTap->chip = strdup(tmp);
+
+	Jim_GetOpt_String(goi, &tmp, NULL);
+	pTap->tapname = strdup(tmp);
 
 	/* name + dot + name + null */
 	x = strlen(pTap->chip) + 1 + strlen(pTap->tapname) + 1;
@@ -1247,7 +1247,7 @@ COMMAND_HANDLER(handle_wait_srst_deassert)
 
 	LOG_USER("Waiting for srst assert + deassert for at most %dms", timeout_ms);
 	int asserted_yet;
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	while (jtag_srst_asserted(&asserted_yet) == ERROR_OK) {
 		if ((timeval_ms() - then) > timeout_ms) {
 			LOG_ERROR("Timed out");
diff --git a/src/jtag/tcl.h b/src/jtag/tcl.h
index 95dea13c..932b47ac 100644
--- a/src/jtag/tcl.h
+++ b/src/jtag/tcl.h
@@ -23,17 +23,15 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _JTAG_TCL_H_
-#define _JTAG_TCL_H_
+#ifndef OPENOCD_JTAG_TCL_H
+#define OPENOCD_JTAG_TCL_H
 
 int jim_jtag_configure(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv);
 int jim_jtag_tap_enabler(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv);
 
-#endif
+#endif /* OPENOCD_JTAG_TCL_H */
diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index d7fa4376..7d1ede5d 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* used to test manual mode */
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 16c3e5d0..67d99070 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* This file supports the zy1000 debugger:
@@ -147,8 +145,8 @@ static int zy1000_power_dropout(int *dropout)
 static void waitSRST(bool asserted)
 {
 	bool first = true;
-	long long start = 0;
-	long total = 0;
+	int64_t start = 0;
+	int64_t total = 0;
 	const char *mode = asserted ? "assert" : "deassert";
 
 	for (;; ) {
@@ -169,7 +167,7 @@ static void waitSRST(bool asserted)
 		keep_alive();
 
 		if (total > 5000) {
-			LOG_ERROR("SRST took too long to %s: %dms", mode, (int)total);
+			LOG_ERROR("SRST took too long to %s: %" PRId64 "ms", mode, total);
 			break;
 		}
 	}
diff --git a/src/main.c b/src/main.c
index f3ff51b6..83e60d8e 100644
--- a/src/main.c
+++ b/src/main.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/openocd.c b/src/openocd.c
index d17af20f..83329b51 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -47,8 +45,13 @@
 #include <strings.h>
 #endif
 
+#ifdef PKGBLDDATE
 #define OPENOCD_VERSION	\
 	"Open On-Chip Debugger " VERSION RELSTR " (" PKGBLDDATE ")"
+#else
+#define OPENOCD_VERSION	\
+	"Open On-Chip Debugger " VERSION RELSTR
+#endif
 
 static const char openocd_startup_tcl[] = {
 #include "startup_tcl.inc"
@@ -294,8 +297,10 @@ static int openocd_thread(int argc, char *argv[], struct command_context *cmd_ct
 
 	if (init_at_startup) {
 		ret = command_run_line(cmd_ctx, "init");
-		if (ERROR_OK != ret)
+		if (ERROR_OK != ret) {
+			server_quit();
 			return ERROR_FAIL;
+		}
 	}
 
 	ret = server_loop(cmd_ctx);
diff --git a/src/openocd.h b/src/openocd.h
index 6d87c2af..543ac3c2 100644
--- a/src/openocd.h
+++ b/src/openocd.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef OPENOCD_H
-#define OPENOCD_H
+#ifndef OPENOCD_OPENOCD_H
+#define OPENOCD_OPENOCD_H
 
 /**
  * Different applications can define this entry point to override
@@ -31,4 +29,4 @@
  */
 int openocd_main(int argc, char *argv[]);
 
-#endif
+#endif /* OPENOCD_OPENOCD_H */
diff --git a/src/pld/Makefile.am b/src/pld/Makefile.am
index 93b79f4a..7f3a5542 100644
--- a/src/pld/Makefile.am
+++ b/src/pld/Makefile.am
@@ -1,8 +1,8 @@
-include $(top_srcdir)/common.mk
-
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libpld.la
-noinst_HEADERS = pld.h xilinx_bit.h virtex2.h
-libpld_la_SOURCES = pld.c xilinx_bit.c virtex2.c
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+noinst_LTLIBRARIES += %D%/libpld.la
+%C%_libpld_la_SOURCES = \
+	%D%/pld.c \
+	%D%/xilinx_bit.c \
+	%D%/virtex2.c \
+	%D%/pld.h \
+	%D%/xilinx_bit.h \
+	%D%/virtex2.h
diff --git a/src/pld/pld.c b/src/pld/pld.c
index fb5d32ed..5210b97b 100644
--- a/src/pld/pld.c
+++ b/src/pld/pld.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/pld/pld.h b/src/pld/pld.h
index c089fe63..3178fd45 100644
--- a/src/pld/pld.h
+++ b/src/pld/pld.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef PLD_H
-#define PLD_H
+#ifndef OPENOCD_PLD_PLD_H
+#define OPENOCD_PLD_PLD_H
 
 #include <helper/command.h>
 
@@ -51,4 +49,4 @@ struct pld_device *get_pld_device_by_num(int num);
 #define ERROR_PLD_DEVICE_INVALID        (-1000)
 #define ERROR_PLD_FILE_LOAD_FAILED      (-1001)
 
-#endif	/* PLD_H */
+#endif /* OPENOCD_PLD_PLD_H */
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index 82eb788f..4e385e97 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/pld/virtex2.h b/src/pld/virtex2.h
index 8ed1c1c7..d6d922e7 100644
--- a/src/pld/virtex2.h
+++ b/src/pld/virtex2.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef VIRTEX2_H
-#define VIRTEX2_H
+#ifndef OPENOCD_PLD_VIRTEX2_H
+#define OPENOCD_PLD_VIRTEX2_H
 
 #include <jtag/jtag.h>
 
@@ -28,4 +26,4 @@ struct virtex2_pld_device {
 	int no_jstart;
 };
 
-#endif	/* VIRTEX2_H */
+#endif /* OPENOCD_PLD_VIRTEX2_H */
diff --git a/src/pld/xilinx_bit.c b/src/pld/xilinx_bit.c
index cd414ba8..a975a7a0 100644
--- a/src/pld/xilinx_bit.c
+++ b/src/pld/xilinx_bit.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/pld/xilinx_bit.h b/src/pld/xilinx_bit.h
index d507dfcf..1a35c3be 100644
--- a/src/pld/xilinx_bit.h
+++ b/src/pld/xilinx_bit.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef XILINX_BIT_H
-#define XILINX_BIT_H
+#ifndef OPENOCD_PLD_XILINX_BIT_H
+#define OPENOCD_PLD_XILINX_BIT_H
 
 struct xilinx_bit_file {
 	uint8_t unknown_header[13];
@@ -33,4 +31,4 @@ struct xilinx_bit_file {
 
 int xilinx_read_bit_file(struct xilinx_bit_file *bit_file, const char *filename);
 
-#endif	/* XILINX_BIT_H */
+#endif /* OPENOCD_PLD_XILINX_BIT_H */
diff --git a/src/rtos/ChibiOS.c b/src/rtos/ChibiOS.c
index 84393860..1bc1af8f 100644
--- a/src/rtos/ChibiOS.c
+++ b/src/rtos/ChibiOS.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -130,15 +128,13 @@ struct rtos_type ChibiOS_rtos = {
 enum ChibiOS_symbol_values {
 	ChibiOS_VAL_rlist = 0,
 	ChibiOS_VAL_ch = 1,
-	ChibiOS_VAL_ch_debug = 2,
-	ChibiOS_VAL_chSysInit = 3
+	ChibiOS_VAL_ch_debug = 2
 };
 
 static symbol_table_elem_t ChibiOS_symbol_list[] = {
 	{ "rlist", 0, true},		/* Thread ready list */
 	{ "ch", 0, true},			/* System data structure */
 	{ "ch_debug", 0, false},	/* Memory Signature containing offsets of fields in rlist */
-	{ "chSysInit", 0, false},	/* Necessary part of API, used for ChibiOS detection */
 	{ NULL, 0, false}
 };
 
@@ -226,7 +222,7 @@ static int ChibiOS_update_stacking(struct rtos *rtos)
 	/* Sometimes the stacking can not be determined only by looking at the
 	 * target name but only a runtime.
 	 *
-	 * For example, this is the case for cortex-m4 targets and ChibiOS which
+	 * For example, this is the case for Cortex-M4 targets and ChibiOS which
 	 * only stack the FPU registers if it is enabled during ChibiOS build.
 	 *
 	 * Terminating which stacking is used is target depending.
@@ -248,7 +244,7 @@ static int ChibiOS_update_stacking(struct rtos *rtos)
 	struct ChibiOS_params *param;
 	param = (struct ChibiOS_params *) rtos->rtos_specific_params;
 
-	/* Check for armv7m with *enabled* FPU, i.e. a Cortex M4  */
+	/* Check for armv7m with *enabled* FPU, i.e. a Cortex-M4  */
 	struct armv7m_common *armv7m_target = target_to_armv7m(rtos->target);
 	if (is_armv7m(armv7m_target)) {
 		if (armv7m_target->fp_feature == FPv4_SP) {
@@ -361,7 +357,6 @@ static int ChibiOS_update_threads(struct rtos *rtos)
 				sizeof(struct thread_detail));
 		rtos->thread_details->threadid = 1;
 		rtos->thread_details->exists = true;
-		rtos->thread_details->display_str = NULL;
 
 		rtos->thread_details->extra_info_str = malloc(
 				sizeof(tmp_thread_extra_info));
@@ -445,14 +440,13 @@ static int ChibiOS_update_threads(struct rtos *rtos)
 		if (threadState < CHIBIOS_NUM_STATES)
 			state_desc = ChibiOS_thread_states[threadState];
 		else
-			state_desc = "Unknown state";
+			state_desc = "Unknown";
 
 		curr_thrd_details->extra_info_str = malloc(strlen(
-					state_desc)+1);
-		strcpy(curr_thrd_details->extra_info_str, state_desc);
+					state_desc)+8);
+		sprintf(curr_thrd_details->extra_info_str, "State: %s", state_desc);
 
 		curr_thrd_details->exists = true;
-		curr_thrd_details->display_str = NULL;
 
 		curr_thrd_details++;
 	}
@@ -520,12 +514,11 @@ static int ChibiOS_detect_rtos(struct target *target)
 {
 	if ((target->rtos->symbols != NULL) &&
 			((target->rtos->symbols[ChibiOS_VAL_rlist].address != 0) ||
-			 (target->rtos->symbols[ChibiOS_VAL_ch].address != 0)) &&
-			(target->rtos->symbols[ChibiOS_VAL_chSysInit].address != 0)) {
+			 (target->rtos->symbols[ChibiOS_VAL_ch].address != 0))) {
 
 		if (target->rtos->symbols[ChibiOS_VAL_ch_debug].address == 0) {
-			LOG_INFO("It looks like the target is running ChibiOS without "
-					"ch_debug.");
+			LOG_INFO("It looks like the target may be running ChibiOS "
+					"without ch_debug.");
 			return 0;
 		}
 
diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
index a141c505..27f8ff46 100644
--- a/src/rtos/FreeRTOS.c
+++ b/src/rtos/FreeRTOS.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -30,6 +28,10 @@
 #include "helper/log.h"
 #include "helper/types.h"
 #include "rtos_standard_stackings.h"
+#include "target/armv7m.h"
+#include "target/cortex_m.h"
+
+
 
 #define FREERTOS_MAX_PRIORITIES	63
 
@@ -45,7 +47,9 @@ struct FreeRTOS_params {
 	const unsigned char list_elem_content_offset;
 	const unsigned char thread_stack_offset;
 	const unsigned char thread_name_offset;
-	const struct rtos_register_stacking *stacking_info;
+	const struct rtos_register_stacking *stacking_info_cm3;
+	const struct rtos_register_stacking *stacking_info_cm4f;
+	const struct rtos_register_stacking *stacking_info_cm4f_fpu;
 };
 
 static const struct FreeRTOS_params FreeRTOS_params_list[] = {
@@ -60,6 +64,8 @@ static const struct FreeRTOS_params FreeRTOS_params_list[] = {
 	0,						/* thread_stack_offset; */
 	52,						/* thread_name_offset; */
 	&rtos_standard_Cortex_M3_stacking,	/* stacking_info */
+	&rtos_standard_Cortex_M4F_stacking,
+	&rtos_standard_Cortex_M4F_FPU_stacking,
 	},
 	{
 	"hla_target",			/* target_name */
@@ -72,6 +78,8 @@ static const struct FreeRTOS_params FreeRTOS_params_list[] = {
 	0,						/* thread_stack_offset; */
 	52,						/* thread_name_offset; */
 	&rtos_standard_Cortex_M3_stacking,	/* stacking_info */
+	&rtos_standard_Cortex_M4F_stacking,
+	&rtos_standard_Cortex_M4F_FPU_stacking,
 	},
 	{
 	"nds32_v3",			/* target_name */
@@ -84,6 +92,8 @@ static const struct FreeRTOS_params FreeRTOS_params_list[] = {
 	0,						/* thread_stack_offset; */
 	52,						/* thread_name_offset; */
 	&rtos_standard_NDS32_N1068_stacking,	/* stacking_info */
+	&rtos_standard_Cortex_M4F_stacking,
+	&rtos_standard_Cortex_M4F_FPU_stacking,
 	},
 };
 
@@ -243,7 +253,6 @@ static int FreeRTOS_update_threads(struct rtos *rtos)
 		rtos->current_thread = RTOS_NO_CURRENT_THREAD;
 		rtos->thread_details->threadid = RTOS_NO_CURRENT_THREAD;
 		rtos->thread_details->exists = true;
-		rtos->thread_details->display_str = NULL;
 		rtos->thread_details->extra_info_str = NULL;
 		rtos->thread_details->thread_name_str = malloc(sizeof(tmp_str));
 		strcpy(rtos->thread_details->thread_name_str, tmp_str);
@@ -382,11 +391,10 @@ static int FreeRTOS_update_threads(struct rtos *rtos)
 			rtos->thread_details[tasks_found].thread_name_str =
 				malloc(strlen(tmp_str)+1);
 			strcpy(rtos->thread_details[tasks_found].thread_name_str, tmp_str);
-			rtos->thread_details[tasks_found].display_str = NULL;
 			rtos->thread_details[tasks_found].exists = true;
 
 			if (rtos->thread_details[tasks_found].threadid == rtos->current_thread) {
-				char running_str[] = "Running";
+				char running_str[] = "State: Running";
 				rtos->thread_details[tasks_found].extra_info_str = malloc(
 						sizeof(running_str));
 				strcpy(rtos->thread_details[tasks_found].extra_info_str,
@@ -450,7 +458,45 @@ static int FreeRTOS_get_thread_reg_list(struct rtos *rtos, int64_t thread_id, ch
 										thread_id + param->thread_stack_offset,
 										stack_ptr);
 
-	return rtos_generic_stack_read(rtos->target, param->stacking_info, stack_ptr, hex_reg_list);
+	/* Check for armv7m with *enabled* FPU, i.e. a Cortex-M4F */
+	int cm4_fpu_enabled = 0;
+	struct armv7m_common *armv7m_target = target_to_armv7m(rtos->target);
+	if (is_armv7m(armv7m_target)) {
+		if (armv7m_target->fp_feature == FPv4_SP) {
+			/* Found ARM v7m target which includes a FPU */
+			uint32_t cpacr;
+
+			retval = target_read_u32(rtos->target, FPU_CPACR, &cpacr);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Could not read CPACR register to check FPU state");
+				return -1;
+			}
+
+			/* Check if CP10 and CP11 are set to full access. */
+			if (cpacr & 0x00F00000) {
+				/* Found target with enabled FPU */
+				cm4_fpu_enabled = 1;
+			}
+		}
+	}
+
+	if (cm4_fpu_enabled == 1) {
+		/* Read the LR to decide between stacking with or without FPU */
+		uint32_t LR_svc = 0;
+		retval = target_read_buffer(rtos->target,
+				stack_ptr + 0x20,
+				param->pointer_width,
+				(uint8_t *)&LR_svc);
+		if (retval != ERROR_OK) {
+			LOG_OUTPUT("Error reading stack frame from FreeRTOS thread\r\n");
+			return retval;
+		}
+		if ((LR_svc & 0x10) == 0)
+			return rtos_generic_stack_read(rtos->target, param->stacking_info_cm4f_fpu, stack_ptr, hex_reg_list);
+		else
+			return rtos_generic_stack_read(rtos->target, param->stacking_info_cm4f, stack_ptr, hex_reg_list);
+	} else
+		return rtos_generic_stack_read(rtos->target, param->stacking_info_cm3, stack_ptr, hex_reg_list);
 }
 
 static int FreeRTOS_get_symbol_list_to_lookup(symbol_table_elem_t *symbol_list[])
diff --git a/src/rtos/Makefile.am b/src/rtos/Makefile.am
index 62293ec6..c59ee3f8 100644
--- a/src/rtos/Makefile.am
+++ b/src/rtos/Makefile.am
@@ -1,34 +1,32 @@
-# ***************************************************************************
-# *   Copyright (C) 2011 by Broadcom Corporation                            *
-# *   Evan Hunter - ehunter@broadcom.com                                    *
-# *                                                                         *
-# *   This program is free software; you can redistribute it and/or modify  *
-# *   it under the terms of the GNU General Public License as published by  *
-# *   the Free Software Foundation; either version 2 of the License, or     *
-# *   (at your option) any later version.                                   *
-# *                                                                         *
-# *   This program is distributed in the hope that it will be useful,       *
-# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
-# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
-# *   GNU General Public License for more details.                          *
-# *                                                                         *
-# *   You should have received a copy of the GNU General Public License     *
-# *   along with this program; if not, write to the                         *
-# *   Free Software Foundation, Inc.,                                       *
-# *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
-# ***************************************************************************
+noinst_LTLIBRARIES += %D%/librtos.la
+%C%_librtos_la_SOURCES = \
+	%D%/rtos.c \
+	%D%/rtos_standard_stackings.c \
+	%D%/rtos_ecos_stackings.c  \
+	%D%/rtos_chibios_stackings.c \
+	%D%/rtos_embkernel_stackings.c \
+	%D%/rtos_mqx_stackings.c \
+	%D%/rtos_ucos_iii_stackings.c \
+	%D%/FreeRTOS.c \
+	%D%/ThreadX.c \
+	%D%/eCos.c \
+	%D%/linux.c \
+	%D%/ChibiOS.c \
+	%D%/embKernel.c \
+	%D%/mqx.c \
+	%D%/uCOS-III.c \
+	%D%/rtos.h \
+	%D%/rtos_standard_stackings.h \
+	%D%/rtos_ecos_stackings.h \
+	%D%/linux_header.h \
+	%D%/rtos_chibios_stackings.h \
+	%D%/rtos_embkernel_stackings.h \
+	%D%/rtos_mqx_stackings.h \
+	%D%/rtos_ucos_iii_stackings.h
 
-include $(top_srcdir)/common.mk
+%C%_librtos_la_CFLAGS = $(AM_CFLAGS)
 
-METASOURCES = AUTO
-noinst_LTLIBRARIES = librtos.la
-noinst_HEADERS = rtos.h rtos_standard_stackings.h rtos_ecos_stackings.h linux_header.h rtos_chibios_stackings.h rtos_embkernel_stackings.h rtos_mqx_stackings.h
-librtos_la_SOURCES = rtos.c rtos_standard_stackings.c rtos_ecos_stackings.c  rtos_chibios_stackings.c rtos_embkernel_stackings.c rtos_mqx_stackings.c FreeRTOS.c ThreadX.c eCos.c linux.c ChibiOS.c embKernel.c mqx.c
-
-librtos_la_CFLAGS =
 if IS_MINGW
 # FD_* macros are sloppy with their signs on MinGW32 platform
-librtos_la_CFLAGS += -Wno-sign-compare
+%C%_librtos_la_CFLAGS += -Wno-sign-compare
 endif
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/rtos/ThreadX.c b/src/rtos/ThreadX.c
index bceeb08c..51d50ac5 100644
--- a/src/rtos/ThreadX.c
+++ b/src/rtos/ThreadX.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -355,7 +353,6 @@ static int ThreadX_update_threads(struct rtos *rtos)
 		rtos->current_thread = RTOS_NO_CURRENT_THREAD;
 		rtos->thread_details->threadid = RTOS_NO_CURRENT_THREAD;
 		rtos->thread_details->exists = true;
-		rtos->thread_details->display_str = NULL;
 		rtos->thread_details->extra_info_str = NULL;
 		rtos->thread_details->thread_name_str = malloc(sizeof(tmp_str));
 		strcpy(rtos->thread_details->thread_name_str, tmp_str);
@@ -445,13 +442,11 @@ static int ThreadX_update_threads(struct rtos *rtos)
 			state_desc = "Unknown state";
 
 		rtos->thread_details[tasks_found].extra_info_str = malloc(strlen(
-					state_desc)+1);
-		strcpy(rtos->thread_details[tasks_found].extra_info_str, state_desc);
+					state_desc)+8);
+		sprintf(rtos->thread_details[tasks_found].extra_info_str, "State: %s", state_desc);
 
 		rtos->thread_details[tasks_found].exists = true;
 
-		rtos->thread_details[tasks_found].display_str = NULL;
-
 		tasks_found++;
 		prev_thread_ptr = thread_ptr;
 
@@ -632,8 +627,6 @@ static int ThreadX_get_thread_detail(struct rtos *rtos,
 
 	detail->exists = true;
 
-	detail->display_str = NULL;
-
 	return 0;
 }
 
diff --git a/src/rtos/eCos.c b/src/rtos/eCos.c
index 746172d6..edc3d8b5 100644
--- a/src/rtos/eCos.c
+++ b/src/rtos/eCos.c
@@ -11,9 +11,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -174,7 +172,6 @@ static int eCos_update_threads(struct rtos *rtos)
 				sizeof(struct thread_detail) * thread_list_size);
 		rtos->thread_details->threadid = 1;
 		rtos->thread_details->exists = true;
-		rtos->thread_details->display_str = NULL;
 		rtos->thread_details->extra_info_str = NULL;
 		rtos->thread_details->thread_name_str = malloc(sizeof(tmp_str));
 		strcpy(rtos->thread_details->thread_name_str, tmp_str);
@@ -264,13 +261,11 @@ static int eCos_update_threads(struct rtos *rtos)
 			state_desc = "Unknown state";
 
 		rtos->thread_details[tasks_found].extra_info_str = malloc(strlen(
-					state_desc)+1);
-		strcpy(rtos->thread_details[tasks_found].extra_info_str, state_desc);
+					state_desc)+8);
+		sprintf(rtos->thread_details[tasks_found].extra_info_str, "State: %s", state_desc);
 
 		rtos->thread_details[tasks_found].exists = true;
 
-		rtos->thread_details[tasks_found].display_str = NULL;
-
 		tasks_found++;
 		prev_thread_ptr = thread_index;
 
diff --git a/src/rtos/embKernel.c b/src/rtos/embKernel.c
index a8b07c39..e515383a 100644
--- a/src/rtos/embKernel.c
+++ b/src/rtos/embKernel.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -145,7 +143,6 @@ static int embKernel_get_tasks_details(struct rtos *rtos, int64_t iterable, cons
 		return retval;
 	details->threadid = (threadid_t) task;
 	details->exists = true;
-	details->display_str = NULL;
 
 	int64_t name_ptr = 0;
 	retval = target_read_buffer(rtos->target, task + param->thread_name_offset, param->pointer_width,
@@ -171,11 +168,11 @@ static int embKernel_get_tasks_details(struct rtos *rtos, int64_t iterable, cons
 		return retval;
 	details->extra_info_str = malloc(EMBKERNEL_MAX_THREAD_NAME_STR_SIZE);
 	if (task == rtos->current_thread) {
-		snprintf(details->extra_info_str, EMBKERNEL_MAX_THREAD_NAME_STR_SIZE, "Pri=%u, Running",
+		snprintf(details->extra_info_str, EMBKERNEL_MAX_THREAD_NAME_STR_SIZE, "State: Running, Priority: %u",
 				(unsigned int) priority);
 	} else {
-		snprintf(details->extra_info_str, EMBKERNEL_MAX_THREAD_NAME_STR_SIZE, "Pri=%u, %s", (unsigned int) priority,
-				state_str);
+		snprintf(details->extra_info_str, EMBKERNEL_MAX_THREAD_NAME_STR_SIZE, "State: %s, Priority: %u",
+				state_str, (unsigned int) priority);
 	}
 
 	LOG_OUTPUT("Getting task details: iterable=0x%08X, task=0x%08X, name=%s\n", (unsigned int)iterable,
diff --git a/src/rtos/linux.c b/src/rtos/linux.c
index c28236d3..3efaab13 100644
--- a/src/rtos/linux.c
+++ b/src/rtos/linux.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -107,11 +105,11 @@ static int linux_os_dummy_update(struct rtos *rtos)
 	return 0;
 }
 
-static int linux_compute_virt2phys(struct target *target, uint32_t address)
+static int linux_compute_virt2phys(struct target *target, target_addr_t address)
 {
 	struct linux_os *linux_os = (struct linux_os *)
 		target->rtos->rtos_specific_params;
-	uint32_t pa = 0;
+	target_addr_t pa = 0;
 	int retval = target->type->virt2phys(target, address, &pa);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Cannot compute linux virt2phys translation");
@@ -1215,7 +1213,7 @@ int linux_thread_extra_info(struct target *target,
 		if (temp->threadid == threadid) {
 			char *pid = " PID: ";
 			char *pid_current = "*PID: ";
-			char *name = "NAME: ";
+			char *name = "Name: ";
 			int str_size = strlen(pid) + strlen(name);
 			char *tmp_str = calloc(1, str_size + 50);
 			char *tmp_str_ptr = tmp_str;
@@ -1227,13 +1225,12 @@ int linux_thread_extra_info(struct target *target,
 			else
 				tmp_str_ptr += sprintf(tmp_str_ptr, "%s", pid);
 
-			tmp_str_ptr +=
-				sprintf(tmp_str_ptr, "%d", (int)temp->pid);
-			tmp_str_ptr += sprintf(tmp_str_ptr, "%s", " | ");
+			tmp_str_ptr += sprintf(tmp_str_ptr, "%d, ", (int)temp->pid);
 			sprintf(tmp_str_ptr, "%s", name);
 			sprintf(tmp_str_ptr, "%s", temp->name);
 			char *hex_str = calloc(1, strlen(tmp_str) * 2 + 1);
-			int pkt_len = hexify(hex_str, tmp_str, 0, strlen(tmp_str) * 2 + 1);
+			size_t pkt_len = hexify(hex_str, (const uint8_t *)tmp_str,
+				strlen(tmp_str), strlen(tmp_str) * 2 + 1);
 			gdb_put_packet(connection, hex_str, pkt_len);
 			free(hex_str);
 			free(tmp_str);
diff --git a/src/rtos/linux_header.h b/src/rtos/linux_header.h
index faaf319b..a2b408ef 100644
--- a/src/rtos/linux_header.h
+++ b/src/rtos/linux_header.h
@@ -1,3 +1,6 @@
+#ifndef OPENOCD_RTOS_LINUX_HEADER_H
+#define OPENOCD_RTOS_LINUX_HEADER_H
+
 /*  gdb script to update the header file
   according to kernel version and build option
   before executing function awareness
@@ -30,3 +33,5 @@ define awareness
 #define CPU_CONT 0x1c
 #define PREEMPT 0x4
 #define MM_CTX 0x160
+
+#endif /* OPENOCD_RTOS_LINUX_HEADER_H */
diff --git a/src/rtos/mqx.c b/src/rtos/mqx.c
index 272658c8..63a48c54 100644
--- a/src/rtos/mqx.c
+++ b/src/rtos/mqx.c
@@ -13,8 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.                                        *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -109,7 +108,7 @@ static int mqx_valid_address_check(
 	enum mqx_arch arch_type = ((struct mqx_params *)rtos->rtos_specific_params)->target_arch;
 	const char * targetname = ((struct mqx_params *)rtos->rtos_specific_params)->target_name;
 
-	/* Cortex M address range */
+	/* Cortex-M address range */
 	if (arch_type == mqx_arch_cortexm) {
 		if (
 			/* code and sram area */
@@ -354,7 +353,7 @@ static int mqx_update_threads(
 		uint32_t task_name_addr = 0, task_id = 0, task_errno = 0;
 		uint32_t state_index = 0, state_max = 0;
 		uint32_t extra_info_length = 0;
-		char *state_name = "unknown state";
+		char *state_name = "Unknown";
 
 		/* set current taskpool address */
 		if (ERROR_OK != mqx_get_member(
@@ -424,7 +423,6 @@ static int mqx_update_threads(
 		/* setup thread details struct */
 		rtos->thread_details[i].threadid = task_id;
 		rtos->thread_details[i].exists = true;
-		rtos->thread_details[i].display_str = NULL;
 		/* set thread name */
 		rtos->thread_details[i].thread_name_str = malloc(strlen((void *)task_name) + 1);
 		if (NULL == rtos->thread_details[i].thread_name_str)
@@ -437,13 +435,13 @@ static int mqx_update_threads(
 		 * calculate length as:
 		 * state length + address length + errno length + formatter length
 		 */
-		extra_info_length += strlen((void *)state_name) + 8 + 8 + 8;
+		extra_info_length += strlen((void *)state_name) + 7 + 13 + 8 + 15 + 8;
 		rtos->thread_details[i].extra_info_str = malloc(extra_info_length + 1);
 		if (NULL == rtos->thread_details[i].extra_info_str)
 			return ERROR_FAIL;
-		snprintf(
-			rtos->thread_details[i].extra_info_str, extra_info_length, "%s : 0x%"PRIx32 " : %" PRIu32,
-			state_name, task_addr, task_errno
+		snprintf(rtos->thread_details[i].extra_info_str, extra_info_length,
+			 "State: %s, Address: 0x%" PRIx32 ",  Error Code: %" PRIu32,
+			 state_name, task_addr, task_errno
 		);
 		/* set active thread */
 		if (active_td_addr == task_addr)
diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 90801a44..4bd7a354 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -36,6 +34,7 @@ extern struct rtos_type Linux_os;
 extern struct rtos_type ChibiOS_rtos;
 extern struct rtos_type embKernel_rtos;
 extern struct rtos_type mqx_rtos;
+extern struct rtos_type uCOS_III_rtos;
 
 static struct rtos_type *rtos_types[] = {
 	&ThreadX_rtos,
@@ -45,6 +44,7 @@ static struct rtos_type *rtos_types[] = {
 	&ChibiOS_rtos,
 	&embKernel_rtos,
 	&mqx_rtos,
+	&uCOS_III_rtos,
 	NULL
 };
 
@@ -112,8 +112,9 @@ int rtos_set_wipe(Jim_GetOptInfo *goi, struct target *target)
 int rtos_create(Jim_GetOptInfo *goi, struct target *target)
 {
 	int x;
-	char *cp;
+	const char *cp;
 	struct Jim_Obj *res;
+	int e;
 
 	if (!goi->isconfigure && goi->argc != 0) {
 		Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "NO PARAMS");
@@ -122,7 +123,9 @@ int rtos_create(Jim_GetOptInfo *goi, struct target *target)
 
 	os_free(target);
 
-	Jim_GetOpt_String(goi, &cp, NULL);
+	e = Jim_GetOpt_String(goi, &cp, NULL);
+	if (e != JIM_OK)
+		return e;
 
 	if (0 == strcmp(cp, "auto")) {
 		/* Auto detect tries to look up all symbols for each RTOS,
@@ -223,7 +226,7 @@ int rtos_qsymbol(struct connection *connection, char const *packet, int packet_s
 		goto done;
 
 	/* Decode any symbol name in the packet*/
-	int len = unhexify(cur_sym, strchr(packet + 8, ':') + 1, strlen(strchr(packet + 8, ':') + 1));
+	size_t len = unhexify((uint8_t *)cur_sym, strchr(packet + 8, ':') + 1, strlen(strchr(packet + 8, ':') + 1));
 	cur_sym[len] = 0;
 
 	if ((strcmp(packet, "qSymbol::") != 0) &&               /* GDB is not offering symbol lookup for the first time */
@@ -271,7 +274,9 @@ int rtos_qsymbol(struct connection *connection, char const *packet, int packet_s
 	}
 
 	reply_len = snprintf(reply, sizeof(reply), "qSymbol:");
-	reply_len += hexify(reply + reply_len, next_sym->symbol_name, 0, sizeof(reply) - reply_len);
+	reply_len += hexify(reply + reply_len,
+		(const uint8_t *)next_sym->symbol_name, strlen(next_sym->symbol_name),
+		sizeof(reply) - reply_len);
 
 done:
 	gdb_put_packet(connection, reply, reply_len);
@@ -306,35 +311,28 @@ int rtos_thread_packet(struct connection *connection, char const *packet, int pa
 			struct thread_detail *detail = &target->rtos->thread_details[found];
 
 			int str_size = 0;
-			if (detail->display_str != NULL)
-				str_size += strlen(detail->display_str);
 			if (detail->thread_name_str != NULL)
 				str_size += strlen(detail->thread_name_str);
 			if (detail->extra_info_str != NULL)
 				str_size += strlen(detail->extra_info_str);
 
-			char *tmp_str = calloc(str_size + 7, sizeof(char));
+			char *tmp_str = calloc(str_size + 9, sizeof(char));
 			char *tmp_str_ptr = tmp_str;
 
-			if (detail->display_str != NULL)
-				tmp_str_ptr += sprintf(tmp_str_ptr, "%s", detail->display_str);
-			if (detail->thread_name_str != NULL) {
-				if (tmp_str_ptr != tmp_str)
-					tmp_str_ptr += sprintf(tmp_str_ptr, " : ");
-				tmp_str_ptr += sprintf(tmp_str_ptr, "%s", detail->thread_name_str);
-			}
+			if (detail->thread_name_str != NULL)
+				tmp_str_ptr += sprintf(tmp_str_ptr, "Name: %s", detail->thread_name_str);
 			if (detail->extra_info_str != NULL) {
 				if (tmp_str_ptr != tmp_str)
-					tmp_str_ptr += sprintf(tmp_str_ptr, " : ");
-				tmp_str_ptr +=
-					sprintf(tmp_str_ptr, " : %s", detail->extra_info_str);
+					tmp_str_ptr += sprintf(tmp_str_ptr, ", ");
+				tmp_str_ptr += sprintf(tmp_str_ptr, "%s", detail->extra_info_str);
 			}
 
 			assert(strlen(tmp_str) ==
 				(size_t) (tmp_str_ptr - tmp_str));
 
 			char *hex_str = malloc(strlen(tmp_str) * 2 + 1);
-			int pkt_len = hexify(hex_str, tmp_str, 0, strlen(tmp_str) * 2 + 1);
+			size_t pkt_len = hexify(hex_str, (const uint8_t *)tmp_str,
+				strlen(tmp_str), strlen(tmp_str) * 2 + 1);
 
 			gdb_put_packet(connection, hex_str, pkt_len);
 			free(hex_str);
@@ -416,9 +414,14 @@ int rtos_thread_packet(struct connection *connection, char const *packet, int pa
 	} else if (packet[0] == 'H') {	/* Set current thread ( 'c' for step and continue, 'g' for
 					 * all other operations ) */
 		if ((packet[1] == 'g') && (target->rtos != NULL)) {
-			sscanf(packet, "Hg%16" SCNx64, &target->rtos->current_threadid);
-			LOG_DEBUG("RTOS: GDB requested to set current thread to 0x%" PRIx64 "\r\n",
-										target->rtos->current_threadid);
+			threadid_t threadid;
+			sscanf(packet, "Hg%16" SCNx64, &threadid);
+			LOG_DEBUG("RTOS: GDB requested to set current thread to 0x%" PRIx64, threadid);
+			/* threadid of 0 indicates target should choose */
+			if (threadid == 0)
+				target->rtos->current_threadid = target->rtos->current_thread;
+			else
+				target->rtos->current_threadid = threadid;
 		}
 		gdb_put_packet(connection, "OK", 2);
 		return ERROR_OK;
@@ -444,9 +447,13 @@ int rtos_get_gdb_reg_list(struct connection *connection)
 										current_threadid,
 										target->rtos->current_thread);
 
-		target->rtos->type->get_thread_reg_list(target->rtos,
-			current_threadid,
-			&hex_reg_list);
+		int retval = target->rtos->type->get_thread_reg_list(target->rtos,
+				current_threadid,
+				&hex_reg_list);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("RTOS: failed to get register list");
+			return retval;
+		}
 
 		if (hex_reg_list != NULL) {
 			gdb_put_packet(connection, hex_reg_list, strlen(hex_reg_list));
@@ -571,12 +578,13 @@ void rtos_free_threadlist(struct rtos *rtos)
 
 		for (j = 0; j < rtos->thread_count; j++) {
 			struct thread_detail *current_thread = &rtos->thread_details[j];
-			free(current_thread->display_str);
 			free(current_thread->thread_name_str);
 			free(current_thread->extra_info_str);
 		}
 		free(rtos->thread_details);
 		rtos->thread_details = NULL;
 		rtos->thread_count = 0;
+		rtos->current_threadid = -1;
+		rtos->current_thread = 0;
 	}
 }
diff --git a/src/rtos/rtos.h b/src/rtos/rtos.h
index 88b44d2e..0e0a5a43 100644
--- a/src/rtos/rtos.h
+++ b/src/rtos/rtos.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef RTOS_H
-#define RTOS_H
+#ifndef OPENOCD_RTOS_RTOS_H
+#define OPENOCD_RTOS_RTOS_H
 
 #include "server/server.h"
 #include <jim-nvp.h>
@@ -47,7 +45,6 @@ typedef struct symbol_table_elem_struct {
 struct thread_detail {
 	threadid_t threadid;
 	bool exists;
-	char *display_str;
 	char *thread_name_str;
 	char *extra_info_str;
 };
@@ -120,4 +117,4 @@ int rtos_smp_init(struct target *target);
 int rtos_qsymbol(struct connection *connection, char const *packet, int packet_size);
 int rtos_set_wipe(Jim_GetOptInfo *goi, struct target *target);
 
-#endif	/* RTOS_H */
+#endif /* OPENOCD_RTOS_RTOS_H */
diff --git a/src/rtos/rtos_chibios_stackings.c b/src/rtos/rtos_chibios_stackings.c
index 0c34f8e0..a6fa5c06 100644
--- a/src/rtos/rtos_chibios_stackings.c
+++ b/src/rtos/rtos_chibios_stackings.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/rtos/rtos_chibios_stackings.h b/src/rtos/rtos_chibios_stackings.h
index 8ba2a6ca..130aaa18 100644
--- a/src/rtos/rtos_chibios_stackings.h
+++ b/src/rtos/rtos_chibios_stackings.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef INCLUDED_RTOS_CHIBIOS_STACKINGS_H_
-#define INCLUDED_RTOS_CHIBIOS_STACKINGS_H_
+#ifndef OPENOCD_RTOS_RTOS_CHIBIOS_STACKINGS_H
+#define OPENOCD_RTOS_RTOS_CHIBIOS_STACKINGS_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -30,4 +28,4 @@
 extern const struct rtos_register_stacking rtos_chibios_arm_v7m_stacking;
 extern const struct rtos_register_stacking rtos_chibios_arm_v7m_stacking_w_fpu;
 
-#endif	/* ifndef INCLUDED_RTOS_CHIBIOS_STACKINGS_H_ */
+#endif /* OPENOCD_RTOS_RTOS_CHIBIOS_STACKINGS_H */
diff --git a/src/rtos/rtos_ecos_stackings.c b/src/rtos/rtos_ecos_stackings.c
index 011dfbb1..c120472a 100644
--- a/src/rtos/rtos_ecos_stackings.c
+++ b/src/rtos/rtos_ecos_stackings.c
@@ -11,9 +11,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/rtos/rtos_ecos_stackings.h b/src/rtos/rtos_ecos_stackings.h
index 3bcd7cb0..951f7de5 100644
--- a/src/rtos/rtos_ecos_stackings.h
+++ b/src/rtos/rtos_ecos_stackings.h
@@ -11,13 +11,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_
-#define INCLUDED_RTOS_STANDARD_STACKINGS_H_
+#ifndef OPENOCD_RTOS_RTOS_ECOS_STACKINGS_H
+#define OPENOCD_RTOS_RTOS_ECOS_STACKINGS_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -27,4 +25,4 @@
 
 extern const struct rtos_register_stacking rtos_eCos_Cortex_M3_stacking;
 
-#endif	/* ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_ */
+#endif /* OPENOCD_RTOS_RTOS_ECOS_STACKINGS_H */
diff --git a/src/rtos/rtos_embkernel_stackings.c b/src/rtos/rtos_embkernel_stackings.c
index b4b35372..39edc527 100644
--- a/src/rtos/rtos_embkernel_stackings.c
+++ b/src/rtos/rtos_embkernel_stackings.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/rtos/rtos_embkernel_stackings.h b/src/rtos/rtos_embkernel_stackings.h
index 5bbcb461..89a0c2f1 100644
--- a/src/rtos/rtos_embkernel_stackings.h
+++ b/src/rtos/rtos_embkernel_stackings.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef INCLUDED_RTOS_EMBKERNEL_STACKINGS_H_
-#define INCLUDED_RTOS_EMBKERNEL_STACKINGS_H_
+#ifndef OPENOCD_RTOS_RTOS_EMBKERNEL_STACKINGS_H
+#define OPENOCD_RTOS_RTOS_EMBKERNEL_STACKINGS_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -29,4 +27,4 @@
 
 extern const struct rtos_register_stacking rtos_embkernel_Cortex_M_stacking;
 
-#endif	/* ifndef INCLUDED_RTOS_EMBKERNEL_STACKINGS_H_ */
+#endif /* OPENOCD_RTOS_RTOS_EMBKERNEL_STACKINGS_H */
diff --git a/src/rtos/rtos_mqx_stackings.c b/src/rtos/rtos_mqx_stackings.c
index a8c0dfb5..7d57089d 100644
--- a/src/rtos/rtos_mqx_stackings.c
+++ b/src/rtos/rtos_mqx_stackings.c
@@ -13,8 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.                                        *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/rtos/rtos_mqx_stackings.h b/src/rtos/rtos_mqx_stackings.h
index 9536c400..6ebd2878 100644
--- a/src/rtos/rtos_mqx_stackings.h
+++ b/src/rtos/rtos_mqx_stackings.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.                                        *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef INCLUDED_RTOS_MQX_STACKINGS_H_
-#define INCLUDED_RTOS_MQX_STACKINGS_H_
+#ifndef OPENOCD_RTOS_RTOS_MQX_STACKINGS_H
+#define OPENOCD_RTOS_RTOS_MQX_STACKINGS_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -28,5 +27,4 @@
 
 extern const struct rtos_register_stacking rtos_mqx_arm_v7m_stacking;
 
-#endif	/* ifndef INCLUDED_RTOS_MQX_STACKINGS_H_ */
-
+#endif /* OPENOCD_RTOS_RTOS_MQX_STACKINGS_H */
diff --git a/src/rtos/rtos_standard_stackings.c b/src/rtos/rtos_standard_stackings.c
index 3d6502e4..0176c01a 100644
--- a/src/rtos/rtos_standard_stackings.c
+++ b/src/rtos/rtos_standard_stackings.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -26,64 +24,132 @@
 #include "target/armv7m.h"
 
 static const struct stack_register_offset rtos_standard_Cortex_M3_stack_offsets[ARMV7M_NUM_CORE_REGS] = {
-	{ 0x20,                      32 },		/* r0   */
-	{ 0x24,                      32 },		/* r1   */
-	{ 0x28,                      32 },		/* r2   */
-	{ 0x2c,                      32 },		/* r3   */
-	{ 0x00,                      32 },		/* r4   */
-	{ 0x04,                      32 },		/* r5   */
-	{ 0x08,                      32 },		/* r6   */
-	{ 0x0c,                      32 },		/* r7   */
-	{ 0x10,                      32 },		/* r8   */
-	{ 0x14,                      32 },		/* r9   */
-	{ 0x18,                      32 },		/* r10  */
-	{ 0x1c,                      32 },		/* r11  */
-	{ 0x30,                      32 },		/* r12  */
-	{ REGISTER_IS_STACK_POINTER, 32 },		/* sp   */
-	{ 0x34,                      32 },		/* lr   */
-	{ 0x38,                      32 },		/* pc   */
-	{ 0x3c,                      32 },		/* xPSR */
+	{ 0x20, 32 },		/* r0   */
+	{ 0x24, 32 },		/* r1   */
+	{ 0x28, 32 },		/* r2   */
+	{ 0x2c, 32 },		/* r3   */
+	{ 0x00, 32 },		/* r4   */
+	{ 0x04, 32 },		/* r5   */
+	{ 0x08, 32 },		/* r6   */
+	{ 0x0c, 32 },		/* r7   */
+	{ 0x10, 32 },		/* r8   */
+	{ 0x14, 32 },		/* r9   */
+	{ 0x18, 32 },		/* r10  */
+	{ 0x1c, 32 },		/* r11  */
+	{ 0x30, 32 },		/* r12  */
+	{ -2,   32 },		/* sp   */
+	{ 0x34, 32 },		/* lr   */
+	{ 0x38, 32 },		/* pc   */
+	{ 0x3c, 32 },		/* xPSR */
 };
 
+static const struct stack_register_offset rtos_standard_Cortex_M4F_stack_offsets[] = {
+	{ 0x24, 32 },		/* r0   */
+	{ 0x28, 32 },		/* r1   */
+	{ 0x2c, 32 },		/* r2   */
+	{ 0x30, 32 },		/* r3   */
+	{ 0x00, 32 },		/* r4   */
+	{ 0x04, 32 },		/* r5   */
+	{ 0x08, 32 },		/* r6   */
+	{ 0x0c, 32 },		/* r7   */
+	{ 0x10, 32 },		/* r8   */
+	{ 0x14, 32 },		/* r9   */
+	{ 0x18, 32 },		/* r10  */
+	{ 0x1c, 32 },		/* r11  */
+	{ 0x34, 32 },		/* r12  */
+	{ -2,   32 },		/* sp   */
+	{ 0x38, 32 },		/* lr   */
+	{ 0x3c, 32 },		/* pc   */
+	{ 0x40, 32 },		/* xPSR */
+};
+
+static const struct stack_register_offset rtos_standard_Cortex_M4F_FPU_stack_offsets[] = {
+	{ 0x64, 32 },		/* r0   */
+	{ 0x68, 32 },		/* r1   */
+	{ 0x6c, 32 },		/* r2   */
+	{ 0x70, 32 },		/* r3   */
+	{ 0x00, 32 },		/* r4   */
+	{ 0x04, 32 },		/* r5   */
+	{ 0x08, 32 },		/* r6   */
+	{ 0x0c, 32 },		/* r7   */
+	{ 0x10, 32 },		/* r8   */
+	{ 0x14, 32 },		/* r9   */
+	{ 0x18, 32 },		/* r10  */
+	{ 0x1c, 32 },		/* r11  */
+	{ 0x74, 32 },		/* r12  */
+	{ -2,   32 },		/* sp   */
+	{ 0x78, 32 },		/* lr   */
+	{ 0x7c, 32 },		/* pc   */
+	{ 0x80, 32 },		/* xPSR */
+};
 
 
+static const struct stack_register_offset rtos_standard_Cortex_R4_stack_offsets[] = {
+	{ 0x08, 32 },		/* r0  (a1)   */
+	{ 0x0c, 32 },		/* r1  (a2)  */
+	{ 0x10, 32 },		/* r2  (a3)  */
+	{ 0x14, 32 },		/* r3  (a4)  */
+	{ 0x18, 32 },		/* r4  (v1)  */
+	{ 0x1c, 32 },		/* r5  (v2)  */
+	{ 0x20, 32 },		/* r6  (v3)  */
+	{ 0x24, 32 },		/* r7  (v4)  */
+	{ 0x28, 32 },		/* r8  (a1)  */
+	{ 0x2c, 32 },		/* r9  (sb)  */
+	{ 0x30, 32 },		/* r10 (sl) */
+	{ 0x34, 32 },		/* r11 (fp) */
+	{ 0x38, 32 },		/* r12 (ip) */
+	{ -2,   32 },		/* sp   */
+	{ 0x3c, 32 },		/* lr   */
+	{ 0x40, 32 },		/* pc   */
+	{ -1,   96 },		/* FPA1 */
+	{ -1,   96 },		/* FPA2 */
+	{ -1,   96 },		/* FPA3 */
+	{ -1,   96 },		/* FPA4 */
+	{ -1,   96 },		/* FPA5 */
+	{ -1,   96 },		/* FPA6 */
+	{ -1,   96 },		/* FPA7 */
+	{ -1,   96 },		/* FPA8 */
+	{ -1,   32 },		/* FPS  */
+	{ 0x04, 32 },		/* CSPR */
+};
+
 static const struct stack_register_offset rtos_standard_NDS32_N1068_stack_offsets[] = {
-	{ 0x88,                      32 },		/* R0  */
-	{ 0x8C,                      32 },		/* R1 */
-	{ 0x14,                      32 },		/* R2 */
-	{ 0x18,                      32 },		/* R3 */
-	{ 0x1C,                      32 },		/* R4 */
-	{ 0x20,                      32 },		/* R5 */
-	{ 0x24,                      32 },		/* R6 */
-	{ 0x28,                      32 },		/* R7 */
-	{ 0x2C,                      32 },		/* R8 */
-	{ 0x30,                      32 },		/* R9 */
-	{ 0x34,                      32 },		/* R10 */
-	{ 0x38,                      32 },		/* R11 */
-	{ 0x3C,                      32 },		/* R12 */
-	{ 0x40,                      32 },		/* R13 */
-	{ 0x44,                      32 },		/* R14 */
-	{ 0x48,                      32 },		/* R15 */
-	{ 0x4C,                      32 },		/* R16 */
-	{ 0x50,                      32 },		/* R17 */
-	{ 0x54,                      32 },		/* R18 */
-	{ 0x58,                      32 },		/* R19 */
-	{ 0x5C,                      32 },		/* R20 */
-	{ 0x60,                      32 },		/* R21 */
-	{ 0x64,                      32 },		/* R22 */
-	{ 0x68,                      32 },		/* R23 */
-	{ 0x6C,                      32 },		/* R24 */
-	{ 0x70,                      32 },		/* R25 */
-	{ 0x74,                      32 },		/* R26 */
-	{ 0x78,                      32 },		/* R27 */
-	{ 0x7C,                      32 },		/* R28 */
-	{ 0x80,                      32 },		/* R29 */
-	{ 0x84,                      32 },		/* R30 (LP) */
-	{ 0x00,                      32 },		/* R31 (SP) */
-	{ 0x04,                      32 },		/* PSW */
-	{ 0x08,                      32 },		/* IPC */
-	{ 0x0C,                      32 },		/* IPSW */
-	{ 0x10,                      32 },		/* IFC_LP */
+	{ 0x88, 32 },		/* R0  */
+	{ 0x8C, 32 },		/* R1 */
+	{ 0x14, 32 },		/* R2 */
+	{ 0x18, 32 },		/* R3 */
+	{ 0x1C, 32 },		/* R4 */
+	{ 0x20, 32 },		/* R5 */
+	{ 0x24, 32 },		/* R6 */
+	{ 0x28, 32 },		/* R7 */
+	{ 0x2C, 32 },		/* R8 */
+	{ 0x30, 32 },		/* R9 */
+	{ 0x34, 32 },		/* R10 */
+	{ 0x38, 32 },		/* R11 */
+	{ 0x3C, 32 },		/* R12 */
+	{ 0x40, 32 },		/* R13 */
+	{ 0x44, 32 },		/* R14 */
+	{ 0x48, 32 },		/* R15 */
+	{ 0x4C, 32 },		/* R16 */
+	{ 0x50, 32 },		/* R17 */
+	{ 0x54, 32 },		/* R18 */
+	{ 0x58, 32 },		/* R19 */
+	{ 0x5C, 32 },		/* R20 */
+	{ 0x60, 32 },		/* R21 */
+	{ 0x64, 32 },		/* R22 */
+	{ 0x68, 32 },		/* R23 */
+	{ 0x6C, 32 },		/* R24 */
+	{ 0x70, 32 },		/* R25 */
+	{ 0x74, 32 },		/* R26 */
+	{ 0x78, 32 },		/* R27 */
+	{ 0x7C, 32 },		/* R28 */
+	{ 0x80, 32 },		/* R29 */
+	{ 0x84, 32 },		/* R30 (LP) */
+	{ 0x00, 32 },		/* R31 (SP) */
+	{ 0x04, 32 },		/* PSW */
+	{ 0x08, 32 },		/* IPC */
+	{ 0x0C, 32 },		/* IPSW */
+	{ 0x10, 32 },		/* IFC_LP */
 };
 
 static int64_t rtos_generic_stack_align(struct target *target,
@@ -114,7 +180,7 @@ int64_t rtos_generic_stack_align8(struct target *target,
 			stacking, stack_ptr, 8);
 }
 
-/* The Cortex M3 will indicate that an alignment adjustment
+/* The Cortex-M3 will indicate that an alignment adjustment
  * has been done on the stack by setting bit 9 of the stacked xPSR
  * register.  In this case, we can just add an extra 4 bytes to get
  * to the program stack.  Note that some places in the ARM documentation
@@ -171,6 +237,29 @@ const struct rtos_register_stacking rtos_standard_Cortex_M3_stacking = {
 	rtos_standard_Cortex_M3_stack_offsets	/* register_offsets */
 };
 
+const struct rtos_register_stacking rtos_standard_Cortex_M4F_stacking = {
+	0x44,					/* stack_registers_size 4 more for LR*/
+	-1,						/* stack_growth_direction */
+	ARMV7M_NUM_CORE_REGS,	/* num_output_registers */
+	rtos_standard_Cortex_M3_stack_align,	/* stack_alignment */
+	rtos_standard_Cortex_M4F_stack_offsets	/* register_offsets */
+};
+
+const struct rtos_register_stacking rtos_standard_Cortex_M4F_FPU_stacking = {
+	0xcc,					/* stack_registers_size 4 more for LR + 48 more for FPU S0-S15 register*/
+	-1,						/* stack_growth_direction */
+	ARMV7M_NUM_CORE_REGS,	/* num_output_registers */
+	rtos_standard_Cortex_M3_stack_align,	/* stack_alignment */
+	rtos_standard_Cortex_M4F_FPU_stack_offsets	/* register_offsets */
+};
+
+const struct rtos_register_stacking rtos_standard_Cortex_R4_stacking = {
+	0x48,				/* stack_registers_size */
+	-1,					/* stack_growth_direction */
+	26,					/* num_output_registers */
+	rtos_generic_stack_align8,	/* stack_alignment */
+	rtos_standard_Cortex_R4_stack_offsets	/* register_offsets */
+};
 
 const struct rtos_register_stacking rtos_standard_NDS32_N1068_stacking = {
 	0x90,				/* stack_registers_size */
diff --git a/src/rtos/rtos_standard_stackings.h b/src/rtos/rtos_standard_stackings.h
index f931bb9f..6971efd1 100644
--- a/src/rtos/rtos_standard_stackings.h
+++ b/src/rtos/rtos_standard_stackings.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_
-#define INCLUDED_RTOS_STANDARD_STACKINGS_H_
+#ifndef OPENOCD_RTOS_RTOS_STANDARD_STACKINGS_H
+#define OPENOCD_RTOS_RTOS_STANDARD_STACKINGS_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -28,6 +26,8 @@
 #include "rtos.h"
 
 extern const struct rtos_register_stacking rtos_standard_Cortex_M3_stacking;
+extern const struct rtos_register_stacking rtos_standard_Cortex_M4F_stacking;
+extern const struct rtos_register_stacking rtos_standard_Cortex_M4F_FPU_stacking;
 extern const struct rtos_register_stacking rtos_standard_Cortex_R4_stacking;
 extern const struct rtos_register_stacking rtos_standard_NDS32_N1068_stacking;
 int64_t rtos_generic_stack_align8(struct target *target,
@@ -37,4 +37,4 @@ int64_t rtos_Cortex_M_stack_align(struct target *target,
 	const uint8_t *stack_data, const struct rtos_register_stacking *stacking,
 	int64_t stack_ptr, size_t xpsr_offset);
 
-#endif	/* ifndef INCLUDED_RTOS_STANDARD_STACKINGS_H_ */
+#endif /* OPENOCD_RTOS_RTOS_STANDARD_STACKINGS_H */
diff --git a/src/rtos/rtos_ucos_iii_stackings.c b/src/rtos/rtos_ucos_iii_stackings.c
new file mode 100644
index 00000000..c260b7f8
--- /dev/null
+++ b/src/rtos/rtos_ucos_iii_stackings.c
@@ -0,0 +1,54 @@
+/***************************************************************************
+ *   Copyright (C) 2017 by Square, Inc.                                    *
+ *   Steven Stallion <stallion@squareup.com>                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/types.h>
+#include <rtos/rtos.h>
+#include <rtos/rtos_standard_stackings.h>
+#include <target/armv7m.h>
+
+static const struct stack_register_offset rtos_uCOS_III_Cortex_M_stack_offsets[] = {
+	{ 0x20, 32 },	/* r0   */
+	{ 0x24, 32 },	/* r1   */
+	{ 0x28, 32 },	/* r2   */
+	{ 0x2c, 32 },	/* r3   */
+	{ 0x00, 32 },	/* r4   */
+	{ 0x04, 32 },	/* r5   */
+	{ 0x08, 32 },	/* r6   */
+	{ 0x0c, 32 },	/* r7   */
+	{ 0x10, 32 },	/* r8   */
+	{ 0x14, 32 },	/* r9   */
+	{ 0x18, 32 },	/* r10  */
+	{ 0x1c, 32 },	/* r11  */
+	{ 0x30, 32 },	/* r12  */
+	{ -2,   32 },	/* sp   */
+	{ 0x34, 32 },	/* lr   */
+	{ 0x38, 32 },	/* pc   */
+	{ 0x3c, 32 },	/* xPSR */
+};
+
+const struct rtos_register_stacking rtos_uCOS_III_Cortex_M_stacking = {
+	0x40,												/* stack_registers_size */
+	-1,													/* stack_growth_direction */
+	ARRAY_SIZE(rtos_uCOS_III_Cortex_M_stack_offsets),	/* num_output_registers */
+	rtos_generic_stack_align8,							/* stack_alignment */
+	rtos_uCOS_III_Cortex_M_stack_offsets				/* register_offsets */
+};
diff --git a/src/rtos/rtos_ucos_iii_stackings.h b/src/rtos/rtos_ucos_iii_stackings.h
new file mode 100644
index 00000000..f4703da3
--- /dev/null
+++ b/src/rtos/rtos_ucos_iii_stackings.h
@@ -0,0 +1,30 @@
+/***************************************************************************
+ *   Copyright (C) 2017 by Square, Inc.                                    *
+ *   Steven Stallion <stallion@squareup.com>                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifndef OPENOCD_RTOS_RTOS_UCOS_III_STACKINGS_H
+#define OPENOCD_RTOS_RTOS_UCOS_III_STACKINGS_H
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <rtos/rtos.h>
+
+extern const struct rtos_register_stacking rtos_uCOS_III_Cortex_M_stacking;
+
+#endif /* OPENOCD_RTOS_RTOS_UCOS_III_STACKINGS_H */
diff --git a/src/rtos/uCOS-III.c b/src/rtos/uCOS-III.c
new file mode 100644
index 00000000..0a0fb3e9
--- /dev/null
+++ b/src/rtos/uCOS-III.c
@@ -0,0 +1,511 @@
+/***************************************************************************
+ *   Copyright (C) 2017 by Square, Inc.                                    *
+ *   Steven Stallion <stallion@squareup.com>                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+#include <helper/time_support.h>
+#include <helper/types.h>
+#include <rtos/rtos.h>
+#include <target/target.h>
+#include <target/target_type.h>
+
+#include "rtos_ucos_iii_stackings.h"
+
+#ifndef UCOS_III_MAX_STRLEN
+#define UCOS_III_MAX_STRLEN 64
+#endif
+
+#ifndef UCOS_III_MAX_THREADS
+#define UCOS_III_MAX_THREADS 256
+#endif
+
+struct uCOS_III_params {
+	const char *target_name;
+	const unsigned char pointer_width;
+	symbol_address_t thread_stack_offset;
+	symbol_address_t thread_name_offset;
+	symbol_address_t thread_state_offset;
+	symbol_address_t thread_priority_offset;
+	symbol_address_t thread_prev_offset;
+	symbol_address_t thread_next_offset;
+	bool thread_offsets_updated;
+	size_t threadid_start;
+	const struct rtos_register_stacking *stacking_info;
+	size_t num_threads;
+	symbol_address_t threads[];
+};
+
+static const struct uCOS_III_params uCOS_III_params_list[] = {
+	{
+		"cortex_m",							/* target_name */
+		sizeof(uint32_t),					/* pointer_width */
+		0,									/* thread_stack_offset */
+		0,									/* thread_name_offset */
+		0,									/* thread_state_offset */
+		0,									/* thread_priority_offset */
+		0,									/* thread_prev_offset */
+		0,									/* thread_next_offset */
+		false,								/* thread_offsets_updated */
+		1,									/* threadid_start */
+		&rtos_uCOS_III_Cortex_M_stacking,	/* stacking_info */
+		0,									/* num_threads */
+	},
+};
+
+static const char * const uCOS_III_symbol_list[] = {
+	"OSRunning",
+	"OSTCBCurPtr",
+	"OSTaskDbgListPtr",
+	"OSTaskQty",
+
+	/* also see: contrib/rtos-helpers/uCOS-III-openocd.c */
+	"openocd_OS_TCB_StkPtr_offset",
+	"openocd_OS_TCB_NamePtr_offset",
+	"openocd_OS_TCB_TaskState_offset",
+	"openocd_OS_TCB_Prio_offset",
+	"openocd_OS_TCB_DbgPrevPtr_offset",
+	"openocd_OS_TCB_DbgNextPtr_offset",
+	NULL
+};
+
+enum uCOS_III_symbol_values {
+	uCOS_III_VAL_OSRunning,
+	uCOS_III_VAL_OSTCBCurPtr,
+	uCOS_III_VAL_OSTaskDbgListPtr,
+	uCOS_III_VAL_OSTaskQty,
+
+	/* also see: contrib/rtos-helpers/uCOS-III-openocd.c */
+	uCOS_III_VAL_OS_TCB_StkPtr_offset,
+	uCOS_III_VAL_OS_TCB_NamePtr_offset,
+	uCOS_III_VAL_OS_TCB_TaskState_offset,
+	uCOS_III_VAL_OS_TCB_Prio_offset,
+	uCOS_III_VAL_OS_TCB_DbgPrevPtr_offset,
+	uCOS_III_VAL_OS_TCB_DbgNextPtr_offset,
+};
+
+static const char * const uCOS_III_thread_state_list[] = {
+	"Ready",
+	"Delay",
+	"Pend",
+	"Pend Timeout",
+	"Suspended",
+	"Delay Suspended",
+	"Pend Suspended",
+	"Pend Timeout Suspended",
+};
+
+static int uCOS_III_find_or_create_thread(struct rtos *rtos, symbol_address_t thread_address,
+		threadid_t *threadid)
+{
+	struct uCOS_III_params *params = rtos->rtos_specific_params;
+	size_t thread_index;
+
+	for (thread_index = 0; thread_index < params->num_threads; thread_index++)
+		if (params->threads[thread_index] == thread_address)
+			goto found;
+
+	if (params->num_threads == UCOS_III_MAX_THREADS) {
+		LOG_WARNING("uCOS-III: too many threads; increase UCOS_III_MAX_THREADS");
+		return ERROR_FAIL;
+	}
+
+	params->threads[thread_index] = thread_address;
+	params->num_threads++;
+found:
+	*threadid = thread_index + params->threadid_start;
+	return ERROR_OK;
+}
+
+static int uCOS_III_find_thread_address(struct rtos *rtos, threadid_t threadid,
+		symbol_address_t *thread_address)
+{
+	struct uCOS_III_params *params = rtos->rtos_specific_params;
+	size_t thread_index;
+
+	thread_index = threadid - params->threadid_start;
+	if (thread_index >= params->num_threads) {
+		LOG_ERROR("uCOS-III: failed to find thread address");
+		return ERROR_FAIL;
+	}
+
+	*thread_address = params->threads[thread_index];
+	return ERROR_OK;
+}
+
+static int uCOS_III_find_last_thread_address(struct rtos *rtos, symbol_address_t *thread_address)
+{
+	struct uCOS_III_params *params = rtos->rtos_specific_params;
+	int retval;
+
+	/* read the thread list head */
+	symbol_address_t thread_list_address = 0;
+
+	retval = target_read_memory(rtos->target,
+			rtos->symbols[uCOS_III_VAL_OSTaskDbgListPtr].address,
+			params->pointer_width,
+			1,
+			(void *)&thread_list_address);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to read thread list address");
+		return retval;
+	}
+
+	/* advance to end of thread list */
+	do {
+		*thread_address = thread_list_address;
+
+		retval = target_read_memory(rtos->target,
+				thread_list_address + params->thread_next_offset,
+				params->pointer_width,
+				1,
+				(void *)&thread_list_address);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to read next thread address");
+			return retval;
+		}
+	} while (thread_list_address != 0);
+
+	return ERROR_OK;
+}
+
+static int uCOS_III_update_thread_offsets(struct rtos *rtos)
+{
+	struct uCOS_III_params *params = rtos->rtos_specific_params;
+
+	if (params->thread_offsets_updated)
+		return ERROR_OK;
+
+	const struct thread_offset_map {
+		enum uCOS_III_symbol_values symbol_value;
+		symbol_address_t *thread_offset;
+	} thread_offset_maps[] = {
+		{
+			uCOS_III_VAL_OS_TCB_StkPtr_offset,
+			&params->thread_stack_offset,
+		},
+		{
+			uCOS_III_VAL_OS_TCB_NamePtr_offset,
+			&params->thread_name_offset,
+		},
+		{
+			uCOS_III_VAL_OS_TCB_TaskState_offset,
+			&params->thread_state_offset,
+		},
+		{
+			uCOS_III_VAL_OS_TCB_Prio_offset,
+			&params->thread_priority_offset,
+		},
+		{
+			uCOS_III_VAL_OS_TCB_DbgPrevPtr_offset,
+			&params->thread_prev_offset,
+		},
+		{
+			uCOS_III_VAL_OS_TCB_DbgNextPtr_offset,
+			&params->thread_next_offset,
+		},
+	};
+
+	for (size_t i = 0; i < ARRAY_SIZE(thread_offset_maps); i++) {
+		const struct thread_offset_map *thread_offset_map = &thread_offset_maps[i];
+
+		int retval = target_read_memory(rtos->target,
+				rtos->symbols[thread_offset_map->symbol_value].address,
+				params->pointer_width,
+				1,
+				(void *)thread_offset_map->thread_offset);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to read thread offset");
+			return retval;
+		}
+	}
+
+	params->thread_offsets_updated = true;
+	return ERROR_OK;
+}
+
+static int uCOS_III_detect_rtos(struct target *target)
+{
+	return target->rtos->symbols != NULL &&
+			target->rtos->symbols[uCOS_III_VAL_OSRunning].address != 0;
+}
+
+static int uCOS_III_reset_handler(struct target *target, enum target_reset_mode reset_mode, void *priv)
+{
+	struct uCOS_III_params *params = target->rtos->rtos_specific_params;
+
+	params->thread_offsets_updated = false;
+	params->num_threads = 0;
+
+	return ERROR_OK;
+}
+
+static int uCOS_III_create(struct target *target)
+{
+	struct uCOS_III_params *params;
+
+	for (size_t i = 0; i < ARRAY_SIZE(uCOS_III_params_list); i++)
+		if (strcmp(uCOS_III_params_list[i].target_name, target->type->name) == 0) {
+			params = malloc(sizeof(*params) + (UCOS_III_MAX_THREADS * sizeof(*params->threads)));
+			if (params == NULL) {
+				LOG_ERROR("uCOS-III: out of memory");
+				return ERROR_FAIL;
+			}
+
+			memcpy(params, &uCOS_III_params_list[i], sizeof(uCOS_III_params_list[i]));
+			target->rtos->rtos_specific_params = (void *)params;
+
+			target_register_reset_callback(uCOS_III_reset_handler, NULL);
+
+			return ERROR_OK;
+		}
+
+	LOG_ERROR("uCOS-III: target not supported: %s", target->type->name);
+	return ERROR_FAIL;
+}
+
+static int uCOS_III_update_threads(struct rtos *rtos)
+{
+	struct uCOS_III_params *params = rtos->rtos_specific_params;
+	int retval;
+
+	/* free previous thread details */
+	rtos_free_threadlist(rtos);
+
+	/* verify RTOS is running */
+	uint8_t rtos_running;
+
+	retval = target_read_u8(rtos->target,
+			rtos->symbols[uCOS_III_VAL_OSRunning].address,
+			&rtos_running);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to read RTOS running");
+		return retval;
+	}
+
+	if (rtos_running != 1 && rtos_running != 0) {
+		LOG_ERROR("uCOS-III: invalid RTOS running value");
+		return ERROR_FAIL;
+	}
+
+	if (!rtos_running) {
+		rtos->thread_details = calloc(1, sizeof(struct thread_detail));
+		if (rtos->thread_details == NULL) {
+			LOG_ERROR("uCOS-III: out of memory");
+			return ERROR_FAIL;
+		}
+
+		rtos->thread_count = 1;
+		rtos->thread_details->threadid = 0;
+		rtos->thread_details->exists = true;
+		rtos->current_thread = 0;
+
+		return ERROR_OK;
+	}
+
+	/* update thread offsets */
+	retval = uCOS_III_update_thread_offsets(rtos);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to update thread offsets");
+		return retval;
+	}
+
+	/* read current thread address */
+	symbol_address_t current_thread_address = 0;
+
+	retval = target_read_memory(rtos->target,
+			rtos->symbols[uCOS_III_VAL_OSTCBCurPtr].address,
+			params->pointer_width,
+			1,
+			(void *)&current_thread_address);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to read current thread address");
+		return retval;
+	}
+
+	/* read number of tasks */
+	retval = target_read_u16(rtos->target,
+			rtos->symbols[uCOS_III_VAL_OSTaskQty].address,
+			(void *)&rtos->thread_count);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to read thread count");
+		return retval;
+	}
+
+	rtos->thread_details = calloc(rtos->thread_count, sizeof(struct thread_detail));
+	if (rtos->thread_details == NULL) {
+		LOG_ERROR("uCOS-III: out of memory");
+		return ERROR_FAIL;
+	}
+
+	/*
+	 * uC/OS-III adds tasks in LIFO order; advance to the end of the
+	 * list and work backwards to preserve the intended order.
+	 */
+	symbol_address_t thread_address = 0;
+
+	retval = uCOS_III_find_last_thread_address(rtos, &thread_address);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to find last thread address");
+		return retval;
+	}
+
+	for (int i = 0; i < rtos->thread_count; i++) {
+		struct thread_detail *thread_detail = &rtos->thread_details[i];
+		char thread_str_buffer[UCOS_III_MAX_STRLEN + 1];
+
+		/* find or create new threadid */
+		retval = uCOS_III_find_or_create_thread(rtos, thread_address, &thread_detail->threadid);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to find or create thread");
+			return retval;
+		}
+
+		if (thread_address == current_thread_address)
+			rtos->current_thread = thread_detail->threadid;
+
+		thread_detail->exists = true;
+
+		/* read thread name */
+		symbol_address_t thread_name_address = 0;
+
+		retval = target_read_memory(rtos->target,
+				thread_address + params->thread_name_offset,
+				params->pointer_width,
+				1,
+				(void *)&thread_name_address);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to name address");
+			return retval;
+		}
+
+		retval = target_read_buffer(rtos->target,
+				thread_name_address,
+				sizeof(thread_str_buffer),
+				(void *)thread_str_buffer);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to read thread name");
+			return retval;
+		}
+
+		thread_str_buffer[sizeof(thread_str_buffer) - 1] = '\0';
+		thread_detail->thread_name_str = strdup(thread_str_buffer);
+
+		/* read thread extra info */
+		uint8_t thread_state;
+		uint8_t thread_priority;
+
+		retval = target_read_u8(rtos->target,
+				thread_address + params->thread_state_offset,
+				&thread_state);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to read thread state");
+			return retval;
+		}
+
+		retval = target_read_u8(rtos->target,
+				thread_address + params->thread_priority_offset,
+				&thread_priority);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to read thread priority");
+			return retval;
+		}
+
+		const char *thread_state_str;
+
+		if (thread_state < ARRAY_SIZE(uCOS_III_thread_state_list))
+			thread_state_str = uCOS_III_thread_state_list[thread_state];
+		else
+			thread_state_str = "Unknown";
+
+		snprintf(thread_str_buffer, sizeof(thread_str_buffer), "State: %s, Priority: %d",
+				thread_state_str, thread_priority);
+		thread_detail->extra_info_str = strdup(thread_str_buffer);
+
+		/* read previous thread address */
+		retval = target_read_memory(rtos->target,
+				thread_address + params->thread_prev_offset,
+				params->pointer_width,
+				1,
+				(void *)&thread_address);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("uCOS-III: failed to read previous thread address");
+			return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int uCOS_III_get_thread_reg_list(struct rtos *rtos, threadid_t threadid, char **hex_reg_list)
+{
+	struct uCOS_III_params *params = rtos->rtos_specific_params;
+	int retval;
+
+	/* find thread address for threadid */
+	symbol_address_t thread_address = 0;
+
+	retval = uCOS_III_find_thread_address(rtos, threadid, &thread_address);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to find thread address");
+		return retval;
+	}
+
+	/* read thread stack address */
+	symbol_address_t stack_address = 0;
+
+	retval = target_read_memory(rtos->target,
+			thread_address + params->thread_stack_offset,
+			params->pointer_width,
+			1,
+			(void *)&stack_address);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("uCOS-III: failed to read stack address");
+		return retval;
+	}
+
+	return rtos_generic_stack_read(rtos->target,
+			params->stacking_info,
+			stack_address,
+			hex_reg_list);
+}
+
+static int uCOS_III_get_symbol_list_to_lookup(symbol_table_elem_t *symbol_list[])
+{
+	*symbol_list = calloc(ARRAY_SIZE(uCOS_III_symbol_list), sizeof(symbol_table_elem_t));
+	if (*symbol_list == NULL) {
+		LOG_ERROR("uCOS-III: out of memory");
+		return ERROR_FAIL;
+	}
+
+	for (size_t i = 0; i < ARRAY_SIZE(uCOS_III_symbol_list); i++)
+		(*symbol_list)[i].symbol_name = uCOS_III_symbol_list[i];
+
+	return ERROR_OK;
+}
+
+const struct rtos_type uCOS_III_rtos = {
+	.name = "uCOS-III",
+	.detect_rtos = uCOS_III_detect_rtos,
+	.create = uCOS_III_create,
+	.update_threads = uCOS_III_update_threads,
+	.get_thread_reg_list = uCOS_III_get_thread_reg_list,
+	.get_symbol_list_to_lookup = uCOS_III_get_symbol_list_to_lookup,
+};
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
index 04d3035f..804efac1 100644
--- a/src/server/Makefile.am
+++ b/src/server/Makefile.am
@@ -1,23 +1,19 @@
-include $(top_srcdir)/common.mk
+noinst_LTLIBRARIES += %D%/libserver.la
+%C%_libserver_la_SOURCES = \
+	%D%/server.c \
+	%D%/telnet_server.c \
+	%D%/gdb_server.c \
+	%D%/server.h \
+	%D%/telnet_server.h \
+	%D%/gdb_server.h \
+	%D%/server_stubs.c \
+	%D%/tcl_server.c \
+	%D%/tcl_server.h
 
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libserver.la
-noinst_HEADERS = server.h telnet_server.h gdb_server.h
-libserver_la_SOURCES = server.c telnet_server.c gdb_server.c
-
-libserver_la_SOURCES += server_stubs.c
-
-libserver_la_CFLAGS =
+%C%_libserver_la_CFLAGS = $(AM_CFLAGS)
 if IS_MINGW
 # FD_* macros are sloppy with their signs on MinGW32 platform
-libserver_la_CFLAGS += -Wno-sign-compare
+%C%_libserver_la_CFLAGS += -Wno-sign-compare
 endif
 
-# tcl server addons
-noinst_HEADERS += tcl_server.h
-libserver_la_SOURCES += tcl_server.c
-
-EXTRA_DIST = \
-	startup.tcl
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+STARTUP_TCL_SRCS += %D%/startup.tcl
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 02bd62ee..e3b10cd4 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -31,9 +31,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -92,6 +90,8 @@ struct gdb_connection {
 	bool attached;
 	/* temporarily used for target description support */
 	struct target_desc_format target_desc;
+	/* temporarily used for thread list support */
+	char *thread_list;
 };
 
 #if 0
@@ -706,7 +706,8 @@ static int gdb_output_con(struct connection *connection, const char *line)
 		return ERROR_GDB_BUFFER_TOO_SMALL;
 
 	hex_buffer[0] = 'O';
-	int pkt_len = hexify(hex_buffer + 1, line, bin_size, bin_size * 2 + 1);
+	size_t pkt_len = hexify(hex_buffer + 1, (const uint8_t *)line, bin_size,
+		bin_size * 2 + 1);
 	int retval = gdb_put_packet(connection, hex_buffer, pkt_len + 1);
 
 	free(hex_buffer);
@@ -743,22 +744,22 @@ static void gdb_signal_reply(struct target *target, struct connection *connectio
 		stop_reason[0] = '\0';
 		if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 			enum watchpoint_rw hit_wp_type;
-			uint32_t hit_wp_address;
+			target_addr_t hit_wp_address;
 
 			if (watchpoint_hit(target, &hit_wp_type, &hit_wp_address) == ERROR_OK) {
 
 				switch (hit_wp_type) {
 					case WPT_WRITE:
 						snprintf(stop_reason, sizeof(stop_reason),
-								"watch:%08" PRIx32 ";", hit_wp_address);
+								"watch:%08" TARGET_PRIxADDR ";", hit_wp_address);
 						break;
 					case WPT_READ:
 						snprintf(stop_reason, sizeof(stop_reason),
-								"rwatch:%08" PRIx32 ";", hit_wp_address);
+								"rwatch:%08" TARGET_PRIxADDR ";", hit_wp_address);
 						break;
 					case WPT_ACCESS:
 						snprintf(stop_reason, sizeof(stop_reason),
-								"awatch:%08" PRIx32 ";", hit_wp_address);
+								"awatch:%08" TARGET_PRIxADDR ";", hit_wp_address);
 						break;
 					default:
 						break;
@@ -945,6 +946,7 @@ static int gdb_new_connection(struct connection *connection)
 	gdb_connection->attached = true;
 	gdb_connection->target_desc.tdesc = NULL;
 	gdb_connection->target_desc.tdesc_length = 0;
+	gdb_connection->thread_list = NULL;
 
 	/* send ACK to GDB for debug request */
 	gdb_write(connection, "+", 1);
@@ -1362,7 +1364,7 @@ static int gdb_read_memory_packet(struct connection *connection,
 {
 	struct target *target = get_target_from_connection(connection);
 	char *separator;
-	uint32_t addr = 0;
+	uint64_t addr = 0;
 	uint32_t len = 0;
 
 	uint8_t *buffer;
@@ -1373,7 +1375,7 @@ static int gdb_read_memory_packet(struct connection *connection,
 	/* skip command character */
 	packet++;
 
-	addr = strtoul(packet, &separator, 16);
+	addr = strtoull(packet, &separator, 16);
 
 	if (*separator != ',') {
 		LOG_ERROR("incomplete read memory packet received, dropping connection");
@@ -1390,7 +1392,7 @@ static int gdb_read_memory_packet(struct connection *connection,
 
 	buffer = malloc(len);
 
-	LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+	LOG_DEBUG("addr: 0x%16.16" PRIx64 ", len: 0x%8.8" PRIx32 "", addr, len);
 
 	retval = target_read_buffer(target, addr, len, buffer);
 
@@ -1415,7 +1417,7 @@ static int gdb_read_memory_packet(struct connection *connection,
 	if (retval == ERROR_OK) {
 		hex_buffer = malloc(len * 2 + 1);
 
-		int pkt_len = hexify(hex_buffer, (char *)buffer, len, len * 2 + 1);
+		size_t pkt_len = hexify(hex_buffer, buffer, len, len * 2 + 1);
 
 		gdb_put_packet(connection, hex_buffer, pkt_len);
 
@@ -1433,7 +1435,7 @@ static int gdb_write_memory_packet(struct connection *connection,
 {
 	struct target *target = get_target_from_connection(connection);
 	char *separator;
-	uint32_t addr = 0;
+	uint64_t addr = 0;
 	uint32_t len = 0;
 
 	uint8_t *buffer;
@@ -1442,7 +1444,7 @@ static int gdb_write_memory_packet(struct connection *connection,
 	/* skip command character */
 	packet++;
 
-	addr = strtoul(packet, &separator, 16);
+	addr = strtoull(packet, &separator, 16);
 
 	if (*separator != ',') {
 		LOG_ERROR("incomplete write memory packet received, dropping connection");
@@ -1458,9 +1460,9 @@ static int gdb_write_memory_packet(struct connection *connection,
 
 	buffer = malloc(len);
 
-	LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+	LOG_DEBUG("addr: 0x%" PRIx64 ", len: 0x%8.8" PRIx32 "", addr, len);
 
-	if (unhexify((char *)buffer, separator, len) != (int)len)
+	if (unhexify(buffer, separator, len) != len)
 		LOG_ERROR("unable to decode memory packet");
 
 	retval = target_write_buffer(target, addr, len, buffer);
@@ -1480,15 +1482,19 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 {
 	struct target *target = get_target_from_connection(connection);
 	char *separator;
-	uint32_t addr = 0;
+	uint64_t addr = 0;
 	uint32_t len = 0;
 
 	int retval = ERROR_OK;
+	/* Packets larger than fast_limit bytes will be acknowledged instantly on
+	 * the assumption that we're in a download and it's important to go as fast
+	 * as possible. */
+	uint32_t fast_limit = 8;
 
 	/* skip command character */
 	packet++;
 
-	addr = strtoul(packet, &separator, 16);
+	addr = strtoull(packet, &separator, 16);
 
 	if (*separator != ',') {
 		LOG_ERROR("incomplete write memory binary packet received, dropping connection");
@@ -1504,31 +1510,44 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 
 	struct gdb_connection *gdb_connection = connection->priv;
 
-	if (gdb_connection->mem_write_error) {
+	if (gdb_connection->mem_write_error)
 		retval = ERROR_FAIL;
-		/* now that we have reported the memory write error, we can clear the condition */
-		gdb_connection->mem_write_error = false;
-	}
 
-	/* By replying the packet *immediately* GDB will send us a new packet
-	 * while we write the last one to the target.
-	 */
-	if (retval == ERROR_OK)
-		gdb_put_packet(connection, "OK", 2);
-	else {
+	if (retval == ERROR_OK) {
+		if (len >= fast_limit) {
+			/* By replying the packet *immediately* GDB will send us a new packet
+			 * while we write the last one to the target.
+			 * We only do this for larger writes, so that users who do something like:
+			 * p *((int*)0xdeadbeef)=8675309
+			 * will get immediate feedback that that write failed.
+			 */
+			gdb_put_packet(connection, "OK", 2);
+		}
+	} else {
 		retval = gdb_error(connection, retval);
+		/* now that we have reported the memory write error, we can clear the condition */
+		gdb_connection->mem_write_error = false;
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
 	if (len) {
-		LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+		LOG_DEBUG("addr: 0x%" PRIx64 ", len: 0x%8.8" PRIx32 "", addr, len);
 
 		retval = target_write_buffer(target, addr, len, (uint8_t *)separator);
 		if (retval != ERROR_OK)
 			gdb_connection->mem_write_error = true;
 	}
 
+	if (len < fast_limit) {
+		if (retval != ERROR_OK) {
+			gdb_error(connection, retval);
+			gdb_connection->mem_write_error = false;
+		} else {
+			gdb_put_packet(connection, "OK", 2);
+		}
+	}
+
 	return ERROR_OK;
 }
 
@@ -1537,13 +1556,13 @@ static int gdb_step_continue_packet(struct connection *connection,
 {
 	struct target *target = get_target_from_connection(connection);
 	int current = 0;
-	uint32_t address = 0x0;
+	uint64_t address = 0x0;
 	int retval = ERROR_OK;
 
 	LOG_DEBUG("-");
 
 	if (packet_size > 1)
-		address = strtoul(packet + 1, NULL, 16);
+		address = strtoull(packet + 1, NULL, 16);
 	else
 		current = 1;
 
@@ -1567,7 +1586,7 @@ static int gdb_breakpoint_watchpoint_packet(struct connection *connection,
 	int type;
 	enum breakpoint_type bp_type = BKPT_SOFT /* dummy init to avoid warning */;
 	enum watchpoint_rw wp_type = WPT_READ /* dummy init to avoid warning */;
-	uint32_t address;
+	uint64_t address;
 	uint32_t size;
 	char *separator;
 	int retval;
@@ -1599,7 +1618,7 @@ static int gdb_breakpoint_watchpoint_packet(struct connection *connection,
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	address = strtoul(separator + 1, &separator, 16);
+	address = strtoull(separator + 1, &separator, 16);
 
 	if (*separator != ',') {
 		LOG_ERROR("incomplete breakpoint/watchpoint packet received, dropping connection");
@@ -2277,6 +2296,95 @@ error:
 	return retval;
 }
 
+static int gdb_generate_thread_list(struct target *target, char **thread_list_out)
+{
+	struct rtos *rtos = target->rtos;
+	int retval = ERROR_OK;
+	char *thread_list = NULL;
+	int pos = 0;
+	int size = 0;
+
+	xml_printf(&retval, &thread_list, &pos, &size,
+		   "<?xml version=\"1.0\"?>\n"
+		   "<threads>\n");
+
+	if (rtos != NULL) {
+		for (int i = 0; i < rtos->thread_count; i++) {
+			struct thread_detail *thread_detail = &rtos->thread_details[i];
+
+			if (!thread_detail->exists)
+				continue;
+
+			xml_printf(&retval, &thread_list, &pos, &size,
+				   "<thread id=\"%" PRIx64 "\">", thread_detail->threadid);
+
+			if (thread_detail->thread_name_str != NULL)
+				xml_printf(&retval, &thread_list, &pos, &size,
+					   "Name: %s", thread_detail->thread_name_str);
+
+			if (thread_detail->extra_info_str != NULL) {
+				if (thread_detail->thread_name_str != NULL)
+					xml_printf(&retval, &thread_list, &pos, &size,
+						   ", ");
+				xml_printf(&retval, &thread_list, &pos, &size,
+					   thread_detail->extra_info_str);
+			}
+
+			xml_printf(&retval, &thread_list, &pos, &size,
+				   "</thread>\n");
+		}
+	}
+
+	xml_printf(&retval, &thread_list, &pos, &size,
+		   "</threads>\n");
+
+	if (retval == ERROR_OK)
+		*thread_list_out = thread_list;
+	else
+		free(thread_list);
+
+	return retval;
+}
+
+static int gdb_get_thread_list_chunk(struct target *target, char **thread_list,
+		char **chunk, int32_t offset, uint32_t length)
+{
+	if (*thread_list == NULL) {
+		int retval = gdb_generate_thread_list(target, thread_list);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Unable to Generate Thread List");
+			return ERROR_FAIL;
+		}
+	}
+
+	size_t thread_list_length = strlen(*thread_list);
+	char transfer_type;
+
+	length = MIN(length, thread_list_length - offset);
+	if (length < (thread_list_length - offset))
+		transfer_type = 'm';
+	else
+		transfer_type = 'l';
+
+	*chunk = malloc(length + 2);
+	if (*chunk == NULL) {
+		LOG_ERROR("Unable to allocate memory");
+		return ERROR_FAIL;
+	}
+
+	(*chunk)[0] = transfer_type;
+	strncpy((*chunk) + 1, (*thread_list) + offset, length);
+	(*chunk)[1 + length] = '\0';
+
+	/* After gdb-server sends out last chunk, invalidate thread list. */
+	if (transfer_type == 'l') {
+		free(*thread_list);
+		*thread_list = NULL;
+	}
+
+	return ERROR_OK;
+}
+
 static int gdb_query_packet(struct connection *connection,
 		char const *packet, int packet_size)
 {
@@ -2288,7 +2396,7 @@ static int gdb_query_packet(struct connection *connection,
 		if (packet_size > 6) {
 			char *cmd;
 			cmd = malloc((packet_size - 6) / 2 + 1);
-			int len = unhexify(cmd, packet + 6, (packet_size - 6) / 2);
+			size_t len = unhexify((uint8_t *)cmd, packet + 6, (packet_size - 6) / 2);
 			cmd[len] = 0;
 
 			/* We want to print all debug output to GDB connection */
@@ -2366,7 +2474,7 @@ static int gdb_query_packet(struct connection *connection,
 			&buffer,
 			&pos,
 			&size,
-			"PacketSize=%x;qXfer:memory-map:read%c;qXfer:features:read%c;QStartNoAckMode+",
+			"PacketSize=%x;qXfer:memory-map:read%c;qXfer:features:read%c;qXfer:threads:read+;QStartNoAckMode+",
 			(GDB_BUFFER_SIZE - 1),
 			((gdb_use_memory_map == 1) && (flash_get_bank_count() > 0)) ? '+' : '-',
 			(gdb_target_desc_supported == 1) ? '+' : '-');
@@ -2412,6 +2520,37 @@ static int gdb_query_packet(struct connection *connection,
 
 		gdb_put_packet(connection, xml, strlen(xml));
 
+		free(xml);
+		return ERROR_OK;
+	} else if (strncmp(packet, "qXfer:threads:read:", 19) == 0) {
+		char *xml = NULL;
+		int retval = ERROR_OK;
+
+		int offset;
+		unsigned int length;
+
+		/* skip command character */
+		packet += 19;
+
+		if (decode_xfer_read(packet, NULL, &offset, &length) < 0) {
+			gdb_send_error(connection, 01);
+			return ERROR_OK;
+		}
+
+		/* Target should prepare correct thread list for annex.
+		 * The first character of returned xml is 'm' or 'l'. 'm' for
+		 * there are *more* chunks to transfer. 'l' for it is the *last*
+		 * chunk of target description.
+		 */
+		retval = gdb_get_thread_list_chunk(target, &gdb_connection->thread_list,
+						   &xml, offset, length);
+		if (retval != ERROR_OK) {
+			gdb_error(connection, retval);
+			return retval;
+		}
+
+		gdb_put_packet(connection, xml, strlen(xml));
+
 		free(xml);
 		return ERROR_OK;
 	} else if (strncmp(packet, "QStartNoAckMode", 15) == 0) {
@@ -2933,6 +3072,11 @@ static int gdb_target_start(struct target *target, const char *port)
 
 static int gdb_target_add_one(struct target *target)
 {
+	if (strcmp(gdb_port, "disabled") == 0) {
+		LOG_INFO("gdb port disabled");
+		return ERROR_OK;
+	}
+
 	/*  one gdb instance per smp list */
 	if ((target->smp) && (target->gdb_service))
 		return ERROR_OK;
@@ -2956,6 +3100,11 @@ static int gdb_target_add_one(struct target *target)
 
 int gdb_target_add_all(struct target *target)
 {
+	if (strcmp(gdb_port, "disabled") == 0) {
+		LOG_INFO("gdb server disabled");
+		return ERROR_OK;
+	}
+
 	if (NULL == target) {
 		LOG_WARNING("gdb services need one or more targets defined");
 		return ERROR_OK;
@@ -3073,7 +3222,7 @@ COMMAND_HANDLER(handle_gdb_save_tdesc_command)
 
 	tdesc_length = strlen(tdesc);
 
-	struct fileio fileio;
+	struct fileio *fileio;
 	size_t size_written;
 
 	char *tdesc_filename = alloc_printf("%s.xml", target_type_name(target));
@@ -3089,9 +3238,9 @@ COMMAND_HANDLER(handle_gdb_save_tdesc_command)
 		goto out;
 	}
 
-	retval = fileio_write(&fileio, tdesc_length, tdesc, &size_written);
+	retval = fileio_write(fileio, tdesc_length, tdesc, &size_written);
 
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	if (retval != ERROR_OK)
 		LOG_ERROR("Error while writing the tdesc file");
@@ -3121,7 +3270,7 @@ static const struct command_registration gdb_command_handlers[] = {
 			"server listens for the next port number after the "
 			"base port number specified. "
 			"No arguments reports GDB port. \"pipe\" means listen to stdin "
-			"output to stdout, an integer is base port number, \"disable\" disables "
+			"output to stdout, an integer is base port number, \"disabled\" disables "
 			"port. Any other string is are interpreted as named pipe to listen to. "
 			"Output pipe is the same name as input pipe, but with 'o' appended.",
 		.usage = "[port_num]",
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index 8092d7b6..2b4ac4ea 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -22,13 +22,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef GDB_SERVER_H
-#define GDB_SERVER_H
+#ifndef OPENOCD_SERVER_GDB_SERVER_H
+#define OPENOCD_SERVER_GDB_SERVER_H
 
 struct image;
 struct reg;
@@ -50,4 +48,4 @@ static inline struct target *get_target_from_connection(struct connection *conne
 #define ERROR_GDB_BUFFER_TOO_SMALL (-800)
 #define ERROR_GDB_TIMEOUT (-801)
 
-#endif	/* GDB_SERVER_H */
+#endif /* OPENOCD_SERVER_GDB_SERVER_H */
diff --git a/src/server/server.c b/src/server/server.c
index bfb8e9be..f39d1109 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -38,6 +36,10 @@
 
 #include <signal.h>
 
+#ifdef HAVE_NETDB_H
+#include <netdb.h>
+#endif
+
 #ifndef _WIN32
 #include <netinet/tcp.h>
 #endif
@@ -54,6 +56,9 @@ static int last_signal;
 /* set the polling period to 100ms */
 static int polling_period = 100;
 
+/* address by name on which to listen for incoming TCP/IP connections */
+static char *bindto_name;
+
 static int add_connection(struct service *service, struct command_context *cmd_ctx)
 {
 	socklen_t address_size;
@@ -127,7 +132,9 @@ static int add_connection(struct service *service, struct command_context *cmd_c
 		free(out_file);
 		if (c->fd_out == -1) {
 			LOG_ERROR("could not open %s", service->port);
-			exit(1);
+			command_done(c->cmd_ctx);
+			free(c);
+			return ERROR_FAIL;
 		}
 
 		LOG_INFO("accepting '%s' connection from pipe %s", service->name, service->port);
@@ -186,7 +193,13 @@ static int remove_connection(struct service *service, struct connection *connect
 	return ERROR_OK;
 }
 
-/* FIX! make service return error instead of invoking exit() */
+static void free_service(struct service *c)
+{
+	free(c->name);
+	free(c->port);
+	free(c);
+}
+
 int add_service(char *name,
 	const char *port,
 	int max_connections,
@@ -196,6 +209,7 @@ int add_service(char *name,
 	void *priv)
 {
 	struct service *c, **p;
+	struct hostent *hp;
 	int so_reuseaddr_option = 1;
 
 	c = malloc(sizeof(struct service));
@@ -229,7 +243,8 @@ int add_service(char *name,
 		c->fd = socket(AF_INET, SOCK_STREAM, 0);
 		if (c->fd == -1) {
 			LOG_ERROR("error creating socket: %s", strerror(errno));
-			exit(-1);
+			free_service(c);
+			return ERROR_FAIL;
 		}
 
 		setsockopt(c->fd,
@@ -242,12 +257,26 @@ int add_service(char *name,
 
 		memset(&c->sin, 0, sizeof(c->sin));
 		c->sin.sin_family = AF_INET;
-		c->sin.sin_addr.s_addr = INADDR_ANY;
+
+		if (bindto_name == NULL)
+			c->sin.sin_addr.s_addr = INADDR_ANY;
+		else {
+			hp = gethostbyname(bindto_name);
+			if (hp == NULL) {
+				LOG_ERROR("couldn't resolve bindto address: %s", bindto_name);
+				close_socket(c->fd);
+				free_service(c);
+				return ERROR_FAIL;
+			}
+			memcpy(&c->sin.sin_addr, hp->h_addr_list[0], hp->h_length);
+		}
 		c->sin.sin_port = htons(c->portnumber);
 
 		if (bind(c->fd, (struct sockaddr *)&c->sin, sizeof(c->sin)) == -1) {
-			LOG_ERROR("couldn't bind to socket: %s", strerror(errno));
-			exit(-1);
+			LOG_ERROR("couldn't bind %s to socket on port %d: %s", name, c->portnumber, strerror(errno));
+			close_socket(c->fd);
+			free_service(c);
+			return ERROR_FAIL;
 		}
 
 #ifndef _WIN32
@@ -265,7 +294,9 @@ int add_service(char *name,
 
 		if (listen(c->fd, 1) == -1) {
 			LOG_ERROR("couldn't listen on socket: %s", strerror(errno));
-			exit(-1);
+			close_socket(c->fd);
+			free_service(c);
+			return ERROR_FAIL;
 		}
 	} else if (c->type == CONNECTION_STDINOUT) {
 		c->fd = fileno(stdin);
@@ -286,13 +317,15 @@ int add_service(char *name,
 		/* we currenty do not support named pipes under win32
 		 * so exit openocd for now */
 		LOG_ERROR("Named pipes currently not supported under this os");
-		exit(1);
+		free_service(c);
+		return ERROR_FAIL;
 #else
 		/* Pipe we're reading from */
 		c->fd = open(c->port, O_RDONLY | O_NONBLOCK);
 		if (c->fd == -1) {
 			LOG_ERROR("could not open %s", c->port);
-			exit(1);
+			free_service(c);
+			return ERROR_FAIL;
 		}
 #endif
 	}
@@ -409,7 +442,7 @@ int server_loop(struct command_context *command_context)
 				FD_ZERO(&read_fds);
 			else {
 				LOG_ERROR("error during select: %s", strerror(errno));
-				exit(-1);
+				return ERROR_FAIL;
 			}
 #else
 
@@ -417,7 +450,7 @@ int server_loop(struct command_context *command_context)
 				FD_ZERO(&read_fds);
 			else {
 				LOG_ERROR("error during select: %s", strerror(errno));
-				exit(-1);
+				return ERROR_FAIL;
 			}
 #endif
 		}
@@ -536,7 +569,7 @@ int server_preinit(void)
 
 	if (WSAStartup(wVersionRequested, &wsaData) != 0) {
 		LOG_ERROR("Failed to Open Winsock");
-		exit(-1);
+		return ERROR_FAIL;
 	}
 
 	/* register ctrl-c handler */
@@ -554,10 +587,18 @@ int server_preinit(void)
 int server_init(struct command_context *cmd_ctx)
 {
 	int ret = tcl_init();
-	if (ERROR_OK != ret)
+
+	if (ret != ERROR_OK)
 		return ret;
 
-	return telnet_init("Open On-Chip Debugger");
+	ret = telnet_init("Open On-Chip Debugger");
+
+	if (ret != ERROR_OK) {
+		remove_services();
+		return ret;
+	}
+
+	return ERROR_OK;
 }
 
 int server_quit(void)
@@ -634,6 +675,22 @@ COMMAND_HANDLER(handle_poll_period_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_bindto_command)
+{
+	switch (CMD_ARGC) {
+		case 0:
+			command_print(CMD_CTX, "bindto name: %s", bindto_name);
+			break;
+		case 1:
+			free(bindto_name);
+			bindto_name = strdup(CMD_ARGV[0]);
+			break;
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	return ERROR_OK;
+}
+
 static const struct command_registration server_command_handlers[] = {
 	{
 		.name = "shutdown",
@@ -649,6 +706,14 @@ static const struct command_registration server_command_handlers[] = {
 		.usage = "",
 		.help = "set the servers polling period",
 	},
+	{
+		.name = "bindto",
+		.handler = &handle_bindto_command,
+		.mode = COMMAND_ANY,
+		.usage = "[name]",
+		.help = "Specify address by name on which to listen for "
+		    "incoming TCP/IP connections",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/server/server.h b/src/server/server.h
index 06152334..68ad16d5 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef SERVER_H
-#define SERVER_H
+#ifndef OPENOCD_SERVER_SERVER_H
+#define OPENOCD_SERVER_SERVER_H
 
 #include <helper/log.h>
 
@@ -111,4 +109,4 @@ COMMAND_HELPER(server_port_command, unsigned short *out);
 #define ERROR_SERVER_REMOTE_CLOSED		(-400)
 #define ERROR_CONNECTION_REJECTED		(-401)
 
-#endif	/* SERVER_H */
+#endif /* OPENOCD_SERVER_SERVER_H */
diff --git a/src/server/server_stubs.c b/src/server/server_stubs.c
index 4584f319..a4c01728 100644
--- a/src/server/server_stubs.c
+++ b/src/server/server_stubs.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/server/tcl_server.c b/src/server/tcl_server.c
index 789eee8b..0077339f 100644
--- a/src/server/tcl_server.c
+++ b/src/server/tcl_server.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -107,7 +105,7 @@ static int tcl_target_callback_trace_handler(struct target *target,
 	if (tclc->tc_trace) {
 		hex = malloc(hex_len);
 		buf = malloc(max_len);
-		hexify(hex, (const char *)data, len, hex_len);
+		hexify(hex, data, len, hex_len);
 		snprintf(buf, max_len, "%s%s%s", header, hex, trailer);
 		tcl_output(connection, buf, strlen(buf));
 		free(hex);
diff --git a/src/server/tcl_server.h b/src/server/tcl_server.h
index 971ab996..422c794e 100644
--- a/src/server/tcl_server.h
+++ b/src/server/tcl_server.h
@@ -12,17 +12,15 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _TCL_SERVER_H_
-#define _TCL_SERVER_H_
+#ifndef OPENOCD_SERVER_TCL_SERVER_H
+#define OPENOCD_SERVER_TCL_SERVER_H
 
 #include <server/server.h>
 
 int tcl_init(void);
 int tcl_register_commands(struct command_context *cmd_ctx);
 
-#endif	/* _TCL_SERVER_H_ */
+#endif /* OPENOCD_SERVER_TCL_SERVER_H */
diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
index 2187dbe2..7507afea 100644
--- a/src/server/telnet_server.c
+++ b/src/server/telnet_server.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -207,17 +205,23 @@ static void telnet_save_history(struct telnet_connection *t_con)
 
 static int telnet_new_connection(struct connection *connection)
 {
-	struct telnet_connection *telnet_connection = malloc(sizeof(struct telnet_connection));
+	struct telnet_connection *telnet_connection;
 	struct telnet_service *telnet_service = connection->service->priv;
 	int i;
 
+	telnet_connection = malloc(sizeof(struct telnet_connection));
+
+	if (!telnet_connection) {
+		LOG_ERROR("Failed to allocate telnet connection.");
+		return ERROR_FAIL;
+	}
+
 	connection->priv = telnet_connection;
 
 	/* initialize telnet connection information */
 	telnet_connection->closed = 0;
 	telnet_connection->line_size = 0;
 	telnet_connection->line_cursor = 0;
-	telnet_connection->option_size = 0;
 	telnet_connection->prompt = strdup("> ");
 	telnet_connection->state = TELNET_STATE_DATA;
 
@@ -568,7 +572,7 @@ static int telnet_input(struct connection *connection)
 				break;
 			default:
 				LOG_ERROR("unknown telnet state");
-				exit(-1);
+				return ERROR_FAIL;
 		}
 
 		bytes_read--;
@@ -619,17 +623,26 @@ int telnet_init(char *banner)
 		return ERROR_OK;
 	}
 
-	struct telnet_service *telnet_service = malloc(sizeof(struct telnet_service));
+	struct telnet_service *telnet_service =
+		malloc(sizeof(struct telnet_service));
+
+	if (!telnet_service) {
+		LOG_ERROR("Failed to allocate telnet service.");
+		return ERROR_FAIL;
+	}
 
 	telnet_service->banner = banner;
 
-	return add_service("telnet",
-		telnet_port,
-		CONNECTION_LIMIT_UNLIMITED,
-		telnet_new_connection,
-		telnet_input,
-		telnet_connection_closed,
+	int ret = add_service("telnet", telnet_port, CONNECTION_LIMIT_UNLIMITED,
+		telnet_new_connection, telnet_input, telnet_connection_closed,
 		telnet_service);
+
+	if (ret != ERROR_OK) {
+		free(telnet_service);
+		return ret;
+	}
+
+	return ERROR_OK;
 }
 
 /* daemon configuration command telnet_port */
diff --git a/src/server/telnet_server.h b/src/server/telnet_server.h
index 94da3d1b..f8fb8268 100644
--- a/src/server/telnet_server.h
+++ b/src/server/telnet_server.h
@@ -19,21 +19,18 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef TELNET_SERVER_H
-#define TELNET_SERVER_H
+#ifndef OPENOCD_SERVER_TELNET_SERVER_H
+#define OPENOCD_SERVER_TELNET_SERVER_H
 
 #include <server/server.h>
 
-#define TELNET_BUFFER_SIZE (1024)
+#define TELNET_BUFFER_SIZE (10*1024)
 
-#define TELNET_OPTION_MAX_SIZE (128)
 #define TELNET_LINE_HISTORY_SIZE (128)
-#define TELNET_LINE_MAX_SIZE (256)
+#define TELNET_LINE_MAX_SIZE (10*256)
 
 enum telnet_states {
 	TELNET_STATE_DATA,
@@ -53,8 +50,6 @@ struct telnet_connection {
 	char line[TELNET_LINE_MAX_SIZE];
 	int line_size;
 	int line_cursor;
-	char option[TELNET_OPTION_MAX_SIZE];
-	int option_size;
 	char last_escape;
 	char *history[TELNET_LINE_HISTORY_SIZE];
 	int next_history;
@@ -69,4 +64,4 @@ struct telnet_service {
 int telnet_init(char *banner);
 int telnet_register_commands(struct command_context *command_context);
 
-#endif	/* TELNET_SERVER_H */
+#endif /* OPENOCD_SERVER_TELNET_SERVER_H */
diff --git a/src/svf/Makefile.am b/src/svf/Makefile.am
index 3a14d208..5603d53b 100644
--- a/src/svf/Makefile.am
+++ b/src/svf/Makefile.am
@@ -1,8 +1,2 @@
-include $(top_srcdir)/common.mk
-
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libsvf.la
-noinst_HEADERS = svf.h
-libsvf_la_SOURCES = svf.c
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+noinst_LTLIBRARIES += %D%/libsvf.la
+%C%_libsvf_la_SOURCES = %D%/svf.c %D%/svf.h
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 7b7b8d09..1d686ba6 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* The specification for SVF is available here:
@@ -363,7 +361,7 @@ COMMAND_HANDLER(handle_svf_command)
 #define SVF_MAX_NUM_OF_OPTIONS 5
 	int command_num = 0;
 	int ret = ERROR_OK;
-	long long time_measure_ms;
+	int64_t time_measure_ms;
 	int time_measure_s, time_measure_m;
 
 	/* use NULL to indicate a "plain" svf file which accounts for
@@ -537,7 +535,7 @@ COMMAND_HANDLER(handle_svf_command)
 	time_measure_s %= 60;
 	if (time_measure_ms < 1000)
 		command_print(CMD_CTX,
-			"\r\nTime used: %dm%ds%lldms ",
+			"\r\nTime used: %dm%ds%" PRId64 "ms ",
 			time_measure_m,
 			time_measure_s,
 			time_measure_ms);
@@ -663,11 +661,13 @@ static int svf_read_command_from_file(FILE *fd)
 				if (svf_getline(&svf_read_line, &svf_read_line_size, svf_fd) <= 0)
 					return ERROR_FAIL;
 				i = -1;
+				/* fallthrough */
 			case '\r':
 				slash = 0;
 				/* Don't save '\r' and '\n' if no data is parsed */
 				if (!cmd_pos)
 					break;
+				/* fallthrough */
 			default:
 				/* The parsing code currently expects a space
 				 * before parentheses -- "TDI (123)".  Also a
diff --git a/src/svf/svf.h b/src/svf/svf.h
index 4f2ac0a9..4101a3f8 100644
--- a/src/svf/svf.h
+++ b/src/svf/svf.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef SVF_H
-#define SVF_H
+#ifndef OPENOCD_SVF_SVF_H
+#define OPENOCD_SVF_SVF_H
 
 #include <jtag/jtag.h>
 
@@ -46,4 +44,4 @@ int svf_add_statemove(tap_state_t goal_state);
  */
 bool svf_tap_state_is_stable(tap_state_t state);
 
-#endif	/* SVF_H */
+#endif /* OPENOCD_SVF_SVF_H */
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 9f47b1fd..597070c4 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -1,31 +1,15 @@
-include $(top_srcdir)/common.mk
-
 if OOCD_TRACE
-OOCD_TRACE_FILES = oocd_trace.c
+OOCD_TRACE_FILES = %D%/oocd_trace.c
 else
 OOCD_TRACE_FILES =
 endif
 
-SUBDIRS = openrisc
-libtarget_la_LIBADD = $(top_builddir)/src/target/openrisc/libopenrisc.la
-
-BIN2C		= $(top_srcdir)/src/helper/bin2char.sh
-
-DEBUG_HANDLER	= $(srcdir)/xscale/debug_handler.bin
-EXTRA_DIST = \
-	startup.tcl \
-	$(wildcard $(srcdir)/xscale/*)
+%C%_libtarget_la_LIBADD = %D%/openrisc/libopenrisc.la
 
-DEBUG_HEADER	= xscale_debug.inc
-BUILT_SOURCES = $(DEBUG_HEADER)
-CLEANFILES = $(DEBUG_HEADER)
+STARTUP_TCL_SRCS += %D%/startup.tcl
 
-$(DEBUG_HEADER): $(DEBUG_HANDLER) $(BIN2C)
-	$(BIN2C) < $< > $@ || { rm -f $@; false; }
-
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libtarget.la
-libtarget_la_SOURCES = \
+noinst_LTLIBRARIES += %D%/libtarget.la
+%C%_libtarget_la_SOURCES = \
 	$(TARGET_CORE_SRC) \
 	$(ARM_DEBUG_SRC) \
 	$(ARMV4_5_SRC) \
@@ -36,176 +20,193 @@ libtarget_la_SOURCES = \
 	$(MIPS32_SRC) \
 	$(NDS32_SRC) \
 	$(INTEL_IA32_SRC) \
-	avrt.c \
-	dsp563xx.c \
-	dsp563xx_once.c \
-	dsp5680xx.c \
-	hla_target.c
+	%D%/avrt.c \
+	%D%/dsp563xx.c \
+	%D%/dsp563xx_once.c \
+	%D%/dsp5680xx.c \
+	%D%/hla_target.c
+
+if TARGET64
+%C%_libtarget_la_SOURCES +=$(ARMV8_SRC)
+endif
 
 TARGET_CORE_SRC = \
-	algorithm.c \
-	register.c \
-	image.c \
-	breakpoints.c \
-	target.c \
-	target_request.c \
-	testee.c \
-	smp.c
+	%D%/algorithm.c \
+	%D%/register.c \
+	%D%/image.c \
+	%D%/breakpoints.c \
+	%D%/target.c \
+	%D%/target_request.c \
+	%D%/testee.c \
+	%D%/smp.c
 
 ARMV4_5_SRC = \
-	armv4_5.c \
-	armv4_5_mmu.c \
-	armv4_5_cache.c \
+	%D%/armv4_5.c \
+	%D%/armv4_5_mmu.c \
+	%D%/armv4_5_cache.c \
 	$(ARM7_9_SRC)
 
 ARM7_9_SRC = \
-	arm7_9_common.c \
-	arm7tdmi.c \
-	arm720t.c \
-	arm9tdmi.c \
-	arm920t.c \
-	arm966e.c \
-	arm946e.c \
-	arm926ejs.c \
-	feroceon.c
+	%D%/arm7_9_common.c \
+	%D%/arm7tdmi.c \
+	%D%/arm720t.c \
+	%D%/arm9tdmi.c \
+	%D%/arm920t.c \
+	%D%/arm966e.c \
+	%D%/arm946e.c \
+	%D%/arm926ejs.c \
+	%D%/feroceon.c
 
 ARM_MISC_SRC = \
-	fa526.c \
-	xscale.c
+	%D%/fa526.c \
+	%D%/xscale.c
 
 ARMV6_SRC = \
-	arm11.c \
-	arm11_dbgtap.c
+	%D%/arm11.c \
+	%D%/arm11_dbgtap.c
 
 ARMV7_SRC = \
-	armv7m.c \
-	armv7m_trace.c \
-	cortex_m.c \
-	armv7a.c \
-	cortex_a.c
+	%D%/armv7m.c \
+	%D%/armv7m_trace.c \
+	%D%/cortex_m.c \
+	%D%/armv7a.c \
+	%D%/cortex_a.c \
+	%D%/ls1_sap.c
+
+ARMV8_SRC = \
+	%D%/armv8_dpm.c \
+	%D%/armv8_opcodes.c \
+	%D%/aarch64.c \
+	%D%/armv8.c \
+	%D%/armv8_cache.c
 
 ARM_DEBUG_SRC = \
-	arm_dpm.c \
-	arm_jtag.c \
-	arm_disassembler.c \
-	arm_simulator.c \
-	arm_semihosting.c \
-	arm_adi_v5.c \
-	armv7a_cache.c \
-	armv7a_cache_l2x.c \
-	adi_v5_jtag.c \
-	adi_v5_swd.c \
-	embeddedice.c \
-	trace.c \
-	etb.c \
-	etm.c \
+	%D%/arm_dpm.c \
+	%D%/arm_jtag.c \
+	%D%/arm_disassembler.c \
+	%D%/arm_simulator.c \
+	%D%/arm_semihosting.c \
+	%D%/arm_adi_v5.c \
+	%D%/armv7a_cache.c \
+	%D%/armv7a_cache_l2x.c \
+	%D%/adi_v5_jtag.c \
+	%D%/adi_v5_swd.c \
+	%D%/embeddedice.c \
+	%D%/trace.c \
+	%D%/etb.c \
+	%D%/etm.c \
 	$(OOCD_TRACE_FILES) \
-	etm_dummy.c
+	%D%/etm_dummy.c \
+	%D%/arm_cti.c
 
 AVR32_SRC = \
-	avr32_ap7k.c \
-	avr32_jtag.c \
-	avr32_mem.c \
-	avr32_regs.c
+	%D%/avr32_ap7k.c \
+	%D%/avr32_jtag.c \
+	%D%/avr32_mem.c \
+	%D%/avr32_regs.c
 
 MIPS32_SRC = \
-	mips32.c \
-	mips_m4k.c \
-	mips32_pracc.c \
-	mips32_dmaacc.c \
-	mips_ejtag.c
+	%D%/mips32.c \
+	%D%/mips_m4k.c \
+	%D%/mips32_pracc.c \
+	%D%/mips32_dmaacc.c \
+	%D%/mips_ejtag.c
 
 NDS32_SRC = \
-	nds32.c \
-	nds32_reg.c \
-	nds32_cmd.c \
-	nds32_disassembler.c \
-	nds32_tlb.c \
-	nds32_v2.c \
-	nds32_v3_common.c \
-	nds32_v3.c \
-	nds32_v3m.c \
-	nds32_aice.c
+	%D%/nds32.c \
+	%D%/nds32_reg.c \
+	%D%/nds32_cmd.c \
+	%D%/nds32_disassembler.c \
+	%D%/nds32_tlb.c \
+	%D%/nds32_v2.c \
+	%D%/nds32_v3_common.c \
+	%D%/nds32_v3.c \
+	%D%/nds32_v3m.c \
+	%D%/nds32_aice.c
 
 INTEL_IA32_SRC = \
-	quark_x10xx.c \
-	lakemont.c \
-	x86_32_common.c
-
-noinst_HEADERS = \
-	algorithm.h \
-	arm.h \
-	arm_dpm.h \
-	arm_jtag.h \
-	arm_adi_v5.h \
-	armv7a_cache.h \
-	armv7a_cache_l2x.h \
-	arm_disassembler.h \
-	arm_opcodes.h \
-	arm_simulator.h \
-	arm_semihosting.h \
-	arm7_9_common.h \
-	arm7tdmi.h \
-	arm720t.h \
-	arm9tdmi.h \
-	arm920t.h \
-	arm926ejs.h \
-	arm966e.h \
-	arm946e.h \
-	arm11.h \
-	arm11_dbgtap.h \
-	armv4_5.h \
-	armv4_5_mmu.h \
-	armv4_5_cache.h \
-	armv7a.h \
-	armv7m.h \
-	armv7m_trace.h \
-	avrt.h \
-	dsp563xx.h \
-	dsp563xx_once.h \
-	dsp5680xx.h \
-	breakpoints.h \
-	cortex_m.h \
-	cortex_a.h \
-	embeddedice.h \
-	etb.h \
-	etm.h \
-	etm_dummy.h \
-	image.h \
-	mips32.h \
-	mips_m4k.h \
-	mips_ejtag.h \
-	mips32_pracc.h \
-	mips32_dmaacc.h \
-	oocd_trace.h \
-	register.h \
-	target.h \
-	target_type.h \
-	trace.h \
-	target_request.h \
-	trace.h \
-	xscale.h \
-	smp.h \
-	avr32_ap7k.h \
-	avr32_jtag.h \
-	avr32_mem.h \
-	avr32_regs.h \
-	nds32.h \
-	nds32_cmd.h \
-	nds32_disassembler.h \
-	nds32_edm.h \
-	nds32_insn.h \
-	nds32_reg.h \
-	nds32_tlb.h \
-	nds32_v2.h \
-	nds32_v3_common.h \
-	nds32_v3.h \
-	nds32_v3m.h \
-	nds32_aice.h \
-	lakemont.h \
-	x86_32_common.h
-
-ocddatadir = $(pkglibdir)
-nobase_dist_ocddata_DATA =
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+	%D%/quark_x10xx.c \
+	%D%/quark_d20xx.c \
+	%D%/lakemont.c \
+	%D%/x86_32_common.c
+
+%C%_libtarget_la_SOURCES += \
+	%D%/algorithm.h \
+	%D%/arm.h \
+	%D%/arm_dpm.h \
+	%D%/arm_jtag.h \
+	%D%/arm_adi_v5.h \
+	%D%/armv7a_cache.h \
+	%D%/armv7a_cache_l2x.h \
+	%D%/arm_disassembler.h \
+	%D%/arm_opcodes.h \
+	%D%/arm_simulator.h \
+	%D%/arm_semihosting.h \
+	%D%/arm7_9_common.h \
+	%D%/arm7tdmi.h \
+	%D%/arm720t.h \
+	%D%/arm9tdmi.h \
+	%D%/arm920t.h \
+	%D%/arm926ejs.h \
+	%D%/arm966e.h \
+	%D%/arm946e.h \
+	%D%/arm11.h \
+	%D%/arm11_dbgtap.h \
+	%D%/armv4_5.h \
+	%D%/armv4_5_mmu.h \
+	%D%/armv4_5_cache.h \
+	%D%/armv7a.h \
+	%D%/armv7m.h \
+	%D%/armv7m_trace.h \
+	%D%/armv8.h \
+	%D%/armv8_dpm.h \
+	%D%/armv8_opcodes.h \
+	%D%/armv8_cache.h \
+	%D%/avrt.h \
+	%D%/dsp563xx.h \
+	%D%/dsp563xx_once.h \
+	%D%/dsp5680xx.h \
+	%D%/breakpoints.h \
+	%D%/cortex_m.h \
+	%D%/cortex_a.h \
+	%D%/aarch64.h \
+	%D%/embeddedice.h \
+	%D%/etb.h \
+	%D%/etm.h \
+	%D%/etm_dummy.h \
+	%D%/image.h \
+	%D%/mips32.h \
+	%D%/mips_m4k.h \
+	%D%/mips_ejtag.h \
+	%D%/mips32_pracc.h \
+	%D%/mips32_dmaacc.h \
+	%D%/oocd_trace.h \
+	%D%/register.h \
+	%D%/target.h \
+	%D%/target_type.h \
+	%D%/trace.h \
+	%D%/target_request.h \
+	%D%/trace.h \
+	%D%/xscale.h \
+	%D%/smp.h \
+	%D%/avr32_ap7k.h \
+	%D%/avr32_jtag.h \
+	%D%/avr32_mem.h \
+	%D%/avr32_regs.h \
+	%D%/nds32.h \
+	%D%/nds32_cmd.h \
+	%D%/nds32_disassembler.h \
+	%D%/nds32_edm.h \
+	%D%/nds32_insn.h \
+	%D%/nds32_reg.h \
+	%D%/nds32_tlb.h \
+	%D%/nds32_v2.h \
+	%D%/nds32_v3_common.h \
+	%D%/nds32_v3.h \
+	%D%/nds32_v3m.h \
+	%D%/nds32_aice.h \
+	%D%/lakemont.h \
+	%D%/x86_32_common.h \
+	%D%/arm_cti.h
+
+include %D%/openrisc/Makefile.am
diff --git a/src/target/aarch64.c b/src/target/aarch64.c
new file mode 100644
index 00000000..5e5d3fc7
--- /dev/null
+++ b/src/target/aarch64.c
@@ -0,0 +1,2452 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by David Ung                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "breakpoints.h"
+#include "aarch64.h"
+#include "register.h"
+#include "target_request.h"
+#include "target_type.h"
+#include "armv8_opcodes.h"
+#include "armv8_cache.h"
+#include <helper/time_support.h>
+
+enum restart_mode {
+	RESTART_LAZY,
+	RESTART_SYNC,
+};
+
+enum halt_mode {
+	HALT_LAZY,
+	HALT_SYNC,
+};
+
+static int aarch64_poll(struct target *target);
+static int aarch64_debug_entry(struct target *target);
+static int aarch64_restore_context(struct target *target, bool bpwp);
+static int aarch64_set_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode);
+static int aarch64_set_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode);
+static int aarch64_set_hybrid_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+static int aarch64_unset_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+static int aarch64_mmu(struct target *target, int *enabled);
+static int aarch64_virt2phys(struct target *target,
+	target_addr_t virt, target_addr_t *phys);
+static int aarch64_read_apb_ap_memory(struct target *target,
+	uint64_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+
+#define foreach_smp_target(pos, head) \
+	for (pos = head; (pos != NULL); pos = pos->next)
+
+static int aarch64_restore_system_control_reg(struct target *target)
+{
+	enum arm_mode target_mode = ARM_MODE_ANY;
+	int retval = ERROR_OK;
+	uint32_t instr;
+
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = target_to_armv8(target);
+
+	if (aarch64->system_control_reg != aarch64->system_control_reg_curr) {
+		aarch64->system_control_reg_curr = aarch64->system_control_reg;
+		/* LOG_INFO("cp15_control_reg: %8.8" PRIx32, cortex_v8->cp15_control_reg); */
+
+		switch (armv8->arm.core_mode) {
+		case ARMV8_64_EL0T:
+			target_mode = ARMV8_64_EL1H;
+			/* fall through */
+		case ARMV8_64_EL1T:
+		case ARMV8_64_EL1H:
+			instr = ARMV8_MSR_GP(SYSTEM_SCTLR_EL1, 0);
+			break;
+		case ARMV8_64_EL2T:
+		case ARMV8_64_EL2H:
+			instr = ARMV8_MSR_GP(SYSTEM_SCTLR_EL2, 0);
+			break;
+		case ARMV8_64_EL3H:
+		case ARMV8_64_EL3T:
+			instr = ARMV8_MSR_GP(SYSTEM_SCTLR_EL3, 0);
+			break;
+
+		case ARM_MODE_SVC:
+		case ARM_MODE_ABT:
+		case ARM_MODE_FIQ:
+		case ARM_MODE_IRQ:
+			instr = ARMV4_5_MCR(15, 0, 0, 1, 0, 0);
+			break;
+
+		default:
+			LOG_INFO("cannot read system control register in this mode");
+			return ERROR_FAIL;
+		}
+
+		if (target_mode != ARM_MODE_ANY)
+			armv8_dpm_modeswitch(&armv8->dpm, target_mode);
+
+		retval = armv8->dpm.instr_write_data_r0(&armv8->dpm, instr, aarch64->system_control_reg);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if (target_mode != ARM_MODE_ANY)
+			armv8_dpm_modeswitch(&armv8->dpm, ARM_MODE_ANY);
+	}
+
+	return retval;
+}
+
+/*  modify system_control_reg in order to enable or disable mmu for :
+ *  - virt2phys address conversion
+ *  - read or write memory in phys or virt address */
+static int aarch64_mmu_modify(struct target *target, int enable)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	int retval = ERROR_OK;
+	uint32_t instr = 0;
+
+	if (enable) {
+		/*	if mmu enabled at target stop and mmu not enable */
+		if (!(aarch64->system_control_reg & 0x1U)) {
+			LOG_ERROR("trying to enable mmu on target stopped with mmu disable");
+			return ERROR_FAIL;
+		}
+		if (!(aarch64->system_control_reg_curr & 0x1U))
+			aarch64->system_control_reg_curr |= 0x1U;
+	} else {
+		if (aarch64->system_control_reg_curr & 0x4U) {
+			/*  data cache is active */
+			aarch64->system_control_reg_curr &= ~0x4U;
+			/* flush data cache armv8 function to be called */
+			if (armv8->armv8_mmu.armv8_cache.flush_all_data_cache)
+				armv8->armv8_mmu.armv8_cache.flush_all_data_cache(target);
+		}
+		if ((aarch64->system_control_reg_curr & 0x1U)) {
+			aarch64->system_control_reg_curr &= ~0x1U;
+		}
+	}
+
+	switch (armv8->arm.core_mode) {
+	case ARMV8_64_EL0T:
+	case ARMV8_64_EL1T:
+	case ARMV8_64_EL1H:
+		instr = ARMV8_MSR_GP(SYSTEM_SCTLR_EL1, 0);
+		break;
+	case ARMV8_64_EL2T:
+	case ARMV8_64_EL2H:
+		instr = ARMV8_MSR_GP(SYSTEM_SCTLR_EL2, 0);
+		break;
+	case ARMV8_64_EL3H:
+	case ARMV8_64_EL3T:
+		instr = ARMV8_MSR_GP(SYSTEM_SCTLR_EL3, 0);
+		break;
+	default:
+		LOG_DEBUG("unknown cpu state 0x%x" PRIx32, armv8->arm.core_state);
+		break;
+	}
+
+	retval = armv8->dpm.instr_write_data_r0(&armv8->dpm, instr,
+				aarch64->system_control_reg_curr);
+	return retval;
+}
+
+/*
+ * Basic debug access, very low level assumes state is saved
+ */
+static int aarch64_init_debug_access(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	int retval;
+	uint32_t dummy;
+
+	LOG_DEBUG(" ");
+
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_OSLAR, 0);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "oslock");
+		return retval;
+	}
+
+	/* Clear Sticky Power Down status Bit in PRSR to enable access to
+	   the registers in the Core Power Domain */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_PRSR, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * Static CTI configuration:
+	 * Channel 0 -> trigger outputs HALT request to PE
+	 * Channel 1 -> trigger outputs Resume request to PE
+	 * Gate all channel trigger events from entering the CTM
+	 */
+
+	/* Enable CTI */
+	retval = arm_cti_enable(armv8->cti, true);
+	/* By default, gate all channel events to and from the CTM */
+	if (retval == ERROR_OK)
+		retval = arm_cti_write_reg(armv8->cti, CTI_GATE, 0);
+	/* output halt requests to PE on channel 0 event */
+	if (retval == ERROR_OK)
+		retval = arm_cti_write_reg(armv8->cti, CTI_OUTEN0, CTI_CHNL(0));
+	/* output restart requests to PE on channel 1 event */
+	if (retval == ERROR_OK)
+		retval = arm_cti_write_reg(armv8->cti, CTI_OUTEN1, CTI_CHNL(1));
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Resync breakpoint registers */
+
+	return ERROR_OK;
+}
+
+/* Write to memory mapped registers directly with no cache or mmu handling */
+static int aarch64_dap_write_memap_register_u32(struct target *target,
+	uint32_t address,
+	uint32_t value)
+{
+	int retval;
+	struct armv8_common *armv8 = target_to_armv8(target);
+
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap, address, value);
+
+	return retval;
+}
+
+static int aarch64_dpm_setup(struct aarch64_common *a8, uint64_t debug)
+{
+	struct arm_dpm *dpm = &a8->armv8_common.dpm;
+	int retval;
+
+	dpm->arm = &a8->armv8_common.arm;
+	dpm->didr = debug;
+
+	retval = armv8_dpm_setup(dpm);
+	if (retval == ERROR_OK)
+		retval = armv8_dpm_initialize(dpm);
+
+	return retval;
+}
+
+static int aarch64_set_dscr_bits(struct target *target, unsigned long bit_mask, unsigned long value)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	return armv8_set_dbgreg_bits(armv8, CPUV8_DBG_DSCR, bit_mask, value);
+}
+
+static int aarch64_check_state_one(struct target *target,
+		uint32_t mask, uint32_t val, int *p_result, uint32_t *p_prsr)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	uint32_t prsr;
+	int retval;
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_PRSR, &prsr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (p_prsr)
+		*p_prsr = prsr;
+
+	if (p_result)
+		*p_result = (prsr & mask) == (val & mask);
+
+	return ERROR_OK;
+}
+
+static int aarch64_wait_halt_one(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t prsr;
+
+	int64_t then = timeval_ms();
+	for (;;) {
+		int halted;
+
+		retval = aarch64_check_state_one(target, PRSR_HALT, PRSR_HALT, &halted, &prsr);
+		if (retval != ERROR_OK || halted)
+			break;
+
+		if (timeval_ms() > then + 1000) {
+			retval = ERROR_TARGET_TIMEOUT;
+			LOG_DEBUG("target %s timeout, prsr=0x%08"PRIx32, target_name(target), prsr);
+			break;
+		}
+	}
+	return retval;
+}
+
+static int aarch64_prepare_halt_smp(struct target *target, bool exc_target, struct target **p_first)
+{
+	int retval = ERROR_OK;
+	struct target_list *head = target->head;
+	struct target *first = NULL;
+
+	LOG_DEBUG("target %s exc %i", target_name(target), exc_target);
+
+	while (head != NULL) {
+		struct target *curr = head->target;
+		struct armv8_common *armv8 = target_to_armv8(curr);
+		head = head->next;
+
+		if (exc_target && curr == target)
+			continue;
+		if (!target_was_examined(curr))
+			continue;
+		if (curr->state != TARGET_RUNNING)
+			continue;
+
+		/* HACK: mark this target as prepared for halting */
+		curr->debug_reason = DBG_REASON_DBGRQ;
+
+		/* open the gate for channel 0 to let HALT requests pass to the CTM */
+		retval = arm_cti_ungate_channel(armv8->cti, 0);
+		if (retval == ERROR_OK)
+			retval = aarch64_set_dscr_bits(curr, DSCR_HDE, DSCR_HDE);
+		if (retval != ERROR_OK)
+			break;
+
+		LOG_DEBUG("target %s prepared", target_name(curr));
+
+		if (first == NULL)
+			first = curr;
+	}
+
+	if (p_first) {
+		if (exc_target && first)
+			*p_first = first;
+		else
+			*p_first = target;
+	}
+
+	return retval;
+}
+
+static int aarch64_halt_one(struct target *target, enum halt_mode mode)
+{
+	int retval = ERROR_OK;
+	struct armv8_common *armv8 = target_to_armv8(target);
+
+	LOG_DEBUG("%s", target_name(target));
+
+	/* allow Halting Debug Mode */
+	retval = aarch64_set_dscr_bits(target, DSCR_HDE, DSCR_HDE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* trigger an event on channel 0, this outputs a halt request to the PE */
+	retval = arm_cti_pulse_channel(armv8->cti, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mode == HALT_SYNC) {
+		retval = aarch64_wait_halt_one(target);
+		if (retval != ERROR_OK) {
+			if (retval == ERROR_TARGET_TIMEOUT)
+				LOG_ERROR("Timeout waiting for target %s halt", target_name(target));
+			return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int aarch64_halt_smp(struct target *target, bool exc_target)
+{
+	struct target *next = target;
+	int retval;
+
+	/* prepare halt on all PEs of the group */
+	retval = aarch64_prepare_halt_smp(target, exc_target, &next);
+
+	if (exc_target && next == target)
+		return retval;
+
+	/* halt the target PE */
+	if (retval == ERROR_OK)
+		retval = aarch64_halt_one(next, HALT_LAZY);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* wait for all PEs to halt */
+	int64_t then = timeval_ms();
+	for (;;) {
+		bool all_halted = true;
+		struct target_list *head;
+		struct target *curr;
+
+		foreach_smp_target(head, target->head) {
+			int halted;
+
+			curr = head->target;
+
+			if (!target_was_examined(curr))
+				continue;
+
+			retval = aarch64_check_state_one(curr, PRSR_HALT, PRSR_HALT, &halted, NULL);
+			if (retval != ERROR_OK || !halted) {
+				all_halted = false;
+				break;
+			}
+		}
+
+		if (all_halted)
+			break;
+
+		if (timeval_ms() > then + 1000) {
+			retval = ERROR_TARGET_TIMEOUT;
+			break;
+		}
+
+		/*
+		 * HACK: on Hi6220 there are 8 cores organized in 2 clusters
+		 * and it looks like the CTI's are not connected by a common
+		 * trigger matrix. It seems that we need to halt one core in each
+		 * cluster explicitly. So if we find that a core has not halted
+		 * yet, we trigger an explicit halt for the second cluster.
+		 */
+		retval = aarch64_halt_one(curr, HALT_LAZY);
+		if (retval != ERROR_OK)
+			break;
+	}
+
+	return retval;
+}
+
+static int update_halt_gdb(struct target *target, enum target_debug_reason debug_reason)
+{
+	struct target *gdb_target = NULL;
+	struct target_list *head;
+	struct target *curr;
+
+	if (debug_reason == DBG_REASON_NOTHALTED) {
+		LOG_INFO("Halting remaining targets in SMP group");
+		aarch64_halt_smp(target, true);
+	}
+
+	/* poll all targets in the group, but skip the target that serves GDB */
+	foreach_smp_target(head, target->head) {
+		curr = head->target;
+		/* skip calling context */
+		if (curr == target)
+			continue;
+		if (!target_was_examined(curr))
+			continue;
+		/* skip targets that were already halted */
+		if (curr->state == TARGET_HALTED)
+			continue;
+		/* remember the gdb_service->target */
+		if (curr->gdb_service != NULL)
+			gdb_target = curr->gdb_service->target;
+		/* skip it */
+		if (curr == gdb_target)
+			continue;
+
+		/* avoid recursion in aarch64_poll() */
+		curr->smp = 0;
+		aarch64_poll(curr);
+		curr->smp = 1;
+	}
+
+	/* after all targets were updated, poll the gdb serving target */
+	if (gdb_target != NULL && gdb_target != target)
+		aarch64_poll(gdb_target);
+
+	return ERROR_OK;
+}
+
+/*
+ * Aarch64 Run control
+ */
+
+static int aarch64_poll(struct target *target)
+{
+	enum target_state prev_target_state;
+	int retval = ERROR_OK;
+	int halted;
+
+	retval = aarch64_check_state_one(target,
+				PRSR_HALT, PRSR_HALT, &halted, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (halted) {
+		prev_target_state = target->state;
+		if (prev_target_state != TARGET_HALTED) {
+			enum target_debug_reason debug_reason = target->debug_reason;
+
+			/* We have a halting debug event */
+			target->state = TARGET_HALTED;
+			LOG_DEBUG("Target %s halted", target_name(target));
+			retval = aarch64_debug_entry(target);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (target->smp)
+				update_halt_gdb(target, debug_reason);
+
+			switch (prev_target_state) {
+			case TARGET_RUNNING:
+			case TARGET_UNKNOWN:
+			case TARGET_RESET:
+				target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+				break;
+			case TARGET_DEBUG_RUNNING:
+				target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
+				break;
+			default:
+				break;
+			}
+		}
+	} else
+		target->state = TARGET_RUNNING;
+
+	return retval;
+}
+
+static int aarch64_halt(struct target *target)
+{
+	if (target->smp)
+		return aarch64_halt_smp(target, false);
+
+	return aarch64_halt_one(target, HALT_SYNC);
+}
+
+static int aarch64_restore_one(struct target *target, int current,
+	uint64_t *address, int handle_breakpoints, int debug_execution)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm *arm = &armv8->arm;
+	int retval;
+	uint64_t resume_pc;
+
+	LOG_DEBUG("%s", target_name(target));
+
+	if (!debug_execution)
+		target_free_all_working_areas(target);
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	resume_pc = buf_get_u64(arm->pc->value, 0, 64);
+	if (!current)
+		resume_pc = *address;
+	else
+		*address = resume_pc;
+
+	/* Make sure that the Armv7 gdb thumb fixups does not
+	 * kill the return address
+	 */
+	switch (arm->core_state) {
+		case ARM_STATE_ARM:
+			resume_pc &= 0xFFFFFFFC;
+			break;
+		case ARM_STATE_AARCH64:
+			resume_pc &= 0xFFFFFFFFFFFFFFFC;
+			break;
+		case ARM_STATE_THUMB:
+		case ARM_STATE_THUMB_EE:
+			/* When the return address is loaded into PC
+			 * bit 0 must be 1 to stay in Thumb state
+			 */
+			resume_pc |= 0x1;
+			break;
+		case ARM_STATE_JAZELLE:
+			LOG_ERROR("How do I resume into Jazelle state??");
+			return ERROR_FAIL;
+	}
+	LOG_DEBUG("resume pc = 0x%016" PRIx64, resume_pc);
+	buf_set_u64(arm->pc->value, 0, 64, resume_pc);
+	arm->pc->dirty = 1;
+	arm->pc->valid = 1;
+
+	/* called it now before restoring context because it uses cpu
+	 * register r0 for restoring system control register */
+	retval = aarch64_restore_system_control_reg(target);
+	if (retval == ERROR_OK)
+		retval = aarch64_restore_context(target, handle_breakpoints);
+
+	return retval;
+}
+
+/**
+ * prepare single target for restart
+ *
+ *
+ */
+static int aarch64_prepare_restart_one(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	int retval;
+	uint32_t dscr;
+	uint32_t tmp;
+
+	LOG_DEBUG("%s", target_name(target));
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((dscr & DSCR_ITE) == 0)
+		LOG_ERROR("DSCR.ITE must be set before leaving debug!");
+	if ((dscr & DSCR_ERR) != 0)
+		LOG_ERROR("DSCR.ERR must be cleared before leaving debug!");
+
+	/* acknowledge a pending CTI halt event */
+	retval = arm_cti_ack_events(armv8->cti, CTI_TRIG(HALT));
+	/*
+	 * open the CTI gate for channel 1 so that the restart events
+	 * get passed along to all PEs. Also close gate for channel 0
+	 * to isolate the PE from halt events.
+	 */
+	if (retval == ERROR_OK)
+		retval = arm_cti_ungate_channel(armv8->cti, 1);
+	if (retval == ERROR_OK)
+		retval = arm_cti_gate_channel(armv8->cti, 0);
+
+	/* make sure that DSCR.HDE is set */
+	if (retval == ERROR_OK) {
+		dscr |= DSCR_HDE;
+		retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+	}
+
+	/* clear sticky bits in PRSR, SDR is now 0 */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_PRSR, &tmp);
+
+	return retval;
+}
+
+static int aarch64_do_restart_one(struct target *target, enum restart_mode mode)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	int retval;
+
+	LOG_DEBUG("%s", target_name(target));
+
+	/* trigger an event on channel 1, generates a restart request to the PE */
+	retval = arm_cti_pulse_channel(armv8->cti, 1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mode == RESTART_SYNC) {
+		int64_t then = timeval_ms();
+		for (;;) {
+			int resumed;
+			/*
+			 * if PRSR.SDR is set now, the target did restart, even
+			 * if it's now already halted again (e.g. due to breakpoint)
+			 */
+			retval = aarch64_check_state_one(target,
+						PRSR_SDR, PRSR_SDR, &resumed, NULL);
+			if (retval != ERROR_OK || resumed)
+				break;
+
+			if (timeval_ms() > then + 1000) {
+				LOG_ERROR("%s: Timeout waiting for resume"PRIx32, target_name(target));
+				retval = ERROR_TARGET_TIMEOUT;
+				break;
+			}
+		}
+	}
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	target->debug_reason = DBG_REASON_NOTHALTED;
+	target->state = TARGET_RUNNING;
+
+	return ERROR_OK;
+}
+
+static int aarch64_restart_one(struct target *target, enum restart_mode mode)
+{
+	int retval;
+
+	LOG_DEBUG("%s", target_name(target));
+
+	retval = aarch64_prepare_restart_one(target);
+	if (retval == ERROR_OK)
+		retval = aarch64_do_restart_one(target, mode);
+
+	return retval;
+}
+
+/*
+ * prepare all but the current target for restart
+ */
+static int aarch64_prep_restart_smp(struct target *target, int handle_breakpoints, struct target **p_first)
+{
+	int retval = ERROR_OK;
+	struct target_list *head;
+	struct target *first = NULL;
+	uint64_t address;
+
+	foreach_smp_target(head, target->head) {
+		struct target *curr = head->target;
+
+		/* skip calling target */
+		if (curr == target)
+			continue;
+		if (!target_was_examined(curr))
+			continue;
+		if (curr->state != TARGET_HALTED)
+			continue;
+
+		/*  resume at current address, not in step mode */
+		retval = aarch64_restore_one(curr, 1, &address, handle_breakpoints, 0);
+		if (retval == ERROR_OK)
+			retval = aarch64_prepare_restart_one(curr);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("failed to restore target %s", target_name(curr));
+			break;
+		}
+		/* remember the first valid target in the group */
+		if (first == NULL)
+			first = curr;
+	}
+
+	if (p_first)
+		*p_first = first;
+
+	return retval;
+}
+
+
+static int aarch64_step_restart_smp(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct target_list *head;
+	struct target *first = NULL;
+
+	LOG_DEBUG("%s", target_name(target));
+
+	retval = aarch64_prep_restart_smp(target, 0, &first);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (first != NULL)
+		retval = aarch64_do_restart_one(first, RESTART_LAZY);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("error restarting target %s", target_name(first));
+		return retval;
+	}
+
+	int64_t then = timeval_ms();
+	for (;;) {
+		struct target *curr = target;
+		bool all_resumed = true;
+
+		foreach_smp_target(head, target->head) {
+			uint32_t prsr;
+			int resumed;
+
+			curr = head->target;
+
+			if (curr == target)
+				continue;
+
+			retval = aarch64_check_state_one(curr,
+					PRSR_SDR, PRSR_SDR, &resumed, &prsr);
+			if (retval != ERROR_OK || (!resumed && (prsr & PRSR_HALT))) {
+				all_resumed = false;
+				break;
+			}
+
+			if (curr->state != TARGET_RUNNING) {
+				curr->state = TARGET_RUNNING;
+				curr->debug_reason = DBG_REASON_NOTHALTED;
+				target_call_event_callbacks(curr, TARGET_EVENT_RESUMED);
+			}
+		}
+
+		if (all_resumed)
+			break;
+
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("%s: timeout waiting for target resume", __func__);
+			retval = ERROR_TARGET_TIMEOUT;
+			break;
+		}
+		/*
+		 * HACK: on Hi6220 there are 8 cores organized in 2 clusters
+		 * and it looks like the CTI's are not connected by a common
+		 * trigger matrix. It seems that we need to halt one core in each
+		 * cluster explicitly. So if we find that a core has not halted
+		 * yet, we trigger an explicit resume for the second cluster.
+		 */
+		retval = aarch64_do_restart_one(curr, RESTART_LAZY);
+		if (retval != ERROR_OK)
+			break;
+}
+
+	return retval;
+}
+
+static int aarch64_resume(struct target *target, int current,
+	target_addr_t address, int handle_breakpoints, int debug_execution)
+{
+	int retval = 0;
+	uint64_t addr = address;
+
+	if (target->state != TARGET_HALTED)
+		return ERROR_TARGET_NOT_HALTED;
+
+	/*
+	 * If this target is part of a SMP group, prepare the others
+	 * targets for resuming. This involves restoring the complete
+	 * target register context and setting up CTI gates to accept
+	 * resume events from the trigger matrix.
+	 */
+	if (target->smp) {
+		retval = aarch64_prep_restart_smp(target, handle_breakpoints, NULL);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* all targets prepared, restore and restart the current target */
+	retval = aarch64_restore_one(target, current, &addr, handle_breakpoints,
+				 debug_execution);
+	if (retval == ERROR_OK)
+		retval = aarch64_restart_one(target, RESTART_SYNC);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->smp) {
+		int64_t then = timeval_ms();
+		for (;;) {
+			struct target *curr = target;
+			struct target_list *head;
+			bool all_resumed = true;
+
+			foreach_smp_target(head, target->head) {
+				uint32_t prsr;
+				int resumed;
+
+				curr = head->target;
+				if (curr == target)
+					continue;
+				if (!target_was_examined(curr))
+					continue;
+
+				retval = aarch64_check_state_one(curr,
+						PRSR_SDR, PRSR_SDR, &resumed, &prsr);
+				if (retval != ERROR_OK || (!resumed && (prsr & PRSR_HALT))) {
+					all_resumed = false;
+					break;
+				}
+
+				if (curr->state != TARGET_RUNNING) {
+					curr->state = TARGET_RUNNING;
+					curr->debug_reason = DBG_REASON_NOTHALTED;
+					target_call_event_callbacks(curr, TARGET_EVENT_RESUMED);
+				}
+			}
+
+			if (all_resumed)
+				break;
+
+			if (timeval_ms() > then + 1000) {
+				LOG_ERROR("%s: timeout waiting for target %s to resume", __func__, target_name(curr));
+				retval = ERROR_TARGET_TIMEOUT;
+				break;
+			}
+
+			/*
+			 * HACK: on Hi6220 there are 8 cores organized in 2 clusters
+			 * and it looks like the CTI's are not connected by a common
+			 * trigger matrix. It seems that we need to halt one core in each
+			 * cluster explicitly. So if we find that a core has not halted
+			 * yet, we trigger an explicit resume for the second cluster.
+			 */
+			retval = aarch64_do_restart_one(curr, RESTART_LAZY);
+			if (retval != ERROR_OK)
+				break;
+		}
+	}
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	target->debug_reason = DBG_REASON_NOTHALTED;
+
+	if (!debug_execution) {
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%" PRIx64, addr);
+	} else {
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx64, addr);
+	}
+
+	return ERROR_OK;
+}
+
+static int aarch64_debug_entry(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm_dpm *dpm = &armv8->dpm;
+	enum arm_state core_state;
+	uint32_t dscr;
+
+	/* make sure to clear all sticky errors */
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DRCR, DRCR_CSE);
+	if (retval == ERROR_OK)
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	if (retval == ERROR_OK)
+		retval = arm_cti_ack_events(armv8->cti, CTI_TRIG(HALT));
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("%s dscr = 0x%08" PRIx32, target_name(target), dscr);
+
+	dpm->dscr = dscr;
+	core_state = armv8_dpm_get_core_state(dpm);
+	armv8_select_opcodes(armv8, core_state == ARM_STATE_AARCH64);
+	armv8_select_reg_access(armv8, core_state == ARM_STATE_AARCH64);
+
+	/* close the CTI gate for all events */
+	if (retval == ERROR_OK)
+		retval = arm_cti_write_reg(armv8->cti, CTI_GATE, 0);
+	/* discard async exceptions */
+	if (retval == ERROR_OK)
+		retval = dpm->instr_cpsr_sync(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Examine debug reason */
+	armv8_dpm_report_dscr(dpm, dscr);
+
+	/* save address of instruction that triggered the watchpoint? */
+	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
+		uint32_t tmp;
+		uint64_t wfar = 0;
+
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_WFAR1,
+				&tmp);
+		if (retval != ERROR_OK)
+			return retval;
+		wfar = tmp;
+		wfar = (wfar << 32);
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_WFAR0,
+				&tmp);
+		if (retval != ERROR_OK)
+			return retval;
+		wfar |= tmp;
+		armv8_dpm_report_wfar(&armv8->dpm, wfar);
+	}
+
+	retval = armv8_dpm_read_current_registers(&armv8->dpm);
+
+	if (retval == ERROR_OK && armv8->post_debug_entry)
+		retval = armv8->post_debug_entry(target);
+
+	return retval;
+}
+
+static int aarch64_post_debug_entry(struct target *target)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	int retval;
+	enum arm_mode target_mode = ARM_MODE_ANY;
+	uint32_t instr;
+
+	switch (armv8->arm.core_mode) {
+	case ARMV8_64_EL0T:
+		target_mode = ARMV8_64_EL1H;
+		/* fall through */
+	case ARMV8_64_EL1T:
+	case ARMV8_64_EL1H:
+		instr = ARMV8_MRS(SYSTEM_SCTLR_EL1, 0);
+		break;
+	case ARMV8_64_EL2T:
+	case ARMV8_64_EL2H:
+		instr = ARMV8_MRS(SYSTEM_SCTLR_EL2, 0);
+		break;
+	case ARMV8_64_EL3H:
+	case ARMV8_64_EL3T:
+		instr = ARMV8_MRS(SYSTEM_SCTLR_EL3, 0);
+		break;
+
+	case ARM_MODE_SVC:
+	case ARM_MODE_ABT:
+	case ARM_MODE_FIQ:
+	case ARM_MODE_IRQ:
+		instr = ARMV4_5_MRC(15, 0, 0, 1, 0, 0);
+		break;
+
+	default:
+		LOG_INFO("cannot read system control register in this mode");
+		return ERROR_FAIL;
+	}
+
+	if (target_mode != ARM_MODE_ANY)
+		armv8_dpm_modeswitch(&armv8->dpm, target_mode);
+
+	retval = armv8->dpm.instr_read_data_r0(&armv8->dpm, instr, &aarch64->system_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target_mode != ARM_MODE_ANY)
+		armv8_dpm_modeswitch(&armv8->dpm, ARM_MODE_ANY);
+
+	LOG_DEBUG("System_register: %8.8" PRIx32, aarch64->system_control_reg);
+	aarch64->system_control_reg_curr = aarch64->system_control_reg;
+
+	if (armv8->armv8_mmu.armv8_cache.info == -1) {
+		armv8_identify_cache(armv8);
+		armv8_read_mpidr(armv8);
+	}
+
+	armv8->armv8_mmu.mmu_enabled =
+			(aarch64->system_control_reg & 0x1U) ? 1 : 0;
+	armv8->armv8_mmu.armv8_cache.d_u_cache_enabled =
+		(aarch64->system_control_reg & 0x4U) ? 1 : 0;
+	armv8->armv8_mmu.armv8_cache.i_cache_enabled =
+		(aarch64->system_control_reg & 0x1000U) ? 1 : 0;
+	return ERROR_OK;
+}
+
+/*
+ * single-step a target
+ */
+static int aarch64_step(struct target *target, int current, target_addr_t address,
+	int handle_breakpoints)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	int saved_retval = ERROR_OK;
+	int retval;
+	uint32_t edecr;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_EDECR, &edecr);
+	/* make sure EDECR.SS is not set when restoring the register */
+
+	if (retval == ERROR_OK) {
+		edecr &= ~0x4;
+		/* set EDECR.SS to enter hardware step mode */
+		retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_EDECR, (edecr|0x4));
+	}
+	/* disable interrupts while stepping */
+	if (retval == ERROR_OK)
+		retval = aarch64_set_dscr_bits(target, 0x3 << 22, 0x3 << 22);
+	/* bail out if stepping setup has failed */
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->smp && !handle_breakpoints) {
+		/*
+		 * isolate current target so that it doesn't get resumed
+		 * together with the others
+		 */
+		retval = arm_cti_gate_channel(armv8->cti, 1);
+		/* resume all other targets in the group */
+		if (retval == ERROR_OK)
+			retval = aarch64_step_restart_smp(target);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Failed to restart non-stepping targets in SMP group");
+			return retval;
+		}
+		LOG_DEBUG("Restarted all non-stepping targets in SMP group");
+	}
+
+	/* all other targets running, restore and restart the current target */
+	retval = aarch64_restore_one(target, current, &address, 0, 0);
+	if (retval == ERROR_OK)
+		retval = aarch64_restart_one(target, RESTART_LAZY);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("target step-resumed at 0x%" PRIx64, address);
+	if (!handle_breakpoints)
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+
+	int64_t then = timeval_ms();
+	for (;;) {
+		int stepped;
+		uint32_t prsr;
+
+		retval = aarch64_check_state_one(target,
+					PRSR_SDR|PRSR_HALT, PRSR_SDR|PRSR_HALT, &stepped, &prsr);
+		if (retval != ERROR_OK || stepped)
+			break;
+
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("timeout waiting for target %s halt after step",
+					target_name(target));
+			retval = ERROR_TARGET_TIMEOUT;
+			break;
+		}
+	}
+
+	if (retval == ERROR_TARGET_TIMEOUT)
+		saved_retval = retval;
+
+	/* restore EDECR */
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_EDECR, edecr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* restore interrupts */
+	retval = aarch64_set_dscr_bits(target, 0x3 << 22, 0);
+	if (retval != ERROR_OK)
+		return ERROR_OK;
+
+	if (saved_retval != ERROR_OK)
+		return saved_retval;
+
+	return aarch64_poll(target);
+}
+
+static int aarch64_restore_context(struct target *target, bool bpwp)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm *arm = &armv8->arm;
+
+	int retval;
+
+	LOG_DEBUG("%s", target_name(target));
+
+	if (armv8->pre_restore_context)
+		armv8->pre_restore_context(target);
+
+	retval = armv8_dpm_write_dirty_registers(&armv8->dpm, bpwp);
+	if (retval == ERROR_OK) {
+		/* registers are now invalid */
+		register_cache_invalidate(arm->core_cache);
+		register_cache_invalidate(arm->core_cache->next);
+	}
+
+	return retval;
+}
+
+/*
+ * Cortex-A8 Breakpoint and watchpoint functions
+ */
+
+/* Setup hardware Breakpoint Register Pair */
+static int aarch64_set_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode)
+{
+	int retval;
+	int brp_i = 0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	struct aarch64_brp *brp_list = aarch64->brp_list;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+		int64_t bpt_value;
+		while (brp_list[brp_i].used && (brp_i < aarch64->brp_num))
+			brp_i++;
+		if (brp_i >= aarch64->brp_num) {
+			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+		breakpoint->set = brp_i + 1;
+		if (breakpoint->length == 2)
+			byte_addr_select = (3 << (breakpoint->address & 0x02));
+		control = ((matchmode & 0x7) << 20)
+			| (1 << 13)
+			| (byte_addr_select << 5)
+			| (3 << 1) | 1;
+		brp_list[brp_i].used = 1;
+		brp_list[brp_i].value = breakpoint->address & 0xFFFFFFFFFFFFFFFC;
+		brp_list[brp_i].control = control;
+		bpt_value = brp_list[brp_i].value;
+
+		retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+				+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_i].BRPn,
+				(uint32_t)(bpt_value & 0xFFFFFFFF));
+		if (retval != ERROR_OK)
+			return retval;
+		retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+				+ CPUV8_DBG_BVR_BASE + 4 + 16 * brp_list[brp_i].BRPn,
+				(uint32_t)(bpt_value >> 32));
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+				+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].control);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%" TARGET_PRIxADDR, brp_i,
+			brp_list[brp_i].control,
+			brp_list[brp_i].value);
+
+	} else if (breakpoint->type == BKPT_SOFT) {
+		uint8_t code[4];
+
+		buf_set_u32(code, 0, 32, armv8_opcode(armv8, ARMV8_OPC_HLT));
+		retval = target_read_memory(target,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length, 1,
+				breakpoint->orig_instr);
+		if (retval != ERROR_OK)
+			return retval;
+
+		armv8_cache_d_inner_flush_virt(armv8,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length);
+
+		retval = target_write_memory(target,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length, 1, code);
+		if (retval != ERROR_OK)
+			return retval;
+
+		armv8_cache_d_inner_flush_virt(armv8,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length);
+
+		armv8_cache_i_inner_inval_virt(armv8,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length);
+
+		breakpoint->set = 0x11;	/* Any nice value but 0 */
+	}
+
+	/* Ensure that halting debug mode is enable */
+	retval = aarch64_set_dscr_bits(target, DSCR_HDE, DSCR_HDE);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Failed to set DSCR.HDE");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+static int aarch64_set_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode)
+{
+	int retval = ERROR_FAIL;
+	int brp_i = 0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	struct aarch64_brp *brp_list = aarch64->brp_list;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return retval;
+	}
+	/*check available context BRPs*/
+	while ((brp_list[brp_i].used ||
+		(brp_list[brp_i].type != BRP_CONTEXT)) && (brp_i < aarch64->brp_num))
+		brp_i++;
+
+	if (brp_i >= aarch64->brp_num) {
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	breakpoint->set = brp_i + 1;
+	control = ((matchmode & 0x7) << 20)
+		| (1 << 13)
+		| (byte_addr_select << 5)
+		| (3 << 1) | 1;
+	brp_list[brp_i].used = 1;
+	brp_list[brp_i].value = (breakpoint->asid);
+	brp_list[brp_i].control = control;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_i].BRPn,
+			brp_list[brp_i].value);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_i].BRPn,
+			brp_list[brp_i].control);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%" TARGET_PRIxADDR, brp_i,
+		brp_list[brp_i].control,
+		brp_list[brp_i].value);
+	return ERROR_OK;
+
+}
+
+static int aarch64_set_hybrid_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	int retval = ERROR_FAIL;
+	int brp_1 = 0;	/* holds the contextID pair */
+	int brp_2 = 0;	/* holds the IVA pair */
+	uint32_t control_CTX, control_IVA;
+	uint8_t CTX_byte_addr_select = 0x0F;
+	uint8_t IVA_byte_addr_select = 0x0F;
+	uint8_t CTX_machmode = 0x03;
+	uint8_t IVA_machmode = 0x01;
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	struct aarch64_brp *brp_list = aarch64->brp_list;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return retval;
+	}
+	/*check available context BRPs*/
+	while ((brp_list[brp_1].used ||
+		(brp_list[brp_1].type != BRP_CONTEXT)) && (brp_1 < aarch64->brp_num))
+		brp_1++;
+
+	printf("brp(CTX) found num: %d\n", brp_1);
+	if (brp_1 >= aarch64->brp_num) {
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	while ((brp_list[brp_2].used ||
+		(brp_list[brp_2].type != BRP_NORMAL)) && (brp_2 < aarch64->brp_num))
+		brp_2++;
+
+	printf("brp(IVA) found num: %d\n", brp_2);
+	if (brp_2 >= aarch64->brp_num) {
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	breakpoint->set = brp_1 + 1;
+	breakpoint->linked_BRP = brp_2;
+	control_CTX = ((CTX_machmode & 0x7) << 20)
+		| (brp_2 << 16)
+		| (0 << 14)
+		| (CTX_byte_addr_select << 5)
+		| (3 << 1) | 1;
+	brp_list[brp_1].used = 1;
+	brp_list[brp_1].value = (breakpoint->asid);
+	brp_list[brp_1].control = control_CTX;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_1].BRPn,
+			brp_list[brp_1].value);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_1].BRPn,
+			brp_list[brp_1].control);
+	if (retval != ERROR_OK)
+		return retval;
+
+	control_IVA = ((IVA_machmode & 0x7) << 20)
+		| (brp_1 << 16)
+		| (1 << 13)
+		| (IVA_byte_addr_select << 5)
+		| (3 << 1) | 1;
+	brp_list[brp_2].used = 1;
+	brp_list[brp_2].value = breakpoint->address & 0xFFFFFFFFFFFFFFFC;
+	brp_list[brp_2].control = control_IVA;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_2].BRPn,
+			brp_list[brp_2].value & 0xFFFFFFFF);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BVR_BASE + 4 + 16 * brp_list[brp_2].BRPn,
+			brp_list[brp_2].value >> 32);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+			+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_2].BRPn,
+			brp_list[brp_2].control);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int aarch64_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	int retval;
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	struct aarch64_brp *brp_list = aarch64->brp_list;
+
+	if (!breakpoint->set) {
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+		if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
+			int brp_i = breakpoint->set - 1;
+			int brp_j = breakpoint->linked_BRP;
+			if ((brp_i < 0) || (brp_i >= aarch64->brp_num)) {
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%" TARGET_PRIxADDR, brp_i,
+				brp_list[brp_i].control, brp_list[brp_i].value);
+			brp_list[brp_i].used = 0;
+			brp_list[brp_i].value = 0;
+			brp_list[brp_i].control = 0;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_i].BRPn,
+					(uint32_t)brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BVR_BASE + 4 + 16 * brp_list[brp_i].BRPn,
+					(uint32_t)brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+			if ((brp_j < 0) || (brp_j >= aarch64->brp_num)) {
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx64, brp_j,
+				brp_list[brp_j].control, brp_list[brp_j].value);
+			brp_list[brp_j].used = 0;
+			brp_list[brp_j].value = 0;
+			brp_list[brp_j].control = 0;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_j].BRPn,
+					brp_list[brp_j].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_j].BRPn,
+					(uint32_t)brp_list[brp_j].value);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BVR_BASE + 4 + 16 * brp_list[brp_j].BRPn,
+					(uint32_t)brp_list[brp_j].value);
+			if (retval != ERROR_OK)
+				return retval;
+
+			breakpoint->linked_BRP = 0;
+			breakpoint->set = 0;
+			return ERROR_OK;
+
+		} else {
+			int brp_i = breakpoint->set - 1;
+			if ((brp_i < 0) || (brp_i >= aarch64->brp_num)) {
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx64, brp_i,
+				brp_list[brp_i].control, brp_list[brp_i].value);
+			brp_list[brp_i].used = 0;
+			brp_list[brp_i].value = 0;
+			brp_list[brp_i].control = 0;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BCR_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BVR_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = aarch64_dap_write_memap_register_u32(target, armv8->debug_base
+					+ CPUV8_DBG_BVR_BASE + 4 + 16 * brp_list[brp_i].BRPn,
+					(uint32_t)brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+			breakpoint->set = 0;
+			return ERROR_OK;
+		}
+	} else {
+		/* restore original instruction (kept in target endianness) */
+
+		armv8_cache_d_inner_flush_virt(armv8,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length);
+
+		if (breakpoint->length == 4) {
+			retval = target_write_memory(target,
+					breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+					4, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		} else {
+			retval = target_write_memory(target,
+					breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+					2, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+
+		armv8_cache_d_inner_flush_virt(armv8,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length);
+
+		armv8_cache_i_inner_inval_virt(armv8,
+				breakpoint->address & 0xFFFFFFFFFFFFFFFE,
+				breakpoint->length);
+	}
+	breakpoint->set = 0;
+
+	return ERROR_OK;
+}
+
+static int aarch64_add_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (aarch64->brp_num_available < 1)) {
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		aarch64->brp_num_available--;
+
+	return aarch64_set_breakpoint(target, breakpoint, 0x00);	/* Exact match */
+}
+
+static int aarch64_add_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (aarch64->brp_num_available < 1)) {
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		aarch64->brp_num_available--;
+
+	return aarch64_set_context_breakpoint(target, breakpoint, 0x02);	/* asid match */
+}
+
+static int aarch64_add_hybrid_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (aarch64->brp_num_available < 1)) {
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		aarch64->brp_num_available--;
+
+	return aarch64_set_hybrid_breakpoint(target, breakpoint);	/* ??? */
+}
+
+
+static int aarch64_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+
+#if 0
+/* It is perfectly possible to remove breakpoints while the target is running */
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+#endif
+
+	if (breakpoint->set) {
+		aarch64_unset_breakpoint(target, breakpoint);
+		if (breakpoint->type == BKPT_HARD)
+			aarch64->brp_num_available++;
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Cortex-A8 Reset functions
+ */
+
+static int aarch64_assert_reset(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+
+	LOG_DEBUG(" ");
+
+	/* FIXME when halt is requested, make it work somehow... */
+
+	/* Issue some kind of warm reset. */
+	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT))
+		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
+	else if (jtag_get_reset_config() & RESET_HAS_SRST) {
+		/* REVISIT handle "pulls" cases, if there's
+		 * hardware that needs them to work.
+		 */
+		jtag_add_reset(0, 1);
+	} else {
+		LOG_ERROR("%s: how to reset?", target_name(target));
+		return ERROR_FAIL;
+	}
+
+	/* registers are now invalid */
+	if (target_was_examined(target)) {
+		register_cache_invalidate(armv8->arm.core_cache);
+		register_cache_invalidate(armv8->arm.core_cache->next);
+	}
+
+	target->state = TARGET_RESET;
+
+	return ERROR_OK;
+}
+
+static int aarch64_deassert_reset(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG(" ");
+
+	/* be certain SRST is off */
+	jtag_add_reset(0, 0);
+
+	if (!target_was_examined(target))
+		return ERROR_OK;
+
+	retval = aarch64_poll(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->reset_halt) {
+		if (target->state != TARGET_HALTED) {
+			LOG_WARNING("%s: ran after reset and before halt ...",
+				target_name(target));
+			retval = target_halt(target);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+
+	return aarch64_init_debug_access(target);
+}
+
+static int aarch64_write_apb_ap_memory(struct target *target,
+	uint64_t address, uint32_t size,
+	uint32_t count, const uint8_t *buffer)
+{
+	/* write memory through APB-AP */
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm_dpm *dpm = &armv8->dpm;
+	struct arm *arm = &armv8->arm;
+	int total_bytes = count * size;
+	int total_u32;
+	int start_byte = address & 0x3;
+	int end_byte   = (address + total_bytes) & 0x3;
+	struct reg *reg;
+	uint32_t dscr;
+	uint8_t *tmp_buff = NULL;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	total_u32 = DIV_ROUND_UP((address & 3) + total_bytes, 4);
+
+	/* Mark register R0 as dirty, as it will be used
+	 * for transferring the data.
+	 * It will be restored automatically when exiting
+	 * debug mode
+	 */
+	reg = armv8_reg_current(arm, 1);
+	reg->dirty = true;
+
+	reg = armv8_reg_current(arm, 0);
+	reg->dirty = true;
+
+	/* This algorithm comes from DDI0487A.g, chapter J9.1 */
+
+	/* The algorithm only copies 32 bit words, so the buffer
+	 * should be expanded to include the words at either end.
+	 * The first and last words will be read first to avoid
+	 * corruption if needed.
+	 */
+	tmp_buff = malloc(total_u32 * 4);
+
+	if ((start_byte != 0) && (total_u32 > 1)) {
+		/* First bytes not aligned - read the 32 bit word to avoid corrupting
+		 * the other bytes in the word.
+		 */
+		retval = aarch64_read_apb_ap_memory(target, (address & ~0x3), 4, 1, tmp_buff);
+		if (retval != ERROR_OK)
+			goto error_free_buff_w;
+	}
+
+	/* If end of write is not aligned, or the write is less than 4 bytes */
+	if ((end_byte != 0) ||
+		((total_u32 == 1) && (total_bytes != 4))) {
+
+		/* Read the last word to avoid corruption during 32 bit write */
+		int mem_offset = (total_u32-1) * 4;
+		retval = aarch64_read_apb_ap_memory(target, (address & ~0x3) + mem_offset, 4, 1, &tmp_buff[mem_offset]);
+		if (retval != ERROR_OK)
+			goto error_free_buff_w;
+	}
+
+	/* Copy the write buffer over the top of the temporary buffer */
+	memcpy(&tmp_buff[start_byte], buffer, total_bytes);
+
+	/* We now have a 32 bit aligned buffer that can be written */
+
+	/* Read DSCR */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_w;
+
+	/* Set Normal access mode  */
+	dscr = (dscr & ~DSCR_MA);
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+
+	if (arm->core_state == ARM_STATE_AARCH64) {
+		/* Write X0 with value 'address' using write procedure */
+		/* Step 1.a+b - Write the address for read access into DBGDTR_EL0 */
+		/* Step 1.c   - Copy value from DTR to R0 using instruction mrs DBGDTR_EL0, x0 */
+		retval = dpm->instr_write_data_dcc_64(dpm,
+				ARMV8_MRS(SYSTEM_DBG_DBGDTR_EL0, 0), address & ~0x3ULL);
+	} else {
+		/* Write R0 with value 'address' using write procedure */
+		/* Step 1.a+b - Write the address for read access into DBGDTRRX */
+		/* Step 1.c   - Copy value from DTR to R0 using instruction mrc DBGDTRTXint, r0 */
+		dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, 0, 0, 5, 0), address & ~0x3ULL);
+
+	}
+	/* Step 1.d   - Change DCC to memory mode */
+	dscr = dscr | DSCR_MA;
+	retval +=  mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+
+	/* Step 2.a   - Do the write */
+	retval = mem_ap_write_buf_noincr(armv8->debug_ap,
+					tmp_buff, 4, total_u32, armv8->debug_base + CPUV8_DBG_DTRRX);
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+	/* Step 3.a   - Switch DTR mode back to Normal mode */
+	dscr = (dscr & ~DSCR_MA);
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+	/* Check for sticky abort flags in the DSCR */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_w;
+
+	dpm->dscr = dscr;
+	if (dscr & (DSCR_ERR | DSCR_SYS_ERROR_PEND)) {
+		/* Abort occurred - clear it and exit */
+		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
+		armv8_dpm_handle_exception(dpm);
+		goto error_free_buff_w;
+	}
+
+	/* Done */
+	free(tmp_buff);
+	return ERROR_OK;
+
+error_unset_dtr_w:
+	/* Unset DTR mode */
+	mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	dscr = (dscr & ~DSCR_MA);
+	mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+error_free_buff_w:
+	LOG_ERROR("error");
+	free(tmp_buff);
+	return ERROR_FAIL;
+}
+
+static int aarch64_read_apb_ap_memory(struct target *target,
+	target_addr_t address, uint32_t size,
+	uint32_t count, uint8_t *buffer)
+{
+	/* read memory through APB-AP */
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm_dpm *dpm = &armv8->dpm;
+	struct arm *arm = &armv8->arm;
+	int total_bytes = count * size;
+	int total_u32;
+	int start_byte = address & 0x3;
+	int end_byte   = (address + total_bytes) & 0x3;
+	struct reg *reg;
+	uint32_t dscr;
+	uint8_t *tmp_buff = NULL;
+	uint8_t *u8buf_ptr;
+	uint32_t value;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	total_u32 = DIV_ROUND_UP((address & 3) + total_bytes, 4);
+	/* Mark register X0, X1 as dirty, as it will be used
+	 * for transferring the data.
+	 * It will be restored automatically when exiting
+	 * debug mode
+	 */
+	reg = armv8_reg_current(arm, 1);
+	reg->dirty = true;
+
+	reg = armv8_reg_current(arm, 0);
+	reg->dirty = true;
+
+	/* Read DSCR */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+
+	/* This algorithm comes from DDI0487A.g, chapter J9.1 */
+
+	/* Set Normal access mode  */
+	dscr = (dscr & ~DSCR_MA);
+	retval +=  mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+
+	if (arm->core_state == ARM_STATE_AARCH64) {
+		/* Write X0 with value 'address' using write procedure */
+		/* Step 1.a+b - Write the address for read access into DBGDTR_EL0 */
+		/* Step 1.c   - Copy value from DTR to R0 using instruction mrs DBGDTR_EL0, x0 */
+		retval += dpm->instr_write_data_dcc_64(dpm,
+				ARMV8_MRS(SYSTEM_DBG_DBGDTR_EL0, 0), address & ~0x3ULL);
+		/* Step 1.d - Dummy operation to ensure EDSCR.Txfull == 1 */
+		retval += dpm->instr_execute(dpm, ARMV8_MSR_GP(SYSTEM_DBG_DBGDTR_EL0, 0));
+		/* Step 1.e - Change DCC to memory mode */
+		dscr = dscr | DSCR_MA;
+		retval +=  mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+		/* Step 1.f - read DBGDTRTX and discard the value */
+		retval += mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DTRTX, &value);
+	} else {
+		/* Write R0 with value 'address' using write procedure */
+		/* Step 1.a+b - Write the address for read access into DBGDTRRXint */
+		/* Step 1.c   - Copy value from DTR to R0 using instruction mrc DBGDTRTXint, r0 */
+		retval += dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, 0, 0, 5, 0), address & ~0x3ULL);
+		/* Step 1.d - Dummy operation to ensure EDSCR.Txfull == 1 */
+		retval += dpm->instr_execute(dpm, ARMV4_5_MCR(14, 0, 0, 0, 5, 0));
+		/* Step 1.e - Change DCC to memory mode */
+		dscr = dscr | DSCR_MA;
+		retval +=  mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+		/* Step 1.f - read DBGDTRTX and discard the value */
+		retval += mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DTRTX, &value);
+
+	}
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_r;
+
+	/* Optimize the read as much as we can, either way we read in a single pass  */
+	if ((start_byte) || (end_byte)) {
+		/* The algorithm only copies 32 bit words, so the buffer
+		 * should be expanded to include the words at either end.
+		 * The first and last words will be read into a temp buffer
+		 * to avoid corruption
+		 */
+		tmp_buff = malloc(total_u32 * 4);
+		if (!tmp_buff)
+			goto error_unset_dtr_r;
+
+		/* use the tmp buffer to read the entire data */
+		u8buf_ptr = tmp_buff;
+	} else
+		/* address and read length are aligned so read directly into the passed buffer */
+		u8buf_ptr = buffer;
+
+	/* Read the data - Each read of the DTRTX register causes the instruction to be reissued
+	 * Abort flags are sticky, so can be read at end of transactions
+	 *
+	 * This data is read in aligned to 32 bit boundary.
+	 */
+
+	/* Step 2.a - Loop n-1 times, each read of DBGDTRTX reads the data from [X0] and
+	 * increments X0 by 4. */
+	retval = mem_ap_read_buf_noincr(armv8->debug_ap, u8buf_ptr, 4, total_u32-1,
+									armv8->debug_base + CPUV8_DBG_DTRTX);
+	if (retval != ERROR_OK)
+			goto error_unset_dtr_r;
+
+	/* Step 3.a - set DTR access mode back to Normal mode	*/
+	dscr = (dscr & ~DSCR_MA);
+	retval =  mem_ap_write_atomic_u32(armv8->debug_ap,
+					armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_r;
+
+	/* Step 3.b - read DBGDTRTX for the final value */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DTRTX, &value);
+	memcpy(u8buf_ptr + (total_u32-1) * 4, &value, 4);
+
+	/* Check for sticky abort flags in the DSCR */
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_r;
+
+	dpm->dscr = dscr;
+
+	if (dscr & (DSCR_ERR | DSCR_SYS_ERROR_PEND)) {
+		/* Abort occurred - clear it and exit */
+		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
+		armv8_dpm_handle_exception(dpm);
+		goto error_free_buff_r;
+	}
+
+	/* check if we need to copy aligned data by applying any shift necessary */
+	if (tmp_buff) {
+		memcpy(buffer, tmp_buff + start_byte, total_bytes);
+		free(tmp_buff);
+	}
+
+	/* Done */
+	return ERROR_OK;
+
+error_unset_dtr_r:
+	/* Unset DTR mode */
+	mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+	dscr = (dscr & ~DSCR_MA);
+	mem_ap_write_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, dscr);
+error_free_buff_r:
+	LOG_ERROR("error");
+	free(tmp_buff);
+	return ERROR_FAIL;
+}
+
+static int aarch64_read_phys_memory(struct target *target,
+	target_addr_t address, uint32_t size,
+	uint32_t count, uint8_t *buffer)
+{
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (count && buffer) {
+		/* read memory through APB-AP */
+		retval = aarch64_mmu_modify(target, 0);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = aarch64_read_apb_ap_memory(target, address, size, count, buffer);
+	}
+	return retval;
+}
+
+static int aarch64_read_memory(struct target *target, target_addr_t address,
+	uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	int mmu_enabled = 0;
+	int retval;
+
+	/* determine if MMU was enabled on target stop */
+	retval = aarch64_mmu(target, &mmu_enabled);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mmu_enabled) {
+		/* enable MMU as we could have disabled it for phys access */
+		retval = aarch64_mmu_modify(target, 1);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	return aarch64_read_apb_ap_memory(target, address, size, count, buffer);
+}
+
+static int aarch64_write_phys_memory(struct target *target,
+	target_addr_t address, uint32_t size,
+	uint32_t count, const uint8_t *buffer)
+{
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (count && buffer) {
+		/* write memory through APB-AP */
+		retval = aarch64_mmu_modify(target, 0);
+		if (retval != ERROR_OK)
+			return retval;
+		return aarch64_write_apb_ap_memory(target, address, size, count, buffer);
+	}
+
+	return retval;
+}
+
+static int aarch64_write_memory(struct target *target, target_addr_t address,
+	uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	int mmu_enabled = 0;
+	int retval;
+
+	/* determine if MMU was enabled on target stop */
+	retval = aarch64_mmu(target, &mmu_enabled);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mmu_enabled) {
+		/* enable MMU as we could have disabled it for phys access */
+		retval = aarch64_mmu_modify(target, 1);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	return aarch64_write_apb_ap_memory(target, address, size, count, buffer);
+}
+
+static int aarch64_handle_target_request(void *priv)
+{
+	struct target *target = priv;
+	struct armv8_common *armv8 = target_to_armv8(target);
+	int retval;
+
+	if (!target_was_examined(target))
+		return ERROR_OK;
+	if (!target->dbg_msg_enabled)
+		return ERROR_OK;
+
+	if (target->state == TARGET_RUNNING) {
+		uint32_t request;
+		uint32_t dscr;
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+
+		/* check if we have data */
+		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
+			retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+					armv8->debug_base + CPUV8_DBG_DTRTX, &request);
+			if (retval == ERROR_OK) {
+				target_request(target, request);
+				retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+						armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int aarch64_examine_first(struct target *target)
+{
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+	struct adiv5_dap *swjdp = armv8->arm.dap;
+	uint32_t cti_base;
+	int i;
+	int retval = ERROR_OK;
+	uint64_t debug, ttypr;
+	uint32_t cpuid;
+	uint32_t tmp0, tmp1;
+	debug = ttypr = cpuid = 0;
+
+	retval = dap_dp_init(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Search for the APB-AB - it is needed for access to debug registers */
+	retval = dap_find_ap(swjdp, AP_TYPE_APB_AP, &armv8->debug_ap);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Could not find APB-AP for debug access");
+		return retval;
+	}
+
+	retval = mem_ap_init(armv8->debug_ap);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Could not initialize the APB-AP");
+		return retval;
+	}
+
+	armv8->debug_ap->memaccess_tck = 10;
+
+	if (!target->dbgbase_set) {
+		uint32_t dbgbase;
+		/* Get ROM Table base */
+		uint32_t apid;
+		int32_t coreidx = target->coreid;
+		retval = dap_get_debugbase(armv8->debug_ap, &dbgbase, &apid);
+		if (retval != ERROR_OK)
+			return retval;
+		/* Lookup 0x15 -- Processor DAP */
+		retval = dap_lookup_cs_component(armv8->debug_ap, dbgbase, 0x15,
+				&armv8->debug_base, &coreidx);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("Detected core %" PRId32 " dbgbase: %08" PRIx32
+				" apid: %08" PRIx32, coreidx, armv8->debug_base, apid);
+	} else
+		armv8->debug_base = target->dbgbase;
+
+	uint32_t prsr;
+	int64_t then = timeval_ms();
+	do {
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_PRSR, &prsr);
+		if (retval == ERROR_OK) {
+			retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+					armv8->debug_base + CPUV8_DBG_PRCR, PRCR_COREPURQ|PRCR_CORENPDRQ);
+			if (retval != ERROR_OK) {
+				LOG_DEBUG("write to PRCR failed");
+				break;
+			}
+		}
+
+		if (timeval_ms() > then + 1000) {
+			retval = ERROR_TARGET_TIMEOUT;
+			break;
+		}
+
+	} while ((prsr & PRSR_PU) == 0);
+
+	if (retval != ERROR_OK) {
+		LOG_ERROR("target %s: failed to set power state of the core.", target_name(target));
+		return retval;
+	}
+
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_OSLAR, 0);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "oslock");
+		return retval;
+	}
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_MAINID0, &cpuid);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "CPUID");
+		return retval;
+	}
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_MEMFEATURE0, &tmp0);
+	retval += mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_MEMFEATURE0 + 4, &tmp1);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "Memory Model Type");
+		return retval;
+	}
+	ttypr |= tmp1;
+	ttypr = (ttypr << 32) | tmp0;
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DBGFEATURE0, &tmp0);
+	retval += mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DBGFEATURE0 + 4, &tmp1);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "ID_AA64DFR0_EL1");
+		return retval;
+	}
+	debug |= tmp1;
+	debug = (debug << 32) | tmp0;
+
+	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
+	LOG_DEBUG("ttypr = 0x%08" PRIx64, ttypr);
+	LOG_DEBUG("debug = 0x%08" PRIx64, debug);
+
+	if (target->ctibase == 0) {
+		/* assume a v8 rom table layout */
+		cti_base = armv8->debug_base + 0x10000;
+		LOG_INFO("Target ctibase is not set, assuming 0x%0" PRIx32, cti_base);
+	} else
+		cti_base = target->ctibase;
+
+	armv8->cti = arm_cti_create(armv8->debug_ap, cti_base);
+	if (armv8->cti == NULL)
+		return ERROR_FAIL;
+
+	retval = aarch64_dpm_setup(aarch64, debug);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Setup Breakpoint Register Pairs */
+	aarch64->brp_num = (uint32_t)((debug >> 12) & 0x0F) + 1;
+	aarch64->brp_num_context = (uint32_t)((debug >> 28) & 0x0F) + 1;
+	aarch64->brp_num_available = aarch64->brp_num;
+	aarch64->brp_list = calloc(aarch64->brp_num, sizeof(struct aarch64_brp));
+	for (i = 0; i < aarch64->brp_num; i++) {
+		aarch64->brp_list[i].used = 0;
+		if (i < (aarch64->brp_num-aarch64->brp_num_context))
+			aarch64->brp_list[i].type = BRP_NORMAL;
+		else
+			aarch64->brp_list[i].type = BRP_CONTEXT;
+		aarch64->brp_list[i].value = 0;
+		aarch64->brp_list[i].control = 0;
+		aarch64->brp_list[i].BRPn = i;
+	}
+
+	LOG_DEBUG("Configured %i hw breakpoints", aarch64->brp_num);
+
+	target->state = TARGET_RUNNING;
+	target->debug_reason = DBG_REASON_NOTHALTED;
+
+	target_set_examined(target);
+	return ERROR_OK;
+}
+
+static int aarch64_examine(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	/* don't re-probe hardware after each reset */
+	if (!target_was_examined(target))
+		retval = aarch64_examine_first(target);
+
+	/* Configure core debug access */
+	if (retval == ERROR_OK)
+		retval = aarch64_init_debug_access(target);
+
+	return retval;
+}
+
+/*
+ *	Cortex-A8 target creation and initialization
+ */
+
+static int aarch64_init_target(struct command_context *cmd_ctx,
+	struct target *target)
+{
+	/* examine_first() does a bunch of this */
+	return ERROR_OK;
+}
+
+static int aarch64_init_arch_info(struct target *target,
+	struct aarch64_common *aarch64, struct jtag_tap *tap)
+{
+	struct armv8_common *armv8 = &aarch64->armv8_common;
+
+	/* Setup struct aarch64_common */
+	aarch64->common_magic = AARCH64_COMMON_MAGIC;
+	/*  tap has no dap initialized */
+	if (!tap->dap) {
+		tap->dap = dap_init();
+		tap->dap->tap = tap;
+	}
+	armv8->arm.dap = tap->dap;
+
+	/* register arch-specific functions */
+	armv8->examine_debug_reason = NULL;
+	armv8->post_debug_entry = aarch64_post_debug_entry;
+	armv8->pre_restore_context = NULL;
+	armv8->armv8_mmu.read_physical_memory = aarch64_read_phys_memory;
+
+	armv8_init_arch_info(target, armv8);
+	target_register_timer_callback(aarch64_handle_target_request, 1, 1, target);
+
+	return ERROR_OK;
+}
+
+static int aarch64_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct aarch64_common *aarch64 = calloc(1, sizeof(struct aarch64_common));
+
+	return aarch64_init_arch_info(target, aarch64, target->tap);
+}
+
+static int aarch64_mmu(struct target *target, int *enabled)
+{
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("%s: target %s not halted", __func__, target_name(target));
+		return ERROR_TARGET_INVALID;
+	}
+
+	*enabled = target_to_aarch64(target)->armv8_common.armv8_mmu.mmu_enabled;
+	return ERROR_OK;
+}
+
+static int aarch64_virt2phys(struct target *target, target_addr_t virt,
+			     target_addr_t *phys)
+{
+	return armv8_mmu_translate_va_pa(target, virt, phys, 1);
+}
+
+COMMAND_HANDLER(aarch64_handle_cache_info_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct armv8_common *armv8 = target_to_armv8(target);
+
+	return armv8_handle_cache_info_command(CMD_CTX,
+			&armv8->armv8_mmu.armv8_cache);
+}
+
+
+COMMAND_HANDLER(aarch64_handle_dbginit_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	if (!target_was_examined(target)) {
+		LOG_ERROR("target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	return aarch64_init_debug_access(target);
+}
+COMMAND_HANDLER(aarch64_handle_smp_off_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	/* check target is an smp target */
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	target->smp = 0;
+	if (head != (struct target_list *)NULL) {
+		while (head != (struct target_list *)NULL) {
+			curr = head->target;
+			curr->smp = 0;
+			head = head->next;
+		}
+		/*  fixes the target display to the debugger */
+		target->gdb_service->target = target;
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(aarch64_handle_smp_on_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	if (head != (struct target_list *)NULL) {
+		target->smp = 1;
+		while (head != (struct target_list *)NULL) {
+			curr = head->target;
+			curr->smp = 1;
+			head = head->next;
+		}
+	}
+	return ERROR_OK;
+}
+
+static const struct command_registration aarch64_exec_command_handlers[] = {
+	{
+		.name = "cache_info",
+		.handler = aarch64_handle_cache_info_command,
+		.mode = COMMAND_EXEC,
+		.help = "display information about target caches",
+		.usage = "",
+	},
+	{
+		.name = "dbginit",
+		.handler = aarch64_handle_dbginit_command,
+		.mode = COMMAND_EXEC,
+		.help = "Initialize core debug",
+		.usage = "",
+	},
+	{	.name = "smp_off",
+		.handler = aarch64_handle_smp_off_command,
+		.mode = COMMAND_EXEC,
+		.help = "Stop smp handling",
+		.usage = "",
+	},
+	{
+		.name = "smp_on",
+		.handler = aarch64_handle_smp_on_command,
+		.mode = COMMAND_EXEC,
+		.help = "Restart smp handling",
+		.usage = "",
+	},
+
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration aarch64_command_handlers[] = {
+	{
+		.chain = armv8_command_handlers,
+	},
+	{
+		.name = "aarch64",
+		.mode = COMMAND_ANY,
+		.help = "Aarch64 command group",
+		.usage = "",
+		.chain = aarch64_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct target_type aarch64_target = {
+	.name = "aarch64",
+
+	.poll = aarch64_poll,
+	.arch_state = armv8_arch_state,
+
+	.halt = aarch64_halt,
+	.resume = aarch64_resume,
+	.step = aarch64_step,
+
+	.assert_reset = aarch64_assert_reset,
+	.deassert_reset = aarch64_deassert_reset,
+
+	/* REVISIT allow exporting VFP3 registers ... */
+	.get_gdb_reg_list = armv8_get_gdb_reg_list,
+
+	.read_memory = aarch64_read_memory,
+	.write_memory = aarch64_write_memory,
+
+	.add_breakpoint = aarch64_add_breakpoint,
+	.add_context_breakpoint = aarch64_add_context_breakpoint,
+	.add_hybrid_breakpoint = aarch64_add_hybrid_breakpoint,
+	.remove_breakpoint = aarch64_remove_breakpoint,
+	.add_watchpoint = NULL,
+	.remove_watchpoint = NULL,
+
+	.commands = aarch64_command_handlers,
+	.target_create = aarch64_target_create,
+	.init_target = aarch64_init_target,
+	.examine = aarch64_examine,
+
+	.read_phys_memory = aarch64_read_phys_memory,
+	.write_phys_memory = aarch64_write_phys_memory,
+	.mmu = aarch64_mmu,
+	.virt2phys = aarch64_virt2phys,
+};
diff --git a/src/target/aarch64.h b/src/target/aarch64.h
new file mode 100644
index 00000000..c9ec02db
--- /dev/null
+++ b/src/target/aarch64.h
@@ -0,0 +1,69 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by David Ung                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ ***************************************************************************/
+
+#ifndef OPENOCD_TARGET_AARCH64_H
+#define OPENOCD_TARGET_AARCH64_H
+
+#include "armv8.h"
+
+#define AARCH64_COMMON_MAGIC 0x411fc082
+
+#define CPUDBG_CPUID	0xD00
+#define CPUDBG_CTYPR	0xD04
+#define CPUDBG_TTYPR	0xD0C
+#define ID_AA64PFR0_EL1	0xD20
+#define ID_AA64DFR0_EL1	0xD28
+#define CPUDBG_LOCKACCESS 0xFB0
+#define CPUDBG_LOCKSTATUS 0xFB4
+
+#define BRP_NORMAL 0
+#define BRP_CONTEXT 1
+
+#define AARCH64_PADDRDBG_CPU_SHIFT 13
+
+struct aarch64_brp {
+	int used;
+	int type;
+	target_addr_t value;
+	uint32_t control;
+	uint8_t BRPn;
+};
+
+struct aarch64_common {
+	int common_magic;
+
+	/* Context information */
+	uint32_t system_control_reg;
+	uint32_t system_control_reg_curr;
+
+	/* Breakpoint register pairs */
+	int brp_num_context;
+	int brp_num;
+	int brp_num_available;
+	struct aarch64_brp *brp_list;
+
+	struct armv8_common armv8_common;
+};
+
+static inline struct aarch64_common *
+target_to_aarch64(struct target *target)
+{
+	return container_of(target->arch_info, struct aarch64_common, armv8_common.arm);
+}
+
+#endif /* OPENOCD_TARGET_AARCH64_H */
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index af19f50b..c7dc4f7c 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -21,9 +21,7 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the
- *   Free Software Foundation, Inc.,
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
  ***************************************************************************/
 
 /**
@@ -39,6 +37,9 @@
 #include "arm.h"
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
+#include <helper/list.h>
+
+/*#define DEBUG_WAIT*/
 
 /* JTAG instructions/registers for JTAG-DP and SWJ-DP */
 #define JTAG_DP_ABORT		0x8
@@ -52,12 +53,198 @@
 
 static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack);
 
+#ifdef DEBUG_WAIT
+static const char *dap_reg_name(int instr, int reg_addr)
+{
+	char *reg_name = "UNK";
+
+	if (instr == JTAG_DP_DPACC) {
+		switch (reg_addr) {
+		case DP_ABORT:
+			reg_name =  "ABORT";
+			break;
+		case DP_CTRL_STAT:
+			reg_name =  "CTRL/STAT";
+			break;
+		case DP_SELECT:
+			reg_name = "SELECT";
+			break;
+		case DP_RDBUFF:
+			reg_name =  "RDBUFF";
+			break;
+		case DP_WCR:
+			reg_name =  "WCR";
+			break;
+		default:
+			reg_name = "UNK";
+			break;
+		}
+	}
+
+	if (instr == JTAG_DP_APACC) {
+		switch (reg_addr) {
+		case MEM_AP_REG_CSW:
+			reg_name = "CSW";
+			break;
+		case MEM_AP_REG_TAR:
+			reg_name = "TAR";
+			break;
+		case MEM_AP_REG_DRW:
+			reg_name = "DRW";
+			break;
+		case MEM_AP_REG_BD0:
+			reg_name = "BD0";
+			break;
+		case MEM_AP_REG_BD1:
+			reg_name = "BD1";
+			break;
+		case MEM_AP_REG_BD2:
+			reg_name = "BD2";
+			break;
+		case MEM_AP_REG_BD3:
+			reg_name = "BD3";
+			break;
+		case MEM_AP_REG_CFG:
+			reg_name = "CFG";
+			break;
+		case MEM_AP_REG_BASE:
+			reg_name = "BASE";
+			break;
+		case AP_REG_IDR:
+			reg_name = "IDR";
+			break;
+		default:
+			reg_name = "UNK";
+			break;
+		}
+	}
+
+	return reg_name;
+}
+#endif
+
+struct dap_cmd {
+	struct list_head lh;
+	uint8_t instr;
+	uint8_t reg_addr;
+	uint8_t RnW;
+	uint8_t *invalue;
+	uint8_t ack;
+	uint32_t memaccess_tck;
+	uint32_t dp_select;
+
+	struct scan_field fields[2];
+	uint8_t out_addr_buf;
+	uint8_t invalue_buf[4];
+	uint8_t outvalue_buf[4];
+};
+
+static void log_dap_cmd(const char *header, struct dap_cmd *el)
+{
+#ifdef DEBUG_WAIT
+	LOG_DEBUG("%s: %2s %6s %5s 0x%08x 0x%08x %2s", header,
+		el->instr == JTAG_DP_APACC ? "AP" : "DP",
+		dap_reg_name(el->instr, el->reg_addr),
+		el->RnW == DPAP_READ ? "READ" : "WRITE",
+		buf_get_u32(el->outvalue_buf, 0, 32),
+		buf_get_u32(el->invalue, 0, 32),
+		el->ack == JTAG_ACK_OK_FAULT ? "OK" :
+			(el->ack == JTAG_ACK_WAIT ? "WAIT" : "INVAL"));
+#endif
+}
+
+static struct dap_cmd *dap_cmd_new(uint8_t instr,
+		uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue,
+		uint32_t memaccess_tck)
+{
+	struct dap_cmd *cmd;
+
+	cmd = (struct dap_cmd *)calloc(1, sizeof(struct dap_cmd));
+	if (cmd != NULL) {
+		INIT_LIST_HEAD(&cmd->lh);
+		cmd->instr = instr;
+		cmd->reg_addr = reg_addr;
+		cmd->RnW = RnW;
+		if (outvalue != NULL)
+			memcpy(cmd->outvalue_buf, outvalue, 4);
+		cmd->invalue = (invalue != NULL) ? invalue : cmd->invalue_buf;
+		cmd->memaccess_tck = memaccess_tck;
+	}
+
+	return cmd;
+}
+
+static void flush_journal(struct list_head *lh)
+{
+	struct dap_cmd *el, *tmp;
+
+	list_for_each_entry_safe(el, tmp, lh, lh) {
+		list_del(&el->lh);
+		free(el);
+	}
+}
+
 /***************************************************************************
  *
  * DPACC and APACC scanchain access through JTAG-DP (or SWJ-DP)
  *
 ***************************************************************************/
 
+static int adi_jtag_dp_scan_cmd(struct adiv5_dap *dap, struct dap_cmd *cmd, uint8_t *ack)
+{
+	struct jtag_tap *tap = dap->tap;
+	int retval;
+
+	retval = arm_jtag_set_instr(tap, cmd->instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Scan out a read or write operation using some DP or AP register.
+	 * For APACC access with any sticky error flag set, this is discarded.
+	 */
+	cmd->fields[0].num_bits = 3;
+	buf_set_u32(&cmd->out_addr_buf, 0, 3, ((cmd->reg_addr >> 1) & 0x6) | (cmd->RnW & 0x1));
+	cmd->fields[0].out_value = &cmd->out_addr_buf;
+	cmd->fields[0].in_value = (ack != NULL) ? ack : &cmd->ack;
+
+	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
+	 * complete; data we write is discarded, data we read is unpredictable.
+	 * When overrun detect is active, STICKYORUN is set.
+	 */
+
+	cmd->fields[1].num_bits = 32;
+	cmd->fields[1].out_value = cmd->outvalue_buf;
+	cmd->fields[1].in_value = cmd->invalue;
+
+	jtag_add_dr_scan(tap, 2, cmd->fields, TAP_IDLE);
+
+	/* Add specified number of tck clocks after starting memory bus
+	 * access, giving the hardware time to complete the access.
+	 * They provide more time for the (MEM) AP to complete the read ...
+	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
+	 */
+	if (cmd->instr == JTAG_DP_APACC) {
+		if (((cmd->reg_addr == MEM_AP_REG_DRW)
+			|| ((cmd->reg_addr & 0xF0) == MEM_AP_REG_BD0))
+			&& (cmd->memaccess_tck != 0))
+			jtag_add_runtest(cmd->memaccess_tck, TAP_IDLE);
+	}
+
+	return ERROR_OK;
+}
+
+static int adi_jtag_dp_scan_cmd_sync(struct adiv5_dap *dap, struct dap_cmd *cmd, uint8_t *ack)
+{
+	int retval;
+
+	retval = adi_jtag_dp_scan_cmd(dap, cmd, ack);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return jtag_execute_queue();
+}
+
 /**
  * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
  * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
@@ -80,49 +267,23 @@ static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack);
 
 static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack,
-		uint32_t memaccess_tck)
+		uint8_t *outvalue, uint8_t *invalue,
+		uint32_t memaccess_tck, uint8_t *ack)
 {
-	struct jtag_tap *tap = dap->tap;
-	struct scan_field fields[2];
-	uint8_t out_addr_buf;
+	struct dap_cmd *cmd;
 	int retval;
 
-	retval = arm_jtag_set_instr(tap, instr, NULL, TAP_IDLE);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Scan out a read or write operation using some DP or AP register.
-	 * For APACC access with any sticky error flag set, this is discarded.
-	 */
-	fields[0].num_bits = 3;
-	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
-	fields[0].out_value = &out_addr_buf;
-	fields[0].in_value = ack;
-
-	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
-	 * complete; data we write is discarded, data we read is unpredictable.
-	 * When overrun detect is active, STICKYORUN is set.
-	 */
-
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].in_value = invalue;
-
-	jtag_add_dr_scan(tap, 2, fields, TAP_IDLE);
+	cmd = dap_cmd_new(instr, reg_addr, RnW, outvalue, invalue, memaccess_tck);
+	if (cmd != NULL)
+		cmd->dp_select = dap->select;
+	else
+		return ERROR_JTAG_DEVICE_ERROR;
 
-	/* Add specified number of tck clocks after starting memory bus
-	 * access, giving the hardware time to complete the access.
-	 * They provide more time for the (MEM) AP to complete the read ...
-	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == MEM_AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == MEM_AP_REG_BD0))
-			&& memaccess_tck != 0)
-		jtag_add_runtest(memaccess_tck, TAP_IDLE);
+	retval = adi_jtag_dp_scan_cmd(dap, cmd, ack);
+	if (retval == ERROR_OK)
+		list_add_tail(&cmd->lh,	&dap->cmd_journal);
 
-	return ERROR_OK;
+	return retval;
 }
 
 /**
@@ -133,8 +294,8 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
  */
 static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue, uint8_t *ack,
-		uint32_t memaccess_tck)
+		uint32_t outvalue, uint32_t *invalue,
+		uint32_t memaccess_tck, uint8_t *ack)
 {
 	uint8_t out_value_buf[4];
 	int retval;
@@ -142,7 +303,7 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 	buf_set_u32(out_value_buf, 0, 32, outvalue);
 
 	retval = adi_jtag_dp_scan(dap, instr, reg_addr, RnW,
-			out_value_buf, (uint8_t *)invalue, ack, memaccess_tck);
+			out_value_buf, (uint8_t *)invalue, memaccess_tck, ack);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -153,13 +314,17 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 	return retval;
 }
 
-static void adi_jtag_finish_read(struct adiv5_dap *dap)
+static int adi_jtag_finish_read(struct adiv5_dap *dap)
 {
+	int retval = ERROR_OK;
+
 	if (dap->last_read != NULL) {
-		adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, dap->last_read, &dap->ack, 0);
+		retval = adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, dap->last_read, 0, NULL);
 		dap->last_read = NULL;
 	}
+
+	return retval;
 }
 
 static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *dap,
@@ -170,143 +335,265 @@ static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *dap,
 
 	/* Issue the read or write */
 	retval = adi_jtag_dp_scan_u32(dap, instr, reg_addr,
-			RnW, outvalue, NULL, NULL, memaccess_tck);
+			RnW, outvalue, NULL, memaccess_tck, NULL);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* For reads,  collect posted value; RDBUFF has no other effect.
 	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
 	 */
-	if ((RnW == DPAP_READ) && (invalue != NULL))
+	if ((RnW == DPAP_READ) && (invalue != NULL)) {
 		retval = adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &dap->ack, 0);
-	return retval;
+				DP_RDBUFF, DPAP_READ, 0, invalue, 0, NULL);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return jtag_execute_queue();
 }
 
-static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
+static int jtagdp_overrun_check(struct adiv5_dap *dap)
 {
 	int retval;
-	uint32_t ctrlstat;
+	struct dap_cmd *el, *tmp, *prev = NULL;
+	int found_wait = 0;
+	int64_t time_now;
+	LIST_HEAD(replay_list);
 
-	/* too expensive to call keep_alive() here */
+	/* make sure all queued transactions are complete */
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* skip all completed transactions up to the first WAIT */
+	list_for_each_entry(el, &dap->cmd_journal, lh) {
+		if (el->ack == JTAG_ACK_OK_FAULT) {
+			log_dap_cmd("LOG", el);
+		} else if (el->ack == JTAG_ACK_WAIT) {
+			found_wait = 1;
+			break;
+		} else {
+			LOG_ERROR("Invalid ACK (%1x) in DAP response", el->ack);
+			log_dap_cmd("ERR", el);
+			retval = ERROR_JTAG_DEVICE_ERROR;
+			goto done;
+		}
+	}
 
-	/* Here be dragons!
-	 *
-	 * It is easy to be in a JTAG clock range where the target
-	 * is not operating in a stable fashion. This happens
-	 * for a few reasons:
-	 *
-	 * - the user may construct a simple test case to try to see
-	 * if a higher JTAG clock works to eke out more performance.
-	 * This simple case may pass, but more complex situations can
-	 * fail.
-	 *
-	 * - The mostly works JTAG clock rate and the complete failure
-	 * JTAG clock rate may be as much as 2-4x apart. This seems
-	 * to be especially true on RC oscillator driven parts.
-	 *
-	 * So: even if calling adi_jtag_scan_inout_check_u32() multiple
-	 * times here seems to "make things better here", it is just
-	 * hiding problems with too high a JTAG clock.
-	 *
-	 * Note that even if some parts have RCLK/RTCK, that doesn't
-	 * mean that RCLK/RTCK is the *correct* rate to run the JTAG
-	 * interface at, i.e. RCLK/RTCK rates can be "too high", especially
-	 * before the RC oscillator phase is not yet complete.
+	/*
+	 * If we found a stalled transaction and a previous transaction
+	 * exists, check if it's a READ access.
 	 */
+	if (found_wait && el != list_first_entry(&dap->cmd_journal, struct dap_cmd, lh)) {
+		prev = list_entry(el->lh.prev, struct dap_cmd, lh);
+		if (prev->RnW == DPAP_READ) {
+			log_dap_cmd("PND", prev);
+			/* search for the next OK transaction, it contains
+			 * the result of the previous READ */
+			tmp = el;
+			list_for_each_entry_from(tmp, &dap->cmd_journal, lh) {
+				if (tmp->ack == JTAG_ACK_OK_FAULT) {
+					/* recover the read value */
+					log_dap_cmd("FND", tmp);
+					if (el->invalue != el->invalue_buf) {
+						uint32_t invalue = le_to_h_u32(tmp->invalue);
+						memcpy(el->invalue, &invalue, sizeof(uint32_t));
+					}
+					prev = NULL;
+					break;
+				}
+			}
 
-	/* Post CTRL/STAT read; discard any previous posted read value
-	 * but collect its ACK status.
-	 */
-	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = jtag_execute_queue();
-	if (retval != ERROR_OK)
-		return retval;
+			if (prev != NULL) {
+				log_dap_cmd("LST", el);
+
+				/*
+				* At this point we're sure that no previous
+				* transaction completed and the DAP/AP is still
+				* in busy state. We know that the next "OK" scan
+				* will return the READ result we need to recover.
+				* To complete the READ, we just keep polling RDBUFF
+				* until the WAIT condition clears
+				*/
+				tmp = dap_cmd_new(JTAG_DP_DPACC,
+						DP_RDBUFF, DPAP_READ, NULL, NULL, 0);
+				if (tmp == NULL) {
+					retval = ERROR_JTAG_DEVICE_ERROR;
+					goto done;
+				}
+				/* synchronously retry the command until it succeeds */
+				time_now = timeval_ms();
+				do {
+					retval = adi_jtag_dp_scan_cmd_sync(dap, tmp, NULL);
+					if (retval != ERROR_OK)
+						break;
+					if (tmp->ack == JTAG_ACK_OK_FAULT) {
+						log_dap_cmd("FND", tmp);
+						if (el->invalue != el->invalue_buf) {
+							uint32_t invalue = le_to_h_u32(tmp->invalue);
+							memcpy(el->invalue, &invalue, sizeof(uint32_t));
+						}
+						break;
+					}
+					if (tmp->ack != JTAG_ACK_WAIT) {
+						LOG_ERROR("Invalid ACK (%1x) in DAP response", tmp->ack);
+						log_dap_cmd("ERR", tmp);
+						retval = ERROR_JTAG_DEVICE_ERROR;
+						break;
+					}
+
+				} while (timeval_ms() - time_now < 1000);
+
+				if (retval == ERROR_OK) {
+					/* timeout happened */
+					if (tmp->ack != JTAG_ACK_OK_FAULT) {
+						LOG_ERROR("Timeout during WAIT recovery");
+						dap->select = DP_SELECT_INVALID;
+						jtag_ap_q_abort(dap, NULL);
+						/* clear the sticky overrun condition */
+						adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+							DP_CTRL_STAT, DPAP_WRITE,
+							dap->dp_ctrl_stat | SSTICKYORUN, NULL, 0);
+						retval = ERROR_JTAG_DEVICE_ERROR;
+					}
+				}
 
-	dap->ack = dap->ack & 0x7;
+				/* we're done with this command, release it */
+				free(tmp);
 
-	/* common code path avoids calling timeval_ms() */
-	if (dap->ack != JTAG_ACK_OK_FAULT) {
-		long long then = timeval_ms();
+				if (retval != ERROR_OK)
+					goto done;
 
-		while (dap->ack != JTAG_ACK_OK_FAULT) {
-			if (dap->ack == JTAG_ACK_WAIT) {
-				if ((timeval_ms()-then) > 1000) {
-					LOG_WARNING("Timeout (1000ms) waiting "
-						"for ACK=OK/FAULT "
-						"in JTAG-DP transaction - aborting");
+			}
+			/* make el->invalue point to the default invalue
+			* so that we can safely retry it without clobbering
+			* the result we just recovered */
+			el->invalue = el->invalue_buf;
+		}
+	}
 
-					uint8_t ack;
-					int abort_ret = jtag_ap_q_abort(dap, &ack);
+	/* move all remaining transactions over to the replay list */
+	list_for_each_entry_safe_from(el, tmp, &dap->cmd_journal, lh) {
+		log_dap_cmd("REP", el);
+		list_move_tail(&el->lh, &replay_list);
+	}
 
-					if (abort_ret != 0)
-						LOG_WARNING("Abort failed : return=%d ack=%d", abort_ret, ack);
+	/* we're done with the journal, flush it */
+	flush_journal(&dap->cmd_journal);
 
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			} else {
-				LOG_WARNING("Invalid ACK %#x "
-						"in JTAG-DP transaction",
-						dap->ack);
-				return ERROR_JTAG_DEVICE_ERROR;
+	/* check for overrun condition in the last batch of transactions */
+	if (found_wait) {
+		LOG_INFO("DAP transaction stalled (WAIT) - slowing down");
+		/* clear the sticky overrun condition */
+		retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+				DP_CTRL_STAT, DPAP_WRITE,
+				dap->dp_ctrl_stat | SSTICKYORUN, NULL, 0);
+		if (retval != ERROR_OK)
+			goto done;
+
+		/* restore SELECT register first */
+		if (!list_empty(&replay_list)) {
+			el = list_first_entry(&replay_list, struct dap_cmd, lh);
+			tmp = dap_cmd_new(JTAG_DP_DPACC,
+					  DP_SELECT, DPAP_WRITE, (uint8_t *)&el->dp_select, NULL, 0);
+			if (tmp == NULL) {
+				retval = ERROR_JTAG_DEVICE_ERROR;
+				goto done;
 			}
+			list_add(&tmp->lh, &replay_list);
 
-			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat, 0);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = jtag_execute_queue();
-			if (retval != ERROR_OK)
-				return retval;
-			dap->ack = dap->ack & 0x7;
+			dap->select = DP_SELECT_INVALID;
+		}
+
+		list_for_each_entry_safe(el, tmp, &replay_list, lh) {
+			time_now = timeval_ms();
+			do {
+				retval = adi_jtag_dp_scan_cmd_sync(dap, el, NULL);
+				if (retval != ERROR_OK)
+					break;
+				log_dap_cmd("REC", el);
+				if (el->ack == JTAG_ACK_OK_FAULT) {
+					if (el->invalue != el->invalue_buf) {
+						uint32_t invalue = le_to_h_u32(el->invalue);
+						memcpy(el->invalue, &invalue, sizeof(uint32_t));
+					}
+					break;
+				}
+				if (el->ack != JTAG_ACK_WAIT) {
+					LOG_ERROR("Invalid ACK (%1x) in DAP response", el->ack);
+					log_dap_cmd("ERR", el);
+					retval = ERROR_JTAG_DEVICE_ERROR;
+					break;
+				}
+			} while (timeval_ms() - time_now < 1000);
+
+			if (retval == ERROR_OK) {
+				if (el->ack != JTAG_ACK_OK_FAULT) {
+					LOG_ERROR("Timeout during WAIT recovery");
+					dap->select = DP_SELECT_INVALID;
+					jtag_ap_q_abort(dap, NULL);
+					/* clear the sticky overrun condition */
+					adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+						DP_CTRL_STAT, DPAP_WRITE,
+						dap->dp_ctrl_stat | SSTICKYORUN, NULL, 0);
+					retval = ERROR_JTAG_DEVICE_ERROR;
+					break;
+				}
+			} else
+				break;
 		}
 	}
 
+ done:
+	flush_journal(&replay_list);
+	flush_journal(&dap->cmd_journal);
+	return retval;
+}
+
+static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
+{
+	int retval;
+	uint32_t ctrlstat;
+
+	/* too expensive to call keep_alive() here */
+
+	/* Post CTRL/STAT read; discard any previous posted read value
+	 * but collect its ACK status.
+	 */
+	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat, 0);
+	if (retval != ERROR_OK)
+		goto done;
+
 	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
 
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat & (SSTICKYORUN | SSTICKYERR)) {
-		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
+	/* Check for STICKYERR */
+	if (ctrlstat & SSTICKYERR) {
+		LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
 		/* Check power to debug regions */
 		if ((ctrlstat & (CDBGPWRUPREQ | CDBGPWRUPACK | CSYSPWRUPREQ | CSYSPWRUPACK)) !=
 						(CDBGPWRUPREQ | CDBGPWRUPACK | CSYSPWRUPREQ | CSYSPWRUPACK)) {
 			LOG_ERROR("Debug regions are unpowered, an unexpected reset might have happened");
-			return ERROR_JTAG_DEVICE_ERROR;
-		} else {
-			if (ctrlstat & SSTICKYORUN)
-				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
-					"memaccess, or reduce jtag speed");
-
-			if (ctrlstat & SSTICKYERR)
-				LOG_ERROR("JTAG-DP STICKY ERROR");
-
-			/* Clear Sticky Error Bits */
-			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					dap->dp_ctrl_stat | CDBGPWRUPREQ | CSYSPWRUPREQ | SSTICKYORUN
-						| SSTICKYERR, NULL, 0);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat, 0);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = jtag_execute_queue();
-			if (retval != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
 		}
-		retval = jtag_execute_queue();
+
+		if (ctrlstat & SSTICKYERR)
+			LOG_ERROR("JTAG-DP STICKY ERROR");
+		if (ctrlstat & SSTICKYORUN)
+			LOG_DEBUG("JTAG-DP STICKY OVERRUN");
+
+		/* Clear Sticky Error Bits */
+		retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+				DP_CTRL_STAT, DPAP_WRITE,
+				dap->dp_ctrl_stat | SSTICKYERR, NULL, 0);
 		if (retval != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
+			goto done;
+
+		retval = ERROR_JTAG_DEVICE_ERROR;
 	}
 
-	return ERROR_OK;
+ done:
+	flush_journal(&dap->cmd_journal);
+	return retval;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -315,7 +602,7 @@ static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
 	int retval =  adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC, reg,
-			DPAP_READ, 0, dap->last_read, &dap->ack, 0);
+			DPAP_READ, 0, dap->last_read, 0, NULL);
 	dap->last_read = data;
 	return retval;
 }
@@ -324,7 +611,7 @@ static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
 	int retval =  adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_WRITE, data, dap->last_read, &dap->ack, 0);
+			reg, DPAP_WRITE, data, dap->last_read, 0, NULL);
 	dap->last_read = NULL;
 	return retval;
 }
@@ -351,8 +638,7 @@ static int jtag_ap_q_read(struct adiv5_ap *ap, unsigned reg,
 		return retval;
 
 	retval =  adi_jtag_dp_scan_u32(ap->dap, JTAG_DP_APACC, reg,
-			DPAP_READ, 0, ap->dap->last_read, &ap->dap->ack,
-			ap->memaccess_tck);
+			DPAP_READ, 0, ap->dap->last_read, ap->memaccess_tck, NULL);
 	ap->dap->last_read = data;
 
 	return retval;
@@ -366,8 +652,7 @@ static int jtag_ap_q_write(struct adiv5_ap *ap, unsigned reg,
 		return retval;
 
 	retval =  adi_jtag_dp_scan_u32(ap->dap, JTAG_DP_APACC, reg,
-			DPAP_WRITE, data, ap->dap->last_read, &ap->dap->ack,
-			ap->memaccess_tck);
+			DPAP_WRITE, data, ap->dap->last_read, ap->memaccess_tck, NULL);
 	ap->dap->last_read = NULL;
 	return retval;
 }
@@ -375,14 +660,32 @@ static int jtag_ap_q_write(struct adiv5_ap *ap, unsigned reg,
 static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	/* for JTAG, this is the only valid ABORT register operation */
-	return adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
-			0, DPAP_WRITE, 1, NULL, ack, 0);
+	int retval =  adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
+			0, DPAP_WRITE, 1, NULL, 0, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return jtag_execute_queue();
 }
 
 static int jtag_dp_run(struct adiv5_dap *dap)
 {
-	adi_jtag_finish_read(dap);
-	return jtagdp_transaction_endcheck(dap);
+	int retval;
+	int retval2 = ERROR_OK;
+
+	retval = adi_jtag_finish_read(dap);
+	if (retval != ERROR_OK)
+		goto done;
+	retval2 = jtagdp_overrun_check(dap);
+	retval = jtagdp_transaction_endcheck(dap);
+
+ done:
+	return (retval2 != ERROR_OK) ? retval2 : retval;
+}
+
+static int jtag_dp_sync(struct adiv5_dap *dap)
+{
+	return jtagdp_overrun_check(dap);
 }
 
 /* FIXME don't export ... just initialize as
@@ -395,6 +698,7 @@ const struct dap_ops jtag_dp_ops = {
 	.queue_ap_write      = jtag_ap_q_write,
 	.queue_ap_abort      = jtag_ap_q_abort,
 	.run                 = jtag_dp_run,
+	.sync                = jtag_dp_sync,
 };
 
 
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index 6990a8b9..41ddbd78 100644
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.
  *
  *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the
- *   Free Software Foundation, Inc.,
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
  ***************************************************************************/
 
 /**
@@ -99,24 +97,36 @@ static int swd_run_inner(struct adiv5_dap *dap)
 
 static int swd_connect(struct adiv5_dap *dap)
 {
-	uint32_t idcode;
+	uint32_t dpidr;
 	int status;
 
 	/* FIXME validate transport config ... is the
 	 * configured DAP present (check IDCODE)?
 	 * Is *only* one DAP configured?
 	 *
-	 * MUST READ IDCODE
+	 * MUST READ DPIDR
 	 */
 
+	/* Check if we should reset srst already when connecting, but not if reconnecting. */
+	if (!dap->do_reconnect) {
+		enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+		if (jtag_reset_config & RESET_CNCT_UNDER_SRST) {
+			if (jtag_reset_config & RESET_SRST_NO_GATING)
+				swd_add_reset(1);
+			else
+				LOG_WARNING("\'srst_nogate\' reset_config option is required");
+		}
+	}
+
 	/* Note, debugport_init() does setup too */
 	jtag_interface->swd->switch_seq(JTAG_TO_SWD);
 
-	/* Make sure we don't try to perform any other accesses before the DPIDR read. */
+	/* Clear link state, including the SELECT cache. */
 	dap->do_reconnect = false;
-	dap->select = 0;
+	dap->select = DP_SELECT_INVALID;
 
-	swd_queue_dp_read(dap, DP_IDCODE, &idcode);
+	swd_queue_dp_read(dap, DP_DPIDR, &dpidr);
 
 	/* force clear all sticky faults */
 	swd_clear_sticky_errors(dap);
@@ -124,7 +134,7 @@ static int swd_connect(struct adiv5_dap *dap)
 	status = swd_run_inner(dap);
 
 	if (status == ERROR_OK) {
-		LOG_INFO("SWD IDCODE %#8.8" PRIx32, idcode);
+		LOG_INFO("SWD DPIDR %#8.8" PRIx32, dpidr);
 		dap->do_reconnect = false;
 	} else
 		dap->do_reconnect = true;
@@ -158,7 +168,8 @@ static int swd_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 /** Select the DP register bank matching bits 7:4 of reg. */
 static void swd_queue_dp_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
-	if (reg == DP_SELECT)
+	/* Only register address 4 is banked. */
+	if ((reg & 0xf) != 4)
 		return;
 
 	uint32_t select_dp_bank = (reg & 0x000000F0) >> 4;
@@ -341,61 +352,6 @@ int dap_to_swd(struct target *target)
 	return retval;
 }
 
-COMMAND_HANDLER(handle_swd_wcr)
-{
-	int retval;
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-	uint32_t wcr;
-	unsigned trn, scale = 0;
-
-	switch (CMD_ARGC) {
-	/* no-args: just dump state */
-	case 0:
-		/*retval = swd_queue_dp_read(dap, DP_WCR, &wcr); */
-		retval = dap_queue_dp_read(dap, DP_WCR, &wcr);
-		if (retval == ERROR_OK)
-			dap->ops->run(dap);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("can't read WCR?");
-			return retval;
-		}
-
-		command_print(CMD_CTX,
-			"turnaround=%" PRIu32 ", prescale=%" PRIu32,
-			WCR_TO_TRN(wcr),
-			WCR_TO_PRESCALE(wcr));
-	return ERROR_OK;
-
-	case 2:		/* TRN and prescale */
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], scale);
-		if (scale > 7) {
-			LOG_ERROR("prescale %d is too big", scale);
-			return ERROR_FAIL;
-		}
-		/* FALL THROUGH */
-
-	case 1:		/* TRN only */
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], trn);
-		if (trn < 1 || trn > 4) {
-			LOG_ERROR("turnaround %d is invalid", trn);
-			return ERROR_FAIL;
-		}
-
-		wcr = ((trn - 1) << 8) | scale;
-		/* FIXME
-		 * write WCR ...
-		 * then, re-init adapter with new TRN
-		 */
-		LOG_ERROR("can't yet modify WCR");
-		return ERROR_FAIL;
-
-	default:	/* too many arguments */
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-}
-
 static const struct command_registration swd_commands[] = {
 	{
 		/*
@@ -410,15 +366,6 @@ static const struct command_registration swd_commands[] = {
 		.mode = COMMAND_CONFIG,
 		.help = "declare a new SWD DAP"
 	},
-	{
-		.name = "wcr",
-		.handler = handle_swd_wcr,
-		.mode = COMMAND_ANY,
-		.help = "display or update DAP's WCR register",
-		.usage = "turnaround (1..4), prescale (0..7)",
-	},
-
-	/* REVISIT -- add a command for SWV trace on/off */
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -477,6 +424,8 @@ static int swd_init(struct command_context *ctx)
 	/* Force the DAP's ops vector for SWD mode.
 	 * messy - is there a better way? */
 	arm->dap->ops = &swd_dap_ops;
+	/* First connect after init is not reconnecting. */
+	dap->do_reconnect = false;
 
 	return swd_connect(dap);
 }
diff --git a/src/target/algorithm.c b/src/target/algorithm.c
index aa8262a6..9fc93860 100644
--- a/src/target/algorithm.c
+++ b/src/target/algorithm.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/algorithm.h b/src/target/algorithm.h
index 2d510db7..8894241c 100644
--- a/src/target/algorithm.h
+++ b/src/target/algorithm.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ALGORITHM_H
-#define ALGORITHM_H
+#ifndef OPENOCD_TARGET_ALGORITHM_H
+#define OPENOCD_TARGET_ALGORITHM_H
 
 enum param_direction {
 	PARAM_IN,
@@ -28,7 +26,7 @@ enum param_direction {
 };
 
 struct mem_param {
-	uint32_t address;
+	target_addr_t address;
 	uint32_t size;
 	uint8_t *value;
 	enum param_direction direction;
@@ -49,4 +47,4 @@ void init_reg_param(struct reg_param *param,
 		char *reg_name, uint32_t size, enum param_direction dir);
 void destroy_reg_param(struct reg_param *param);
 
-#endif /* ALGORITHM_H */
+#endif /* OPENOCD_TARGET_ALGORITHM_H */
diff --git a/src/target/arm.h b/src/target/arm.h
index 27636cc3..f89aa688 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -19,13 +19,11 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#ifndef ARM_H
-#define ARM_H
+#ifndef OPENOCD_TARGET_ARM_H
+#define OPENOCD_TARGET_ARM_H
 
 #include <helper/command.h>
 #include "target.h"
@@ -61,12 +59,22 @@ enum arm_mode {
 	ARM_MODE_MON = 22,
 	ARM_MODE_ABT = 23,
 	ARM_MODE_UND = 27,
+	ARM_MODE_1176_MON = 28,
 	ARM_MODE_SYS = 31,
 
 	ARM_MODE_THREAD = 0,
 	ARM_MODE_USER_THREAD = 1,
 	ARM_MODE_HANDLER = 2,
 
+	/* shift left 4 bits for armv8 64 */
+	ARMV8_64_EL0T = 0x0F,
+	ARMV8_64_EL1T = 0x4F,
+	ARMV8_64_EL1H = 0x5F,
+	ARMV8_64_EL2T = 0x8F,
+	ARMV8_64_EL2H = 0x9F,
+	ARMV8_64_EL3T = 0xCF,
+	ARMV8_64_EL3H = 0xDF,
+
 	ARM_MODE_ANY = -1
 };
 
@@ -79,6 +87,7 @@ enum arm_state {
 	ARM_STATE_THUMB,
 	ARM_STATE_JAZELLE,
 	ARM_STATE_THUMB_EE,
+	ARM_STATE_AARCH64,
 };
 
 #define ARM_COMMON_MAGIC 0x0A450A45
@@ -131,11 +140,26 @@ struct arm {
 	/** Flag reporting whether semihosting is active. */
 	bool is_semihosting;
 
+	/** Flag reporting whether semihosting fileio is active. */
+	bool is_semihosting_fileio;
+
+	/** Flag reporting whether semihosting fileio operation is active. */
+	bool semihosting_hit_fileio;
+
+	/** Current semihosting operation. */
+	int semihosting_op;
+
+	/** Current semihosting result. */
+	int semihosting_result;
+
 	/** Value to be returned by semihosting SYS_ERRNO request. */
 	int semihosting_errno;
 
 	int (*setup_semihosting)(struct target *target, int enable);
 
+	/** Semihosting command line. */
+	char *semihosting_cmdline;
+
 	/** Backpointer to the target. */
 	struct target *target;
 
@@ -202,10 +226,11 @@ struct arm_reg {
 	enum arm_mode mode;
 	struct target *target;
 	struct arm *arm;
-	uint8_t value[4];
+	uint8_t value[8];
 };
 
 struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm);
+struct reg_cache *armv8_build_reg_cache(struct target *target);
 
 extern const struct command_registration arm_command_handlers[];
 
@@ -213,6 +238,9 @@ int arm_arch_state(struct target *target);
 int arm_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
+int armv8_get_gdb_reg_list(struct target *target,
+		struct reg **reg_list[], int *reg_list_size,
+		enum target_register_class reg_class);
 
 int arm_init_arch_info(struct target *target, struct arm *arm);
 
@@ -220,7 +248,7 @@ int arm_init_arch_info(struct target *target, struct arm *arm);
 int armv4_5_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
+		target_addr_t entry_point, target_addr_t exit_point,
 		int timeout_ms, void *arch_info);
 int armv4_5_run_algorithm_inner(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
@@ -231,14 +259,15 @@ int armv4_5_run_algorithm_inner(struct target *target,
 				int timeout_ms, void *arch_info));
 
 int arm_checksum_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *checksum);
+		target_addr_t address, uint32_t count, uint32_t *checksum);
 int arm_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *blank);
+		target_addr_t address, uint32_t count, uint32_t *blank, uint8_t erased_value);
 
 void arm_set_cpsr(struct arm *arm, uint32_t cpsr);
 struct reg *arm_reg_current(struct arm *arm, unsigned regnum);
+struct reg *armv8_reg_current(struct arm *arm, unsigned regnum);
 
 extern struct reg arm_gdb_dummy_fp_reg;
 extern struct reg arm_gdb_dummy_fps_reg;
 
-#endif /* ARM_H */
+#endif /* OPENOCD_TARGET_ARM_H */
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 0cb1d8c8..13fbd207 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -44,7 +42,7 @@
 
 
 static int arm11_step(struct target *target, int current,
-		uint32_t address, int handle_breakpoints);
+		target_addr_t address, int handle_breakpoints);
 
 
 /** Check and if necessary take control of the system
@@ -392,7 +390,7 @@ static int arm11_halt(struct target *target)
 			break;
 
 
-		long long then = 0;
+		int64_t then = 0;
 		if (i == 1000)
 			then = timeval_ms();
 		if (i >= 1000) {
@@ -420,16 +418,38 @@ static uint32_t arm11_nextpc(struct arm11_common *arm11, int current, uint32_t a
 {
 	void *value = arm11->arm.pc->value;
 
-	if (!current)
-		buf_set_u32(value, 0, 32, address);
-	else
+	/* use the current program counter */
+	if (current)
 		address = buf_get_u32(value, 0, 32);
 
+	/* Make sure that the gdb thumb fixup does not
+	 * kill the return address
+	 */
+	switch (arm11->arm.core_state) {
+		case ARM_STATE_ARM:
+			address &= 0xFFFFFFFC;
+			break;
+		case ARM_STATE_THUMB:
+			/* When the return address is loaded into PC
+			 * bit 0 must be 1 to stay in Thumb state
+			 */
+			address |= 0x1;
+			break;
+
+		/* catch-all for JAZELLE and THUMB_EE */
+		default:
+			break;
+	}
+
+	buf_set_u32(value, 0, 32, address);
+	arm11->arm.pc->dirty = 1;
+	arm11->arm.pc->valid = 1;
+
 	return address;
 }
 
 static int arm11_resume(struct target *target, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution)
+	target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	/*	  LOG_DEBUG("current %d  address %08x  handle_breakpoints %d  debug_execution %d", */
 	/*	current, address, handle_breakpoints, debug_execution); */
@@ -447,7 +467,7 @@ static int arm11_resume(struct target *target, int current,
 
 	address = arm11_nextpc(arm11, current, address);
 
-	LOG_DEBUG("RESUME PC %08" PRIx32 "%s", address, !current ? "!" : "");
+	LOG_DEBUG("RESUME PC %08" TARGET_PRIxADDR "%s", address, !current ? "!" : "");
 
 	/* clear breakpoints/watchpoints and VCR*/
 	CHECK_RETVAL(arm11_sc7_clear_vbw(arm11));
@@ -461,7 +481,7 @@ static int arm11_resume(struct target *target, int current,
 
 		for (bp = target->breakpoints; bp; bp = bp->next) {
 			if (bp->address == address) {
-				LOG_DEBUG("must step over %08" PRIx32 "", bp->address);
+				LOG_DEBUG("must step over %08" TARGET_PRIxADDR "", bp->address);
 				arm11_step(target, 1, 0, 0);
 				break;
 			}
@@ -487,7 +507,7 @@ static int arm11_resume(struct target *target, int current,
 
 			CHECK_RETVAL(arm11_sc7_run(arm11, brp, ARRAY_SIZE(brp)));
 
-			LOG_DEBUG("Add BP %d at %08" PRIx32, brp_num,
+			LOG_DEBUG("Add BP %d at %08" TARGET_PRIxADDR, brp_num,
 				bp->address);
 
 			brp_num++;
@@ -514,7 +534,7 @@ static int arm11_resume(struct target *target, int current,
 			break;
 
 
-		long long then = 0;
+		int64_t then = 0;
 		if (i == 1000)
 			then = timeval_ms();
 		if (i >= 1000) {
@@ -537,7 +557,7 @@ static int arm11_resume(struct target *target, int current,
 }
 
 static int arm11_step(struct target *target, int current,
-	uint32_t address, int handle_breakpoints)
+	target_addr_t address, int handle_breakpoints)
 {
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
@@ -551,7 +571,7 @@ static int arm11_step(struct target *target, int current,
 
 	address = arm11_nextpc(arm11, current, address);
 
-	LOG_DEBUG("STEP PC %08" PRIx32 "%s", address, !current ? "!" : "");
+	LOG_DEBUG("STEP PC %08" TARGET_PRIxADDR "%s", address, !current ? "!" : "");
 
 
 	/** \todo TODO: Thumb not supported here */
@@ -563,13 +583,13 @@ static int arm11_step(struct target *target, int current,
 	/* skip over BKPT */
 	if ((next_instruction & 0xFFF00070) == 0xe1200070) {
 		address = arm11_nextpc(arm11, 0, address + 4);
-		LOG_DEBUG("Skipping BKPT %08" PRIx32, address);
+		LOG_DEBUG("Skipping BKPT %08" TARGET_PRIxADDR, address);
 	}
 	/* skip over Wait for interrupt / Standby
 	 * mcr	15, 0, r?, cr7, cr0, {4} */
 	else if ((next_instruction & 0xFFFF0FFF) == 0xee070f90) {
 		address = arm11_nextpc(arm11, 0, address + 4);
-		LOG_DEBUG("Skipping WFI %08" PRIx32, address);
+		LOG_DEBUG("Skipping WFI %08" TARGET_PRIxADDR, address);
 	}
 	/* ignore B to self */
 	else if ((next_instruction & 0xFEFFFFFF) == 0xeafffffe)
@@ -694,21 +714,32 @@ static int arm11_assert_reset(struct target *target)
 {
 	struct arm11_common *arm11 = target_to_arm11(target);
 
-	/* optionally catch reset vector */
-	if (target->reset_halt && !(arm11->vcr & 1))
-		CHECK_RETVAL(arm11_sc7_set_vcr(arm11, arm11->vcr | 1));
-
-	/* Issue some kind of warm reset. */
-	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT))
-		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
-	else if (jtag_get_reset_config() & RESET_HAS_SRST) {
-		/* REVISIT handle "pulls" cases, if there's
-		 * hardware that needs them to work.
-		 */
-		jtag_add_reset(0, 1);
+	if (!(target_was_examined(target))) {
+		if (jtag_get_reset_config() & RESET_HAS_SRST)
+			jtag_add_reset(0, 1);
+		else {
+			LOG_WARNING("Reset is not asserted because the target is not examined.");
+			LOG_WARNING("Use a reset button or power cycle the target.");
+			return ERROR_TARGET_NOT_EXAMINED;
+		}
 	} else {
-		LOG_ERROR("%s: how to reset?", target_name(target));
-		return ERROR_FAIL;
+
+		/* optionally catch reset vector */
+		if (target->reset_halt && !(arm11->vcr & 1))
+			CHECK_RETVAL(arm11_sc7_set_vcr(arm11, arm11->vcr | 1));
+
+		/* Issue some kind of warm reset. */
+		if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT))
+			target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
+		else if (jtag_get_reset_config() & RESET_HAS_SRST) {
+			/* REVISIT handle "pulls" cases, if there's
+			 * hardware that needs them to work.
+			 */
+			jtag_add_reset(0, 1);
+		} else {
+			LOG_ERROR("%s: how to reset?", target_name(target));
+			return ERROR_FAIL;
+		}
 	}
 
 	/* registers are now invalid */
@@ -856,7 +887,7 @@ static int arm11_read_memory_inner(struct target *target,
 }
 
 static int arm11_read_memory(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	uint8_t *buffer)
@@ -1012,7 +1043,7 @@ static int arm11_write_memory_inner(struct target *target,
 }
 
 static int arm11_write_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	target_addr_t address, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
 	/* pointer increment matters only for multi-unit writes ...
diff --git a/src/target/arm11.h b/src/target/arm11.h
index d9e45357..77cc2236 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -15,13 +15,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM11_H
-#define ARM11_H
+#ifndef OPENOCD_TARGET_ARM11_H
+#define OPENOCD_TARGET_ARM11_H
 
 #include "arm.h"
 #include "arm_dpm.h"
@@ -113,4 +111,4 @@ enum arm11_sc7 {
 	ARM11_SC7_WCR0                          = 112,
 };
 
-#endif	/* ARM11_H */
+#endif /* OPENOCD_TARGET_ARM11_H */
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 9271a2b9..2232b3ef 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -410,7 +408,7 @@ int arm11_run_instr_no_data(struct arm11_common *arm11,
 			if (flag)
 				break;
 
-			long long then = 0;
+			int64_t then = 0;
 
 			if (i == 1000)
 				then = timeval_ms();
@@ -493,7 +491,7 @@ int arm11_run_instr_data_to_core(struct arm11_common *arm11,
 
 			JTAG_DEBUG("DTR  Ready %d  nRetry %d", Ready, nRetry);
 
-			long long then = 0;
+			int64_t then = 0;
 
 			if (i == 1000)
 				then = timeval_ms();
@@ -525,7 +523,7 @@ int arm11_run_instr_data_to_core(struct arm11_common *arm11,
 		JTAG_DEBUG("DTR  Data %08x  Ready %d  nRetry %d",
 			(unsigned) Data, Ready, nRetry);
 
-		long long then = 0;
+		int64_t then = 0;
 
 		if (i == 1000)
 			then = timeval_ms();
@@ -789,7 +787,7 @@ int arm11_run_instr_data_from_core(struct arm11_common *arm11,
 			JTAG_DEBUG("DTR  Data %08x  Ready %d  nRetry %d",
 				(unsigned) Data, Ready, nRetry);
 
-			long long then = 0;
+			int64_t then = 0;
 
 			if (i == 1000)
 				then = timeval_ms();
@@ -924,7 +922,7 @@ int arm11_sc7_run(struct arm11_common *arm11, struct arm11_sc7_action *actions,
 			if (Ready)
 				break;
 
-			long long then = 0;
+			int64_t then = 0;
 
 			if (i_n == 1000)
 				then = timeval_ms();
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 7f48ec4f..541434ed 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -15,13 +15,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM11_DBGTAP_H
-#define ARM11_DBGTAP_H
+#ifndef OPENOCD_TARGET_ARM11_DBGTAP_H
+#define OPENOCD_TARGET_ARM11_DBGTAP_H
 
 #include "arm11.h"
 
@@ -82,4 +80,4 @@ int arm11_read_memory_word(struct arm11_common *arm11,
 int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr);
 int arm11_bpwp_flush(struct arm11_common *arm11);
 
-#endif	/* ARM11_DBGTAP_H */
+#endif /* OPENOCD_TARGET_ARM11_DBGTAP_H */
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index a97ad118..bcbfa9df 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -273,7 +271,7 @@ static int arm720_mmu(struct target *target, int *enabled)
 }
 
 static int arm720_virt2phys(struct target *target,
-		uint32_t virtual, uint32_t *physical)
+		target_addr_t virtual, target_addr_t *physical)
 {
 	uint32_t cb;
 	struct arm720t_common *arm720t = target_to_arm720(target);
@@ -288,7 +286,7 @@ static int arm720_virt2phys(struct target *target,
 }
 
 static int arm720t_read_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	struct arm720t_common *arm720t = target_to_arm720(target);
@@ -311,7 +309,7 @@ static int arm720t_read_memory(struct target *target,
 }
 
 static int arm720t_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct arm720t_common *arm720t = target_to_arm720(target);
 
@@ -319,7 +317,7 @@ static int arm720t_read_phys_memory(struct target *target,
 }
 
 static int arm720t_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct arm720t_common *arm720t = target_to_arm720(target);
 
@@ -338,7 +336,7 @@ static int arm720t_soft_reset_halt(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	int timeout;
 	while (!(timeout = ((timeval_ms()-then) > 1000))) {
 		if (buf_get_u32(dbg_stat->value, EICE_DBG_STATUS_DBGACK, 1) == 0) {
diff --git a/src/target/arm720t.h b/src/target/arm720t.h
index 35d45ffd..31dad9c7 100644
--- a/src/target/arm720t.h
+++ b/src/target/arm720t.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM720T_H
-#define ARM720T_H
+#ifndef OPENOCD_TARGET_ARM720T_H
+#define OPENOCD_TARGET_ARM720T_H
 
 #include "arm7tdmi.h"
 #include "armv4_5_mmu.h"
@@ -40,4 +38,4 @@ static inline struct arm720t_common *target_to_arm720(struct target *target)
 	return container_of(target->arch_info, struct arm720t_common, arm7_9_common.arm);
 }
 
-#endif /* ARM720T_H */
+#endif /* OPENOCD_TARGET_ARM720T_H */
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 7b40f505..7fd1ed9f 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -24,9 +24,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -103,7 +101,8 @@ static void arm7_9_assign_wp(struct arm7_9_common *arm7_9, struct breakpoint *br
 		arm7_9->wp_available--;
 	} else
 		LOG_ERROR("BUG: no hardware comparator available");
-	LOG_DEBUG("BPID: %" PRId32 " (0x%08" PRIx32 ") using hw wp: %d",
+
+	LOG_DEBUG("BPID: %" PRId32 " (0x%08" TARGET_PRIxADDR ") using hw wp: %d",
 			breakpoint->unique_id,
 			breakpoint->address,
 			breakpoint->set);
@@ -189,7 +188,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	int retval = ERROR_OK;
 
-	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" PRIx32 ", Type: %d",
+	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" TARGET_PRIxADDR ", Type: %d",
 		breakpoint->unique_id,
 		breakpoint->address,
 		breakpoint->type);
@@ -246,7 +245,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 			if (retval != ERROR_OK)
 				return retval;
 			if (verify != arm7_9->arm_bkpt) {
-				LOG_ERROR("Unable to set 32 bit software breakpoint at address %08" PRIx32
+				LOG_ERROR("Unable to set 32 bit software breakpoint at address %08" TARGET_PRIxADDR
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -266,7 +265,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 			if (retval != ERROR_OK)
 				return retval;
 			if (verify != arm7_9->thumb_bkpt) {
-				LOG_ERROR("Unable to set thumb software breakpoint at address %08" PRIx32
+				LOG_ERROR("Unable to set thumb software breakpoint at address %08" TARGET_PRIxADDR
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -301,7 +300,7 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 	int retval = ERROR_OK;
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 
-	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" PRIx32,
+	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" TARGET_PRIxADDR,
 		breakpoint->unique_id,
 		breakpoint->address);
 
@@ -350,12 +349,12 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 			if (retval != ERROR_OK)
 				return retval;
 			current_instr = target_buffer_get_u16(target, (uint8_t *)&current_instr);
-			if (current_instr == arm7_9->thumb_bkpt)
+			if (current_instr == arm7_9->thumb_bkpt) {
 				retval = target_write_memory(target,
 						breakpoint->address, 2, 1, breakpoint->orig_instr);
 				if (retval != ERROR_OK)
 					return retval;
-
+			}
 		}
 
 		if (--arm7_9->sw_breakpoint_count == 0) {
@@ -636,8 +635,8 @@ int arm7_9_execute_sys_speed(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
-	int timeout;
+	int64_t then = timeval_ms();
+	bool timeout;
 	while (!(timeout = ((timeval_ms()-then) > 1000))) {
 		/* read debug status register */
 		embeddedice_read_reg(dbg_stat);
@@ -875,6 +874,13 @@ int arm7_9_assert_reset(struct target *target)
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	bool use_event = false;
 
+	/* TODO: apply hw reset signal in not examined state */
+	if (!(target_was_examined(target))) {
+		LOG_WARNING("Reset is not asserted because the target is not examined.");
+		LOG_WARNING("Use a reset button or power cycle the target.");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	LOG_DEBUG("target->state: %s", target_state_name(target));
 
 	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT))
@@ -1687,7 +1693,7 @@ static void arm7_9_enable_breakpoints(struct target *target)
 
 int arm7_9_resume(struct target *target,
 	int current,
-	uint32_t address,
+	target_addr_t address,
 	int handle_breakpoints,
 	int debug_execution)
 {
@@ -1719,7 +1725,7 @@ int arm7_9_resume(struct target *target,
 		breakpoint = breakpoint_find(target,
 				buf_get_u32(arm->pc->value, 0, 32));
 		if (breakpoint != NULL) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (id: %" PRId32,
+			LOG_DEBUG("unset breakpoint at 0x%8.8" TARGET_PRIxADDR " (id: %" PRId32,
 				breakpoint->address,
 				breakpoint->unique_id);
 			retval = arm7_9_unset_breakpoint(target, breakpoint);
@@ -1778,7 +1784,7 @@ int arm7_9_resume(struct target *target,
 			LOG_DEBUG("new PC after step: 0x%8.8" PRIx32,
 				buf_get_u32(arm->pc->value, 0, 32));
 
-			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("set breakpoint at 0x%8.8" TARGET_PRIxADDR "", breakpoint->address);
 			retval = arm7_9_set_breakpoint(target, breakpoint);
 			if (retval != ERROR_OK)
 				return retval;
@@ -1889,7 +1895,7 @@ void arm7_9_disable_eice_step(struct target *target)
 	embeddedice_store_reg(&arm7_9->eice_cache->reg_list[EICE_W1_CONTROL_VALUE]);
 }
 
-int arm7_9_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
+int arm7_9_step(struct target *target, int current, target_addr_t address, int handle_breakpoints)
 {
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm *arm = &arm7_9->arm;
@@ -2089,7 +2095,7 @@ static int arm7_9_write_core_reg(struct target *target, struct reg *r,
 }
 
 int arm7_9_read_memory(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	uint8_t *buffer)
@@ -2104,7 +2110,7 @@ int arm7_9_read_memory(struct target *target,
 	int retval;
 	int last_reg = 0;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("address: 0x%8.8" TARGET_PRIxADDR ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
 		address, size, count);
 
 	if (target->state != TARGET_HALTED) {
@@ -2242,7 +2248,8 @@ int arm7_9_read_memory(struct target *target,
 
 	if (((cpsr & 0x1f) == ARM_MODE_ABT) && (arm->core_mode != ARM_MODE_ABT)) {
 		LOG_WARNING(
-			"memory read caused data abort (address: 0x%8.8" PRIx32 ", size: 0x%" PRIx32 ", count: 0x%" PRIx32 ")",
+			"memory read caused data abort "
+			"(address: 0x%8.8" TARGET_PRIxADDR ", size: 0x%" PRIx32 ", count: 0x%" PRIx32 ")",
 			address,
 			size,
 			count);
@@ -2258,7 +2265,7 @@ int arm7_9_read_memory(struct target *target,
 }
 
 int arm7_9_write_memory(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	const uint8_t *buffer)
@@ -2455,7 +2462,8 @@ int arm7_9_write_memory(struct target *target,
 
 	if (((cpsr & 0x1f) == ARM_MODE_ABT) && (arm->core_mode != ARM_MODE_ABT)) {
 		LOG_WARNING(
-			"memory write caused data abort (address: 0x%8.8" PRIx32 ", size: 0x%" PRIx32 ", count: 0x%" PRIx32 ")",
+			"memory write caused data abort "
+			"(address: 0x%8.8" TARGET_PRIxADDR ", size: 0x%" PRIx32 ", count: 0x%" PRIx32 ")",
 			address,
 			size,
 			count);
@@ -2471,7 +2479,7 @@ int arm7_9_write_memory(struct target *target,
 }
 
 int arm7_9_write_memory_opt(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	const uint8_t *buffer)
@@ -2571,7 +2579,7 @@ static const uint32_t dcc_code[] = {
 };
 
 int arm7_9_bulk_write_memory(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t count,
 	const uint8_t *buffer)
 {
@@ -2627,7 +2635,7 @@ int arm7_9_bulk_write_memory(struct target *target,
 		uint32_t endaddress = buf_get_u32(reg_params[0].value, 0, 32);
 		if (endaddress != (address + count*4)) {
 			LOG_ERROR(
-				"DCC write failed, expected end address 0x%08" PRIx32 " got 0x%0" PRIx32 "",
+				"DCC write failed, expected end address 0x%08" TARGET_PRIxADDR " got 0x%0" PRIx32 "",
 				(address + count*4),
 				endaddress);
 			retval = ERROR_FAIL;
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index 5821e132..811f9c59 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -22,13 +22,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM7_9_COMMON_H
-#define ARM7_9_COMMON_H
+#ifndef OPENOCD_TARGET_ARM7_9_COMMON_H
+#define OPENOCD_TARGET_ARM7_9_COMMON_H
 
 #include "arm.h"
 #include "arm_jtag.h"
@@ -124,13 +122,13 @@ struct arm7_9_common {
 	 * Used as a fallback when bulk writes are unavailable, or for writing data needed to
 	 * do the bulk writes.
 	 */
-	int (*write_memory)(struct target *target, uint32_t address,
+	int (*write_memory)(struct target *target, target_addr_t address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
 	/**
 	 * Write target memory in multiples of 4 bytes, optimized for
 	 * writing large quantities of data.
 	 */
-	int (*bulk_write_memory)(struct target *target, uint32_t address,
+	int (*bulk_write_memory)(struct target *target, target_addr_t address,
 			uint32_t count, const uint8_t *buffer);
 };
 
@@ -157,19 +155,19 @@ int arm7_9_early_halt(struct target *target);
 int arm7_9_soft_reset_halt(struct target *target);
 
 int arm7_9_halt(struct target *target);
-int arm7_9_resume(struct target *target, int current, uint32_t address,
+int arm7_9_resume(struct target *target, int current, target_addr_t address,
 		int handle_breakpoints, int debug_execution);
-int arm7_9_step(struct target *target, int current, uint32_t address,
+int arm7_9_step(struct target *target, int current, target_addr_t address,
 		int handle_breakpoints);
-int arm7_9_read_memory(struct target *target, uint32_t address,
+int arm7_9_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer);
-int arm7_9_write_memory(struct target *target, uint32_t address,
+int arm7_9_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer);
-int arm7_9_write_memory_opt(struct target *target, uint32_t address,
+int arm7_9_write_memory_opt(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer);
 int arm7_9_write_memory_no_opt(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer);
-int arm7_9_bulk_write_memory(struct target *target, uint32_t address,
+int arm7_9_bulk_write_memory(struct target *target, target_addr_t address,
 		uint32_t count, const uint8_t *buffer);
 
 int arm7_9_run_algorithm(struct target *target, int num_mem_params,
@@ -194,4 +192,4 @@ int arm7_9_endianness_callback(jtag_callback_data_t pu8_in,
 		jtag_callback_data_t i_size, jtag_callback_data_t i_be,
 		jtag_callback_data_t i_flip);
 
-#endif /* ARM7_9_COMMON_H */
+#endif /* OPENOCD_TARGET_ARM7_9_COMMON_H */
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 490ecfc0..9dcb302d 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -32,6 +30,7 @@
 #include "target_type.h"
 #include "register.h"
 #include "arm_opcodes.h"
+#include "arm_semihosting.h"
 
 /*
  * For information about ARM7TDMI, see ARM DDI 0210C (r4p1)
@@ -617,7 +616,7 @@ static void arm7tdmi_build_reg_cache(struct target *target)
 int arm7tdmi_init_target(struct command_context *cmd_ctx, struct target *target)
 {
 	arm7tdmi_build_reg_cache(target);
-
+	arm_semihosting_init(target);
 	return ERROR_OK;
 }
 
diff --git a/src/target/arm7tdmi.h b/src/target/arm7tdmi.h
index a44ceee5..053f64df 100644
--- a/src/target/arm7tdmi.h
+++ b/src/target/arm7tdmi.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM7TDMI_H
-#define ARM7TDMI_H
+#ifndef OPENOCD_TARGET_ARM7TDMI_H
+#define OPENOCD_TARGET_ARM7TDMI_H
 
 #include "embeddedice.h"
 
@@ -31,4 +29,4 @@ int arm7tdmi_init_arch_info(struct target *target,
 int arm7tdmi_init_target(struct command_context *cmd_ctx,
 		struct target *target);
 
-#endif /* ARM7TDMI_H */
+#endif /* OPENOCD_TARGET_ARM7TDMI_H */
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index b1579bca..7927a2be 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -555,7 +553,7 @@ static int arm920_mmu(struct target *target, int *enabled)
 }
 
 static int arm920_virt2phys(struct target *target,
-	uint32_t virt, uint32_t *phys)
+	target_addr_t virt, target_addr_t *phys)
 {
 	uint32_t cb;
 	struct arm920t_common *arm920t = target_to_arm920(target);
@@ -570,7 +568,7 @@ static int arm920_virt2phys(struct target *target,
 }
 
 /** Reads a buffer, in the specified word size, with current MMU settings. */
-int arm920t_read_memory(struct target *target, uint32_t address,
+int arm920t_read_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
@@ -582,7 +580,7 @@ int arm920t_read_memory(struct target *target, uint32_t address,
 
 
 static int arm920t_read_phys_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	target_addr_t address, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
 	struct arm920t_common *arm920t = target_to_arm920(target);
@@ -592,7 +590,7 @@ static int arm920t_read_phys_memory(struct target *target,
 }
 
 static int arm920t_write_phys_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	target_addr_t address, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
 	struct arm920t_common *arm920t = target_to_arm920(target);
@@ -602,7 +600,7 @@ static int arm920t_write_phys_memory(struct target *target,
 }
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
-int arm920t_write_memory(struct target *target, uint32_t address,
+int arm920t_write_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
@@ -753,8 +751,8 @@ int arm920t_soft_reset_halt(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
-	int timeout;
+	int64_t then = timeval_ms();
+	bool timeout;
 	while (!(timeout = ((timeval_ms()-then) > 1000))) {
 		if (buf_get_u32(dbg_stat->value, EICE_DBG_STATUS_DBGACK, 1) == 0) {
 			embeddedice_read_reg(dbg_stat);
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 71876a69..2e3b08ca 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM920T_H
-#define ARM920T_H
+#ifndef OPENOCD_TARGET_ARM920T_H
+#define OPENOCD_TARGET_ARM920T_H
 
 #include "arm9tdmi.h"
 #include "armv4_5_mmu.h"
@@ -57,9 +55,9 @@ struct arm920t_tlb_entry {
 int arm920t_arch_state(struct target *target);
 int arm920t_soft_reset_halt(struct target *target);
 int arm920t_read_memory(struct target *target,
-	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int arm920t_write_memory(struct target *target,
-	uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+	target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 int arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
 int arm920t_get_ttb(struct target *target, uint32_t *result);
@@ -70,4 +68,4 @@ int arm920t_enable_mmu_caches(struct target *target,
 
 extern const struct command_registration arm920t_command_handlers[];
 
-#endif /* ARM920T_H */
+#endif /* OPENOCD_TARGET_ARM920T_H */
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index d8bf2d04..58de7785 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -89,7 +87,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 
 	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 
 	for (;;) {
 		/* rescan with NOP, to wait for the access to complete */
@@ -175,7 +173,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 
 	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 
 	for (;;) {
 		/* rescan with NOP, to wait for the access to complete */
@@ -548,7 +546,7 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	int timeout;
 	while (!(timeout = ((timeval_ms()-then) > 1000))) {
 		if (buf_get_u32(dbg_stat->value, EICE_DBG_STATUS_DBGACK, 1) == 0) {
@@ -596,7 +594,7 @@ int arm926ejs_soft_reset_halt(struct target *target)
 }
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
-int arm926ejs_write_memory(struct target *target, uint32_t address,
+int arm926ejs_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
@@ -625,7 +623,7 @@ int arm926ejs_write_memory(struct target *target, uint32_t address,
 				return retval;
 		}
 
-		uint32_t pa;
+		target_addr_t pa;
 		retval = target->type->virt2phys(target, address, &pa);
 		if (retval != ERROR_OK)
 			return retval;
@@ -657,7 +655,7 @@ int arm926ejs_write_memory(struct target *target, uint32_t address,
 }
 
 static int arm926ejs_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size,
+		target_addr_t address, uint32_t size,
 		uint32_t count, const uint8_t *buffer)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
@@ -667,7 +665,7 @@ static int arm926ejs_write_phys_memory(struct target *target,
 }
 
 static int arm926ejs_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size,
+		target_addr_t address, uint32_t size,
 		uint32_t count, uint8_t *buffer)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
@@ -738,7 +736,7 @@ COMMAND_HANDLER(arm926ejs_handle_cache_info_command)
 	return armv4_5_handle_cache_info_command(CMD_CTX, &arm926ejs->armv4_5_mmu.armv4_5_cache);
 }
 
-static int arm926ejs_virt2phys(struct target *target, uint32_t virtual, uint32_t *physical)
+static int arm926ejs_virt2phys(struct target *target, target_addr_t virtual, target_addr_t *physical)
 {
 	uint32_t cb;
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
index cc19c9fc..d4fd0cb6 100644
--- a/src/target/arm926ejs.h
+++ b/src/target/arm926ejs.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM926EJS_H
-#define ARM926EJS_H
+#ifndef OPENOCD_TARGET_ARM926EJS_H
+#define OPENOCD_TARGET_ARM926EJS_H
 
 #include "arm9tdmi.h"
 #include "armv4_5_mmu.h"
@@ -49,9 +47,9 @@ int arm926ejs_init_arch_info(struct target *target,
 		struct arm926ejs_common *arm926ejs, struct jtag_tap *tap);
 int arm926ejs_arch_state(struct target *target);
 int arm926ejs_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 int arm926ejs_soft_reset_halt(struct target *target);
 
 extern const struct command_registration arm926ejs_command_handlers[];
 
-#endif /* ARM926EJS_H */
+#endif /* OPENOCD_TARGET_ARM926EJS_H */
diff --git a/src/target/arm946e.c b/src/target/arm946e.c
index c21ff95f..06c9fc30 100644
--- a/src/target/arm946e.c
+++ b/src/target/arm946e.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -489,7 +487,7 @@ uint32_t arm946e_invalidate_icache(struct target *target, uint32_t address,
 }
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
-int arm946e_write_memory(struct target *target, uint32_t address,
+int arm946e_write_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
@@ -537,7 +535,7 @@ int arm946e_write_memory(struct target *target, uint32_t address,
 
 }
 
-int arm946e_read_memory(struct target *target, uint32_t address,
+int arm946e_read_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
diff --git a/src/target/arm946e.h b/src/target/arm946e.h
index fd45f05a..ee1ef323 100644
--- a/src/target/arm946e.h
+++ b/src/target/arm946e.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM946E_H
-#define ARM946E_H
+#ifndef OPENOCD_TARGET_ARM946E_H
+#define OPENOCD_TARGET_ARM946E_H
 
 #include "arm9tdmi.h"
 
@@ -50,4 +48,4 @@ int arm946e_write_cp15(struct target *target, int reg_addr, uint32_t value);
 
 extern const struct command_registration arm946e_command_handlers[];
 
-#endif	/* ARM946E_H */
+#endif /* OPENOCD_TARGET_ARM946E_H */
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index a174eab4..0429c54b 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/arm966e.h b/src/target/arm966e.h
index e7ace929..aa2e9bb2 100644
--- a/src/target/arm966e.h
+++ b/src/target/arm966e.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM966E_H
-#define ARM966E_H
+#ifndef OPENOCD_TARGET_ARM966E_H
+#define OPENOCD_TARGET_ARM966E_H
 
 #include "arm9tdmi.h"
 
@@ -47,4 +45,4 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value);
 
 extern const struct command_registration arm966e_command_handlers[];
 
-#endif /* ARM966E_H */
+#endif /* OPENOCD_TARGET_ARM966E_H */
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index ca000a7f..82b430f8 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -32,6 +30,7 @@
 #include "target_type.h"
 #include "register.h"
 #include "arm_opcodes.h"
+#include "arm_semihosting.h"
 
 /*
  * NOTE:  this holds code that's used with multiple ARM9 processors:
@@ -716,6 +715,7 @@ int arm9tdmi_init_target(struct command_context *cmd_ctx,
 		struct target *target)
 {
 	arm9tdmi_build_reg_cache(target);
+	arm_semihosting_init(target);
 	return ERROR_OK;
 }
 
diff --git a/src/target/arm9tdmi.h b/src/target/arm9tdmi.h
index 366cd129..c6f0ccf0 100644
--- a/src/target/arm9tdmi.h
+++ b/src/target/arm9tdmi.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM9TDMI_H
-#define ARM9TDMI_H
+#ifndef OPENOCD_TARGET_ARM9TDMI_H
+#define OPENOCD_TARGET_ARM9TDMI_H
 
 #include "embeddedice.h"
 
@@ -55,4 +53,4 @@ void arm9tdmi_branch_resume(struct target *target);
 void arm9tdmi_enable_single_step(struct target *target, uint32_t next_pc);
 void arm9tdmi_disable_single_step(struct target *target);
 
-#endif /* ARM9TDMI_H */
+#endif /* OPENOCD_TARGET_ARM9TDMI_H */
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 6efc0af1..20062902 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -24,9 +24,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /**
@@ -75,7 +73,9 @@
 #include "jtag/interface.h"
 #include "arm.h"
 #include "arm_adi_v5.h"
+#include <helper/jep106.h>
 #include <helper/time_support.h>
+#include <helper/list.h>
 
 /* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
 
@@ -346,8 +346,10 @@ static int mem_ap_write(struct adiv5_ap *ap, const uint8_t *buffer, uint32_t siz
 			case 4:
 				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
 				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
+				/* fallthrough */
 			case 2:
 				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
+				/* fallthrough */
 			case 1:
 				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
 			}
@@ -509,8 +511,10 @@ static int mem_ap_read(struct adiv5_ap *ap, uint8_t *buffer, uint32_t size, uint
 			case 4:
 				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
 				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
+				/* fallthrough */
 			case 2:
 				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
+				/* fallthrough */
 			case 1:
 				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
 			}
@@ -519,8 +523,10 @@ static int mem_ap_read(struct adiv5_ap *ap, uint8_t *buffer, uint32_t size, uint
 			case 4:
 				*buffer++ = *read_ptr >> 8 * (address++ & 3);
 				*buffer++ = *read_ptr >> 8 * (address++ & 3);
+				/* fallthrough */
 			case 2:
 				*buffer++ = *read_ptr >> 8 * (address++ & 3);
+				/* fallthrough */
 			case 1:
 				*buffer++ = *read_ptr >> 8 * (address++ & 3);
 			}
@@ -586,6 +592,7 @@ struct adiv5_dap *dap_init(void)
 		/* Number of bits for tar autoincrement, impl. dep. at least 10 */
 		dap->ap[i].tar_autoincr_block = (1<<10);
 	}
+	INIT_LIST_HEAD(&dap->cmd_journal);
 	return dap;
 }
 
@@ -611,60 +618,58 @@ int dap_dp_init(struct adiv5_dap *dap)
 	dap->select = DP_SELECT_INVALID;
 	dap->last_read = NULL;
 
-	for (size_t i = 0; i < 10; i++) {
+	for (size_t i = 0; i < 30; i++) {
 		/* DP initialization */
 
-		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-		if (retval != ERROR_OK)
-			continue;
-
-		retval = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
-		if (retval != ERROR_OK)
-			continue;
+		retval = dap_dp_read_atomic(dap, DP_CTRL_STAT, NULL);
+		if (retval == ERROR_OK)
+			break;
+	}
 
-		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-		if (retval != ERROR_OK)
-			continue;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
+	if (retval != ERROR_OK)
+		return retval;
 
-		dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-		retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
-		if (retval != ERROR_OK)
-			continue;
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (retval != ERROR_OK)
+		return retval;
 
-		/* Check that we have debug power domains activated */
-		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
-		retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
-					      CDBGPWRUPACK, CDBGPWRUPACK,
-					      DAP_POWER_DOMAIN_TIMEOUT);
-		if (retval != ERROR_OK)
-			continue;
+	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
 
-		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-		retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
-					      CSYSPWRUPACK, CSYSPWRUPACK,
-					      DAP_POWER_DOMAIN_TIMEOUT);
-		if (retval != ERROR_OK)
-			continue;
+	/* Check that we have debug power domains activated */
+	LOG_DEBUG("DAP: wait CDBGPWRUPACK");
+	retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
+				      CDBGPWRUPACK, CDBGPWRUPACK,
+				      DAP_POWER_DOMAIN_TIMEOUT);
+	if (retval != ERROR_OK)
+		return retval;
 
-		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-		if (retval != ERROR_OK)
-			continue;
+	LOG_DEBUG("DAP: wait CSYSPWRUPACK");
+	retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
+				      CSYSPWRUPACK, CSYSPWRUPACK,
+				      DAP_POWER_DOMAIN_TIMEOUT);
+	if (retval != ERROR_OK)
+		return retval;
 
-		/* With debug power on we can activate OVERRUN checking */
-		dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-		retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
-		if (retval != ERROR_OK)
-			continue;
-		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-		if (retval != ERROR_OK)
-			continue;
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (retval != ERROR_OK)
+		return retval;
 
-		retval = dap_run(dap);
-		if (retval != ERROR_OK)
-			continue;
+	/* With debug power on we can activate OVERRUN checking */
+	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (retval != ERROR_OK)
+		return retval;
 
-		break;
-	}
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return retval;
 }
@@ -737,10 +742,9 @@ static const char *class_description[16] = {
 	"Generic IP component", "PrimeCell or System component"
 };
 
-static bool is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
+static bool is_dap_cid_ok(uint32_t cid)
 {
-	return cid3 == 0xb1 && cid2 == 0x05
-			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
+	return (cid & 0xffff0fff) == 0xb105000d;
 }
 
 /*
@@ -874,6 +878,61 @@ int dap_lookup_cs_component(struct adiv5_ap *ap,
 	return ERROR_OK;
 }
 
+static int dap_read_part_id(struct adiv5_ap *ap, uint32_t component_base, uint32_t *cid, uint64_t *pid)
+{
+	assert((component_base & 0xFFF) == 0);
+	assert(ap != NULL && cid != NULL && pid != NULL);
+
+	uint32_t cid0, cid1, cid2, cid3;
+	uint32_t pid0, pid1, pid2, pid3, pid4;
+	int retval;
+
+	/* IDs are in last 4K section */
+	retval = mem_ap_read_u32(ap, component_base + 0xFE0, &pid0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFE4, &pid1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFE8, &pid2);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFEC, &pid3);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFD0, &pid4);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFF0, &cid0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFF4, &cid1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFF8, &cid2);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = mem_ap_read_u32(ap, component_base + 0xFFC, &cid3);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_run(ap->dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	*cid = (cid3 & 0xff) << 24
+			| (cid2 & 0xff) << 16
+			| (cid1 & 0xff) << 8
+			| (cid0 & 0xff);
+	*pid = (uint64_t)(pid4 & 0xff) << 32
+			| (pid3 & 0xff) << 24
+			| (pid2 & 0xff) << 16
+			| (pid1 & 0xff) << 8
+			| (pid0 & 0xff);
+
+	return ERROR_OK;
+}
+
 /* The designer identity code is encoded as:
  * bits 11:8 : JEP106 Bank (number of continuation codes), only valid when bit 7 is 1.
  * bit 7     : Set when bits 6:0 represent a JEP106 ID and cleared when bits 6:0 represent
@@ -905,63 +964,102 @@ static const struct {
 	const char *type;
 	const char *full;
 } dap_partnums[] = {
-	{ ARM_ID, 0x000, "Cortex-M3 SCS",    "(System Control Space)", },
-	{ ARM_ID, 0x001, "Cortex-M3 ITM",    "(Instrumentation Trace Module)", },
-	{ ARM_ID, 0x002, "Cortex-M3 DWT",    "(Data Watchpoint and Trace)", },
-	{ ARM_ID, 0x003, "Cortex-M3 FBP",    "(Flash Patch and Breakpoint)", },
-	{ ARM_ID, 0x008, "Cortex-M0 SCS",    "(System Control Space)", },
-	{ ARM_ID, 0x00a, "Cortex-M0 DWT",    "(Data Watchpoint and Trace)", },
-	{ ARM_ID, 0x00b, "Cortex-M0 BPU",    "(Breakpoint Unit)", },
-	{ ARM_ID, 0x00c, "Cortex-M4 SCS",    "(System Control Space)", },
-	{ ARM_ID, 0x00d, "CoreSight ETM11",  "(Embedded Trace)", },
-	{ ARM_ID, 0x490, "Cortex-A15 GIC",   "(Generic Interrupt Controller)", },
-	{ ARM_ID, 0x4c7, "Cortex-M7 PPB",    "(Private Peripheral Bus ROM Table)", },
-	{ ARM_ID, 0x906, "CoreSight CTI",    "(Cross Trigger)", },
-	{ ARM_ID, 0x907, "CoreSight ETB",    "(Trace Buffer)", },
-	{ ARM_ID, 0x908, "CoreSight CSTF",   "(Trace Funnel)", },
-	{ ARM_ID, 0x910, "CoreSight ETM9",   "(Embedded Trace)", },
-	{ ARM_ID, 0x912, "CoreSight TPIU",   "(Trace Port Interface Unit)", },
-	{ ARM_ID, 0x913, "CoreSight ITM",    "(Instrumentation Trace Macrocell)", },
-	{ ARM_ID, 0x914, "CoreSight SWO",    "(Single Wire Output)", },
-	{ ARM_ID, 0x917, "CoreSight HTM",    "(AHB Trace Macrocell)", },
-	{ ARM_ID, 0x920, "CoreSight ETM11",  "(Embedded Trace)", },
-	{ ARM_ID, 0x921, "Cortex-A8 ETM",    "(Embedded Trace)", },
-	{ ARM_ID, 0x922, "Cortex-A8 CTI",    "(Cross Trigger)", },
-	{ ARM_ID, 0x923, "Cortex-M3 TPIU",   "(Trace Port Interface Unit)", },
-	{ ARM_ID, 0x924, "Cortex-M3 ETM",    "(Embedded Trace)", },
-	{ ARM_ID, 0x925, "Cortex-M4 ETM",    "(Embedded Trace)", },
-	{ ARM_ID, 0x930, "Cortex-R4 ETM",    "(Embedded Trace)", },
-	{ ARM_ID, 0x941, "CoreSight TPIU-Lite", "(Trace Port Interface Unit)", },
-	{ ARM_ID, 0x950, "CoreSight Component", "(unidentified Cortex-A9 component)", },
-	{ ARM_ID, 0x955, "CoreSight Component", "(unidentified Cortex-A5 component)", },
-	{ ARM_ID, 0x95f, "Cortex-A15 PTM",   "(Program Trace Macrocell)", },
-	{ ARM_ID, 0x961, "CoreSight TMC",    "(Trace Memory Controller)", },
-	{ ARM_ID, 0x962, "CoreSight STM",    "(System Trace Macrocell)", },
-	{ ARM_ID, 0x9a0, "CoreSight PMU",    "(Performance Monitoring Unit)", },
-	{ ARM_ID, 0x9a1, "Cortex-M4 TPIU",   "(Trace Port Interface Unit)", },
-	{ ARM_ID, 0x9a5, "Cortex-A5 ETM",    "(Embedded Trace)", },
-	{ ARM_ID, 0x9a7, "Cortex-A7 PMU",    "(Performance Monitor Unit)", },
-	{ ARM_ID, 0x9af, "Cortex-A15 PMU",   "(Performance Monitor Unit)", },
-	{ ARM_ID, 0xc05, "Cortex-A5 Debug",  "(Debug Unit)", },
-	{ ARM_ID, 0xc07, "Cortex-A7 Debug",  "(Debug Unit)", },
-	{ ARM_ID, 0xc08, "Cortex-A8 Debug",  "(Debug Unit)", },
-	{ ARM_ID, 0xc09, "Cortex-A9 Debug",  "(Debug Unit)", },
-	{ ARM_ID, 0xc0f, "Cortex-A15 Debug", "(Debug Unit)", },
-	{ ARM_ID, 0xc14, "Cortex-R4 Debug",  "(Debug Unit)", },
-	{ 0x0E5,  0x000, "SHARC+/Blackfin+", "", },
+	{ ARM_ID, 0x000, "Cortex-M3 SCS",              "(System Control Space)", },
+	{ ARM_ID, 0x001, "Cortex-M3 ITM",              "(Instrumentation Trace Module)", },
+	{ ARM_ID, 0x002, "Cortex-M3 DWT",              "(Data Watchpoint and Trace)", },
+	{ ARM_ID, 0x003, "Cortex-M3 FPB",              "(Flash Patch and Breakpoint)", },
+	{ ARM_ID, 0x008, "Cortex-M0 SCS",              "(System Control Space)", },
+	{ ARM_ID, 0x00a, "Cortex-M0 DWT",              "(Data Watchpoint and Trace)", },
+	{ ARM_ID, 0x00b, "Cortex-M0 BPU",              "(Breakpoint Unit)", },
+	{ ARM_ID, 0x00c, "Cortex-M4 SCS",              "(System Control Space)", },
+	{ ARM_ID, 0x00d, "CoreSight ETM11",            "(Embedded Trace)", },
+	{ ARM_ID, 0x00e, "Cortex-M7 FPB",              "(Flash Patch and Breakpoint)", },
+	{ ARM_ID, 0x490, "Cortex-A15 GIC",             "(Generic Interrupt Controller)", },
+	{ ARM_ID, 0x4a1, "Cortex-A53 ROM",             "(v8 Memory Map ROM Table)", },
+	{ ARM_ID, 0x4a2, "Cortex-A57 ROM",             "(ROM Table)", },
+	{ ARM_ID, 0x4a3, "Cortex-A53 ROM",             "(v7 Memory Map ROM Table)", },
+	{ ARM_ID, 0x4a4, "Cortex-A72 ROM",             "(ROM Table)", },
+	{ ARM_ID, 0x4af, "Cortex-A15 ROM",             "(ROM Table)", },
+	{ ARM_ID, 0x4c0, "Cortex-M0+ ROM",             "(ROM Table)", },
+	{ ARM_ID, 0x4c3, "Cortex-M3 ROM",              "(ROM Table)", },
+	{ ARM_ID, 0x4c4, "Cortex-M4 ROM",              "(ROM Table)", },
+	{ ARM_ID, 0x4c7, "Cortex-M7 PPB ROM",          "(Private Peripheral Bus ROM Table)", },
+	{ ARM_ID, 0x4c8, "Cortex-M7 ROM",              "(ROM Table)", },
+	{ ARM_ID, 0x470, "Cortex-M1 ROM",              "(ROM Table)", },
+	{ ARM_ID, 0x471, "Cortex-M0 ROM",              "(ROM Table)", },
+	{ ARM_ID, 0x906, "CoreSight CTI",              "(Cross Trigger)", },
+	{ ARM_ID, 0x907, "CoreSight ETB",              "(Trace Buffer)", },
+	{ ARM_ID, 0x908, "CoreSight CSTF",             "(Trace Funnel)", },
+	{ ARM_ID, 0x909, "CoreSight ATBR",             "(Advanced Trace Bus Replicator)", },
+	{ ARM_ID, 0x910, "CoreSight ETM9",             "(Embedded Trace)", },
+	{ ARM_ID, 0x912, "CoreSight TPIU",             "(Trace Port Interface Unit)", },
+	{ ARM_ID, 0x913, "CoreSight ITM",              "(Instrumentation Trace Macrocell)", },
+	{ ARM_ID, 0x914, "CoreSight SWO",              "(Single Wire Output)", },
+	{ ARM_ID, 0x917, "CoreSight HTM",              "(AHB Trace Macrocell)", },
+	{ ARM_ID, 0x920, "CoreSight ETM11",            "(Embedded Trace)", },
+	{ ARM_ID, 0x921, "Cortex-A8 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x922, "Cortex-A8 CTI",              "(Cross Trigger)", },
+	{ ARM_ID, 0x923, "Cortex-M3 TPIU",             "(Trace Port Interface Unit)", },
+	{ ARM_ID, 0x924, "Cortex-M3 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x925, "Cortex-M4 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x930, "Cortex-R4 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x931, "Cortex-R5 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x932, "CoreSight MTB-M0+",          "(Micro Trace Buffer)", },
+	{ ARM_ID, 0x941, "CoreSight TPIU-Lite",        "(Trace Port Interface Unit)", },
+	{ ARM_ID, 0x950, "Cortex-A9 PTM",              "(Program Trace Macrocell)", },
+	{ ARM_ID, 0x955, "Cortex-A5 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x95a, "Cortex-A72 ETM",             "(Embedded Trace)", },
+	{ ARM_ID, 0x95b, "Cortex-A17 PTM",             "(Program Trace Macrocell)", },
+	{ ARM_ID, 0x95d, "Cortex-A53 ETM",             "(Embedded Trace)", },
+	{ ARM_ID, 0x95e, "Cortex-A57 ETM",             "(Embedded Trace)", },
+	{ ARM_ID, 0x95f, "Cortex-A15 PTM",             "(Program Trace Macrocell)", },
+	{ ARM_ID, 0x961, "CoreSight TMC",              "(Trace Memory Controller)", },
+	{ ARM_ID, 0x962, "CoreSight STM",              "(System Trace Macrocell)", },
+	{ ARM_ID, 0x975, "Cortex-M7 ETM",              "(Embedded Trace)", },
+	{ ARM_ID, 0x9a0, "CoreSight PMU",              "(Performance Monitoring Unit)", },
+	{ ARM_ID, 0x9a1, "Cortex-M4 TPIU",             "(Trace Port Interface Unit)", },
+	{ ARM_ID, 0x9a4, "CoreSight GPR",              "(Granular Power Requester)", },
+	{ ARM_ID, 0x9a5, "Cortex-A5 PMU",              "(Performance Monitor Unit)", },
+	{ ARM_ID, 0x9a7, "Cortex-A7 PMU",              "(Performance Monitor Unit)", },
+	{ ARM_ID, 0x9a8, "Cortex-A53 CTI",             "(Cross Trigger)", },
+	{ ARM_ID, 0x9a9, "Cortex-M7 TPIU",             "(Trace Port Interface Unit)", },
+	{ ARM_ID, 0x9ae, "Cortex-A17 PMU",             "(Performance Monitor Unit)", },
+	{ ARM_ID, 0x9af, "Cortex-A15 PMU",             "(Performance Monitor Unit)", },
+	{ ARM_ID, 0x9b7, "Cortex-R7 PMU",              "(Performance Monitoring Unit)", },
+	{ ARM_ID, 0x9d3, "Cortex-A53 PMU",             "(Performance Monitor Unit)", },
+	{ ARM_ID, 0x9d7, "Cortex-A57 PMU",             "(Performance Monitor Unit)", },
+	{ ARM_ID, 0x9d8, "Cortex-A72 PMU",             "(Performance Monitor Unit)", },
+	{ ARM_ID, 0xc05, "Cortex-A5 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xc07, "Cortex-A7 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xc08, "Cortex-A8 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xc09, "Cortex-A9 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xc0e, "Cortex-A17 Debug",           "(Debug Unit)", },
+	{ ARM_ID, 0xc0f, "Cortex-A15 Debug",           "(Debug Unit)", },
+	{ ARM_ID, 0xc14, "Cortex-R4 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xc15, "Cortex-R5 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xc17, "Cortex-R7 Debug",            "(Debug Unit)", },
+	{ ARM_ID, 0xd03, "Cortex-A53 Debug",           "(Debug Unit)", },
+	{ ARM_ID, 0xd07, "Cortex-A57 Debug",           "(Debug Unit)", },
+	{ ARM_ID, 0xd08, "Cortex-A72 Debug",           "(Debug Unit)", },
+	{ 0x097,  0x9af, "MSP432 ROM",                 "(ROM Table)" },
+	{ 0x09f,  0xcd0, "Atmel CPU with DSU",         "(CPU)" },
+	{ 0x0c1,  0x1db, "XMC4500 ROM",                "(ROM Table)" },
+	{ 0x0c1,  0x1df, "XMC4700/4800 ROM",           "(ROM Table)" },
+	{ 0x0c1,  0x1ed, "XMC1000 ROM",                "(ROM Table)" },
+	{ 0x0E5,  0x000, "SHARC+/Blackfin+",           "", },
+	{ 0x0F0,  0x440, "Qualcomm QDSS Component v1", "(Qualcomm Designed CoreSight Component v1)", },
 	/* legacy comment: 0x113: what? */
-	{ ANY_ID,  0x120, "TI SDTI",         "(System Debug Trace Interface)", }, /* from OMAP3 memmap */
-	{ ANY_ID,  0x343, "TI DAPCTL",       "", }, /* from OMAP3 memmap */
+	{ ANY_ID, 0x120, "TI SDTI",                    "(System Debug Trace Interface)", }, /* from OMAP3 memmap */
+	{ ANY_ID, 0x343, "TI DAPCTL",                  "", }, /* from OMAP3 memmap */
 };
 
 static int dap_rom_display(struct command_context *cmd_ctx,
 				struct adiv5_ap *ap, uint32_t dbgbase, int depth)
 {
-	struct adiv5_dap *dap = ap->dap;
 	int retval;
-	uint32_t cid0, cid1, cid2, cid3, memtype, romentry;
-	uint16_t entry_offset;
-	char tabs[7] = "";
+	uint64_t pid;
+	uint32_t cid;
+	char tabs[16] = "";
 
 	if (depth > 16) {
 		command_print(cmd_ctx, "\tTables too deep");
@@ -971,330 +1069,241 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 	if (depth)
 		snprintf(tabs, sizeof(tabs), "[L%02d] ", depth);
 
-	/* bit 16 of apid indicates a memory access port */
-	if (dbgbase & 0x02)
-		command_print(cmd_ctx, "\t%sValid ROM table present", tabs);
-	else
-		command_print(cmd_ctx, "\t%sROM table in legacy format", tabs);
+	uint32_t base_addr = dbgbase & 0xFFFFF000;
+	command_print(cmd_ctx, "\t\tComponent base address 0x%08" PRIx32, base_addr);
 
-	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	retval = mem_ap_read_u32(ap, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = mem_ap_read_u32(ap, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = mem_ap_read_u32(ap, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = mem_ap_read_u32(ap, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = mem_ap_read_u32(ap, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
+	retval = dap_read_part_id(ap, base_addr, &cid, &pid);
+	if (retval != ERROR_OK) {
+		command_print(cmd_ctx, "\t\tCan't read component, the corresponding core might be turned off");
+		return ERROR_OK; /* Don't abort recursion */
+	}
 
-	if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-		command_print(cmd_ctx, "\t%sCID3 0x%02x"
-				", CID2 0x%02x"
-				", CID1 0x%02x"
-				", CID0 0x%02x",
-				tabs,
-				(unsigned)cid3, (unsigned)cid2,
-				(unsigned)cid1, (unsigned)cid0);
-	if (memtype & 0x01)
-		command_print(cmd_ctx, "\t%sMEMTYPE system memory present on bus", tabs);
-	else
-		command_print(cmd_ctx, "\t%sMEMTYPE system memory not present: dedicated debug bus", tabs);
+	if (!is_dap_cid_ok(cid)) {
+		command_print(cmd_ctx, "\t\tInvalid CID 0x%08" PRIx32, cid);
+		return ERROR_OK; /* Don't abort recursion */
+	}
+
+	/* component may take multiple 4K pages */
+	uint32_t size = (pid >> 36) & 0xf;
+	if (size > 0)
+		command_print(cmd_ctx, "\t\tStart address 0x%08" PRIx32, (uint32_t)(base_addr - 0x1000 * size));
 
-	/* Now we read ROM table entries from dbgbase&0xFFFFF000) | 0x000 until we get 0x00000000 */
-	for (entry_offset = 0; ; entry_offset += 4) {
-		retval = mem_ap_read_atomic_u32(ap, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+	command_print(cmd_ctx, "\t\tPeripheral ID 0x%010" PRIx64, pid);
+
+	uint8_t class = (cid >> 12) & 0xf;
+	uint16_t part_num = pid & 0xfff;
+	uint16_t designer_id = ((pid >> 32) & 0xf) << 8 | ((pid >> 12) & 0xff);
+
+	if (designer_id & 0x80) {
+		/* JEP106 code */
+		command_print(cmd_ctx, "\t\tDesigner is 0x%03" PRIx16 ", %s",
+				designer_id, jep106_manufacturer(designer_id >> 8, designer_id & 0x7f));
+	} else {
+		/* Legacy ASCII ID, clear invalid bits */
+		designer_id &= 0x7f;
+		command_print(cmd_ctx, "\t\tDesigner ASCII code 0x%02" PRIx16 ", %s",
+				designer_id, designer_id == 0x41 ? "ARM" : "<unknown>");
+	}
+
+	/* default values to be overwritten upon finding a match */
+	const char *type = "Unrecognized";
+	const char *full = "";
+
+	/* search dap_partnums[] array for a match */
+	for (unsigned entry = 0; entry < ARRAY_SIZE(dap_partnums); entry++) {
+
+		if ((dap_partnums[entry].designer_id != designer_id) && (dap_partnums[entry].designer_id != ANY_ID))
+			continue;
+
+		if (dap_partnums[entry].part_num != part_num)
+			continue;
+
+		type = dap_partnums[entry].type;
+		full = dap_partnums[entry].full;
+		break;
+	}
+
+	command_print(cmd_ctx, "\t\tPart is 0x%" PRIx16", %s %s", part_num, type, full);
+	command_print(cmd_ctx, "\t\tComponent class is 0x%" PRIx8 ", %s", class, class_description[class]);
+
+	if (class == 1) { /* ROM Table */
+		uint32_t memtype;
+		retval = mem_ap_read_atomic_u32(ap, base_addr | 0xFCC, &memtype);
 		if (retval != ERROR_OK)
 			return retval;
-		command_print(cmd_ctx, "\t%sROMTABLE[0x%x] = 0x%" PRIx32 "",
-				tabs, entry_offset, romentry);
-		if (romentry & 0x01) {
-			uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
-			uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
-			uint32_t component_base;
-			uint16_t part_num, designer_id;
-			const char *type, *full;
-
-			component_base = (dbgbase & 0xFFFFF000) + (romentry & 0xFFFFF000);
-
-			/* IDs are in last 4K section */
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFE0, &c_pid0);
-			if (retval != ERROR_OK) {
-				command_print(cmd_ctx, "\t%s\tCan't read component with base address 0x%" PRIx32
-					      ", the corresponding core might be turned off", tabs, component_base);
-				continue;
-			}
-			c_pid0 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFE4, &c_pid1);
-			if (retval != ERROR_OK)
-				return retval;
-			c_pid1 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFE8, &c_pid2);
-			if (retval != ERROR_OK)
-				return retval;
-			c_pid2 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFEC, &c_pid3);
-			if (retval != ERROR_OK)
-				return retval;
-			c_pid3 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFD0, &c_pid4);
-			if (retval != ERROR_OK)
-				return retval;
-			c_pid4 &= 0xff;
 
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFF0, &c_cid0);
-			if (retval != ERROR_OK)
-				return retval;
-			c_cid0 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFF4, &c_cid1);
-			if (retval != ERROR_OK)
-				return retval;
-			c_cid1 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFF8, &c_cid2);
-			if (retval != ERROR_OK)
-				return retval;
-			c_cid2 &= 0xff;
-			retval = mem_ap_read_atomic_u32(ap, component_base + 0xFFC, &c_cid3);
+		if (memtype & 0x01)
+			command_print(cmd_ctx, "\t\tMEMTYPE system memory present on bus");
+		else
+			command_print(cmd_ctx, "\t\tMEMTYPE system memory not present: dedicated debug bus");
+
+		/* Read ROM table entries from base address until we get 0x00000000 or reach the reserved area */
+		for (uint16_t entry_offset = 0; entry_offset < 0xF00; entry_offset += 4) {
+			uint32_t romentry;
+			retval = mem_ap_read_atomic_u32(ap, base_addr | entry_offset, &romentry);
 			if (retval != ERROR_OK)
 				return retval;
-			c_cid3 &= 0xff;
-
-			command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32 ", "
-				      "start address 0x%" PRIx32, component_base,
-				      /* component may take multiple 4K pages */
-				      (uint32_t)(component_base - 0x1000*(c_pid4 >> 4)));
-			command_print(cmd_ctx, "\t\tComponent class is 0x%" PRIx8 ", %s",
-					(uint8_t)((c_cid1 >> 4) & 0xf),
-					/* See ARM IHI 0029B Table 3-3 */
-					class_description[(c_cid1 >> 4) & 0xf]);
-
-			/* CoreSight component? */
-			if (((c_cid1 >> 4) & 0x0f) == 9) {
-				uint32_t devtype;
-				unsigned minor;
-				const char *major = "Reserved", *subtype = "Reserved";
-
-				retval = mem_ap_read_atomic_u32(ap,
-						(component_base & 0xfffff000) | 0xfcc,
-						&devtype);
+			command_print(cmd_ctx, "\t%sROMTABLE[0x%x] = 0x%" PRIx32 "",
+					tabs, entry_offset, romentry);
+			if (romentry & 0x01) {
+				/* Recurse */
+				retval = dap_rom_display(cmd_ctx, ap, base_addr + (romentry & 0xFFFFF000), depth + 1);
 				if (retval != ERROR_OK)
 					return retval;
-				minor = (devtype >> 4) & 0x0f;
-				switch (devtype & 0x0f) {
-				case 0:
-					major = "Miscellaneous";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 4:
-						subtype = "Validation component";
-						break;
-					}
-					break;
-				case 1:
-					major = "Trace Sink";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 1:
-						subtype = "Port";
-						break;
-					case 2:
-						subtype = "Buffer";
-						break;
-					case 3:
-						subtype = "Router";
-						break;
-					}
-					break;
-				case 2:
-					major = "Trace Link";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 1:
-						subtype = "Funnel, router";
-						break;
-					case 2:
-						subtype = "Filter";
-						break;
-					case 3:
-						subtype = "FIFO, buffer";
-						break;
-					}
-					break;
-				case 3:
-					major = "Trace Source";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 1:
-						subtype = "Processor";
-						break;
-					case 2:
-						subtype = "DSP";
-						break;
-					case 3:
-						subtype = "Engine/Coprocessor";
-						break;
-					case 4:
-						subtype = "Bus";
-						break;
-					case 6:
-						subtype = "Software";
-						break;
-					}
-					break;
-				case 4:
-					major = "Debug Control";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 1:
-						subtype = "Trigger Matrix";
-						break;
-					case 2:
-						subtype = "Debug Auth";
-						break;
-					case 3:
-						subtype = "Power Requestor";
-						break;
-					}
-					break;
-				case 5:
-					major = "Debug Logic";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 1:
-						subtype = "Processor";
-						break;
-					case 2:
-						subtype = "DSP";
-						break;
-					case 3:
-						subtype = "Engine/Coprocessor";
-						break;
-					case 4:
-						subtype = "Bus";
-						break;
-					case 5:
-						subtype = "Memory";
-						break;
-					}
-					break;
-				case 6:
-					major = "Perfomance Monitor";
-					switch (minor) {
-					case 0:
-						subtype = "other";
-						break;
-					case 1:
-						subtype = "Processor";
-						break;
-					case 2:
-						subtype = "DSP";
-						break;
-					case 3:
-						subtype = "Engine/Coprocessor";
-						break;
-					case 4:
-						subtype = "Bus";
-						break;
-					case 5:
-						subtype = "Memory";
-						break;
-					}
-					break;
-				}
-				command_print(cmd_ctx, "\t\tType is 0x%02" PRIx8 ", %s, %s",
-						(uint8_t)(devtype & 0xff),
-						major, subtype);
-				/* REVISIT also show 0xfc8 DevId */
+			} else if (romentry != 0) {
+				command_print(cmd_ctx, "\t\tComponent not present");
+			} else {
+				command_print(cmd_ctx, "\t%s\tEnd of ROM table", tabs);
+				break;
 			}
+		}
+	} else if (class == 9) { /* CoreSight component */
+		const char *major = "Reserved", *subtype = "Reserved";
 
-			if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-				command_print(cmd_ctx,
-						"\t\tCID3 0%02x"
-						", CID2 0%02x"
-						", CID1 0%02x"
-						", CID0 0%02x",
-						(int)c_cid3,
-						(int)c_cid2,
-						(int)c_cid1,
-						(int)c_cid0);
-			command_print(cmd_ctx,
-				"\t\tPeripheral ID[4..0] = hex "
-				"%02x %02x %02x %02x %02x",
-				(int)c_pid4, (int)c_pid3, (int)c_pid2,
-				(int)c_pid1, (int)c_pid0);
-
-			part_num = (c_pid0 & 0xff);
-			part_num |= (c_pid1 & 0x0f) << 8;
-			designer_id = (c_pid1 & 0xf0) >> 4;
-			designer_id |= (c_pid2 & 0x0f) << 4;
-			designer_id |= (c_pid4 & 0x0f) << 8;
-			if ((designer_id & 0x80) == 0) {
-				/* Legacy ASCII ID, clear invalid bits */
-				designer_id &= 0x7f;
+		uint32_t devtype;
+		retval = mem_ap_read_atomic_u32(ap, base_addr | 0xFCC, &devtype);
+		if (retval != ERROR_OK)
+			return retval;
+		unsigned minor = (devtype >> 4) & 0x0f;
+		switch (devtype & 0x0f) {
+		case 0:
+			major = "Miscellaneous";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 4:
+				subtype = "Validation component";
+				break;
 			}
-
-			/* default values to be overwritten upon finding a match */
-			type = NULL;
-			full = "";
-
-			/* search dap_partnums[] array for a match */
-			unsigned entry;
-			for (entry = 0; entry < ARRAY_SIZE(dap_partnums); entry++) {
-
-				if ((dap_partnums[entry].designer_id != designer_id) && (dap_partnums[entry].designer_id != ANY_ID))
-					continue;
-
-				if (dap_partnums[entry].part_num != part_num)
-					continue;
-
-				type = dap_partnums[entry].type;
-				full = dap_partnums[entry].full;
+			break;
+		case 1:
+			major = "Trace Sink";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 1:
+				subtype = "Port";
+				break;
+			case 2:
+				subtype = "Buffer";
+				break;
+			case 3:
+				subtype = "Router";
 				break;
 			}
-
-			if (type) {
-				command_print(cmd_ctx, "\t\tPart is %s %s",
-						type, full);
-			} else {
-				command_print(cmd_ctx, "\t\tUnrecognized (Part 0x%" PRIx16 ", designer 0x%" PRIx16 ")",
-						part_num, designer_id);
+			break;
+		case 2:
+			major = "Trace Link";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 1:
+				subtype = "Funnel, router";
+				break;
+			case 2:
+				subtype = "Filter";
+				break;
+			case 3:
+				subtype = "FIFO, buffer";
+				break;
 			}
-
-			/* ROM Table? */
-			if (((c_cid1 >> 4) & 0x0f) == 1) {
-				retval = dap_rom_display(cmd_ctx, ap, component_base, depth + 1);
-				if (retval != ERROR_OK)
-					return retval;
+			break;
+		case 3:
+			major = "Trace Source";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 1:
+				subtype = "Processor";
+				break;
+			case 2:
+				subtype = "DSP";
+				break;
+			case 3:
+				subtype = "Engine/Coprocessor";
+				break;
+			case 4:
+				subtype = "Bus";
+				break;
+			case 6:
+				subtype = "Software";
+				break;
 			}
-		} else {
-			if (romentry)
-				command_print(cmd_ctx, "\t\tComponent not present");
-			else
+			break;
+		case 4:
+			major = "Debug Control";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 1:
+				subtype = "Trigger Matrix";
+				break;
+			case 2:
+				subtype = "Debug Auth";
+				break;
+			case 3:
+				subtype = "Power Requestor";
 				break;
+			}
+			break;
+		case 5:
+			major = "Debug Logic";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 1:
+				subtype = "Processor";
+				break;
+			case 2:
+				subtype = "DSP";
+				break;
+			case 3:
+				subtype = "Engine/Coprocessor";
+				break;
+			case 4:
+				subtype = "Bus";
+				break;
+			case 5:
+				subtype = "Memory";
+				break;
+			}
+			break;
+		case 6:
+			major = "Perfomance Monitor";
+			switch (minor) {
+			case 0:
+				subtype = "other";
+				break;
+			case 1:
+				subtype = "Processor";
+				break;
+			case 2:
+				subtype = "DSP";
+				break;
+			case 3:
+				subtype = "Engine/Coprocessor";
+				break;
+			case 4:
+				subtype = "Bus";
+				break;
+			case 5:
+				subtype = "Memory";
+				break;
+			}
+			break;
 		}
+		command_print(cmd_ctx, "\t\tType is 0x%02" PRIx8 ", %s, %s",
+				(uint8_t)(devtype & 0xff),
+				major, subtype);
+		/* REVISIT also show 0xfc8 DevId */
 	}
-	command_print(cmd_ctx, "\t%s\tEnd of ROM table", tabs);
+
 	return ERROR_OK;
 }
 
@@ -1303,7 +1312,6 @@ static int dap_info_command(struct command_context *cmd_ctx,
 {
 	int retval;
 	uint32_t dbgbase, apid;
-	int romtable_present = 0;
 	uint8_t mem_ap;
 
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
@@ -1342,16 +1350,56 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	if (mem_ap) {
 		command_print(cmd_ctx, "MEM-AP BASE 0x%8.8" PRIx32, dbgbase);
 
-		romtable_present = dbgbase != 0xFFFFFFFF;
-		if (romtable_present)
-			dap_rom_display(cmd_ctx, ap, dbgbase, 0);
-		else
+		if (dbgbase == 0xFFFFFFFF || (dbgbase & 0x3) == 0x2) {
 			command_print(cmd_ctx, "\tNo ROM table present");
+		} else {
+			if (dbgbase & 0x01)
+				command_print(cmd_ctx, "\tValid ROM table present");
+			else
+				command_print(cmd_ctx, "\tROM table in legacy format");
+
+			dap_rom_display(cmd_ctx, ap, dbgbase & 0xFFFFF000, 0);
+		}
 	}
 
 	return ERROR_OK;
 }
 
+int adiv5_jim_configure(struct target *target, Jim_GetOptInfo *goi)
+{
+	struct adiv5_private_config *pc;
+	const char *arg;
+	jim_wide ap_num;
+	int e;
+
+	/* check if argv[0] is for us */
+	arg = Jim_GetString(goi->argv[0], NULL);
+	if (strcmp(arg, "-ap-num"))
+		return JIM_CONTINUE;
+
+	e = Jim_GetOpt_String(goi, &arg, NULL);
+	if (e != JIM_OK)
+		return e;
+
+	if (goi->argc == 0) {
+		Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "-ap-num ?ap-number? ...");
+		return JIM_ERR;
+	}
+
+	e = Jim_GetOpt_Wide(goi, &ap_num);
+	if (e != JIM_OK)
+		return e;
+
+	if (target->private_config == NULL) {
+		pc = calloc(1, sizeof(struct adiv5_private_config));
+		target->private_config = pc;
+		pc->ap_num = ap_num;
+	}
+
+
+	return JIM_OK;
+}
+
 COMMAND_HANDLER(handle_dap_info_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
@@ -1547,6 +1595,45 @@ COMMAND_HANDLER(dap_apid_command)
 	return retval;
 }
 
+COMMAND_HANDLER(dap_apreg_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, reg, value;
+	int retval;
+
+	if (CMD_ARGC < 2 || CMD_ARGC > 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+	/* AP address is in bits 31:24 of DP_SELECT */
+	if (apsel >= 256)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], reg);
+	if (reg >= 256 || (reg & 3))
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (CMD_ARGC == 3) {
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
+		retval = dap_queue_ap_write(dap_ap(dap, apsel), reg, value);
+	} else {
+		retval = dap_queue_ap_read(dap_ap(dap, apsel), reg, &value);
+	}
+	if (retval == ERROR_OK)
+		retval = dap_run(dap);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (CMD_ARGC == 2)
+		command_print(CMD_CTX, "0x%08" PRIx32, value);
+
+	return retval;
+}
+
 COMMAND_HANDLER(dap_ti_be_32_quirks_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
@@ -1606,6 +1693,14 @@ static const struct command_registration dap_commands[] = {
 			"(default currently selected AP)",
 		.usage = "[ap_num]",
 	},
+	{
+		.name = "apreg",
+		.handler = dap_apreg_command,
+		.mode = COMMAND_EXEC,
+		.help = "read/write a register from AP "
+			"(reg is byte address of a word register, like 0 4 8...)",
+		.usage = "ap_num reg [value]",
+	},
 	{
 		.name = "baseaddr",
 		.handler = dap_baseaddr_command,
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index fed25ec2..bf9cb5cc 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM_ADI_V5_H
-#define ARM_ADI_V5_H
+#ifndef OPENOCD_TARGET_ARM_ADI_V5_H
+#define OPENOCD_TARGET_ARM_ADI_V5_H
 
 /**
  * @file
@@ -31,14 +29,9 @@
  * resources accessed through a MEM-AP.
  */
 
+#include <helper/list.h>
 #include "arm_jtag.h"
 
-/* FIXME remove these JTAG-specific decls when mem_ap_read_buf_u32()
- * is no longer JTAG-specific
- */
-#define JTAG_DP_DPACC		0xA
-#define JTAG_DP_APACC		0xB
-
 /* three-bit ACK values for SWD access (sent LSB first) */
 #define SWD_ACK_OK    0x1
 #define SWD_ACK_WAIT  0x2
@@ -52,18 +45,21 @@
 /* A[3:0] for DP registers; A[1:0] are always zero.
  * - JTAG accesses all of these via JTAG_DP_DPACC, except for
  *   IDCODE (JTAG_DP_IDCODE) and ABORT (JTAG_DP_ABORT).
- * - SWD accesses these directly, sometimes needing SELECT.CTRLSEL
+ * - SWD accesses these directly, sometimes needing SELECT.DPBANKSEL
  */
-#define DP_IDCODE		BANK_REG(0x0, 0x0)	/* SWD: read */
-#define DP_ABORT		BANK_REG(0x0, 0x0)	/* SWD: write */
-#define DP_CTRL_STAT		BANK_REG(0x0, 0x4)	/* r/w */
-#define DP_RESEND		BANK_REG(0x0, 0x8)	/* SWD: read */
-#define DP_SELECT		BANK_REG(0x0, 0x8)	/* JTAG: r/w; SWD: write */
-#define DP_RDBUFF		BANK_REG(0x0, 0xC)	/* read-only */
-#define DP_WCR			BANK_REG(0x1, 0x4)	/* SWD: r/w */
-
-#define WCR_TO_TRN(wcr) ((uint32_t)(1 + (3 & ((wcr)) >> 8)))	/* 1..4 clocks */
-#define WCR_TO_PRESCALE(wcr) ((uint32_t)(7 & ((wcr))))		/* impl defined */
+#define DP_DPIDR        BANK_REG(0x0, 0x0) /* DPv1+: ro */
+#define DP_ABORT        BANK_REG(0x0, 0x0) /* DPv1+: SWD: wo */
+#define DP_CTRL_STAT    BANK_REG(0x0, 0x4) /* DPv0+: rw */
+#define DP_DLCR         BANK_REG(0x1, 0x4) /* DPv1+: SWD: rw */
+#define DP_TARGETID     BANK_REG(0x2, 0x4) /* DPv2: ro */
+#define DP_DLPIDR       BANK_REG(0x3, 0x4) /* DPv2: ro */
+#define DP_EVENTSTAT    BANK_REG(0x4, 0x4) /* DPv2: ro */
+#define DP_RESEND       BANK_REG(0x0, 0x8) /* DPv1+: SWD: ro */
+#define DP_SELECT       BANK_REG(0x0, 0x8) /* DPv0+: JTAG: rw; SWD: wo */
+#define DP_RDBUFF       BANK_REG(0x0, 0xC) /* DPv0+: ro */
+#define DP_TARGETSEL    BANK_REG(0x0, 0xC) /* DPv2: SWD: wo */
+
+#define DLCR_TO_TRN(dlcr) ((uint32_t)(1 + ((3 & (dlcr)) >> 8))) /* 1..4 clocks */
 
 /* Fields of the DP's AP ABORT register */
 #define DAPABORT        (1UL << 0)
@@ -206,6 +202,9 @@ struct adiv5_ap {
 struct adiv5_dap {
 	const struct dap_ops *ops;
 
+	/* dap transaction list for WAIT support */
+	struct list_head cmd_journal;
+
 	struct jtag_tap *tap;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
@@ -270,6 +269,10 @@ struct dap_ops {
 
 	/** Executes all queued DAP operations. */
 	int (*run)(struct adiv5_dap *dap);
+
+	/** Executes all queued DAP operations but doesn't check
+	 * sticky error conditions */
+	int (*sync)(struct adiv5_dap *dap);
 };
 
 /*
@@ -393,6 +396,14 @@ static inline int dap_run(struct adiv5_dap *dap)
 	return dap->ops->run(dap);
 }
 
+static inline int dap_sync(struct adiv5_dap *dap)
+{
+	assert(dap->ops != NULL);
+	if (dap->ops->sync)
+		return dap->ops->sync(dap);
+	return ERROR_OK;
+}
+
 static inline int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg,
 				     uint32_t *value)
 {
@@ -493,4 +504,10 @@ int dap_to_jtag(struct target *target);
 
 extern const struct command_registration dap_command_handlers[];
 
-#endif
+struct adiv5_private_config {
+	int ap_num;
+};
+
+extern int adiv5_jim_configure(struct target *target, Jim_GetOptInfo *goi);
+
+#endif /* OPENOCD_TARGET_ARM_ADI_V5_H */
diff --git a/src/target/arm_cti.c b/src/target/arm_cti.c
new file mode 100644
index 00000000..75169b2e
--- /dev/null
+++ b/src/target/arm_cti.c
@@ -0,0 +1,148 @@
+/***************************************************************************
+ *   Copyright (C) 2016 by Matthias Welwarsky                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdint.h>
+#include "target/arm_adi_v5.h"
+#include "target/arm_cti.h"
+#include "target/target.h"
+#include "helper/time_support.h"
+
+struct arm_cti {
+	uint32_t base;
+	struct adiv5_ap *ap;
+};
+
+struct arm_cti *arm_cti_create(struct adiv5_ap *ap, uint32_t base)
+{
+	struct arm_cti *self = calloc(1, sizeof(struct arm_cti));
+	if (!self)
+		return NULL;
+
+	self->base = base;
+	self->ap = ap;
+	return self;
+}
+
+static int arm_cti_mod_reg_bits(struct arm_cti *self, unsigned int reg, uint32_t mask, uint32_t value)
+{
+	uint32_t tmp;
+
+	/* Read register */
+	int retval = mem_ap_read_atomic_u32(self->ap, self->base + reg, &tmp);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* clear bitfield */
+	tmp &= ~mask;
+	/* put new value */
+	tmp |= value & mask;
+
+	/* write new value */
+	return mem_ap_write_atomic_u32(self->ap, self->base + reg, tmp);
+}
+
+int arm_cti_enable(struct arm_cti *self, bool enable)
+{
+	uint32_t val = enable ? 1 : 0;
+
+	return mem_ap_write_atomic_u32(self->ap, self->base + CTI_CTR, val);
+}
+
+int arm_cti_ack_events(struct arm_cti *self, uint32_t event)
+{
+	int retval;
+	uint32_t tmp;
+
+	retval = mem_ap_write_atomic_u32(self->ap, self->base + CTI_INACK, event);
+	if (retval == ERROR_OK) {
+		int64_t then = timeval_ms();
+		for (;;) {
+			retval = mem_ap_read_atomic_u32(self->ap, self->base + CTI_TROUT_STATUS, &tmp);
+			if (retval != ERROR_OK)
+				break;
+			if ((tmp & event) == 0)
+				break;
+			if (timeval_ms() > then + 1000) {
+				LOG_ERROR("timeout waiting for target");
+				retval = ERROR_TARGET_TIMEOUT;
+				break;
+			}
+		}
+	}
+
+	return retval;
+}
+
+int arm_cti_gate_channel(struct arm_cti *self, uint32_t channel)
+{
+	if (channel > 31)
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+
+	return arm_cti_mod_reg_bits(self, CTI_GATE, CTI_CHNL(channel), 0);
+}
+
+int arm_cti_ungate_channel(struct arm_cti *self, uint32_t channel)
+{
+	if (channel > 31)
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+
+	return arm_cti_mod_reg_bits(self, CTI_GATE, CTI_CHNL(channel), 0xFFFFFFFF);
+}
+
+int arm_cti_write_reg(struct arm_cti *self, unsigned int reg, uint32_t value)
+{
+	return mem_ap_write_atomic_u32(self->ap, self->base + reg, value);
+}
+
+int arm_cti_read_reg(struct arm_cti *self, unsigned int reg, uint32_t *p_value)
+{
+	if (p_value == NULL)
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+
+	return mem_ap_read_atomic_u32(self->ap, self->base + reg, p_value);
+}
+
+int arm_cti_pulse_channel(struct arm_cti *self, uint32_t channel)
+{
+	if (channel > 31)
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+
+	return arm_cti_write_reg(self, CTI_APPPULSE, CTI_CHNL(channel));
+}
+
+int arm_cti_set_channel(struct arm_cti *self, uint32_t channel)
+{
+	if (channel > 31)
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+
+	return arm_cti_write_reg(self, CTI_APPSET, CTI_CHNL(channel));
+}
+
+int arm_cti_clear_channel(struct arm_cti *self, uint32_t channel)
+{
+	if (channel > 31)
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+
+	return arm_cti_write_reg(self, CTI_APPCLEAR, CTI_CHNL(channel));
+}
diff --git a/src/target/arm_cti.h b/src/target/arm_cti.h
new file mode 100644
index 00000000..99724c40
--- /dev/null
+++ b/src/target/arm_cti.h
@@ -0,0 +1,73 @@
+/***************************************************************************
+ *   Copyright (C) 2016 by Matthias Welwarsky                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef OPENOCD_TARGET_ARM_CTI_H
+#define OPENOCD_TARGET_ARM_CTI_H
+
+/*define CTI(cross trigger interface)*/
+#define CTI_CTR				0x0
+#define CTI_INACK			0x10
+#define CTI_APPSET			0x14
+#define CTI_APPCLEAR		0x18
+#define CTI_APPPULSE		0x1C
+#define CTI_INEN0			0x20
+#define CTI_INEN1			0x24
+#define CTI_INEN2			0x28
+#define CTI_INEN3			0x2C
+#define CTI_INEN4			0x30
+#define CTI_INEN5			0x34
+#define CTI_INEN6			0x38
+#define CTI_INEN7			0x3C
+#define CTI_INEN(n)			(0x20 + 4 * n)
+#define CTI_OUTEN0			0xA0
+#define CTI_OUTEN1			0xA4
+#define CTI_OUTEN2			0xA8
+#define CTI_OUTEN3			0xAC
+#define CTI_OUTEN4			0xB0
+#define CTI_OUTEN5			0xB4
+#define CTI_OUTEN6			0xB8
+#define CTI_OUTEN7			0xBC
+#define CTI_OUTEN(n)		(0xA0 + 4 * n)
+#define CTI_TRIN_STATUS		0x130
+#define CTI_TROUT_STATUS	0x134
+#define CTI_CHIN_STATUS		0x138
+#define CTI_CHOU_STATUS		0x13C
+#define CTI_GATE			0x140
+#define CTI_UNLOCK			0xFB0
+
+#define CTI_CHNL(x)			(1 << x)
+#define CTI_TRIG_HALT		0
+#define CTI_TRIG_RESUME		1
+#define CTI_TRIG(n)			(1 << CTI_TRIG_##n)
+
+/* forward-declare arm_cti struct */
+struct arm_cti;
+
+extern struct arm_cti *arm_cti_create(struct adiv5_ap *ap, uint32_t base);
+extern int arm_cti_enable(struct arm_cti *self, bool enable);
+extern int arm_cti_ack_events(struct arm_cti *self, uint32_t event);
+extern int arm_cti_gate_channel(struct arm_cti *self, uint32_t channel);
+extern int arm_cti_ungate_channel(struct arm_cti *self, uint32_t channel);
+extern int arm_cti_write_reg(struct arm_cti *self, unsigned int reg, uint32_t value);
+extern int arm_cti_read_reg(struct arm_cti *self, unsigned int reg, uint32_t *value);
+extern int arm_cti_pulse_channel(struct arm_cti *self, uint32_t channel);
+extern int arm_cti_set_channel(struct arm_cti *self, uint32_t channel);
+extern int arm_cti_clear_channel(struct arm_cti *self, uint32_t channel);
+
+#endif /* OPENOCD_TARGET_ARM_CTI_H */
diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 65086c2f..3f1daca4 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -278,7 +276,7 @@ static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
 	uint8_t cp_num = (opcode & 0xf00) >> 8;
 
 	/* MCRR or MRRC */
-	if (((opcode & 0x0ff00000) == 0x0c400000) || ((opcode & 0x0ff00000) == 0x0c400000)) {
+	if (((opcode & 0x0ff00000) == 0x0c400000) || ((opcode & 0x0ff00000) == 0x0c500000)) {
 		uint8_t cp_opcode, Rd, Rn, CRm;
 		char *mnemonic;
 
@@ -3301,6 +3299,7 @@ static int t2ev_data_immed(uint32_t opcode, uint32_t address,
 		case 0x10:
 		case 0x12:
 			is_signed = true;
+			/* fallthrough */
 		case 0x18:
 		case 0x1a:
 			/* signed/unsigned saturated add */
diff --git a/src/target/arm_disassembler.h b/src/target/arm_disassembler.h
index 4aee3519..6f8f65d4 100644
--- a/src/target/arm_disassembler.h
+++ b/src/target/arm_disassembler.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM_DISASSEMBLER_H
-#define ARM_DISASSEMBLER_H
+#ifndef OPENOCD_TARGET_ARM_DISASSEMBLER_H
+#define OPENOCD_TARGET_ARM_DISASSEMBLER_H
 
 enum arm_instruction_type {
 	ARM_UNKNOWN_INSTUCTION,
@@ -203,4 +201,4 @@ int arm_access_size(struct arm_instruction *instruction);
 
 #define COND(opcode) (arm_condition_strings[(opcode & 0xf0000000) >> 28])
 
-#endif /* ARM_DISASSEMBLER_H */
+#endif /* OPENOCD_TARGET_ARM_DISASSEMBLER_H */
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 5df625f0..3e8180c3 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -12,9 +12,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -23,6 +21,7 @@
 
 #include "arm.h"
 #include "arm_dpm.h"
+#include "armv8_dpm.h"
 #include <jtag/jtag.h>
 #include "register.h"
 #include "breakpoints.h"
@@ -167,6 +166,9 @@ static int dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 					/* core-specific ... ? */
 					LOG_WARNING("Jazelle PC adjustment unknown");
 					break;
+				default:
+					LOG_WARNING("unknow core state");
+					break;
 			}
 			break;
 		default:
@@ -230,6 +232,18 @@ static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 	return retval;
 }
 
+/**
+ * Write to program counter and switch the core state (arm/thumb) according to
+ * the address.
+ */
+static int dpm_write_pc_core_state(struct arm_dpm *dpm, struct reg *r)
+{
+	uint32_t value = buf_get_u32(r->value, 0, 32);
+
+	/* read r0 from DCC; then "BX r0" */
+	return dpm->instr_write_data_r0(dpm, ARMV4_5_BX(0), value);
+}
+
 /**
  * Read basic registers of the the current context:  R0 to R15, and CPSR;
  * sets the core mode (such as USR or IRQ) and state (such as ARM or Thumb).
@@ -423,20 +437,20 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 				/* cope with special cases */
 				switch (regnum) {
-					case 8 ... 12:
-						/* r8..r12 "anything but FIQ" case;
-						 * we "know" core mode is accurate
-						 * since we haven't changed it yet
-						 */
-						if (arm->core_mode == ARM_MODE_FIQ
-							&& ARM_MODE_ANY
-							!= mode)
-							tmode = ARM_MODE_USR;
-						break;
-					case 16:
-						/* SPSR */
-						regnum++;
-						break;
+				case 8 ... 12:
+					/* r8..r12 "anything but FIQ" case;
+					 * we "know" core mode is accurate
+					 * since we haven't changed it yet
+					 */
+					if (arm->core_mode == ARM_MODE_FIQ
+					    && ARM_MODE_ANY
+					    != mode)
+						tmode = ARM_MODE_USR;
+					break;
+				case 16:
+					/* SPSR */
+					regnum++;
+					break;
 				}
 
 				/* REVISIT error checks */
@@ -450,8 +464,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 				continue;
 
 			retval = dpm_write_reg(dpm,
-					&cache->reg_list[i],
-					regnum);
+					       &cache->reg_list[i],
+					       regnum);
 			if (retval != ERROR_OK)
 				goto done;
 		}
@@ -467,6 +481,19 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 		goto done;
 	arm->cpsr->dirty = false;
 
+	/* restore the PC, make sure to also switch the core state
+	 * to whatever it was set to with "arm core_state" command.
+	 * target code will have set PC to an appropriate resume address.
+	 */
+	retval = dpm_write_pc_core_state(dpm, arm->pc);
+	if (retval != ERROR_OK)
+		goto done;
+	/* on Cortex-A5 (as found on NXP VF610 SoC), BX instruction
+	 * executed in debug state doesn't appear to set the PC,
+	 * explicitly set it with a "MOV pc, r0". This doesn't influence
+	 * CPSR on Cortex-A9 so it should be OK. Maybe due to different
+	 * debug version?
+	 */
 	retval = dpm_write_reg(dpm, arm->pc, 15);
 	if (retval != ERROR_OK)
 		goto done;
@@ -882,6 +909,7 @@ void arm_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
 			addr -= 4;
 			break;
 		case ARM_STATE_JAZELLE:
+		case ARM_STATE_AARCH64:
 			/* ?? */
 			break;
 	}
@@ -902,20 +930,16 @@ void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 
 	/* Examine debug reason */
 	switch (DSCR_ENTRY(dscr)) {
-		case 6:	/* Data abort (v6 only) */
-		case 7:	/* Prefetch abort (v6 only) */
-		/* FALL THROUGH -- assume a v6 core in abort mode */
-		case 0:	/* HALT request from debugger */
-		case 4:	/* EDBGRQ */
+		case DSCR_ENTRY_HALT_REQ:	/* HALT request from debugger */
+		case DSCR_ENTRY_EXT_DBG_REQ:	/* EDBGRQ */
 			target->debug_reason = DBG_REASON_DBGRQ;
 			break;
-		case 1:	/* HW breakpoint */
-		case 3:	/* SW BKPT */
-		case 5:	/* vector catch */
+		case DSCR_ENTRY_BREAKPOINT:	/* HW breakpoint */
+		case DSCR_ENTRY_BKPT_INSTR:	/* vector catch */
 			target->debug_reason = DBG_REASON_BREAKPOINT;
 			break;
-		case 2:	/* asynch watchpoint */
-		case 10:/* precise watchpoint */
+		case DSCR_ENTRY_IMPRECISE_WATCHPT:	/* asynch watchpoint */
+		case DSCR_ENTRY_PRECISE_WATCHPT:/* precise watchpoint */
 			target->debug_reason = DBG_REASON_WATCHPOINT;
 			break;
 		default:
@@ -940,7 +964,7 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 {
 	struct arm *arm = dpm->arm;
 	struct target *target = arm->target;
-	struct reg_cache *cache;
+	struct reg_cache *cache = 0;
 
 	arm->dpm = dpm;
 
@@ -949,11 +973,13 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 	arm->read_core_reg = arm_dpm_read_core_reg;
 	arm->write_core_reg = arm_dpm_write_core_reg;
 
-	cache = arm_build_reg_cache(target, arm);
-	if (!cache)
-		return ERROR_FAIL;
+	if (arm->core_cache == NULL) {
+		cache = arm_build_reg_cache(target, arm);
+		if (!cache)
+			return ERROR_FAIL;
 
-	*register_get_last_cache_p(&target->reg_cache) = cache;
+		*register_get_last_cache_p(&target->reg_cache) = cache;
+	}
 
 	/* coprocessor access setup */
 	arm->mrc = dpm_mrc;
@@ -972,9 +998,8 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 	/* FIXME add vector catch support */
 
 	dpm->nbp = 1 + ((dpm->didr >> 24) & 0xf);
-	dpm->dbp = calloc(dpm->nbp, sizeof *dpm->dbp);
-
 	dpm->nwp = 1 + ((dpm->didr >> 28) & 0xf);
+	dpm->dbp = calloc(dpm->nbp, sizeof *dpm->dbp);
 	dpm->dwp = calloc(dpm->nwp, sizeof *dpm->dwp);
 
 	if (!dpm->dbp || !dpm->dwp) {
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 63b89172..2a846440 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -12,13 +12,11 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#ifndef __ARM_DPM_H
-#define __ARM_DPM_H
+#ifndef OPENOCD_TARGET_ARM_DPM_H
+#define OPENOCD_TARGET_ARM_DPM_H
 
 /**
  * @file
@@ -61,7 +59,7 @@ struct arm_dpm {
 	struct arm *arm;
 
 	/** Cache of DIDR */
-	uint32_t didr;
+	uint64_t didr;
 
 	/** Invoke before a series of instruction operations */
 	int (*prepare)(struct arm_dpm *);
@@ -69,16 +67,26 @@ struct arm_dpm {
 	/** Invoke after a series of instruction operations */
 	int (*finish)(struct arm_dpm *);
 
+	/** Runs one instruction. */
+	int (*instr_execute)(struct arm_dpm *, uint32_t opcode);
+
 	/* WRITE TO CPU */
 
 	/** Runs one instruction, writing data to DCC before execution. */
 	int (*instr_write_data_dcc)(struct arm_dpm *,
 			uint32_t opcode, uint32_t data);
 
+	int (*instr_write_data_dcc_64)(struct arm_dpm *,
+			uint32_t opcode, uint64_t data);
+
 	/** Runs one instruction, writing data to R0 before execution. */
 	int (*instr_write_data_r0)(struct arm_dpm *,
 			uint32_t opcode, uint32_t data);
 
+	/** Runs one instruction, writing data to R0 before execution. */
+	int (*instr_write_data_r0_64)(struct arm_dpm *,
+			uint32_t opcode, uint64_t data);
+
 	/** Optional core-specific operation invoked after CPSR writes. */
 	int (*instr_cpsr_sync)(struct arm_dpm *dpm);
 
@@ -88,10 +96,19 @@ struct arm_dpm {
 	int (*instr_read_data_dcc)(struct arm_dpm *,
 			uint32_t opcode, uint32_t *data);
 
+	int (*instr_read_data_dcc_64)(struct arm_dpm *,
+			uint32_t opcode, uint64_t *data);
+
 	/** Runs one instruction, reading data from r0 after execution. */
 	int (*instr_read_data_r0)(struct arm_dpm *,
 			uint32_t opcode, uint32_t *data);
 
+	int (*instr_read_data_r0_64)(struct arm_dpm *,
+			uint32_t opcode, uint64_t *data);
+
+	struct reg *(*arm_reg_current)(struct arm *arm,
+			unsigned regnum);
+
 	/* BREAKPOINT/WATCHPOINT SUPPORT */
 
 	/**
@@ -121,11 +138,14 @@ struct arm_dpm {
 	struct dpm_wp *dwp;
 
 	/** Address of the instruction which triggered a watchpoint. */
-	uint32_t wp_pc;
+	target_addr_t wp_pc;
 
 	/** Recent value of DSCR. */
 	uint32_t dscr;
 
+	/** Recent exception level on armv8 */
+	unsigned int last_el;
+
 	/* FIXME -- read/write DCSR methods and symbols */
 };
 
@@ -135,7 +155,6 @@ int arm_dpm_initialize(struct arm_dpm *dpm);
 int arm_dpm_read_current_registers(struct arm_dpm *);
 int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
 
-
 int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
 
 void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
@@ -168,21 +187,21 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 #define DSCR_DTR_TX_FULL            (0x1 << 29)
 #define DSCR_DTR_RX_FULL            (0x1 << 30) /* bit 31 is reserved */
 
-#define DSCR_ENTRY(dscr)            (((dscr) >> 2) & 0xf)
-#define DSCR_RUN_MODE(dscr)         ((dscr) & (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
+#define DSCR_ENTRY(dscr)            ((dscr) & 0x3f)
+#define DSCR_RUN_MODE(dscr)         ((dscr) & 0x03)
 
 
 /* Methods of entry into debug mode */
-#define DSCR_ENTRY_HALT_REQ           (0x0 << 2)
-#define DSCR_ENTRY_BREAKPOINT         (0x1 << 2)
-#define DSCR_ENTRY_IMPRECISE_WATCHPT  (0x2 << 2)
-#define DSCR_ENTRY_BKPT_INSTR         (0x3 << 2)
-#define DSCR_ENTRY_EXT_DBG_REQ        (0x4 << 2)
-#define DSCR_ENTRY_VECT_CATCH         (0x5 << 2)
-#define DSCR_ENTRY_D_SIDE_ABORT       (0x6 << 2)  /* v6 only */
-#define DSCR_ENTRY_I_SIDE_ABORT       (0x7 << 2)  /* v6 only */
-#define DSCR_ENTRY_OS_UNLOCK          (0x8 << 2)
-#define DSCR_ENTRY_PRECISE_WATCHPT    (0xA << 2)
+#define DSCR_ENTRY_HALT_REQ           (0x03)
+#define DSCR_ENTRY_BREAKPOINT         (0x07)
+#define DSCR_ENTRY_IMPRECISE_WATCHPT  (0x0B)
+#define DSCR_ENTRY_BKPT_INSTR         (0x0F)
+#define DSCR_ENTRY_EXT_DBG_REQ        (0x13)
+#define DSCR_ENTRY_VECT_CATCH         (0x17)
+#define DSCR_ENTRY_D_SIDE_ABORT       (0x1B)  /* v6 only */
+#define DSCR_ENTRY_I_SIDE_ABORT       (0x1F)  /* v6 only */
+#define DSCR_ENTRY_OS_UNLOCK          (0x23)
+#define DSCR_ENTRY_PRECISE_WATCHPT    (0x2B)
 
 /* DTR modes */
 #define DSCR_EXT_DCC_NON_BLOCKING     (0x0 << 20)
@@ -242,4 +261,25 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 
 void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
 
-#endif /* __ARM_DPM_H */
+/* PRCR (Device Power-down and Reset Control Register) bits */
+#define PRCR_DEBUG_NO_POWER_DOWN         (1 << 0)
+#define PRCR_WARM_RESET                  (1 << 1)
+#define PRCR_HOLD_NON_DEBUG_RESET        (1 << 2)
+
+/* PRSR (Device Power-down and Reset Status Register) bits */
+#define PRSR_POWERUP_STATUS              (1 << 0)
+#define PRSR_STICKY_POWERDOWN_STATUS     (1 << 1)
+#define PRSR_RESET_STATUS                (1 << 2)
+#define PRSR_STICKY_RESET_STATUS         (1 << 3)
+#define PRSR_HALTED                      (1 << 4)  /* v7.1 Debug only */
+#define PRSR_OSLK                        (1 << 5)  /* v7.1 Debug only */
+#define PRSR_DLK                         (1 << 6)  /* v7.1 Debug only */
+
+/* OSLSR (OS Lock Status Register) bits */
+#define OSLSR_OSLM0                      (1 << 0)
+#define OSLSR_OSLK                       (1 << 1)
+#define OSLSR_nTT                        (1 << 2)
+#define OSLSR_OSLM1                      (1 << 3)
+#define OSLSR_OSLM                       (OSLSR_OSLM0|OSLSR_OSLM1)
+
+#endif /* OPENOCD_TARGET_ARM_DPM_H */
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index d2b9feee..9b73d4ea 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index dbfec857..bb92abb8 100644
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM_JTAG
-#define ARM_JTAG
+#ifndef OPENOCD_TARGET_ARM_JTAG_H
+#define OPENOCD_TARGET_ARM_JTAG_H
 
 #include <jtag/jtag.h>
 
@@ -77,4 +75,4 @@ static inline void arm_le_to_h_u32(jtag_callback_data_t arg)
 	*((uint32_t *)arg) = le_to_h_u32(in);
 }
 
-#endif /* ARM_JTAG */
+#endif /* OPENOCD_TARGET_ARM_JTAG_H */
diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
index 81c4766a..a53fee71 100644
--- a/src/target/arm_opcodes.h
+++ b/src/target/arm_opcodes.h
@@ -22,12 +22,11 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the
- * Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-#ifndef __ARM_OPCODES_H
-#define __ARM_OPCODES_H
+
+#ifndef OPENOCD_TARGET_ARM_OPCODES_H
+#define OPENOCD_TARGET_ARM_OPCODES_H
 
 /**
  * @file
@@ -311,4 +310,4 @@
 	((0xB660 | (0 << 8) | ((IF)&0x3)) \
 	| ((0xB660 | (0 << 8) | ((IF)&0x3)) << 16))
 
-#endif /* __ARM_OPCODES_H */
+#endif /* OPENOCD_TARGET_ARM_OPCODES_H */
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 21b7809c..f31f901f 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -5,6 +5,9 @@
  *   Copyright (C) 2010 by Spencer Oliver                                  *
  *   spen@spen-soft.co.uk                                                  *
  *                                                                         *
+ *   Copyright (C) 2016 by Square, Inc.                                    *
+ *   Steven Stallion <stallion@squareup.com>                               *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -16,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /**
@@ -41,8 +42,11 @@
 #include "armv4_5.h"
 #include "arm7_9_common.h"
 #include "armv7m.h"
+#include "armv7a.h"
 #include "cortex_m.h"
 #include "register.h"
+#include "arm_opcodes.h"
+#include "target_type.h"
 #include "arm_semihosting.h"
 #include <helper/binarybuffer.h>
 #include <helper/log.h>
@@ -63,13 +67,59 @@ static const int open_modeflags[12] = {
 	O_RDWR | O_CREAT | O_APPEND | O_BINARY
 };
 
+static int post_result(struct target *target)
+{
+	struct arm *arm = target_to_arm(target);
+
+	/* REVISIT this looks wrong ... ARM11 and Cortex-A8
+	 * should work this way at least sometimes.
+	 */
+	if (is_arm7_9(target_to_arm7_9(target)) ||
+	    is_armv7a(target_to_armv7a(target))) {
+		uint32_t spsr;
+
+		/* return value in R0 */
+		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, arm->semihosting_result);
+		arm->core_cache->reg_list[0].dirty = 1;
+
+		/* LR --> PC */
+		buf_set_u32(arm->core_cache->reg_list[15].value, 0, 32,
+			buf_get_u32(arm_reg_current(arm, 14)->value, 0, 32));
+		arm->core_cache->reg_list[15].dirty = 1;
+
+		/* saved PSR --> current PSR */
+		spsr = buf_get_u32(arm->spsr->value, 0, 32);
+
+		/* REVISIT should this be arm_set_cpsr(arm, spsr)
+		 * instead of a partially unrolled version?
+		 */
+
+		buf_set_u32(arm->cpsr->value, 0, 32, spsr);
+		arm->cpsr->dirty = 1;
+		arm->core_mode = spsr & 0x1f;
+		if (spsr & 0x20)
+			arm->core_state = ARM_STATE_THUMB;
+
+	} else {
+		/* resume execution, this will be pc+2 to skip over the
+		 * bkpt instruction */
+
+		/* return result in R0 */
+		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, arm->semihosting_result);
+		arm->core_cache->reg_list[0].dirty = 1;
+	}
+
+	return ERROR_OK;
+}
+
 static int do_semihosting(struct target *target)
 {
 	struct arm *arm = target_to_arm(target);
+	struct gdb_fileio_info *fileio_info = target->fileio_info;
 	uint32_t r0 = buf_get_u32(arm->core_cache->reg_list[0].value, 0, 32);
 	uint32_t r1 = buf_get_u32(arm->core_cache->reg_list[1].value, 0, 32);
 	uint8_t params[16];
-	int retval, result;
+	int retval;
 
 	/*
 	 * TODO: lots of security issues are not considered yet, such as:
@@ -77,10 +127,10 @@ static int do_semihosting(struct target *target)
 	 * - no safety checks on opened/deleted/renamed file paths
 	 * Beware the target app you use this support with.
 	 *
-	 * TODO: explore mapping requests to GDB's "File-I/O Remote
-	 * Protocol Extension" ... when GDB is active.
+	 * TODO: unsupported semihosting fileio operations could be
+	 * implemented if we had a small working area at our disposal.
 	 */
-	switch (r0) {
+	switch ((arm->semihosting_op = r0)) {
 	case 0x01:	/* SYS_OPEN */
 		retval = target_read_memory(target, r1, 4, 3, params);
 		if (retval != ERROR_OK)
@@ -89,27 +139,40 @@ static int do_semihosting(struct target *target)
 			uint32_t a = target_buffer_get_u32(target, params+0);
 			uint32_t m = target_buffer_get_u32(target, params+4);
 			uint32_t l = target_buffer_get_u32(target, params+8);
-			if (l <= 255 && m <= 11) {
-				uint8_t fn[256];
-				retval = target_read_memory(target, a, 1, l, fn);
-				if (retval != ERROR_OK)
-					return retval;
-				fn[l] = 0;
-				if (strcmp((char *)fn, ":tt") == 0) {
-					if (m < 4)
-						result = dup(STDIN_FILENO);
-					else
-						result = dup(STDOUT_FILENO);
-				} else {
-					/* cygwin requires the permission setting
-					 * otherwise it will fail to reopen a previously
-					 * written file */
-					result = open((char *)fn, open_modeflags[m], 0644);
+			uint8_t fn[256];
+			retval = target_read_memory(target, a, 1, l, fn);
+			if (retval != ERROR_OK)
+				return retval;
+			fn[l] = 0;
+			if (arm->is_semihosting_fileio) {
+				if (strcmp((char *)fn, ":tt") == 0)
+					arm->semihosting_result = 0;
+				else {
+					arm->semihosting_hit_fileio = true;
+					fileio_info->identifier = "open";
+					fileio_info->param_1 = a;
+					fileio_info->param_2 = l;
+					fileio_info->param_3 = open_modeflags[m];
+					fileio_info->param_4 = 0644;
 				}
-				arm->semihosting_errno =  errno;
 			} else {
-				result = -1;
-				arm->semihosting_errno = EINVAL;
+				if (l <= 255 && m <= 11) {
+					if (strcmp((char *)fn, ":tt") == 0) {
+						if (m < 4)
+							arm->semihosting_result = dup(STDIN_FILENO);
+						else
+							arm->semihosting_result = dup(STDOUT_FILENO);
+					} else {
+						/* cygwin requires the permission setting
+						 * otherwise it will fail to reopen a previously
+						 * written file */
+						arm->semihosting_result = open((char *)fn, open_modeflags[m], 0644);
+					}
+					arm->semihosting_errno =  errno;
+				} else {
+					arm->semihosting_result = -1;
+					arm->semihosting_errno = EINVAL;
+				}
 			}
 		}
 		break;
@@ -120,33 +183,63 @@ static int do_semihosting(struct target *target)
 			return retval;
 		else {
 			int fd = target_buffer_get_u32(target, params+0);
-			result = close(fd);
-			arm->semihosting_errno = errno;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "close";
+				fileio_info->param_1 = fd;
+			} else {
+				arm->semihosting_result = close(fd);
+				arm->semihosting_errno = errno;
+			}
 		}
 		break;
 
 	case 0x03:	/* SYS_WRITEC */
-		{
+		if (arm->is_semihosting_fileio) {
+			arm->semihosting_hit_fileio = true;
+			fileio_info->identifier = "write";
+			fileio_info->param_1 = 1;
+			fileio_info->param_2 = r1;
+			fileio_info->param_3 = 1;
+		} else {
 			unsigned char c;
 			retval = target_read_memory(target, r1, 1, 1, &c);
 			if (retval != ERROR_OK)
 				return retval;
 			putchar(c);
-			result = 0;
+			arm->semihosting_result = 0;
 		}
 		break;
 
 	case 0x04:	/* SYS_WRITE0 */
-		do {
-			unsigned char c;
-			retval = target_read_memory(target, r1++, 1, 1, &c);
-			if (retval != ERROR_OK)
-				return retval;
-			if (!c)
-				break;
-			putchar(c);
-		} while (1);
-		result = 0;
+		if (arm->is_semihosting_fileio) {
+			size_t count = 0;
+			for (uint32_t a = r1;; a++) {
+				unsigned char c;
+				retval = target_read_memory(target, a, 1, 1, &c);
+				if (retval != ERROR_OK)
+					return retval;
+				if (c == '\0')
+					break;
+				count++;
+			}
+			arm->semihosting_hit_fileio = true;
+			fileio_info->identifier = "write";
+			fileio_info->param_1 = 1;
+			fileio_info->param_2 = r1;
+			fileio_info->param_3 = count;
+		} else {
+			do {
+				unsigned char c;
+				retval = target_read_memory(target, r1++, 1, 1, &c);
+				if (retval != ERROR_OK)
+					return retval;
+				if (!c)
+					break;
+				putchar(c);
+			} while (1);
+			arm->semihosting_result = 0;
+		}
 		break;
 
 	case 0x05:	/* SYS_WRITE */
@@ -157,21 +250,29 @@ static int do_semihosting(struct target *target)
 			int fd = target_buffer_get_u32(target, params+0);
 			uint32_t a = target_buffer_get_u32(target, params+4);
 			size_t l = target_buffer_get_u32(target, params+8);
-			uint8_t *buf = malloc(l);
-			if (!buf) {
-				result = -1;
-				arm->semihosting_errno = ENOMEM;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "write";
+				fileio_info->param_1 = fd;
+				fileio_info->param_2 = a;
+				fileio_info->param_3 = l;
 			} else {
-				retval = target_read_buffer(target, a, l, buf);
-				if (retval != ERROR_OK) {
+				uint8_t *buf = malloc(l);
+				if (!buf) {
+					arm->semihosting_result = -1;
+					arm->semihosting_errno = ENOMEM;
+				} else {
+					retval = target_read_buffer(target, a, l, buf);
+					if (retval != ERROR_OK) {
+						free(buf);
+						return retval;
+					}
+					arm->semihosting_result = write(fd, buf, l);
+					arm->semihosting_errno = errno;
+					if (arm->semihosting_result >= 0)
+						arm->semihosting_result = l - arm->semihosting_result;
 					free(buf);
-					return retval;
 				}
-				result = write(fd, buf, l);
-				arm->semihosting_errno = errno;
-				if (result >= 0)
-					result = l - result;
-				free(buf);
 			}
 		}
 		break;
@@ -184,42 +285,60 @@ static int do_semihosting(struct target *target)
 			int fd = target_buffer_get_u32(target, params+0);
 			uint32_t a = target_buffer_get_u32(target, params+4);
 			ssize_t l = target_buffer_get_u32(target, params+8);
-			uint8_t *buf = malloc(l);
-			if (!buf) {
-				result = -1;
-				arm->semihosting_errno = ENOMEM;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "read";
+				fileio_info->param_1 = fd;
+				fileio_info->param_2 = a;
+				fileio_info->param_3 = l;
 			} else {
-				result = read(fd, buf, l);
-				arm->semihosting_errno = errno;
-				if (result >= 0) {
-					retval = target_write_buffer(target, a, result, buf);
-					if (retval != ERROR_OK) {
-						free(buf);
-						return retval;
+				uint8_t *buf = malloc(l);
+				if (!buf) {
+					arm->semihosting_result = -1;
+					arm->semihosting_errno = ENOMEM;
+				} else {
+					arm->semihosting_result = read(fd, buf, l);
+					arm->semihosting_errno = errno;
+					if (arm->semihosting_result >= 0) {
+						retval = target_write_buffer(target, a, arm->semihosting_result, buf);
+						if (retval != ERROR_OK) {
+							free(buf);
+							return retval;
+						}
+						arm->semihosting_result = l - arm->semihosting_result;
 					}
-					result = l - result;
+					free(buf);
 				}
-				free(buf);
 			}
 		}
 		break;
 
 	case 0x07:	/* SYS_READC */
-		result = getchar();
+		if (arm->is_semihosting_fileio) {
+			LOG_ERROR("SYS_READC not supported by semihosting fileio");
+			return ERROR_FAIL;
+		}
+		arm->semihosting_result = getchar();
 		break;
 
 	case 0x08:	/* SYS_ISERROR */
 		retval = target_read_memory(target, r1, 4, 1, params);
 		if (retval != ERROR_OK)
 			return retval;
-		result = (target_buffer_get_u32(target, params+0) != 0);
+		arm->semihosting_result = (target_buffer_get_u32(target, params+0) != 0);
 		break;
 
 	case 0x09:	/* SYS_ISTTY */
-		retval = target_read_memory(target, r1, 4, 1, params);
-		if (retval != ERROR_OK)
-			return retval;
-		result = isatty(target_buffer_get_u32(target, params+0));
+		if (arm->is_semihosting_fileio) {
+			arm->semihosting_hit_fileio = true;
+			fileio_info->identifier = "isatty";
+			fileio_info->param_1 = r1;
+		} else {
+			retval = target_read_memory(target, r1, 4, 1, params);
+			if (retval != ERROR_OK)
+				return retval;
+			arm->semihosting_result = isatty(target_buffer_get_u32(target, params+0));
+		}
 		break;
 
 	case 0x0a:	/* SYS_SEEK */
@@ -229,27 +348,39 @@ static int do_semihosting(struct target *target)
 		else {
 			int fd = target_buffer_get_u32(target, params+0);
 			off_t pos = target_buffer_get_u32(target, params+4);
-			result = lseek(fd, pos, SEEK_SET);
-			arm->semihosting_errno = errno;
-			if (result == pos)
-				result = 0;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "lseek";
+				fileio_info->param_1 = fd;
+				fileio_info->param_2 = pos;
+				fileio_info->param_3 = SEEK_SET;
+			} else {
+				arm->semihosting_result = lseek(fd, pos, SEEK_SET);
+				arm->semihosting_errno = errno;
+				if (arm->semihosting_result == pos)
+					arm->semihosting_result = 0;
+			}
 		}
 		break;
 
 	case 0x0c:	/* SYS_FLEN */
+		if (arm->is_semihosting_fileio) {
+			LOG_ERROR("SYS_FLEN not supported by semihosting fileio");
+			return ERROR_FAIL;
+		}
 		retval = target_read_memory(target, r1, 4, 1, params);
 		if (retval != ERROR_OK)
 			return retval;
 		else {
 			int fd = target_buffer_get_u32(target, params+0);
 			struct stat buf;
-			result = fstat(fd, &buf);
-			if (result == -1) {
+			arm->semihosting_result = fstat(fd, &buf);
+			if (arm->semihosting_result == -1) {
 				arm->semihosting_errno = errno;
-				result = -1;
+				arm->semihosting_result = -1;
 				break;
 			}
-			result = buf.st_size;
+			arm->semihosting_result = buf.st_size;
 		}
 		break;
 
@@ -260,17 +391,24 @@ static int do_semihosting(struct target *target)
 		else {
 			uint32_t a = target_buffer_get_u32(target, params+0);
 			uint32_t l = target_buffer_get_u32(target, params+4);
-			if (l <= 255) {
-				uint8_t fn[256];
-				retval = target_read_memory(target, a, 1, l, fn);
-				if (retval != ERROR_OK)
-					return retval;
-				fn[l] = 0;
-				result = remove((char *)fn);
-				arm->semihosting_errno =  errno;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "unlink";
+				fileio_info->param_1 = a;
+				fileio_info->param_2 = l;
 			} else {
-				result = -1;
-				arm->semihosting_errno = EINVAL;
+				if (l <= 255) {
+					uint8_t fn[256];
+					retval = target_read_memory(target, a, 1, l, fn);
+					if (retval != ERROR_OK)
+						return retval;
+					fn[l] = 0;
+					arm->semihosting_result = remove((char *)fn);
+					arm->semihosting_errno =  errno;
+				} else {
+					arm->semihosting_result = -1;
+					arm->semihosting_errno = EINVAL;
+				}
 			}
 		}
 		break;
@@ -284,31 +422,40 @@ static int do_semihosting(struct target *target)
 			uint32_t l1 = target_buffer_get_u32(target, params+4);
 			uint32_t a2 = target_buffer_get_u32(target, params+8);
 			uint32_t l2 = target_buffer_get_u32(target, params+12);
-			if (l1 <= 255 && l2 <= 255) {
-				uint8_t fn1[256], fn2[256];
-				retval = target_read_memory(target, a1, 1, l1, fn1);
-				if (retval != ERROR_OK)
-					return retval;
-				retval = target_read_memory(target, a2, 1, l2, fn2);
-				if (retval != ERROR_OK)
-					return retval;
-				fn1[l1] = 0;
-				fn2[l2] = 0;
-				result = rename((char *)fn1, (char *)fn2);
-				arm->semihosting_errno =  errno;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "rename";
+				fileio_info->param_1 = a1;
+				fileio_info->param_2 = l1;
+				fileio_info->param_3 = a2;
+				fileio_info->param_4 = l2;
 			} else {
-				result = -1;
-				arm->semihosting_errno = EINVAL;
+				if (l1 <= 255 && l2 <= 255) {
+					uint8_t fn1[256], fn2[256];
+					retval = target_read_memory(target, a1, 1, l1, fn1);
+					if (retval != ERROR_OK)
+						return retval;
+					retval = target_read_memory(target, a2, 1, l2, fn2);
+					if (retval != ERROR_OK)
+						return retval;
+					fn1[l1] = 0;
+					fn2[l2] = 0;
+					arm->semihosting_result = rename((char *)fn1, (char *)fn2);
+					arm->semihosting_errno =  errno;
+				} else {
+					arm->semihosting_result = -1;
+					arm->semihosting_errno = EINVAL;
+				}
 			}
 		}
 		break;
 
 	case 0x11:	/* SYS_TIME */
-		result = time(NULL);
+		arm->semihosting_result = time(NULL);
 		break;
 
 	case 0x13:	/* SYS_ERRNO */
-		result = arm->semihosting_errno;
+		arm->semihosting_result = arm->semihosting_errno;
 		break;
 
 	case 0x15:	/* SYS_GET_CMDLINE */
@@ -318,15 +465,15 @@ static int do_semihosting(struct target *target)
 		else {
 			uint32_t a = target_buffer_get_u32(target, params+0);
 			uint32_t l = target_buffer_get_u32(target, params+4);
-			char *arg = "foobar";
+			char *arg = arm->semihosting_cmdline != NULL ? arm->semihosting_cmdline : "";
 			uint32_t s = strlen(arg) + 1;
 			if (l < s)
-				result = -1;
+				arm->semihosting_result = -1;
 			else {
 				retval = target_write_buffer(target, a, s, (uint8_t *)arg);
 				if (retval != ERROR_OK)
 					return retval;
-				result = 0;
+				arm->semihosting_result = 0;
 			}
 		}
 		break;
@@ -342,7 +489,7 @@ static int do_semihosting(struct target *target)
 			retval = target_write_memory(target, a, 4, 4, params);
 			if (retval != ERROR_OK)
 				return retval;
-			result = 0;
+			arm->semihosting_result = 0;
 		}
 		break;
 
@@ -386,17 +533,24 @@ static int do_semihosting(struct target *target)
 		else {
 			uint32_t len = target_buffer_get_u32(target, params+4);
 			uint32_t c_ptr = target_buffer_get_u32(target, params);
-			uint8_t cmd[256];
-			if (len > 255) {
-				result = -1;
-				arm->semihosting_errno = EINVAL;
+			if (arm->is_semihosting_fileio) {
+				arm->semihosting_hit_fileio = true;
+				fileio_info->identifier = "system";
+				fileio_info->param_1 = c_ptr;
+				fileio_info->param_2 = len;
 			} else {
-				memset(cmd, 0x0, 256);
-				retval = target_read_memory(target, c_ptr, 1, len, cmd);
-				if (retval != ERROR_OK)
-					return retval;
-				else
-					result = system((const char *)cmd);
+				uint8_t cmd[256];
+				if (len > 255) {
+					arm->semihosting_result = -1;
+					arm->semihosting_errno = EINVAL;
+				} else {
+					memset(cmd, 0x0, 256);
+					retval = target_read_memory(target, c_ptr, 1, len, cmd);
+					if (retval != ERROR_OK)
+						return retval;
+					else
+						arm->semihosting_result = system((const char *)cmd);
+				}
 			}
 		}
 		break;
@@ -408,50 +562,84 @@ static int do_semihosting(struct target *target)
 	default:
 		fprintf(stderr, "semihosting: unsupported call %#x\n",
 				(unsigned) r0);
-		result = -1;
+		arm->semihosting_result = -1;
 		arm->semihosting_errno = ENOTSUP;
 	}
 
-	/* resume execution to the original mode */
+	return ERROR_OK;
+}
 
-	/* REVISIT this looks wrong ... ARM11 and Cortex-A8
-	 * should work this way at least sometimes.
+static int get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fileio_info)
+{
+	struct arm *arm = target_to_arm(target);
+
+	/* To avoid uneccessary duplication, semihosting prepares the
+	 * fileio_info structure out-of-band when the target halts. See
+	 * do_semihosting for more detail.
 	 */
-	if (is_arm7_9(target_to_arm7_9(target))) {
-		uint32_t spsr;
+	if (!arm->is_semihosting_fileio || !arm->semihosting_hit_fileio)
+		return ERROR_FAIL;
 
-		/* return value in R0 */
-		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
-		arm->core_cache->reg_list[0].dirty = 1;
+	return ERROR_OK;
+}
 
-		/* LR --> PC */
-		buf_set_u32(arm->core_cache->reg_list[15].value, 0, 32,
-			buf_get_u32(arm_reg_current(arm, 14)->value, 0, 32));
-		arm->core_cache->reg_list[15].dirty = 1;
+static int gdb_fileio_end(struct target *target, int result, int fileio_errno, bool ctrl_c)
+{
+	struct arm *arm = target_to_arm(target);
+	struct gdb_fileio_info *fileio_info = target->fileio_info;
 
-		/* saved PSR --> current PSR */
-		spsr = buf_get_u32(arm->spsr->value, 0, 32);
+	/* clear pending status */
+	arm->semihosting_hit_fileio = false;
 
-		/* REVISIT should this be arm_set_cpsr(arm, spsr)
-		 * instead of a partially unrolled version?
-		 */
+	arm->semihosting_result = result;
+	arm->semihosting_errno = fileio_errno;
 
-		buf_set_u32(arm->cpsr->value, 0, 32, spsr);
-		arm->cpsr->dirty = 1;
-		arm->core_mode = spsr & 0x1f;
-		if (spsr & 0x20)
-			arm->core_state = ARM_STATE_THUMB;
+	/* Some fileio results do not match up with what the semihosting
+	 * operation expects; for these operations, we munge the results
+	 * below:
+	 */
+	switch (arm->semihosting_op) {
+	case 0x05:	/* SYS_WRITE */
+		if (result < 0)
+			arm->semihosting_result = fileio_info->param_3;
+		else
+			arm->semihosting_result = 0;
+		break;
 
-	} else {
-		/* resume execution, this will be pc+2 to skip over the
-		 * bkpt instruction */
+	case 0x06:	/* SYS_READ */
+		if (result == (int)fileio_info->param_3)
+			arm->semihosting_result = 0;
+		if (result <= 0)
+			arm->semihosting_result = fileio_info->param_3;
+		break;
 
-		/* return result in R0 */
-		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
-		arm->core_cache->reg_list[0].dirty = 1;
+	case 0x0a:	/* SYS_SEEK */
+		if (result > 0)
+			arm->semihosting_result = 0;
+		break;
 	}
 
-	return target_resume(target, 1, 0, 0, 0);
+	return post_result(target);
+}
+
+/**
+ * Initialize ARM semihosting support.
+ *
+ * @param target Pointer to the ARM target to initialize.
+ * @return An error status if there is a problem during initialization.
+ */
+int arm_semihosting_init(struct target *target)
+{
+	target->fileio_info = malloc(sizeof(*target->fileio_info));
+	if (target->fileio_info == NULL) {
+		LOG_ERROR("out of memory");
+		return ERROR_FAIL;
+	}
+
+	target->type->get_gdb_fileio_info = get_gdb_fileio_info;
+	target->type->gdb_fileio_end = gdb_fileio_end;
+
+	return ERROR_OK;
 }
 
 /**
@@ -470,20 +658,42 @@ static int do_semihosting(struct target *target)
 int arm_semihosting(struct target *target, int *retval)
 {
 	struct arm *arm = target_to_arm(target);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
 	uint32_t pc, lr, spsr;
 	struct reg *r;
 
 	if (!arm->is_semihosting)
 		return 0;
 
-	if (is_arm7_9(target_to_arm7_9(target))) {
+	if (is_arm7_9(target_to_arm7_9(target)) ||
+	    is_armv7a(armv7a)) {
+		uint32_t vbar = 0x00000000;
+
 		if (arm->core_mode != ARM_MODE_SVC)
 			return 0;
 
+		if (is_armv7a(armv7a)) {
+			struct arm_dpm *dpm = armv7a->arm.dpm;
+
+			*retval = dpm->prepare(dpm);
+			if (*retval == ERROR_OK) {
+				*retval = dpm->instr_read_data_r0(dpm,
+								 ARMV4_5_MRC(15, 0, 0, 12, 0, 0),
+								 &vbar);
+
+				dpm->finish(dpm);
+
+				if (*retval != ERROR_OK)
+					return 1;
+			} else {
+				return 1;
+			}
+		}
+
 		/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
 		r = arm->pc;
 		pc = buf_get_u32(r->value, 0, 32);
-		if (pc != 0x00000008 && pc != 0xffff0008)
+		if (pc != (vbar + 0x00000008) && pc != 0xffff0008)
 			return 0;
 
 		r = arm_reg_current(arm, 14);
@@ -553,6 +763,35 @@ int arm_semihosting(struct target *target, int *retval)
 		return 0;
 	}
 
-	*retval = do_semihosting(target);
-	return 1;
+	/* Perform semihosting if we are not waiting on a fileio
+	 * operation to complete.
+	 */
+	if (!arm->semihosting_hit_fileio) {
+		*retval = do_semihosting(target);
+		if (*retval != ERROR_OK) {
+			LOG_ERROR("Failed semihosting operation");
+			return 0;
+		}
+	}
+
+	/* Post result to target if we are not waiting on a fileio
+	 * operation to complete:
+	 */
+	if (!arm->semihosting_hit_fileio) {
+		*retval = post_result(target);
+		if (*retval != ERROR_OK) {
+			LOG_ERROR("Failed to post semihosting result");
+			return 0;
+		}
+
+		*retval = target_resume(target, 1, 0, 0, 0);
+		if (*retval != ERROR_OK) {
+			LOG_ERROR("Failed to resume target");
+			return 0;
+		}
+
+		return 1;
+	}
+
+	return 0;
 }
diff --git a/src/target/arm_semihosting.h b/src/target/arm_semihosting.h
index 58b34326..011f19f0 100644
--- a/src/target/arm_semihosting.h
+++ b/src/target/arm_semihosting.h
@@ -13,14 +13,13 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM_SEMIHOSTING_H
-#define ARM_SEMIHOSTING_H
+#ifndef OPENOCD_TARGET_ARM_SEMIHOSTING_H
+#define OPENOCD_TARGET_ARM_SEMIHOSTING_H
 
+int arm_semihosting_init(struct target *target);
 int arm_semihosting(struct target *target, int *retval);
 
-#endif
+#endif /* OPENOCD_TARGET_ARM_SEMIHOSTING_H */
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 26f5b8e1..245e108a 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/arm_simulator.h b/src/target/arm_simulator.h
index 3aedaee2..5bdbf562 100644
--- a/src/target/arm_simulator.h
+++ b/src/target/arm_simulator.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM_SIMULATOR_H
-#define ARM_SIMULATOR_H
+#ifndef OPENOCD_TARGET_ARM_SIMULATOR_H
+#define OPENOCD_TARGET_ARM_SIMULATOR_H
 
 struct target;
 
@@ -38,4 +36,4 @@ struct arm_sim_interface {
 /* armv4_5 version */
 int arm_simulate_step(struct target *target, uint32_t *dry_run_pc);
 
-#endif /* ARM_SIMULATOR_H */
+#endif /* OPENOCD_TARGET_ARM_SIMULATOR_H */
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 46fa2e49..580952bc 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -140,6 +138,12 @@ static const struct {
 		.n_indices = ARRAY_SIZE(arm_mon_indices),
 		.indices = arm_mon_indices,
 	},
+	{
+		.name = "Secure Monitor ARM1176JZF-S",
+		.psr = ARM_MODE_1176_MON,
+		.n_indices = ARRAY_SIZE(arm_mon_indices),
+		.indices = arm_mon_indices,
+	},
 
 	/* These special modes are currently only supported
 	 * by ARMv6M and ARMv7M profiles */
@@ -199,6 +203,7 @@ int arm_mode_to_number(enum arm_mode mode)
 		case ARM_MODE_SYS:
 			return 6;
 		case ARM_MODE_MON:
+		case ARM_MODE_1176_MON:
 			return 7;
 		default:
 			LOG_ERROR("invalid mode value encountered %d", mode);
@@ -661,14 +666,19 @@ int arm_arch_state(struct target *target)
 		return ERROR_FAIL;
 	}
 
+	/* avoid filling log waiting for fileio reply */
+	if (arm->semihosting_hit_fileio)
+		return ERROR_OK;
+
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-		"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
+		"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s%s",
 		arm_state_strings[arm->core_state],
 		debug_reason_name(target),
 		arm_mode_name(arm->core_mode),
 		buf_get_u32(arm->cpsr->value, 0, 32),
 		buf_get_u32(arm->pc->value, 0, 32),
-		arm->is_semihosting ? ", semihosting" : "");
+		arm->is_semihosting ? ", semihosting" : "",
+		arm->is_semihosting_fileio ? " fileio" : "");
 
 	return ERROR_OK;
 }
@@ -806,7 +816,7 @@ COMMAND_HANDLER(handle_arm_disassemble_command)
 	}
 
 	struct arm *arm = target_to_arm(target);
-	uint32_t address;
+	target_addr_t address;
 	int count = 1;
 	int thumb = 0;
 
@@ -830,7 +840,7 @@ COMMAND_HANDLER(handle_arm_disassemble_command)
 			COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], count);
 		/* FALL THROUGH */
 		case 1:
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+			COMMAND_PARSE_ADDRESS(CMD_ARGV[0], address);
 			if (address & 0x01) {
 				if (!thumb) {
 					command_print(CMD_CTX, "Disassemble as Thumb");
@@ -1050,6 +1060,73 @@ COMMAND_HANDLER(handle_arm_semihosting_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_arm_semihosting_fileio_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	struct arm *arm = target_to_arm(target);
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (!arm->is_semihosting) {
+		command_print(CMD_CTX, "semihosting is not enabled");
+		return ERROR_FAIL;
+	}
+
+	if (CMD_ARGC > 0)
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], arm->is_semihosting_fileio);
+
+	command_print(CMD_CTX, "semihosting fileio is %s",
+		arm->is_semihosting_fileio
+		? "enabled" : "disabled");
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_arm_semihosting_cmdline)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	unsigned int i;
+
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	struct arm *arm = target_to_arm(target);
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (!arm->setup_semihosting) {
+		command_print(CMD_CTX, "semihosting not supported for current target");
+		return ERROR_FAIL;
+	}
+
+	free(arm->semihosting_cmdline);
+	arm->semihosting_cmdline = CMD_ARGC > 0 ? strdup(CMD_ARGV[0]) : NULL;
+
+	for (i = 1; i < CMD_ARGC; i++) {
+		char *cmdline = alloc_printf("%s %s", arm->semihosting_cmdline, CMD_ARGV[i]);
+		if (cmdline == NULL)
+			break;
+		free(arm->semihosting_cmdline);
+		arm->semihosting_cmdline = cmdline;
+	}
+
+	return ERROR_OK;
+}
+
 static const struct command_registration arm_exec_command_handlers[] = {
 	{
 		.name = "reg",
@@ -1092,6 +1169,20 @@ static const struct command_registration arm_exec_command_handlers[] = {
 		.usage = "['enable'|'disable']",
 		.help = "activate support for semihosting operations",
 	},
+	{
+		"semihosting_cmdline",
+		.handler = handle_arm_semihosting_cmdline,
+		.mode = COMMAND_EXEC,
+		.usage = "arguments",
+		.help = "command line arguments to be passed to program",
+	},
+	{
+		"semihosting_fileio",
+		.handler = handle_arm_semihosting_fileio_command,
+		.mode = COMMAND_EXEC,
+		.usage = "['enable'|'disable']",
+		.help = "activate support for semihosting fileio operations",
+	},
 
 	COMMAND_REGISTRATION_DONE
 };
@@ -1386,8 +1477,8 @@ int armv4_5_run_algorithm(struct target *target,
 	struct mem_param *mem_params,
 	int num_reg_params,
 	struct reg_param *reg_params,
-	uint32_t entry_point,
-	uint32_t exit_point,
+	target_addr_t entry_point,
+	target_addr_t exit_point,
 	int timeout_ms,
 	void *arch_info)
 {
@@ -1396,8 +1487,8 @@ int armv4_5_run_algorithm(struct target *target,
 			mem_params,
 			num_reg_params,
 			reg_params,
-			entry_point,
-			exit_point,
+			(uint32_t)entry_point,
+			(uint32_t)exit_point,
 			timeout_ms,
 			arch_info,
 			armv4_5_run_algorithm_completion);
@@ -1408,7 +1499,7 @@ int armv4_5_run_algorithm(struct target *target,
  *
  */
 int arm_checksum_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *checksum)
+	target_addr_t address, uint32_t count, uint32_t *checksum)
 {
 	struct working_area *crc_algorithm;
 	struct arm_algorithm arm_algo;
@@ -1418,49 +1509,24 @@ int arm_checksum_memory(struct target *target,
 	uint32_t i;
 	uint32_t exit_var = 0;
 
-	/* see contrib/loaders/checksum/armv4_5_crc.s for src */
-
-	static const uint32_t arm_crc_code[] = {
-		0xE1A02000,		/* mov		r2, r0 */
-		0xE3E00000,		/* mov		r0, #0xffffffff */
-		0xE1A03001,		/* mov		r3, r1 */
-		0xE3A04000,		/* mov		r4, #0 */
-		0xEA00000B,		/* b		ncomp */
-		/* nbyte: */
-		0xE7D21004,		/* ldrb	r1, [r2, r4] */
-		0xE59F7030,		/* ldr		r7, CRC32XOR */
-		0xE0200C01,		/* eor		r0, r0, r1, asl 24 */
-		0xE3A05000,		/* mov		r5, #0 */
-		/* loop: */
-		0xE3500000,		/* cmp		r0, #0 */
-		0xE1A06080,		/* mov		r6, r0, asl #1 */
-		0xE2855001,		/* add		r5, r5, #1 */
-		0xE1A00006,		/* mov		r0, r6 */
-		0xB0260007,		/* eorlt	r0, r6, r7 */
-		0xE3550008,		/* cmp		r5, #8 */
-		0x1AFFFFF8,		/* bne		loop */
-		0xE2844001,		/* add		r4, r4, #1 */
-		/* ncomp: */
-		0xE1540003,		/* cmp		r4, r3 */
-		0x1AFFFFF1,		/* bne		nbyte */
-		/* end: */
-		0xe1200070,		/* bkpt		#0 */
-		/* CRC32XOR: */
-		0x04C11DB7		/* .word 0x04C11DB7 */
+	static const uint8_t arm_crc_code_le[] = {
+#include "../../contrib/loaders/checksum/armv4_5_crc.inc"
 	};
 
+	assert(sizeof(arm_crc_code_le) % 4 == 0);
+
 	retval = target_alloc_working_area(target,
-			sizeof(arm_crc_code), &crc_algorithm);
+			sizeof(arm_crc_code_le), &crc_algorithm);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* convert code into a buffer in target endianness */
-	for (i = 0; i < ARRAY_SIZE(arm_crc_code); i++) {
+	for (i = 0; i < ARRAY_SIZE(arm_crc_code_le) / 4; i++) {
 		retval = target_write_u32(target,
 				crc_algorithm->address + i * sizeof(uint32_t),
-				arm_crc_code[i]);
+				le_to_h_u32(&arm_crc_code_le[i * 4]));
 		if (retval != ERROR_OK)
-			return retval;
+			goto cleanup;
 	}
 
 	arm_algo.common_magic = ARM_COMMON_MAGIC;
@@ -1478,28 +1544,25 @@ int arm_checksum_memory(struct target *target,
 
 	/* armv4 must exit using a hardware breakpoint */
 	if (arm->is_armv4)
-		exit_var = crc_algorithm->address + sizeof(arm_crc_code) - 8;
+		exit_var = crc_algorithm->address + sizeof(arm_crc_code_le) - 8;
 
 	retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
 			crc_algorithm->address,
 			exit_var,
 			timeout, &arm_algo);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("error executing ARM crc algorithm");
-		destroy_reg_param(&reg_params[0]);
-		destroy_reg_param(&reg_params[1]);
-		target_free_working_area(target, crc_algorithm);
-		return retval;
-	}
 
-	*checksum = buf_get_u32(reg_params[0].value, 0, 32);
+	if (retval == ERROR_OK)
+		*checksum = buf_get_u32(reg_params[0].value, 0, 32);
+	else
+		LOG_ERROR("error executing ARM crc algorithm");
 
 	destroy_reg_param(&reg_params[0]);
 	destroy_reg_param(&reg_params[1]);
 
+cleanup:
 	target_free_working_area(target, crc_algorithm);
 
-	return ERROR_OK;
+	return retval;
 }
 
 /**
@@ -1509,7 +1572,7 @@ int arm_checksum_memory(struct target *target,
  *
  */
 int arm_blank_check_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *blank)
+	target_addr_t address, uint32_t count, uint32_t *blank, uint8_t erased_value)
 {
 	struct working_area *check_algorithm;
 	struct reg_param reg_params[3];
@@ -1519,32 +1582,32 @@ int arm_blank_check_memory(struct target *target,
 	uint32_t i;
 	uint32_t exit_var = 0;
 
-	/* see contrib/loaders/erase_check/armv4_5_erase_check.s for src */
-
-	static const uint32_t check_code[] = {
-		/* loop: */
-		0xe4d03001,		/* ldrb r3, [r0], #1 */
-		0xe0022003,		/* and r2, r2, r3    */
-		0xe2511001,		/* subs r1, r1, #1   */
-		0x1afffffb,		/* bne loop          */
-		/* end: */
-		0xe1200070,		/* bkpt #0 */
+	static const uint8_t check_code_le[] = {
+#include "../../contrib/loaders/erase_check/armv4_5_erase_check.inc"
 	};
 
+	assert(sizeof(check_code_le) % 4 == 0);
+
+	if (erased_value != 0xff) {
+		LOG_ERROR("Erase value 0x%02" PRIx8 " not yet supported for ARMv4/v5 targets",
+			erased_value);
+		return ERROR_FAIL;
+	}
+
 	/* make sure we have a working area */
 	retval = target_alloc_working_area(target,
-			sizeof(check_code), &check_algorithm);
+			sizeof(check_code_le), &check_algorithm);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* convert code into a buffer in target endianness */
-	for (i = 0; i < ARRAY_SIZE(check_code); i++) {
+	for (i = 0; i < ARRAY_SIZE(check_code_le) / 4; i++) {
 		retval = target_write_u32(target,
 				check_algorithm->address
 				+ i * sizeof(uint32_t),
-				check_code[i]);
+				le_to_h_u32(&check_code_le[i * 4]));
 		if (retval != ERROR_OK)
-			return retval;
+			goto cleanup;
 	}
 
 	arm_algo.common_magic = ARM_COMMON_MAGIC;
@@ -1558,33 +1621,28 @@ int arm_blank_check_memory(struct target *target,
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 
 	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT);
-	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
+	buf_set_u32(reg_params[2].value, 0, 32, erased_value);
 
 	/* armv4 must exit using a hardware breakpoint */
 	if (arm->is_armv4)
-		exit_var = check_algorithm->address + sizeof(check_code) - 4;
+		exit_var = check_algorithm->address + sizeof(check_code_le) - 4;
 
 	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
 			check_algorithm->address,
 			exit_var,
 			10000, &arm_algo);
-	if (retval != ERROR_OK) {
-		destroy_reg_param(&reg_params[0]);
-		destroy_reg_param(&reg_params[1]);
-		destroy_reg_param(&reg_params[2]);
-		target_free_working_area(target, check_algorithm);
-		return retval;
-	}
 
-	*blank = buf_get_u32(reg_params[2].value, 0, 32);
+	if (retval == ERROR_OK)
+		*blank = buf_get_u32(reg_params[2].value, 0, 32);
 
 	destroy_reg_param(&reg_params[0]);
 	destroy_reg_param(&reg_params[1]);
 	destroy_reg_param(&reg_params[2]);
 
+cleanup:
 	target_free_working_area(target, check_algorithm);
 
-	return ERROR_OK;
+	return retval;
 }
 
 static int arm_full_context(struct target *target)
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 250d95bb..3ce4ed0e 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARMV4_5_H
-#define ARMV4_5_H
+#ifndef OPENOCD_TARGET_ARMV4_5_H
+#define OPENOCD_TARGET_ARMV4_5_H
 
 /* This stuff "knows" that its callers aren't talking
  * to microcontroller profile (current Cortex-M) parts.
@@ -48,4 +46,4 @@ extern const int armv4_5_core_reg_map[8][17];
 /* offset into armv4_5 core register cache -- OBSOLETE, DO NOT USE! */
 enum { ARMV4_5_CPSR = 31, };
 
-#endif /* ARMV4_5_H */
+#endif /* OPENOCD_TARGET_ARMV4_5_H */
diff --git a/src/target/armv4_5_cache.c b/src/target/armv4_5_cache.c
index 66dac3c2..bd0091d8 100644
--- a/src/target/armv4_5_cache.c
+++ b/src/target/armv4_5_cache.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/armv4_5_cache.h b/src/target/armv4_5_cache.h
index a1777e80..2fd1ca38 100644
--- a/src/target/armv4_5_cache.h
+++ b/src/target/armv4_5_cache.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARMV4_5_CACHE_H
-#define ARMV4_5_CACHE_H
+#ifndef OPENOCD_TARGET_ARMV4_5_CACHE_H
+#define OPENOCD_TARGET_ARMV4_5_CACHE_H
 
 struct command_context;
 
@@ -54,4 +52,4 @@ enum {
 	ARMV4_5_CACHE_RR_BIT = 0x5000,
 };
 
-#endif /* ARMV4_5_CACHE_H */
+#endif /* OPENOCD_TARGET_ARMV4_5_CACHE_H */
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index ad9040fb..115a4895 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index e2dde7fe..7beaf4ee 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARMV4_5_MMU_H
-#define ARMV4_5_MMU_H
+#ifndef OPENOCD_TARGET_ARMV4_5_MMU_H
+#define OPENOCD_TARGET_ARMV4_5_MMU_H
 
 #include "armv4_5_cache.h"
 
@@ -27,8 +25,9 @@ struct target;
 
 struct armv4_5_mmu_common {
 	int (*get_ttb)(struct target *target, uint32_t *result);
-	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+	int (*read_memory)(struct target *target, target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_memory)(struct target *target, target_addr_t address,
+			    uint32_t size, uint32_t count, const uint8_t *buffer);
 	int (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
 	int (*enable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
 	struct armv4_5_cache_common armv4_5_cache;
@@ -55,4 +54,4 @@ enum {
 	ARMV4_5_MMU_R_BIT = 0x200
 };
 
-#endif /* ARMV4_5_MMU_H */
+#endif /* OPENOCD_TARGET_ARMV4_5_MMU_H */
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index b9320d14..db72afd2 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -14,9 +14,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -177,7 +175,7 @@ done:
 	return retval;
 }
 
-/*  method adapted to cortex A : reused arm v4 v5 method*/
+/*  method adapted to Cortex-A : reused ARM v4 v5 method */
 int armv7a_mmu_translate_va(struct target *target,  uint32_t va, uint32_t *val)
 {
 	uint32_t first_lvl_descriptor = 0x0;
@@ -357,7 +355,7 @@ int armv7a_mmu_translate_va_pa(struct target *target, uint32_t va,
 				break;
 			case 7:
 				LOG_INFO("inner: Write-Back, no Write-Allocate");
-
+				break;
 			default:
 				LOG_INFO("inner: %" PRIx32 " ???", INNER);
 		}
@@ -681,11 +679,40 @@ done:
 
 }
 
+static int armv7a_setup_semihosting(struct target *target, int enable)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	uint32_t vcr;
+	int ret;
+
+	ret = mem_ap_read_atomic_u32(armv7a->debug_ap,
+					 armv7a->debug_base + CPUDBG_VCR,
+					 &vcr);
+	if (ret < 0) {
+		LOG_ERROR("Failed to read VCR register\n");
+		return ret;
+	}
+
+	if (enable)
+		vcr |= DBG_VCR_SVC_MASK;
+	else
+		vcr &= ~DBG_VCR_SVC_MASK;
+
+	ret = mem_ap_write_atomic_u32(armv7a->debug_ap,
+					  armv7a->debug_base + CPUDBG_VCR,
+					  vcr);
+	if (ret < 0)
+		LOG_ERROR("Failed to write VCR register\n");
+
+	return ret;
+}
+
 int armv7a_init_arch_info(struct target *target, struct armv7a_common *armv7a)
 {
 	struct arm *arm = &armv7a->arm;
 	arm->arch_info = armv7a;
 	target->arch_info = &armv7a->arm;
+	arm->setup_semihosting = armv7a_setup_semihosting;
 	/*  target is useful in all function arm v4 5 compatible */
 	armv7a->arm.target = target;
 	armv7a->arm.common_magic = ARM_COMMON_MAGIC;
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 5ca4eb86..14112e4e 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARMV7A_H
-#define ARMV7A_H
+#ifndef OPENOCD_TARGET_ARMV7A_H
+#define OPENOCD_TARGET_ARMV7A_H
 
 #include "arm_adi_v5.h"
 #include "armv7a_cache.h"
@@ -50,7 +48,6 @@ struct armv7a_l2x_cache {
 };
 
 struct armv7a_cachesize {
-	uint32_t level_num;
 	/*  cache dimensionning */
 	uint32_t linelen;
 	uint32_t associativity;
@@ -93,7 +90,7 @@ struct armv7a_mmu_common {
 	uint32_t ttbr_mask[2];
 	uint32_t ttbr_range[2];
 
-	int (*read_physical_memory)(struct target *target, uint32_t address, uint32_t size,
+	int (*read_physical_memory)(struct target *target, target_addr_t address, uint32_t size,
 			uint32_t count, uint8_t *buffer);
 	struct armv7a_cache_common armv7a_cache;
 	uint32_t mmu_enabled;
@@ -136,6 +133,12 @@ target_to_armv7a(struct target *target)
 	return container_of(target->arch_info, struct armv7a_common, arm);
 }
 
+static inline bool is_armv7a(struct armv7a_common *armv7a)
+{
+	return armv7a->common_magic == ARMV7_COMMON_MAGIC;
+}
+
+
 /* register offsets from armv7a.debug_base */
 
 /* See ARMv7a arch spec section C10.2 */
@@ -174,6 +177,13 @@ target_to_armv7a(struct target *target)
 /* See ARMv7a arch spec section C10.8 */
 #define CPUDBG_AUTHSTATUS	0xFB8
 
+/* Masks for Vector Catch register */
+#define DBG_VCR_FIQ_MASK	((1 << 31) | (1 << 7))
+#define DBG_VCR_IRQ_MASK	((1 << 30) | (1 << 6))
+#define DBG_VCR_DATA_ABORT_MASK	((1 << 28) | (1 << 4))
+#define DBG_VCR_PREF_ABORT_MASK	((1 << 27) | (1 << 3))
+#define DBG_VCR_SVC_MASK	((1 << 26) | (1 << 2))
+
 int armv7a_arch_state(struct target *target);
 int armv7a_identify_cache(struct target *target);
 int armv7a_init_arch_info(struct target *target, struct armv7a_common *armv7a);
@@ -186,4 +196,4 @@ int armv7a_handle_cache_info_command(struct command_context *cmd_ctx,
 
 extern const struct command_registration armv7a_command_handlers[];
 
-#endif /* ARMV4_5_H */
+#endif /* OPENOCD_TARGET_ARMV7A_H */
diff --git a/src/target/armv7a_cache.c b/src/target/armv7a_cache.c
index 9237e73f..7af3e6d4 100644
--- a/src/target/armv7a_cache.c
+++ b/src/target/armv7a_cache.c
@@ -11,6 +11,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/armv7a_cache.h b/src/target/armv7a_cache.h
index e0ebb618..e0f7eb3a 100644
--- a/src/target/armv7a_cache.h
+++ b/src/target/armv7a_cache.h
@@ -11,10 +11,13 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM7A_CACHE_H
-#define ARM7A_CACHE_H
+#ifndef OPENOCD_TARGET_ARM7A_CACHE_H
+#define OPENOCD_TARGET_ARM7A_CACHE_H
 
 #include "arm_jtag.h"
 #include "armv7a_cache_l2x.h"
@@ -40,4 +43,4 @@ extern const struct command_registration arm7a_cache_command_handlers[];
 #define CACHE_LEVEL_HAS_D_CACHE		0x2
 #define CACHE_LEVEL_HAS_I_CACHE		0x1
 
-#endif
+#endif /* OPENOCD_TARGET_ARM7A_CACHE_H */
diff --git a/src/target/armv7a_cache_l2x.c b/src/target/armv7a_cache_l2x.c
index 8b35fd89..e181f268 100644
--- a/src/target/armv7a_cache_l2x.c
+++ b/src/target/armv7a_cache_l2x.c
@@ -11,6 +11,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -60,12 +63,12 @@ int arm7a_l2x_flush_all_data(struct target *target)
 
 	l2_way_val = (1 << l2x_cache->way) - 1;
 
-	return target_write_phys_memory(target,
+	return target_write_phys_u32(target,
 			l2x_cache->base + L2X0_CLEAN_INV_WAY,
-			4, 1, (uint8_t *)&l2_way_val);
+			l2_way_val);
 }
 
-int armv7a_l2x_cache_flush_virt(struct target *target, uint32_t virt,
+int armv7a_l2x_cache_flush_virt(struct target *target, target_addr_t virt,
 					uint32_t size)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -80,16 +83,15 @@ int armv7a_l2x_cache_flush_virt(struct target *target, uint32_t virt,
 		return retval;
 
 	for (i = 0; i < size; i += linelen) {
-		uint32_t pa, offs = virt + i;
+		target_addr_t pa, offs = virt + i;
 
 		/* FIXME: use less verbose virt2phys? */
 		retval = target->type->virt2phys(target, offs, &pa);
 		if (retval != ERROR_OK)
 			goto done;
 
-		retval = target_write_phys_memory(target,
-				l2x_cache->base + L2X0_CLEAN_INV_LINE_PA,
-				4, 1, (uint8_t *)&pa);
+		retval = target_write_phys_u32(target,
+				l2x_cache->base + L2X0_CLEAN_INV_LINE_PA, pa);
 		if (retval != ERROR_OK)
 			goto done;
 	}
@@ -101,7 +103,7 @@ done:
 	return retval;
 }
 
-static int armv7a_l2x_cache_inval_virt(struct target *target, uint32_t virt,
+static int armv7a_l2x_cache_inval_virt(struct target *target, target_addr_t virt,
 					uint32_t size)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -116,16 +118,15 @@ static int armv7a_l2x_cache_inval_virt(struct target *target, uint32_t virt,
 		return retval;
 
 	for (i = 0; i < size; i += linelen) {
-		uint32_t pa, offs = virt + i;
+		target_addr_t pa, offs = virt + i;
 
 		/* FIXME: use less verbose virt2phys? */
 		retval = target->type->virt2phys(target, offs, &pa);
 		if (retval != ERROR_OK)
 			goto done;
 
-		retval = target_write_phys_memory(target,
-				l2x_cache->base + L2X0_INV_LINE_PA,
-				4, 1, (uint8_t *)&pa);
+		retval = target_write_phys_u32(target,
+				l2x_cache->base + L2X0_INV_LINE_PA, pa);
 		if (retval != ERROR_OK)
 			goto done;
 	}
@@ -137,7 +138,7 @@ done:
 	return retval;
 }
 
-static int armv7a_l2x_cache_clean_virt(struct target *target, uint32_t virt,
+static int armv7a_l2x_cache_clean_virt(struct target *target, target_addr_t virt,
 					unsigned int size)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -152,16 +153,15 @@ static int armv7a_l2x_cache_clean_virt(struct target *target, uint32_t virt,
 		return retval;
 
 	for (i = 0; i < size; i += linelen) {
-		uint32_t pa, offs = virt + i;
+		target_addr_t pa, offs = virt + i;
 
 		/* FIXME: use less verbose virt2phys? */
 		retval = target->type->virt2phys(target, offs, &pa);
 		if (retval != ERROR_OK)
 			goto done;
 
-		retval = target_write_phys_memory(target,
-				l2x_cache->base + L2X0_CLEAN_LINE_PA,
-				4, 1, (uint8_t *)&pa);
+		retval = target_write_phys_u32(target,
+				l2x_cache->base + L2X0_CLEAN_LINE_PA, pa);
 		if (retval != ERROR_OK)
 			goto done;
 	}
@@ -249,7 +249,8 @@ COMMAND_HANDLER(arm7a_l2x_cache_flush_all_command)
 COMMAND_HANDLER(arm7a_l2x_cache_flush_virt_cmd)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	uint32_t virt, size;
+	target_addr_t virt;
+	uint32_t size;
 
 	if (CMD_ARGC == 0 || CMD_ARGC > 2)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -259,7 +260,7 @@ COMMAND_HANDLER(arm7a_l2x_cache_flush_virt_cmd)
 	else
 		size = 1;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], virt);
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], virt);
 
 	return armv7a_l2x_cache_flush_virt(target, virt, size);
 }
@@ -267,7 +268,8 @@ COMMAND_HANDLER(arm7a_l2x_cache_flush_virt_cmd)
 COMMAND_HANDLER(arm7a_l2x_cache_inval_virt_cmd)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	uint32_t virt, size;
+	target_addr_t virt;
+	uint32_t size;
 
 	if (CMD_ARGC == 0 || CMD_ARGC > 2)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -277,7 +279,7 @@ COMMAND_HANDLER(arm7a_l2x_cache_inval_virt_cmd)
 	else
 		size = 1;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], virt);
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], virt);
 
 	return armv7a_l2x_cache_inval_virt(target, virt, size);
 }
@@ -285,7 +287,8 @@ COMMAND_HANDLER(arm7a_l2x_cache_inval_virt_cmd)
 COMMAND_HANDLER(arm7a_l2x_cache_clean_virt_cmd)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	uint32_t virt, size;
+	target_addr_t virt;
+	uint32_t size;
 
 	if (CMD_ARGC == 0 || CMD_ARGC > 2)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -295,7 +298,7 @@ COMMAND_HANDLER(arm7a_l2x_cache_clean_virt_cmd)
 	else
 		size = 1;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], virt);
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], virt);
 
 	return armv7a_l2x_cache_clean_virt(target, virt, size);
 }
diff --git a/src/target/armv7a_cache_l2x.h b/src/target/armv7a_cache_l2x.h
index 99fbe8aa..f98b5544 100644
--- a/src/target/armv7a_cache_l2x.h
+++ b/src/target/armv7a_cache_l2x.h
@@ -11,10 +11,13 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARM7A_CACHE_L2X_H
-#define ARM7A_CACHE_L2X_H
+#ifndef OPENOCD_TARGET_ARM7A_CACHE_L2X_H
+#define OPENOCD_TARGET_ARM7A_CACHE_L2X_H
 
 #define L2X0_CACHE_LINE_SIZE		32
 
@@ -148,8 +151,8 @@ struct l2c_init_data {
 
 extern const struct command_registration arm7a_l2x_cache_command_handler[];
 
-int armv7a_l2x_cache_flush_virt(struct target *target, uint32_t virt,
+int armv7a_l2x_cache_flush_virt(struct target *target, target_addr_t virt,
 					uint32_t size);
 int arm7a_l2x_flush_all_data(struct target *target);
 
-#endif
+#endif /* OPENOCD_TARGET_ARM7A_CACHE_L2X_H */
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 15de8cd9..e0911c30 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -22,9 +22,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  *                                                                         *
  *   ARMv7-M Architecture, Application Level Reference Manual              *
  *              ARM DDI 0405C (September 2008)                             *
@@ -320,7 +318,7 @@ int armv7m_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
 int armv7m_run_algorithm(struct target *target,
 	int num_mem_params, struct mem_param *mem_params,
 	int num_reg_params, struct reg_param *reg_params,
-	uint32_t entry_point, uint32_t exit_point,
+	target_addr_t entry_point, target_addr_t exit_point,
 	int timeout_ms, void *arch_info)
 {
 	int retval;
@@ -345,7 +343,7 @@ int armv7m_run_algorithm(struct target *target,
 int armv7m_start_algorithm(struct target *target,
 	int num_mem_params, struct mem_param *mem_params,
 	int num_reg_params, struct reg_param *reg_params,
-	uint32_t entry_point, uint32_t exit_point,
+	target_addr_t entry_point, target_addr_t exit_point,
 	void *arch_info)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
@@ -433,7 +431,7 @@ int armv7m_start_algorithm(struct target *target,
 int armv7m_wait_algorithm(struct target *target,
 	int num_mem_params, struct mem_param *mem_params,
 	int num_reg_params, struct reg_param *reg_params,
-	uint32_t exit_point, int timeout_ms,
+	target_addr_t exit_point, int timeout_ms,
 	void *arch_info)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
@@ -463,7 +461,7 @@ int armv7m_wait_algorithm(struct target *target,
 
 	armv7m->load_core_reg_u32(target, 15, &pc);
 	if (exit_point && (pc != exit_point)) {
-		LOG_DEBUG("failed algorithm halted at 0x%" PRIx32 ", expected 0x%" PRIx32,
+		LOG_DEBUG("failed algorithm halted at 0x%" PRIx32 ", expected 0x%" TARGET_PRIxADDR,
 			pc,
 			exit_point);
 		return ERROR_TARGET_TIMEOUT;
@@ -538,11 +536,15 @@ int armv7m_arch_state(struct target *target)
 	struct arm *arm = &armv7m->arm;
 	uint32_t ctrl, sp;
 
+	/* avoid filling log waiting for fileio reply */
+	if (arm->semihosting_hit_fileio)
+		return ERROR_OK;
+
 	ctrl = buf_get_u32(arm->core_cache->reg_list[ARMV7M_CONTROL].value, 0, 32);
 	sp = buf_get_u32(arm->core_cache->reg_list[ARMV7M_R13].value, 0, 32);
 
 	LOG_USER("target halted due to %s, current mode: %s %s\n"
-		"xPSR: %#8.8" PRIx32 " pc: %#8.8" PRIx32 " %csp: %#8.8" PRIx32 "%s",
+		"xPSR: %#8.8" PRIx32 " pc: %#8.8" PRIx32 " %csp: %#8.8" PRIx32 "%s%s",
 		debug_reason_name(target),
 		arm_mode_name(arm->core_mode),
 		armv7m_exception_string(armv7m->exception_number),
@@ -550,7 +552,8 @@ int armv7m_arch_state(struct target *target)
 		buf_get_u32(arm->pc->value, 0, 32),
 		(ctrl & 0x02) ? 'p' : 'm',
 		sp,
-		arm->is_semihosting ? ", semihosting" : "");
+		arm->is_semihosting ? ", semihosting" : "",
+		arm->is_semihosting_fileio ? " fileio" : "");
 
 	return ERROR_OK;
 }
@@ -679,47 +682,15 @@ int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 
 /** Generates a CRC32 checksum of a memory region. */
 int armv7m_checksum_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *checksum)
+	target_addr_t address, uint32_t count, uint32_t *checksum)
 {
 	struct working_area *crc_algorithm;
 	struct armv7m_algorithm armv7m_info;
 	struct reg_param reg_params[2];
 	int retval;
 
-	/* see contrib/loaders/checksum/armv7m_crc.s for src */
-
 	static const uint8_t cortex_m_crc_code[] = {
-		/* main: */
-		0x02, 0x46,			/* mov		r2, r0 */
-		0x00, 0x20,			/* movs		r0, #0 */
-		0xC0, 0x43,			/* mvns		r0, r0 */
-		0x0A, 0x4E,			/* ldr		r6, CRC32XOR */
-		0x0B, 0x46,			/* mov		r3, r1 */
-		0x00, 0x24,			/* movs		r4, #0 */
-		0x0D, 0xE0,			/* b		ncomp */
-		/* nbyte: */
-		0x11, 0x5D,			/* ldrb		r1, [r2, r4] */
-		0x09, 0x06,			/* lsls		r1, r1, #24 */
-		0x48, 0x40,			/* eors		r0, r0, r1 */
-		0x00, 0x25,			/* movs		r5, #0 */
-		/* loop: */
-		0x00, 0x28,			/* cmp		r0, #0 */
-		0x02, 0xDA,			/* bge		notset */
-		0x40, 0x00,			/* lsls		r0, r0, #1 */
-		0x70, 0x40,			/* eors		r0, r0, r6 */
-		0x00, 0xE0,			/* b		cont */
-		/* notset: */
-		0x40, 0x00,			/* lsls		r0, r0, #1 */
-		/* cont: */
-		0x01, 0x35,			/* adds		r5, r5, #1 */
-		0x08, 0x2D,			/* cmp		r5, #8 */
-		0xF6, 0xD1,			/* bne		loop */
-		0x01, 0x34,			/* adds		r4, r4, #1 */
-		/* ncomp: */
-		0x9C, 0x42,			/* cmp		r4, r3 */
-		0xEF, 0xD1,			/* bne		nbyte */
-		0x00, 0xBE,			/* bkpt		#0 */
-		0xB7, 0x1D, 0xC1, 0x04	/* CRC32XOR:	.word	0x04c11db7 */
+#include "../../contrib/loaders/checksum/armv7m_crc.inc"
 	};
 
 	retval = target_alloc_working_area(target, sizeof(cortex_m_crc_code), &crc_algorithm);
@@ -760,36 +731,44 @@ cleanup:
 	return retval;
 }
 
-/** Checks whether a memory region is zeroed. */
+/** Checks whether a memory region is erased. */
 int armv7m_blank_check_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *blank)
+	target_addr_t address, uint32_t count, uint32_t *blank, uint8_t erased_value)
 {
 	struct working_area *erase_check_algorithm;
 	struct reg_param reg_params[3];
 	struct armv7m_algorithm armv7m_info;
+	const uint8_t *code;
+	uint32_t code_size;
 	int retval;
 
-	/* see contrib/loaders/erase_check/armv7m_erase_check.s for src */
-
 	static const uint8_t erase_check_code[] = {
-		/* loop: */
-		0x03, 0x78,		/* ldrb	r3, [r0] */
-		0x01, 0x30,		/* adds	r0, #1 */
-		0x1A, 0x40,		/* ands	r2, r2, r3 */
-		0x01, 0x39,		/* subs	r1, r1, #1 */
-		0xFA, 0xD1,		/* bne	loop */
-		0x00, 0xBE		/* bkpt	#0 */
+#include "../../contrib/loaders/erase_check/armv7m_erase_check.inc"
+	};
+	static const uint8_t zero_erase_check_code[] = {
+#include "../../contrib/loaders/erase_check/armv7m_0_erase_check.inc"
 	};
 
+	switch (erased_value) {
+	case 0x00:
+		code = zero_erase_check_code;
+		code_size = sizeof(zero_erase_check_code);
+		break;
+	case 0xff:
+	default:
+		code = erase_check_code;
+		code_size = sizeof(erase_check_code);
+	}
+
 	/* make sure we have a working area */
-	if (target_alloc_working_area(target, sizeof(erase_check_code),
+	if (target_alloc_working_area(target, code_size,
 		&erase_check_algorithm) != ERROR_OK)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
 	retval = target_write_buffer(target, erase_check_algorithm->address,
-			sizeof(erase_check_code), (uint8_t *)erase_check_code);
+			code_size, code);
 	if (retval != ERROR_OK)
-		return retval;
+		goto cleanup;
 
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
@@ -801,7 +780,7 @@ int armv7m_blank_check_memory(struct target *target,
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 
 	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT);
-	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
+	buf_set_u32(reg_params[2].value, 0, 32, erased_value);
 
 	retval = target_run_algorithm(target,
 			0,
@@ -809,7 +788,7 @@ int armv7m_blank_check_memory(struct target *target,
 			3,
 			reg_params,
 			erase_check_algorithm->address,
-			erase_check_algorithm->address + (sizeof(erase_check_code) - 2),
+			erase_check_algorithm->address + (code_size - 2),
 			10000,
 			&armv7m_info);
 
@@ -820,6 +799,7 @@ int armv7m_blank_check_memory(struct target *target,
 	destroy_reg_param(&reg_params[1]);
 	destroy_reg_param(&reg_params[2]);
 
+cleanup:
 	target_free_working_area(target, erase_check_algorithm);
 
 	return retval;
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 65a2ef05..284bb9ca 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARMV7M_COMMON_H
-#define ARMV7M_COMMON_H
+#ifndef OPENOCD_TARGET_ARMV7M_H
+#define OPENOCD_TARGET_ARMV7M_H
 
 #include "arm_adi_v5.h"
 #include "arm.h"
@@ -134,6 +132,8 @@ enum {
 enum {
 	FP_NONE = 0,
 	FPv4_SP,
+	FPv5_SP,
+	FPv5_DP,
 };
 
 #define ARMV7M_NUM_CORE_REGS (ARMV7M_xPSR + 1)
@@ -203,19 +203,19 @@ int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m);
 int armv7m_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
+		target_addr_t entry_point, target_addr_t exit_point,
 		int timeout_ms, void *arch_info);
 
 int armv7m_start_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
+		target_addr_t entry_point, target_addr_t exit_point,
 		void *arch_info);
 
 int armv7m_wait_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t exit_point, int timeout_ms,
+		target_addr_t exit_point, int timeout_ms,
 		void *arch_info);
 
 int armv7m_invalidate_core_regs(struct target *target);
@@ -223,12 +223,12 @@ int armv7m_invalidate_core_regs(struct target *target);
 int armv7m_restore_context(struct target *target);
 
 int armv7m_checksum_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *checksum);
+		target_addr_t address, uint32_t count, uint32_t *checksum);
 int armv7m_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *blank);
+		target_addr_t address, uint32_t count, uint32_t *blank, uint8_t erased_value);
 
 int armv7m_maybe_skip_bkpt_inst(struct target *target, bool *inst_found);
 
 extern const struct command_registration armv7m_command_handlers[];
 
-#endif /* ARMV7M_H */
+#endif /* OPENOCD_TARGET_ARMV7M_H */
diff --git a/src/target/armv7m_trace.c b/src/target/armv7m_trace.c
index 3592bad0..c1e4f5ba 100644
--- a/src/target/armv7m_trace.c
+++ b/src/target/armv7m_trace.c
@@ -10,6 +10,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/armv7m_trace.h b/src/target/armv7m_trace.h
index eae72f55..4f993946 100644
--- a/src/target/armv7m_trace.h
+++ b/src/target/armv7m_trace.h
@@ -10,10 +10,13 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ARMV7M_TRACE_H
-#define ARMV7M_TRACE_H
+#ifndef OPENOCD_TARGET_ARMV7M_TRACE_H
+#define OPENOCD_TARGET_ARMV7M_TRACE_H
 
 #include <target/target.h>
 #include <command.h>
@@ -85,4 +88,4 @@ int armv7m_trace_tpiu_config(struct target *target);
  */
 int armv7m_trace_itm_config(struct target *target);
 
-#endif
+#endif /* OPENOCD_TARGET_ARMV7M_TRACE_H */
diff --git a/src/target/armv8.c b/src/target/armv8.c
new file mode 100644
index 00000000..df5e2510
--- /dev/null
+++ b/src/target/armv8.c
@@ -0,0 +1,1308 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by David Ung                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/replacements.h>
+
+#include "armv8.h"
+#include "arm_disassembler.h"
+
+#include "register.h"
+#include <helper/binarybuffer.h>
+#include <helper/command.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "armv8_opcodes.h"
+#include "target.h"
+#include "target_type.h"
+
+static const char * const armv8_state_strings[] = {
+	"AArch32", "Thumb", "Jazelle", "ThumbEE", "AArch64",
+};
+
+static const struct {
+	const char *name;
+	unsigned psr;
+} armv8_mode_data[] = {
+	/* These special modes are currently only supported
+	 * by ARMv6M and ARMv7M profiles */
+	{
+		.name = "USR",
+		.psr = ARM_MODE_USR,
+	},
+	{
+		.name = "FIQ",
+		.psr = ARM_MODE_FIQ,
+	},
+	{
+		.name = "IRQ",
+		.psr = ARM_MODE_IRQ,
+	},
+	{
+		.name = "SVC",
+		.psr = ARM_MODE_SVC,
+	},
+	{
+		.name = "MON",
+		.psr = ARM_MODE_MON,
+	},
+	{
+		.name = "ABT",
+		.psr = ARM_MODE_ABT,
+	},
+	{
+		.name = "EL0T",
+		.psr = ARMV8_64_EL0T,
+	},
+	{
+		.name = "EL1T",
+		.psr = ARMV8_64_EL1T,
+	},
+	{
+		.name = "EL1H",
+		.psr = ARMV8_64_EL1H,
+	},
+	{
+		.name = "EL2T",
+		.psr = ARMV8_64_EL2T,
+	},
+	{
+		.name = "EL2H",
+		.psr = ARMV8_64_EL2H,
+	},
+	{
+		.name = "EL3T",
+		.psr = ARMV8_64_EL3T,
+	},
+	{
+		.name = "EL3H",
+		.psr = ARMV8_64_EL3H,
+	},
+};
+
+/** Map PSR mode bits to the name of an ARM processor operating mode. */
+const char *armv8_mode_name(unsigned psr_mode)
+{
+	for (unsigned i = 0; i < ARRAY_SIZE(armv8_mode_data); i++) {
+		if (armv8_mode_data[i].psr == psr_mode)
+			return armv8_mode_data[i].name;
+	}
+	LOG_ERROR("unrecognized psr mode: %#02x", psr_mode);
+	return "UNRECOGNIZED";
+}
+
+int armv8_mode_to_number(enum arm_mode mode)
+{
+	switch (mode) {
+		case ARM_MODE_ANY:
+		/* map MODE_ANY to user mode */
+		case ARM_MODE_USR:
+			return 0;
+		case ARM_MODE_FIQ:
+			return 1;
+		case ARM_MODE_IRQ:
+			return 2;
+		case ARM_MODE_SVC:
+			return 3;
+		case ARM_MODE_ABT:
+			return 4;
+		case ARM_MODE_UND:
+			return 5;
+		case ARM_MODE_SYS:
+			return 6;
+		case ARM_MODE_MON:
+			return 7;
+		case ARMV8_64_EL0T:
+			return 8;
+		case ARMV8_64_EL1T:
+			return 9;
+		case ARMV8_64_EL1H:
+			return 10;
+		case ARMV8_64_EL2T:
+			return 11;
+		case ARMV8_64_EL2H:
+			return 12;
+		case ARMV8_64_EL3T:
+			return 13;
+		case ARMV8_64_EL3H:
+			return 14;
+
+		default:
+			LOG_ERROR("invalid mode value encountered %d", mode);
+			return -1;
+	}
+}
+
+static int armv8_read_reg(struct armv8_common *armv8, int regnum, uint64_t *regval)
+{
+	struct arm_dpm *dpm = &armv8->dpm;
+	int retval;
+	uint32_t value;
+	uint64_t value_64;
+
+	switch (regnum) {
+	case 0 ... 30:
+		retval = dpm->instr_read_data_dcc_64(dpm,
+				ARMV8_MSR_GP(SYSTEM_DBG_DBGDTR_EL0, regnum), &value_64);
+		break;
+	case ARMV8_SP:
+		retval = dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MOVFSP_64(0), &value_64);
+		break;
+	case ARMV8_PC:
+		retval = dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS_DLR(0), &value_64);
+		break;
+	case ARMV8_xPSR:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS_DSPSR(0), &value);
+		value_64 = value;
+		break;
+	case ARMV8_ELR_EL1:
+		retval = dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_ELR_EL1, 0), &value_64);
+		break;
+	case ARMV8_ELR_EL2:
+		retval = dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_ELR_EL2, 0), &value_64);
+		break;
+	case ARMV8_ELR_EL3:
+		retval = dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_ELR_EL3, 0), &value_64);
+		break;
+	case ARMV8_ESR_EL1:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_ESR_EL1, 0), &value);
+		value_64 = value;
+		break;
+	case ARMV8_ESR_EL2:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_ESR_EL2, 0), &value);
+		value_64 = value;
+		break;
+	case ARMV8_ESR_EL3:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_ESR_EL3, 0), &value);
+		value_64 = value;
+		break;
+	case ARMV8_SPSR_EL1:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_SPSR_EL1, 0), &value);
+		value_64 = value;
+		break;
+	case ARMV8_SPSR_EL2:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_SPSR_EL2, 0), &value);
+		value_64 = value;
+		break;
+	case ARMV8_SPSR_EL3:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_SPSR_EL3, 0), &value);
+		value_64 = value;
+		break;
+	default:
+		retval = ERROR_FAIL;
+		break;
+	}
+
+	if (retval == ERROR_OK && regval != NULL)
+		*regval = value_64;
+
+	return retval;
+}
+
+static int armv8_write_reg(struct armv8_common *armv8, int regnum, uint64_t value_64)
+{
+	struct arm_dpm *dpm = &armv8->dpm;
+	int retval;
+	uint32_t value;
+
+	switch (regnum) {
+	case 0 ... 30:
+		retval = dpm->instr_write_data_dcc_64(dpm,
+			ARMV8_MRS(SYSTEM_DBG_DBGDTR_EL0, regnum),
+			value_64);
+		break;
+	case ARMV8_SP:
+		retval = dpm->instr_write_data_r0_64(dpm,
+			ARMV8_MOVTSP_64(0),
+			value_64);
+		break;
+	case ARMV8_PC:
+		retval = dpm->instr_write_data_r0_64(dpm,
+			ARMV8_MSR_DLR(0),
+			value_64);
+		break;
+	case ARMV8_xPSR:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+			ARMV8_MSR_DSPSR(0),
+			value);
+		break;
+	/* registers clobbered by taking exception in debug state */
+	case ARMV8_ELR_EL1:
+		retval = dpm->instr_write_data_r0_64(dpm,
+				ARMV8_MSR_GP(SYSTEM_ELR_EL1, 0), value_64);
+		break;
+	case ARMV8_ELR_EL2:
+		retval = dpm->instr_write_data_r0_64(dpm,
+				ARMV8_MSR_GP(SYSTEM_ELR_EL2, 0), value_64);
+		break;
+	case ARMV8_ELR_EL3:
+		retval = dpm->instr_write_data_r0_64(dpm,
+				ARMV8_MSR_GP(SYSTEM_ELR_EL3, 0), value_64);
+		break;
+	case ARMV8_ESR_EL1:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP(SYSTEM_ESR_EL1, 0), value);
+		break;
+	case ARMV8_ESR_EL2:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP(SYSTEM_ESR_EL2, 0), value);
+		break;
+	case ARMV8_ESR_EL3:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP(SYSTEM_ESR_EL3, 0), value);
+		break;
+	case ARMV8_SPSR_EL1:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP(SYSTEM_SPSR_EL1, 0), value);
+		break;
+	case ARMV8_SPSR_EL2:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP(SYSTEM_SPSR_EL2, 0), value);
+		break;
+	case ARMV8_SPSR_EL3:
+		value = value_64;
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP(SYSTEM_SPSR_EL3, 0), value);
+		break;
+	default:
+		retval = ERROR_FAIL;
+		break;
+	}
+
+	return retval;
+}
+
+static int armv8_read_reg32(struct armv8_common *armv8, int regnum, uint64_t *regval)
+{
+	struct arm_dpm *dpm = &armv8->dpm;
+	uint32_t value = 0;
+	int retval;
+
+	switch (regnum) {
+	case ARMV8_R0 ... ARMV8_R14:
+		/* return via DCC:  "MCR p14, 0, Rnum, c0, c5, 0" */
+		retval = dpm->instr_read_data_dcc(dpm,
+			ARMV4_5_MCR(14, 0, regnum, 0, 5, 0),
+			&value);
+		break;
+	case ARMV8_SP:
+		retval = dpm->instr_read_data_dcc(dpm,
+			ARMV4_5_MCR(14, 0, 13, 0, 5, 0),
+			&value);
+		break;
+	case ARMV8_PC:
+		retval = dpm->instr_read_data_r0(dpm,
+			ARMV8_MRC_DLR(0),
+			&value);
+		break;
+	case ARMV8_xPSR:
+		retval = dpm->instr_read_data_r0(dpm,
+			ARMV8_MRC_DSPSR(0),
+			&value);
+		break;
+	case ARMV8_ELR_EL1: /* mapped to LR_svc */
+		retval = dpm->instr_read_data_dcc(dpm,
+				ARMV4_5_MCR(14, 0, 14, 0, 5, 0),
+				&value);
+		break;
+	case ARMV8_ELR_EL2: /* mapped to ELR_hyp */
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS_T1(0, 14, 0, 1),
+				&value);
+		break;
+	case ARMV8_ELR_EL3: /* mapped to LR_mon */
+		retval = dpm->instr_read_data_dcc(dpm,
+				ARMV4_5_MCR(14, 0, 14, 0, 5, 0),
+				&value);
+		break;
+	case ARMV8_ESR_EL1: /* mapped to DFSR */
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV4_5_MRC(15, 0, 0, 5, 0, 0),
+				&value);
+		break;
+	case ARMV8_ESR_EL2: /* mapped to HSR */
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV4_5_MRC(15, 4, 0, 5, 2, 0),
+				&value);
+		break;
+	case ARMV8_ESR_EL3: /* FIXME: no equivalent in aarch32? */
+		retval = ERROR_FAIL;
+		break;
+	case ARMV8_SPSR_EL1: /* mapped to SPSR_svc */
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS_xPSR_T1(1, 0),
+				&value);
+		break;
+	case ARMV8_SPSR_EL2: /* mapped to SPSR_hyp */
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS_xPSR_T1(1, 0),
+				&value);
+		break;
+	case ARMV8_SPSR_EL3: /* mapped to SPSR_mon */
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS_xPSR_T1(1, 0),
+				&value);
+		break;
+	default:
+		retval = ERROR_FAIL;
+		break;
+	}
+
+	if (retval == ERROR_OK && regval != NULL)
+		*regval = value;
+
+	return retval;
+}
+
+static int armv8_write_reg32(struct armv8_common *armv8, int regnum, uint64_t value)
+{
+	struct arm_dpm *dpm = &armv8->dpm;
+	int retval;
+
+	switch (regnum) {
+	case ARMV8_R0 ... ARMV8_R14:
+		/* load register from DCC:  "MRC p14, 0, Rnum, c0, c5, 0" */
+		retval = dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, regnum, 0, 5, 0), value);
+		break;
+	case ARMV8_SP:
+		retval = dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, 13, 0, 5, 0), value);
+			break;
+	case ARMV8_PC:/* PC
+		 * read r0 from DCC; then "MOV pc, r0" */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MCR_DLR(0), value);
+		break;
+	case ARMV8_xPSR: /* CPSR */
+		/* read r0 from DCC, then "MCR r0, DSPSR" */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MCR_DSPSR(0), value);
+		break;
+	case ARMV8_ELR_EL1: /* mapped to LR_svc */
+		retval = dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, 14, 0, 5, 0),
+				value);
+		break;
+	case ARMV8_ELR_EL2: /* mapped to ELR_hyp */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP_T1(0, 14, 0, 1),
+				value);
+		break;
+	case ARMV8_ELR_EL3: /* mapped to LR_mon */
+		retval = dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, 14, 0, 5, 0),
+				value);
+		break;
+	case ARMV8_ESR_EL1: /* mapped to DFSR */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV4_5_MCR(15, 0, 0, 5, 0, 0),
+				value);
+		break;
+	case ARMV8_ESR_EL2: /* mapped to HSR */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV4_5_MCR(15, 4, 0, 5, 2, 0),
+				value);
+		break;
+	case ARMV8_ESR_EL3: /* FIXME: no equivalent in aarch32? */
+		retval = ERROR_FAIL;
+		break;
+	case ARMV8_SPSR_EL1: /* mapped to SPSR_svc */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP_xPSR_T1(1, 0, 15),
+				value);
+		break;
+	case ARMV8_SPSR_EL2: /* mapped to SPSR_hyp */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP_xPSR_T1(1, 0, 15),
+				value);
+		break;
+	case ARMV8_SPSR_EL3: /* mapped to SPSR_mon */
+		retval = dpm->instr_write_data_r0(dpm,
+				ARMV8_MSR_GP_xPSR_T1(1, 0, 15),
+				value);
+		break;
+	default:
+		retval = ERROR_FAIL;
+		break;
+	}
+
+	return retval;
+
+}
+
+void armv8_select_reg_access(struct armv8_common *armv8, bool is_aarch64)
+{
+	if (is_aarch64) {
+		armv8->read_reg_u64 = armv8_read_reg;
+		armv8->write_reg_u64 = armv8_write_reg;
+	} else {
+		armv8->read_reg_u64 = armv8_read_reg32;
+		armv8->write_reg_u64 = armv8_write_reg32;
+	}
+}
+
+/*  retrieve core id cluster id  */
+int armv8_read_mpidr(struct armv8_common *armv8)
+{
+	int retval = ERROR_FAIL;
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	uint32_t mpidr;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm->instr_read_data_r0(dpm, armv8_opcode(armv8, READ_REG_MPIDR), &mpidr);
+	if (retval != ERROR_OK)
+		goto done;
+	if (mpidr & 1<<31) {
+		armv8->multi_processor_system = (mpidr >> 30) & 1;
+		armv8->cluster_id = (mpidr >> 8) & 0xf;
+		armv8->cpu_id = mpidr & 0x3;
+		LOG_INFO("%s cluster %x core %x %s", target_name(armv8->arm.target),
+			armv8->cluster_id,
+			armv8->cpu_id,
+			armv8->multi_processor_system == 0 ? "multi core" : "single core");
+	} else
+		LOG_ERROR("mpidr not in multiprocessor format");
+
+done:
+	dpm->finish(dpm);
+	return retval;
+}
+
+/**
+ * Configures host-side ARM records to reflect the specified CPSR.
+ * Later, code can use arm_reg_current() to map register numbers
+ * according to how they are exposed by this mode.
+ */
+void armv8_set_cpsr(struct arm *arm, uint32_t cpsr)
+{
+	uint32_t mode = cpsr & 0x1F;
+
+	/* NOTE:  this may be called very early, before the register
+	 * cache is set up.  We can't defend against many errors, in
+	 * particular against CPSRs that aren't valid *here* ...
+	 */
+	if (arm->cpsr) {
+		buf_set_u32(arm->cpsr->value, 0, 32, cpsr);
+		arm->cpsr->valid = 1;
+		arm->cpsr->dirty = 0;
+	}
+
+	/* Older ARMs won't have the J bit */
+	enum arm_state state = 0xFF;
+
+	if (((cpsr & 0x10) >> 4) == 0) {
+		state = ARM_STATE_AARCH64;
+	} else {
+		if (cpsr & (1 << 5)) {	/* T */
+			if (cpsr & (1 << 24)) { /* J */
+				LOG_WARNING("ThumbEE -- incomplete support");
+				state = ARM_STATE_THUMB_EE;
+			} else
+				state = ARM_STATE_THUMB;
+		} else {
+			if (cpsr & (1 << 24)) { /* J */
+				LOG_ERROR("Jazelle state handling is BROKEN!");
+				state = ARM_STATE_JAZELLE;
+			} else
+				state = ARM_STATE_ARM;
+		}
+	}
+	arm->core_state = state;
+	if (arm->core_state == ARM_STATE_AARCH64)
+		arm->core_mode = (mode << 4) | 0xf;
+	else
+		arm->core_mode = mode;
+
+	LOG_DEBUG("set CPSR %#8.8x: %s mode, %s state", (unsigned) cpsr,
+		armv8_mode_name(arm->core_mode),
+		armv8_state_strings[arm->core_state]);
+}
+
+static void armv8_show_fault_registers32(struct armv8_common *armv8)
+{
+	uint32_t dfsr, ifsr, dfar, ifar;
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return;
+
+	/* ARMV4_5_MRC(cpnum, op1, r0, CRn, CRm, op2) */
+
+	/* c5/c0 - {data, instruction} fault status registers */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 5, 0, 0),
+			&dfsr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 5, 0, 1),
+			&ifsr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* c6/c0 - {data, instruction} fault address registers */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 6, 0, 0),
+			&dfar);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 6, 0, 2),
+			&ifar);
+	if (retval != ERROR_OK)
+		goto done;
+
+	LOG_USER("Data fault registers        DFSR: %8.8" PRIx32
+		", DFAR: %8.8" PRIx32, dfsr, dfar);
+	LOG_USER("Instruction fault registers IFSR: %8.8" PRIx32
+		", IFAR: %8.8" PRIx32, ifsr, ifar);
+
+done:
+	/* (void) */ dpm->finish(dpm);
+}
+
+static __attribute__((unused)) void armv8_show_fault_registers(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+
+	if (armv8->arm.core_state != ARM_STATE_AARCH64)
+		armv8_show_fault_registers32(armv8);
+}
+
+static uint8_t armv8_pa_size(uint32_t ps)
+{
+	uint8_t ret = 0;
+	switch (ps) {
+		case 0:
+			ret = 32;
+			break;
+		case 1:
+			ret = 36;
+			break;
+		case 2:
+			ret = 40;
+			break;
+		case 3:
+			ret = 42;
+			break;
+		case 4:
+			ret = 44;
+			break;
+		case 5:
+			ret = 48;
+			break;
+		default:
+			LOG_INFO("Unknow physicall address size");
+			break;
+	}
+	return ret;
+}
+
+static __attribute__((unused)) int armv8_read_ttbcr32(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	uint32_t ttbcr, ttbcr_n;
+	int retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+	/*  MRC p15,0,<Rt>,c2,c0,2 ; Read CP15 Translation Table Base Control Register*/
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 2, 0, 2),
+			&ttbcr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	LOG_DEBUG("ttbcr %" PRIx32, ttbcr);
+
+	ttbcr_n = ttbcr & 0x7;
+	armv8->armv8_mmu.ttbcr = ttbcr;
+
+	/*
+	 * ARM Architecture Reference Manual (ARMv7-A and ARMv7-Redition),
+	 * document # ARM DDI 0406C
+	 */
+	armv8->armv8_mmu.ttbr_range[0]  = 0xffffffff >> ttbcr_n;
+	armv8->armv8_mmu.ttbr_range[1] = 0xffffffff;
+	armv8->armv8_mmu.ttbr_mask[0] = 0xffffffff << (14 - ttbcr_n);
+	armv8->armv8_mmu.ttbr_mask[1] = 0xffffffff << 14;
+
+	LOG_DEBUG("ttbr1 %s, ttbr0_mask %" PRIx32 " ttbr1_mask %" PRIx32,
+		  (ttbcr_n != 0) ? "used" : "not used",
+		  armv8->armv8_mmu.ttbr_mask[0],
+		  armv8->armv8_mmu.ttbr_mask[1]);
+
+done:
+	dpm->finish(dpm);
+	return retval;
+}
+
+static __attribute__((unused)) int armv8_read_ttbcr(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	struct arm *arm = &armv8->arm;
+	uint32_t ttbcr;
+	uint64_t ttbcr_64;
+
+	int retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* claaer ttrr1_used and ttbr0_mask */
+	memset(&armv8->armv8_mmu.ttbr1_used, 0, sizeof(armv8->armv8_mmu.ttbr1_used));
+	memset(&armv8->armv8_mmu.ttbr0_mask, 0, sizeof(armv8->armv8_mmu.ttbr0_mask));
+
+	switch (armv8_curel_from_core_mode(arm->core_mode)) {
+	case SYSTEM_CUREL_EL3:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_TCR_EL3, 0),
+				&ttbcr);
+		retval += dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_TTBR0_EL3, 0),
+				&armv8->ttbr_base);
+		if (retval != ERROR_OK)
+			goto done;
+		armv8->va_size = 64 - (ttbcr & 0x3F);
+		armv8->pa_size = armv8_pa_size((ttbcr >> 16) & 7);
+		armv8->page_size = (ttbcr >> 14) & 3;
+		break;
+	case SYSTEM_CUREL_EL2:
+		retval = dpm->instr_read_data_r0(dpm,
+				ARMV8_MRS(SYSTEM_TCR_EL2, 0),
+				&ttbcr);
+		retval += dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_TTBR0_EL2, 0),
+				&armv8->ttbr_base);
+		if (retval != ERROR_OK)
+			goto done;
+		armv8->va_size = 64 - (ttbcr & 0x3F);
+		armv8->pa_size = armv8_pa_size((ttbcr >> 16) & 7);
+		armv8->page_size = (ttbcr >> 14) & 3;
+		break;
+	case SYSTEM_CUREL_EL0:
+		armv8_dpm_modeswitch(dpm, ARMV8_64_EL1H);
+		/* fall through */
+	case SYSTEM_CUREL_EL1:
+		retval = dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_TCR_EL1, 0),
+				&ttbcr_64);
+		armv8->va_size = 64 - (ttbcr_64 & 0x3F);
+		armv8->pa_size = armv8_pa_size((ttbcr_64 >> 32) & 7);
+		armv8->page_size = (ttbcr_64 >> 14) & 3;
+		armv8->armv8_mmu.ttbr1_used = (((ttbcr_64 >> 16) & 0x3F) != 0) ? 1 : 0;
+		armv8->armv8_mmu.ttbr0_mask  = 0x0000FFFFFFFFFFFF;
+		retval += dpm->instr_read_data_r0_64(dpm,
+				ARMV8_MRS(SYSTEM_TTBR0_EL1 | (armv8->armv8_mmu.ttbr1_used), 0),
+				&armv8->ttbr_base);
+		if (retval != ERROR_OK)
+			goto done;
+		break;
+	default:
+		LOG_ERROR("unknow core state");
+		retval = ERROR_FAIL;
+		break;
+	}
+	if (retval != ERROR_OK)
+		goto done;
+
+	if (armv8->armv8_mmu.ttbr1_used == 1)
+		LOG_INFO("TTBR0 access above %" PRIx64, (uint64_t)(armv8->armv8_mmu.ttbr0_mask));
+
+done:
+	armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	dpm->finish(dpm);
+	return retval;
+}
+
+/*  method adapted to cortex A : reused arm v4 v5 method*/
+int armv8_mmu_translate_va(struct target *target,  target_addr_t va, target_addr_t *val)
+{
+	return ERROR_OK;
+}
+
+/*  V8 method VA TO PA  */
+int armv8_mmu_translate_va_pa(struct target *target, target_addr_t va,
+	target_addr_t *val, int meminfo)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = &armv8->dpm;
+	enum arm_mode target_mode = ARM_MODE_ANY;
+	uint32_t retval;
+	uint32_t instr = 0;
+	uint64_t par;
+
+	static const char * const shared_name[] = {
+			"Non-", "UNDEFINED ", "Outer ", "Inner "
+	};
+
+	static const char * const secure_name[] = {
+			"Secure", "Not Secure"
+	};
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	switch (armv8_curel_from_core_mode(arm->core_mode)) {
+	case SYSTEM_CUREL_EL0:
+		instr = ARMV8_SYS(SYSTEM_ATS12E0R, 0);
+		/* can only execute instruction at EL2 */
+		target_mode = ARMV8_64_EL2H;
+		break;
+	case SYSTEM_CUREL_EL1:
+		instr = ARMV8_SYS(SYSTEM_ATS12E1R, 0);
+		/* can only execute instruction at EL2 */
+		target_mode = ARMV8_64_EL2H;
+		break;
+	case SYSTEM_CUREL_EL2:
+		instr = ARMV8_SYS(SYSTEM_ATS1E2R, 0);
+		break;
+	case SYSTEM_CUREL_EL3:
+		instr = ARMV8_SYS(SYSTEM_ATS1E3R, 0);
+		break;
+
+	default:
+		break;
+	};
+
+	if (target_mode != ARM_MODE_ANY)
+		armv8_dpm_modeswitch(dpm, target_mode);
+
+	/* write VA to R0 and execute translation instruction */
+	retval = dpm->instr_write_data_r0_64(dpm, instr, (uint64_t)va);
+	/* read result from PAR_EL1 */
+	if (retval == ERROR_OK)
+		retval = dpm->instr_read_data_r0_64(dpm, ARMV8_MRS(SYSTEM_PAR_EL1, 0), &par);
+
+	/* switch back to saved PE mode */
+	if (target_mode != ARM_MODE_ANY)
+		armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+
+	dpm->finish(dpm);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (par & 1) {
+		LOG_ERROR("Address translation failed at stage %i, FST=%x, PTW=%i",
+				((int)(par >> 9) & 1)+1, (int)(par >> 1) & 0x3f, (int)(par >> 8) & 1);
+
+		*val = 0;
+		retval = ERROR_FAIL;
+	} else {
+		*val = (par & 0xFFFFFFFFF000UL) | (va & 0xFFF);
+		if (meminfo) {
+			int SH = (par >> 7) & 3;
+			int NS = (par >> 9) & 1;
+			int ATTR = (par >> 56) & 0xFF;
+
+			char *memtype = (ATTR & 0xF0) == 0 ? "Device Memory" : "Normal Memory";
+
+			LOG_USER("%sshareable, %s",
+					shared_name[SH], secure_name[NS]);
+			LOG_USER("%s", memtype);
+		}
+	}
+
+	return retval;
+}
+
+int armv8_handle_cache_info_command(struct command_context *cmd_ctx,
+	struct armv8_cache_common *armv8_cache)
+{
+	if (armv8_cache->info == -1) {
+		command_print(cmd_ctx, "cache not yet identified");
+		return ERROR_OK;
+	}
+
+	if (armv8_cache->display_cache_info)
+		armv8_cache->display_cache_info(cmd_ctx, armv8_cache);
+	return ERROR_OK;
+}
+
+int armv8_init_arch_info(struct target *target, struct armv8_common *armv8)
+{
+	struct arm *arm = &armv8->arm;
+	arm->arch_info = armv8;
+	target->arch_info = &armv8->arm;
+	/*  target is useful in all function arm v4 5 compatible */
+	armv8->arm.target = target;
+	armv8->arm.common_magic = ARM_COMMON_MAGIC;
+	armv8->common_magic = ARMV8_COMMON_MAGIC;
+
+	armv8->armv8_mmu.armv8_cache.l2_cache = NULL;
+	armv8->armv8_mmu.armv8_cache.info = -1;
+	armv8->armv8_mmu.armv8_cache.flush_all_data_cache = NULL;
+	armv8->armv8_mmu.armv8_cache.display_cache_info = NULL;
+	return ERROR_OK;
+}
+
+int armv8_aarch64_state(struct target *target)
+{
+	struct arm *arm = target_to_arm(target);
+
+	if (arm->common_magic != ARM_COMMON_MAGIC) {
+		LOG_ERROR("BUG: called for a non-ARM target");
+		return ERROR_FAIL;
+	}
+
+	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
+		"cpsr: 0x%8.8" PRIx32 " pc: 0x%" PRIx64 "%s",
+		armv8_state_strings[arm->core_state],
+		debug_reason_name(target),
+		armv8_mode_name(arm->core_mode),
+		buf_get_u32(arm->cpsr->value, 0, 32),
+		buf_get_u64(arm->pc->value, 0, 64),
+		arm->is_semihosting ? ", semihosting" : "");
+
+	return ERROR_OK;
+}
+
+int armv8_arch_state(struct target *target)
+{
+	static const char * const state[] = {
+		"disabled", "enabled"
+	};
+
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm *arm = &armv8->arm;
+
+	if (armv8->common_magic != ARMV8_COMMON_MAGIC) {
+		LOG_ERROR("BUG: called for a non-Armv8 target");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (arm->core_state == ARM_STATE_AARCH64)
+		armv8_aarch64_state(target);
+	else
+		arm_arch_state(target);
+
+	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
+		state[armv8->armv8_mmu.mmu_enabled],
+		state[armv8->armv8_mmu.armv8_cache.d_u_cache_enabled],
+		state[armv8->armv8_mmu.armv8_cache.i_cache_enabled]);
+
+	if (arm->core_mode == ARM_MODE_ABT)
+		armv8_show_fault_registers(target);
+
+	if (target->debug_reason == DBG_REASON_WATCHPOINT)
+		LOG_USER("Watchpoint triggered at PC %#08x",
+			(unsigned) armv8->dpm.wp_pc);
+
+	return ERROR_OK;
+}
+
+static const struct {
+	unsigned id;
+	const char *name;
+	unsigned bits;
+	enum arm_mode mode;
+	enum reg_type type;
+	const char *group;
+	const char *feature;
+} armv8_regs[] = {
+	{ ARMV8_R0,  "x0",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R1,  "x1",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R2,  "x2",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R3,  "x3",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R4,  "x4",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R5,  "x5",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R6,  "x6",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R7,  "x7",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R8,  "x8",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R9,  "x9",  64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R10, "x10", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R11, "x11", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R12, "x12", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R13, "x13", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R14, "x14", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R15, "x15", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R16, "x16", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R17, "x17", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R18, "x18", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R19, "x19", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R20, "x20", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R21, "x21", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R22, "x22", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R23, "x23", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R24, "x24", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R25, "x25", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R26, "x26", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R27, "x27", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R28, "x28", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R29, "x29", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_R30, "x30", 64, ARM_MODE_ANY, REG_TYPE_UINT64, "general", "org.gnu.gdb.aarch64.core" },
+
+	{ ARMV8_SP, "sp", 64, ARM_MODE_ANY, REG_TYPE_DATA_PTR, "general", "org.gnu.gdb.aarch64.core" },
+	{ ARMV8_PC,  "pc", 64, ARM_MODE_ANY, REG_TYPE_CODE_PTR, "general", "org.gnu.gdb.aarch64.core" },
+
+	{ ARMV8_xPSR, "CPSR", 32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.aarch64.core" },
+
+	{ ARMV8_ELR_EL1, "ELR_EL1", 64, ARMV8_64_EL1H, REG_TYPE_CODE_PTR, "banked", "net.sourceforge.openocd.banked" },
+	{ ARMV8_ESR_EL1, "ESR_EL1", 32, ARMV8_64_EL1H, REG_TYPE_UINT32, "banked", "net.sourceforge.openocd.banked" },
+	{ ARMV8_SPSR_EL1, "SPSR_EL1", 32, ARMV8_64_EL1H, REG_TYPE_UINT32, "banked", "net.sourceforge.openocd.banked" },
+
+	{ ARMV8_ELR_EL2, "ELR_EL2", 64, ARMV8_64_EL2H, REG_TYPE_CODE_PTR, "banked", "net.sourceforge.openocd.banked" },
+	{ ARMV8_ESR_EL2, "ESR_EL2", 32, ARMV8_64_EL2H, REG_TYPE_UINT32, "banked", "net.sourceforge.openocd.banked" },
+	{ ARMV8_SPSR_EL2, "SPSR_EL2", 32, ARMV8_64_EL2H, REG_TYPE_UINT32, "banked", "net.sourceforge.openocd.banked" },
+
+	{ ARMV8_ELR_EL3, "ELR_EL3", 64, ARMV8_64_EL3H, REG_TYPE_CODE_PTR, "banked", "net.sourceforge.openocd.banked" },
+	{ ARMV8_ESR_EL3, "ESR_EL3", 32, ARMV8_64_EL3H, REG_TYPE_UINT32, "banked", "net.sourceforge.openocd.banked" },
+	{ ARMV8_SPSR_EL3, "SPSR_EL3", 32, ARMV8_64_EL3H, REG_TYPE_UINT32, "banked", "net.sourceforge.openocd.banked" },
+};
+
+static const struct {
+	unsigned id;
+	const char *name;
+	unsigned bits;
+	enum arm_mode mode;
+	enum reg_type type;
+	const char *group;
+	const char *feature;
+} armv8_regs32[] = {
+	{ ARMV8_R0,  "r0",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R1,  "r1",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R2,  "r2",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R3,  "r3",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R4,  "r4",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R5,  "r5",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R6,  "r6",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R7,  "r7",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R8,  "r8",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R9,  "r9",  32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R10, "r10", 32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R11, "r11", 32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R12, "r12", 32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R13, "sp", 32, ARM_MODE_ANY, REG_TYPE_DATA_PTR, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_R14, "lr",  32, ARM_MODE_ANY, REG_TYPE_CODE_PTR, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_PC, "pc",   32, ARM_MODE_ANY, REG_TYPE_CODE_PTR, "general", "org.gnu.gdb.arm.core" },
+	{ ARMV8_xPSR, "cpsr", 32, ARM_MODE_ANY, REG_TYPE_UINT32, "general", "org.gnu.gdb.arm.core" },
+};
+
+#define ARMV8_NUM_REGS ARRAY_SIZE(armv8_regs)
+#define ARMV8_NUM_REGS32 ARRAY_SIZE(armv8_regs32)
+
+static int armv8_get_core_reg(struct reg *reg)
+{
+	struct arm_reg *armv8_reg = reg->arch_info;
+	struct target *target = armv8_reg->target;
+	struct arm *arm = target_to_arm(target);
+
+	if (target->state != TARGET_HALTED)
+		return ERROR_TARGET_NOT_HALTED;
+
+	return arm->read_core_reg(target, reg, armv8_reg->num, arm->core_mode);
+}
+
+static int armv8_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	struct arm_reg *armv8_reg = reg->arch_info;
+	struct target *target = armv8_reg->target;
+	struct arm *arm = target_to_arm(target);
+	uint64_t value = buf_get_u64(buf, 0, 64);
+
+	if (target->state != TARGET_HALTED)
+		return ERROR_TARGET_NOT_HALTED;
+
+	if (reg == arm->cpsr) {
+		armv8_set_cpsr(arm, (uint32_t)value);
+	} else {
+		buf_set_u64(reg->value, 0, 64, value);
+		reg->valid = 1;
+	}
+
+	reg->dirty = 1;
+
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type armv8_reg_type = {
+	.get = armv8_get_core_reg,
+	.set = armv8_set_core_reg,
+};
+
+static int armv8_get_core_reg32(struct reg *reg)
+{
+	struct arm_reg *armv8_reg = reg->arch_info;
+	struct target *target = armv8_reg->target;
+	struct arm *arm = target_to_arm(target);
+	struct reg_cache *cache = arm->core_cache;
+	struct reg *reg64;
+	int retval;
+
+	/* get the corresponding Aarch64 register */
+	reg64 = cache->reg_list + armv8_reg->num;
+	if (reg64->valid) {
+		reg->valid = true;
+		return ERROR_OK;
+	}
+
+	retval = arm->read_core_reg(target, reg64, armv8_reg->num, arm->core_mode);
+	if (retval == ERROR_OK)
+		reg->valid = reg64->valid;
+
+	return retval;
+}
+
+static int armv8_set_core_reg32(struct reg *reg, uint8_t *buf)
+{
+	struct arm_reg *armv8_reg = reg->arch_info;
+	struct target *target = armv8_reg->target;
+	struct arm *arm = target_to_arm(target);
+	struct reg_cache *cache = arm->core_cache;
+	struct reg *reg64 = cache->reg_list + armv8_reg->num;
+	uint32_t value = buf_get_u32(buf, 0, 32);
+
+	if (reg64 == arm->cpsr) {
+		armv8_set_cpsr(arm, value);
+	} else {
+		buf_set_u32(reg->value, 0, 32, value);
+		reg->valid = 1;
+		reg64->valid = 1;
+	}
+
+	reg64->dirty = 1;
+
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type armv8_reg32_type = {
+	.get = armv8_get_core_reg32,
+	.set = armv8_set_core_reg32,
+};
+
+/** Builds cache of architecturally defined registers.  */
+struct reg_cache *armv8_build_reg_cache(struct target *target)
+{
+	struct armv8_common *armv8 = target_to_armv8(target);
+	struct arm *arm = &armv8->arm;
+	int num_regs = ARMV8_NUM_REGS;
+	int num_regs32 = ARMV8_NUM_REGS32;
+	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg_cache *cache32 = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = calloc(num_regs, sizeof(struct reg));
+	struct reg *reg_list32 = calloc(num_regs32, sizeof(struct reg));
+	struct arm_reg *arch_info = calloc(num_regs, sizeof(struct arm_reg));
+	struct reg_feature *feature;
+	int i;
+
+	/* Build the process context cache */
+	cache->name = "Aarch64 registers";
+	cache->next = cache32;
+	cache->reg_list = reg_list;
+	cache->num_regs = num_regs;
+
+	for (i = 0; i < num_regs; i++) {
+		arch_info[i].num = armv8_regs[i].id;
+		arch_info[i].mode = armv8_regs[i].mode;
+		arch_info[i].target = target;
+		arch_info[i].arm = arm;
+
+		reg_list[i].name = armv8_regs[i].name;
+		reg_list[i].size = armv8_regs[i].bits;
+		reg_list[i].value = &arch_info[i].value[0];
+		reg_list[i].type = &armv8_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+
+		reg_list[i].group = armv8_regs[i].group;
+		reg_list[i].number = i;
+		reg_list[i].exist = true;
+		reg_list[i].caller_save = true;	/* gdb defaults to true */
+
+		feature = calloc(1, sizeof(struct reg_feature));
+		if (feature) {
+			feature->name = armv8_regs[i].feature;
+			reg_list[i].feature = feature;
+		} else
+			LOG_ERROR("unable to allocate feature list");
+
+		reg_list[i].reg_data_type = calloc(1, sizeof(struct reg_data_type));
+		if (reg_list[i].reg_data_type)
+			reg_list[i].reg_data_type->type = armv8_regs[i].type;
+		else
+			LOG_ERROR("unable to allocate reg type list");
+	}
+
+	arm->cpsr = reg_list + ARMV8_xPSR;
+	arm->pc = reg_list + ARMV8_PC;
+	arm->core_cache = cache;
+
+	/* shadow cache for ARM mode registers */
+	cache32->name = "Aarch32 registers";
+	cache32->next = NULL;
+	cache32->reg_list = reg_list32;
+	cache32->num_regs = num_regs32;
+
+	for (i = 0; i < num_regs32; i++) {
+		reg_list32[i].name = armv8_regs32[i].name;
+		reg_list32[i].size = armv8_regs32[i].bits;
+		reg_list32[i].value = &arch_info[armv8_regs32[i].id].value[0];
+		reg_list32[i].type = &armv8_reg32_type;
+		reg_list32[i].arch_info = &arch_info[armv8_regs32[i].id];
+		reg_list32[i].group = armv8_regs32[i].group;
+		reg_list32[i].number = i;
+		reg_list32[i].exist = true;
+		reg_list32[i].caller_save = true;
+
+		feature = calloc(1, sizeof(struct reg_feature));
+		if (feature) {
+			feature->name = armv8_regs32[i].feature;
+			reg_list32[i].feature = feature;
+		} else
+			LOG_ERROR("unable to allocate feature list");
+
+		reg_list32[i].reg_data_type = calloc(1, sizeof(struct reg_data_type));
+		if (reg_list32[i].reg_data_type)
+			reg_list32[i].reg_data_type->type = armv8_regs32[i].type;
+		else
+			LOG_ERROR("unable to allocate reg type list");
+	}
+
+	(*cache_p) = cache;
+	return cache;
+}
+
+struct reg *armv8_reg_current(struct arm *arm, unsigned regnum)
+{
+	struct reg *r;
+
+	if (regnum > (ARMV8_LAST_REG - 1))
+		return NULL;
+
+	r = arm->core_cache->reg_list + regnum;
+	return r;
+}
+
+const struct command_registration armv8_command_handlers[] = {
+	{
+		.chain = dap_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+
+int armv8_get_gdb_reg_list(struct target *target,
+	struct reg **reg_list[], int *reg_list_size,
+	enum target_register_class reg_class)
+{
+	struct arm *arm = target_to_arm(target);
+	int i;
+
+	if (arm->core_state == ARM_STATE_AARCH64) {
+
+		LOG_DEBUG("Creating Aarch64 register list for target %s", target_name(target));
+
+		switch (reg_class) {
+		case REG_CLASS_GENERAL:
+			*reg_list_size = ARMV8_ELR_EL1;
+			*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+
+			for (i = 0; i < *reg_list_size; i++)
+					(*reg_list)[i] = armv8_reg_current(arm, i);
+			return ERROR_OK;
+
+		case REG_CLASS_ALL:
+			*reg_list_size = ARMV8_LAST_REG;
+			*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+
+			for (i = 0; i < *reg_list_size; i++)
+					(*reg_list)[i] = armv8_reg_current(arm, i);
+
+			return ERROR_OK;
+
+		default:
+			LOG_ERROR("not a valid register class type in query.");
+			return ERROR_FAIL;
+		}
+	} else {
+		struct reg_cache *cache32 = arm->core_cache->next;
+
+		LOG_DEBUG("Creating Aarch32 register list for target %s", target_name(target));
+
+		switch (reg_class) {
+		case REG_CLASS_GENERAL:
+		case REG_CLASS_ALL:
+			*reg_list_size = cache32->num_regs;
+			*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+
+			for (i = 0; i < *reg_list_size; i++)
+				(*reg_list)[i] = cache32->reg_list + i;
+
+			return ERROR_OK;
+		default:
+			LOG_ERROR("not a valid register class type in query.");
+			return ERROR_FAIL;
+		}
+	}
+}
+
+int armv8_set_dbgreg_bits(struct armv8_common *armv8, unsigned int reg, unsigned long mask, unsigned long value)
+{
+	uint32_t tmp;
+
+	/* Read register */
+	int retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + reg, &tmp);
+	if (ERROR_OK != retval)
+		return retval;
+
+	/* clear bitfield */
+	tmp &= ~mask;
+	/* put new value */
+	tmp |= value & mask;
+
+	/* write new value */
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap,
+			armv8->debug_base + reg, tmp);
+	return retval;
+}
diff --git a/src/target/armv8.h b/src/target/armv8.h
new file mode 100644
index 00000000..02663cab
--- /dev/null
+++ b/src/target/armv8.h
@@ -0,0 +1,282 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by David Ung                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ ***************************************************************************/
+
+#ifndef OPENOCD_TARGET_ARMV8_H
+#define OPENOCD_TARGET_ARMV8_H
+
+#include "arm_adi_v5.h"
+#include "arm.h"
+#include "armv4_5_mmu.h"
+#include "armv4_5_cache.h"
+#include "armv8_dpm.h"
+#include "arm_cti.h"
+
+enum {
+	ARMV8_R0 = 0,
+	ARMV8_R1,
+	ARMV8_R2,
+	ARMV8_R3,
+	ARMV8_R4,
+	ARMV8_R5,
+	ARMV8_R6,
+	ARMV8_R7,
+	ARMV8_R8,
+	ARMV8_R9,
+	ARMV8_R10,
+	ARMV8_R11,
+	ARMV8_R12,
+	ARMV8_R13,
+	ARMV8_R14,
+	ARMV8_R15,
+	ARMV8_R16,
+	ARMV8_R17,
+	ARMV8_R18,
+	ARMV8_R19,
+	ARMV8_R20,
+	ARMV8_R21,
+	ARMV8_R22,
+	ARMV8_R23,
+	ARMV8_R24,
+	ARMV8_R25,
+	ARMV8_R26,
+	ARMV8_R27,
+	ARMV8_R28,
+	ARMV8_R29,
+	ARMV8_R30,
+
+	ARMV8_SP = 31,
+	ARMV8_PC = 32,
+	ARMV8_xPSR = 33,
+
+	ARMV8_ELR_EL1 = 34,
+	ARMV8_ESR_EL1 = 35,
+	ARMV8_SPSR_EL1 = 36,
+
+	ARMV8_ELR_EL2 = 37,
+	ARMV8_ESR_EL2 = 38,
+	ARMV8_SPSR_EL2 = 39,
+
+	ARMV8_ELR_EL3 = 40,
+	ARMV8_ESR_EL3 = 41,
+	ARMV8_SPSR_EL3 = 42,
+
+	ARMV8_LAST_REG,
+};
+
+
+#define ARMV8_COMMON_MAGIC 0x0A450AAA
+
+/* VA to PA translation operations opc2 values*/
+#define V2PCWPR  0
+#define V2PCWPW  1
+#define V2PCWUR  2
+#define V2PCWUW  3
+#define V2POWPR  4
+#define V2POWPW  5
+#define V2POWUR  6
+#define V2POWUW  7
+/*   L210/L220 cache controller support */
+struct armv8_l2x_cache {
+	uint32_t base;
+	uint32_t way;
+};
+
+struct armv8_cachesize {
+	uint32_t level_num;
+	/*  cache dimensionning */
+	uint32_t linelen;
+	uint32_t associativity;
+	uint32_t nsets;
+	uint32_t cachesize;
+	/* info for set way operation on cache */
+	uint32_t index;
+	uint32_t index_shift;
+	uint32_t way;
+	uint32_t way_shift;
+};
+
+/* information about one architecture cache at any level */
+struct armv8_arch_cache {
+	int ctype;				/* cache type, CLIDR encoding */
+	struct armv8_cachesize d_u_size;	/* data cache */
+	struct armv8_cachesize i_size;		/* instruction cache */
+};
+
+struct armv8_cache_common {
+	int info;
+	int loc;
+	uint32_t iminline;
+	uint32_t dminline;
+	struct armv8_arch_cache arch[6];	/* cache info, L1 - L7 */
+	int i_cache_enabled;
+	int d_u_cache_enabled;
+
+	/* l2 external unified cache if some */
+	void *l2_cache;
+	int (*flush_all_data_cache)(struct target *target);
+	int (*display_cache_info)(struct command_context *cmd_ctx,
+			struct armv8_cache_common *armv8_cache);
+};
+
+struct armv8_mmu_common {
+	/* following field mmu working way */
+	int32_t ttbr1_used; /*  -1 not initialized, 0 no ttbr1 1 ttbr1 used and  */
+	uint64_t ttbr0_mask;/*  masked to be used  */
+
+	uint32_t ttbcr;     /* cache for ttbcr register */
+	uint32_t ttbr_mask[2];
+	uint32_t ttbr_range[2];
+
+	int (*read_physical_memory)(struct target *target, target_addr_t address,
+			uint32_t size, uint32_t count, uint8_t *buffer);
+	struct armv8_cache_common armv8_cache;
+	uint32_t mmu_enabled;
+};
+
+struct armv8_common {
+	struct arm arm;
+	int common_magic;
+	struct reg_cache *core_cache;
+
+	/* Core Debug Unit */
+	struct arm_dpm dpm;
+	uint32_t debug_base;
+	struct adiv5_ap *debug_ap;
+
+	const uint32_t *opcodes;
+
+	/* mdir */
+	uint8_t multi_processor_system;
+	uint8_t cluster_id;
+	uint8_t cpu_id;
+
+	/* armv8 aarch64 need below information for page translation */
+	uint8_t va_size;
+	uint8_t pa_size;
+	uint32_t page_size;
+	uint64_t ttbr_base;
+
+	struct armv8_mmu_common armv8_mmu;
+
+	struct arm_cti *cti;
+
+	/* Direct processor core register read and writes */
+	int (*read_reg_u64)(struct armv8_common *armv8, int num, uint64_t *value);
+	int (*write_reg_u64)(struct armv8_common *armv8, int num, uint64_t value);
+
+	int (*examine_debug_reason)(struct target *target);
+	int (*post_debug_entry)(struct target *target);
+
+	void (*pre_restore_context)(struct target *target);
+};
+
+static inline struct armv8_common *
+target_to_armv8(struct target *target)
+{
+	return container_of(target->arch_info, struct armv8_common, arm);
+}
+
+/* register offsets from armv8.debug_base */
+#define CPUV8_DBG_MAINID0		0xD00
+#define CPUV8_DBG_CPUFEATURE0	0xD20
+#define CPUV8_DBG_DBGFEATURE0	0xD28
+#define CPUV8_DBG_MEMFEATURE0	0xD38
+
+#define CPUV8_DBG_LOCKACCESS 0xFB0
+#define CPUV8_DBG_LOCKSTATUS 0xFB4
+
+#define CPUV8_DBG_EDESR		0x20
+#define CPUV8_DBG_EDECR		0x24
+#define CPUV8_DBG_WFAR0		0x30
+#define CPUV8_DBG_WFAR1		0x34
+#define CPUV8_DBG_DSCR		0x088
+#define CPUV8_DBG_DRCR		0x090
+#define CPUV8_DBG_PRCR		0x310
+#define CPUV8_DBG_PRSR		0x314
+
+#define CPUV8_DBG_DTRRX		0x080
+#define CPUV8_DBG_ITR		0x084
+#define CPUV8_DBG_SCR		0x088
+#define CPUV8_DBG_DTRTX		0x08c
+
+#define CPUV8_DBG_BVR_BASE	0x400
+#define CPUV8_DBG_BCR_BASE	0x408
+#define CPUV8_DBG_WVR_BASE	0x800
+#define CPUV8_DBG_WCR_BASE	0x808
+#define CPUV8_DBG_VCR		0x01C
+
+#define CPUV8_DBG_OSLAR		0x300
+
+#define CPUV8_DBG_AUTHSTATUS	0xFB8
+
+#define PAGE_SIZE_4KB				0x1000
+#define PAGE_SIZE_4KB_LEVEL0_BITS	39
+#define PAGE_SIZE_4KB_LEVEL1_BITS	30
+#define PAGE_SIZE_4KB_LEVEL2_BITS	21
+#define PAGE_SIZE_4KB_LEVEL3_BITS	12
+
+#define PAGE_SIZE_4KB_LEVEL0_MASK	((0x1FFULL) << PAGE_SIZE_4KB_LEVEL0_BITS)
+#define PAGE_SIZE_4KB_LEVEL1_MASK	((0x1FFULL) << PAGE_SIZE_4KB_LEVEL1_BITS)
+#define PAGE_SIZE_4KB_LEVEL2_MASK	((0x1FFULL) << PAGE_SIZE_4KB_LEVEL2_BITS)
+#define PAGE_SIZE_4KB_LEVEL3_MASK	((0x1FFULL) << PAGE_SIZE_4KB_LEVEL3_BITS)
+
+#define PAGE_SIZE_4KB_TRBBASE_MASK	0xFFFFFFFFF000
+
+int armv8_arch_state(struct target *target);
+int armv8_read_mpidr(struct armv8_common *armv8);
+int armv8_identify_cache(struct armv8_common *armv8);
+int armv8_init_arch_info(struct target *target, struct armv8_common *armv8);
+int armv8_mmu_translate_va_pa(struct target *target, target_addr_t va,
+		target_addr_t *val, int meminfo);
+int armv8_mmu_translate_va(struct target *target,  target_addr_t va, target_addr_t *val);
+
+int armv8_handle_cache_info_command(struct command_context *cmd_ctx,
+		struct armv8_cache_common *armv8_cache);
+
+void armv8_set_cpsr(struct arm *arm, uint32_t cpsr);
+
+static inline unsigned int armv8_curel_from_core_mode(enum arm_mode core_mode)
+{
+	switch (core_mode) {
+	/* Aarch32 modes */
+	case ARM_MODE_USR:
+		return 0;
+	case ARM_MODE_SVC:
+	case ARM_MODE_ABT: /* FIXME: EL3? */
+	case ARM_MODE_IRQ: /* FIXME: EL3? */
+	case ARM_MODE_FIQ: /* FIXME: EL3? */
+	case ARM_MODE_UND: /* FIXME: EL3? */
+	case ARM_MODE_SYS: /* FIXME: EL3? */
+		return 1;
+	/* case ARM_MODE_HYP:
+	 *     return 2;
+	 */
+	case ARM_MODE_MON:
+		return 3;
+	/* all Aarch64 modes */
+	default:
+		return (core_mode >> 6) & 3;
+	}
+}
+
+void armv8_select_reg_access(struct armv8_common *armv8, bool is_aarch64);
+int armv8_set_dbgreg_bits(struct armv8_common *armv8, unsigned int reg, unsigned long mask, unsigned long value);
+
+extern const struct command_registration armv8_command_handlers[];
+
+#endif /* OPENOCD_TARGET_ARMV8_H */
diff --git a/src/target/armv8_cache.c b/src/target/armv8_cache.c
new file mode 100644
index 00000000..7f610c95
--- /dev/null
+++ b/src/target/armv8_cache.c
@@ -0,0 +1,423 @@
+/***************************************************************************
+ *   Copyright (C) 2016 by Matthias Welwarsky                              *
+ *   matthias.welwarsky@sysgo.com                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "armv8_cache.h"
+#include "armv8_dpm.h"
+#include "armv8_opcodes.h"
+
+/* CLIDR cache types */
+#define CACHE_LEVEL_HAS_UNIFIED_CACHE	0x4
+#define CACHE_LEVEL_HAS_D_CACHE		0x2
+#define CACHE_LEVEL_HAS_I_CACHE		0x1
+
+static int armv8_d_cache_sanity_check(struct armv8_common *armv8)
+{
+	struct armv8_cache_common *armv8_cache = &armv8->armv8_mmu.armv8_cache;
+
+	if (armv8_cache->d_u_cache_enabled)
+		return ERROR_OK;
+
+	return ERROR_TARGET_INVALID;
+}
+
+static int armv8_i_cache_sanity_check(struct armv8_common *armv8)
+{
+	struct armv8_cache_common *armv8_cache = &armv8->armv8_mmu.armv8_cache;
+
+	if (armv8_cache->i_cache_enabled)
+		return ERROR_OK;
+
+	return ERROR_TARGET_INVALID;
+}
+
+static int armv8_cache_d_inner_flush_level(struct armv8_common *armv8, struct armv8_cachesize *size, int cl)
+{
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	int retval = ERROR_OK;
+	int32_t c_way, c_index = size->index;
+
+	LOG_DEBUG("cl %" PRId32, cl);
+	do {
+		c_way = size->way;
+		do {
+			uint32_t value = (c_index << size->index_shift)
+				| (c_way << size->way_shift) | (cl << 1);
+			/*
+			 * DC CISW - Clean and invalidate data cache
+			 * line by Set/Way.
+			 */
+			retval = dpm->instr_write_data_r0(dpm,
+					armv8_opcode(armv8, ARMV8_OPC_DCCISW), value);
+			if (retval != ERROR_OK)
+				goto done;
+			c_way -= 1;
+		} while (c_way >= 0);
+		c_index -= 1;
+	} while (c_index >= 0);
+
+ done:
+	return retval;
+}
+
+static int armv8_cache_d_inner_clean_inval_all(struct armv8_common *armv8)
+{
+	struct armv8_cache_common *cache = &(armv8->armv8_mmu.armv8_cache);
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	int cl;
+	int retval;
+
+	retval = armv8_d_cache_sanity_check(armv8);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	for (cl = 0; cl < cache->loc; cl++) {
+		/* skip i-only caches */
+		if (cache->arch[cl].ctype < CACHE_LEVEL_HAS_D_CACHE)
+			continue;
+
+		armv8_cache_d_inner_flush_level(armv8, &cache->arch[cl].d_u_size, cl);
+	}
+
+	retval = dpm->finish(dpm);
+	return retval;
+
+done:
+	LOG_ERROR("clean invalidate failed");
+	dpm->finish(dpm);
+
+	return retval;
+}
+
+int armv8_cache_d_inner_flush_virt(struct armv8_common *armv8, target_addr_t va, size_t size)
+{
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	struct armv8_cache_common *armv8_cache = &armv8->armv8_mmu.armv8_cache;
+	uint64_t linelen = armv8_cache->dminline;
+	target_addr_t va_line, va_end;
+	int retval;
+
+	retval = armv8_d_cache_sanity_check(armv8);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	va_line = va & (-linelen);
+	va_end = va + size;
+
+	while (va_line < va_end) {
+		/* DC CIVAC */
+		/* Aarch32: DCCIMVAC: ARMV4_5_MCR(15, 0, 0, 7, 14, 1) */
+		retval = dpm->instr_write_data_r0_64(dpm,
+				armv8_opcode(armv8, ARMV8_OPC_DCCIVAC), va_line);
+		if (retval != ERROR_OK)
+			goto done;
+		va_line += linelen;
+	}
+
+	dpm->finish(dpm);
+	return retval;
+
+done:
+	LOG_ERROR("d-cache invalidate failed");
+	dpm->finish(dpm);
+
+	return retval;
+}
+
+int armv8_cache_i_inner_inval_virt(struct armv8_common *armv8, target_addr_t va, size_t size)
+{
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	struct armv8_cache_common *armv8_cache = &armv8->armv8_mmu.armv8_cache;
+	uint64_t linelen = armv8_cache->iminline;
+	target_addr_t va_line, va_end;
+	int retval;
+
+	retval = armv8_i_cache_sanity_check(armv8);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	va_line = va & (-linelen);
+	va_end = va + size;
+
+	while (va_line < va_end) {
+		/* IC IVAU - Invalidate instruction cache by VA to PoU. */
+		retval = dpm->instr_write_data_r0_64(dpm,
+				armv8_opcode(armv8, ARMV8_OPC_ICIVAU), va_line);
+		if (retval != ERROR_OK)
+			goto done;
+		va_line += linelen;
+	}
+
+	dpm->finish(dpm);
+	return retval;
+
+done:
+	LOG_ERROR("d-cache invalidate failed");
+	dpm->finish(dpm);
+
+	return retval;
+}
+
+static int armv8_handle_inner_cache_info_command(struct command_context *cmd_ctx,
+	struct armv8_cache_common *armv8_cache)
+{
+	int cl;
+
+	if (armv8_cache->info == -1) {
+		command_print(cmd_ctx, "cache not yet identified");
+		return ERROR_OK;
+	}
+
+	for (cl = 0; cl < armv8_cache->loc; cl++) {
+		struct armv8_arch_cache *arch = &(armv8_cache->arch[cl]);
+
+		if (arch->ctype & 1) {
+			command_print(cmd_ctx,
+				"L%d I-Cache: linelen %" PRIi32
+				", associativity %" PRIi32
+				", nsets %" PRIi32
+				", cachesize %" PRId32 " KBytes",
+				cl+1,
+				arch->i_size.linelen,
+				arch->i_size.associativity,
+				arch->i_size.nsets,
+				arch->i_size.cachesize);
+		}
+
+		if (arch->ctype >= 2) {
+			command_print(cmd_ctx,
+				"L%d D-Cache: linelen %" PRIi32
+				", associativity %" PRIi32
+				", nsets %" PRIi32
+				", cachesize %" PRId32 " KBytes",
+				cl+1,
+				arch->d_u_size.linelen,
+				arch->d_u_size.associativity,
+				arch->d_u_size.nsets,
+				arch->d_u_size.cachesize);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int _armv8_flush_all_data(struct target *target)
+{
+	return armv8_cache_d_inner_clean_inval_all(target_to_armv8(target));
+}
+
+static int  armv8_flush_all_data(struct target *target)
+{
+	int retval = ERROR_FAIL;
+	/*  check that armv8_cache is correctly identify */
+	struct armv8_common *armv8 = target_to_armv8(target);
+	if (armv8->armv8_mmu.armv8_cache.info == -1) {
+		LOG_ERROR("trying to flush un-identified cache");
+		return retval;
+	}
+
+	if (target->smp) {
+		/*  look if all the other target have been flushed in order to flush level
+		 *  2 */
+		struct target_list *head;
+		struct target *curr;
+		head = target->head;
+		while (head != (struct target_list *)NULL) {
+			curr = head->target;
+			if (curr->state == TARGET_HALTED) {
+				LOG_INFO("Wait flushing data l1 on core %" PRId32, curr->coreid);
+				retval = _armv8_flush_all_data(curr);
+			}
+			head = head->next;
+		}
+	} else
+		retval = _armv8_flush_all_data(target);
+	return retval;
+}
+
+static int get_cache_info(struct arm_dpm *dpm, int cl, int ct, uint32_t *cache_reg)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval = ERROR_OK;
+
+	/*  select cache level */
+	retval = dpm->instr_write_data_r0(dpm,
+			armv8_opcode(armv8, WRITE_REG_CSSELR),
+			(cl << 1) | (ct == 1 ? 1 : 0));
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm->instr_read_data_r0(dpm,
+			armv8_opcode(armv8, READ_REG_CCSIDR),
+			cache_reg);
+ done:
+	return retval;
+}
+
+static struct armv8_cachesize decode_cache_reg(uint32_t cache_reg)
+{
+	struct armv8_cachesize size;
+	int i = 0;
+
+	size.linelen = 16 << (cache_reg & 0x7);
+	size.associativity = ((cache_reg >> 3) & 0x3ff) + 1;
+	size.nsets = ((cache_reg >> 13) & 0x7fff) + 1;
+	size.cachesize = size.linelen * size.associativity * size.nsets / 1024;
+
+	/*  compute info for set way operation on cache */
+	size.index_shift = (cache_reg & 0x7) + 4;
+	size.index = (cache_reg >> 13) & 0x7fff;
+	size.way = ((cache_reg >> 3) & 0x3ff);
+
+	while (((size.way << i) & 0x80000000) == 0)
+		i++;
+	size.way_shift = i;
+
+	return size;
+}
+
+int armv8_identify_cache(struct armv8_common *armv8)
+{
+	/*  read cache descriptor */
+	int retval = ERROR_FAIL;
+	struct arm_dpm *dpm = armv8->arm.dpm;
+	uint32_t csselr, clidr, ctr;
+	uint32_t cache_reg;
+	int cl, ctype;
+	struct armv8_cache_common *cache = &(armv8->armv8_mmu.armv8_cache);
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* retrieve CTR */
+	retval = dpm->instr_read_data_r0(dpm,
+			armv8_opcode(armv8, READ_REG_CTR), &ctr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	cache->iminline = 4UL << (ctr & 0xf);
+	cache->dminline = 4UL << ((ctr & 0xf0000) >> 16);
+	LOG_DEBUG("ctr %" PRIx32 " ctr.iminline %" PRId32 " ctr.dminline %" PRId32,
+		 ctr, cache->iminline, cache->dminline);
+
+	/*  retrieve CLIDR */
+	retval = dpm->instr_read_data_r0(dpm,
+			armv8_opcode(armv8, READ_REG_CLIDR), &clidr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	cache->loc = (clidr & 0x7000000) >> 24;
+	LOG_DEBUG("Number of cache levels to PoC %" PRId32, cache->loc);
+
+	/*  retrieve selected cache for later restore
+	 *  MRC p15, 2,<Rd>, c0, c0, 0; Read CSSELR */
+	retval = dpm->instr_read_data_r0(dpm,
+			armv8_opcode(armv8, READ_REG_CSSELR), &csselr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* retrieve all available inner caches */
+	for (cl = 0; cl < cache->loc; clidr >>= 3, cl++) {
+
+		/* isolate cache type at current level */
+		ctype = clidr & 7;
+
+		/* skip reserved values */
+		if (ctype > CACHE_LEVEL_HAS_UNIFIED_CACHE)
+			continue;
+
+		/* separate d or unified d/i cache at this level ? */
+		if (ctype & (CACHE_LEVEL_HAS_UNIFIED_CACHE | CACHE_LEVEL_HAS_D_CACHE)) {
+			/* retrieve d-cache info */
+			retval = get_cache_info(dpm, cl, 0, &cache_reg);
+			if (retval != ERROR_OK)
+				goto done;
+			cache->arch[cl].d_u_size = decode_cache_reg(cache_reg);
+
+			LOG_DEBUG("data/unified cache index %d << %d, way %d << %d",
+					cache->arch[cl].d_u_size.index,
+					cache->arch[cl].d_u_size.index_shift,
+					cache->arch[cl].d_u_size.way,
+					cache->arch[cl].d_u_size.way_shift);
+
+			LOG_DEBUG("cacheline %d bytes %d KBytes asso %d ways",
+					cache->arch[cl].d_u_size.linelen,
+					cache->arch[cl].d_u_size.cachesize,
+					cache->arch[cl].d_u_size.associativity);
+		}
+
+		/* separate i-cache at this level ? */
+		if (ctype & CACHE_LEVEL_HAS_I_CACHE) {
+			/* retrieve i-cache info */
+			retval = get_cache_info(dpm, cl, 1, &cache_reg);
+			if (retval != ERROR_OK)
+				goto done;
+			cache->arch[cl].i_size = decode_cache_reg(cache_reg);
+
+			LOG_DEBUG("instruction cache index %d << %d, way %d << %d",
+					cache->arch[cl].i_size.index,
+					cache->arch[cl].i_size.index_shift,
+					cache->arch[cl].i_size.way,
+					cache->arch[cl].i_size.way_shift);
+
+			LOG_DEBUG("cacheline %d bytes %d KBytes asso %d ways",
+					cache->arch[cl].i_size.linelen,
+					cache->arch[cl].i_size.cachesize,
+					cache->arch[cl].i_size.associativity);
+		}
+
+		cache->arch[cl].ctype = ctype;
+	}
+
+	/*  restore selected cache  */
+	dpm->instr_write_data_r0(dpm,
+			armv8_opcode(armv8, WRITE_REG_CSSELR), csselr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	armv8->armv8_mmu.armv8_cache.info = 1;
+
+	/*  if no l2 cache initialize l1 data cache flush function function */
+	if (armv8->armv8_mmu.armv8_cache.flush_all_data_cache == NULL) {
+		armv8->armv8_mmu.armv8_cache.display_cache_info =
+			armv8_handle_inner_cache_info_command;
+		armv8->armv8_mmu.armv8_cache.flush_all_data_cache =
+			armv8_flush_all_data;
+	}
+
+done:
+	dpm->finish(dpm);
+	return retval;
+
+}
diff --git a/src/target/armv8_cache.h b/src/target/armv8_cache.h
new file mode 100644
index 00000000..fa46e16d
--- /dev/null
+++ b/src/target/armv8_cache.h
@@ -0,0 +1,26 @@
+/***************************************************************************
+ *   Copyright (C) 2016 by Matthias Welwarsky                              *
+ *   matthias.welwarsky@sysgo.com                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
+ ***************************************************************************/
+#ifndef OPENOCD_TARGET_ARMV8_CACHE_H_
+#define OPENOCD_TARGET_ARMV8_CACHE_H_
+
+#include "armv8.h"
+
+extern int armv8_cache_d_inner_flush_virt(struct armv8_common *armv8, target_addr_t va, size_t size);
+extern int armv8_cache_i_inner_inval_virt(struct armv8_common *armv8, target_addr_t va, size_t size);
+
+#endif /* OPENOCD_TARGET_ARMV8_CACHE_H_ */
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
new file mode 100644
index 00000000..f4e7a079
--- /dev/null
+++ b/src/target/armv8_dpm.c
@@ -0,0 +1,1472 @@
+/*
+ * Copyright (C) 2009 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "armv8.h"
+#include "armv8_dpm.h"
+#include <jtag/jtag.h>
+#include "register.h"
+#include "breakpoints.h"
+#include "target_type.h"
+#include "armv8_opcodes.h"
+
+#include "helper/time_support.h"
+
+/* T32 ITR format */
+#define T32_FMTITR(instr) (((instr & 0x0000FFFF) << 16) | ((instr & 0xFFFF0000) >> 16))
+
+/**
+ * @file
+ * Implements various ARM DPM operations using architectural debug registers.
+ * These routines layer over core-specific communication methods to cope with
+ * implementation differences between cores like ARM1136 and Cortex-A8.
+ *
+ * The "Debug Programmers' Model" (DPM) for ARMv6 and ARMv7 is defined by
+ * Part C (Debug Architecture) of the ARM Architecture Reference Manual,
+ * ARMv7-A and ARMv7-R edition (ARM DDI 0406B).  In OpenOCD, DPM operations
+ * are abstracted through internal programming interfaces to share code and
+ * to minimize needless differences in debug behavior between cores.
+ */
+
+/**
+ * Get core state from EDSCR, without necessity to retrieve CPSR
+ */
+enum arm_state armv8_dpm_get_core_state(struct arm_dpm *dpm)
+{
+	int el = (dpm->dscr >> 8) & 0x3;
+	int rw = (dpm->dscr >> 10) & 0xF;
+
+	dpm->last_el = el;
+
+	/* In Debug state, each bit gives the current Execution state of each EL */
+	if ((rw >> el) & 0b1)
+		return ARM_STATE_AARCH64;
+
+	return ARM_STATE_ARM;
+}
+
+/*----------------------------------------------------------------------*/
+
+static int dpmv8_write_dcc(struct armv8_common *armv8, uint32_t data)
+{
+	return mem_ap_write_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DTRRX, data);
+}
+
+static int dpmv8_write_dcc_64(struct armv8_common *armv8, uint64_t data)
+{
+	int ret;
+	ret = mem_ap_write_u32(armv8->debug_ap,
+			       armv8->debug_base + CPUV8_DBG_DTRRX, data);
+	if (ret == ERROR_OK)
+		ret = mem_ap_write_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DTRTX, data >> 32);
+	return ret;
+}
+
+static int dpmv8_read_dcc(struct armv8_common *armv8, uint32_t *data,
+	uint32_t *dscr_p)
+{
+	uint32_t dscr = DSCR_ITE;
+	int retval;
+
+	if (dscr_p)
+		dscr = *dscr_p;
+
+	/* Wait for DTRRXfull */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for read dcc");
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+					    armv8->debug_base + CPUV8_DBG_DTRTX,
+					    data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+static int dpmv8_read_dcc_64(struct armv8_common *armv8, uint64_t *data,
+	uint32_t *dscr_p)
+{
+	uint32_t dscr = DSCR_ITE;
+	uint32_t higher;
+	int retval;
+
+	if (dscr_p)
+		dscr = *dscr_p;
+
+	/* Wait for DTRRXfull */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for DTR_TX_FULL, dscr = 0x%08" PRIx32, dscr);
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+					    armv8->debug_base + CPUV8_DBG_DTRTX,
+					    (uint32_t *)data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+					    armv8->debug_base + CPUV8_DBG_DTRRX,
+					    &higher);
+	if (retval != ERROR_OK)
+		return retval;
+
+	*data = *(uint32_t *)data | (uint64_t)higher << 32;
+
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+static int dpmv8_dpm_prepare(struct arm_dpm *dpm)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	uint32_t dscr;
+	int retval;
+
+	/* set up invariant:  ITE is set after ever DPM operation */
+	long long then = timeval_ms();
+	for (;; ) {
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dscr & DSCR_ITE) != 0)
+			break;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for dpm prepare");
+			return ERROR_FAIL;
+		}
+	}
+
+	/* update the stored copy of dscr */
+	dpm->dscr = dscr;
+
+	/* this "should never happen" ... */
+	if (dscr & DSCR_DTR_RX_FULL) {
+		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
+		/* Clear DCCRX */
+		retval = mem_ap_read_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_DTRRX, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int dpmv8_dpm_finish(struct arm_dpm *dpm)
+{
+	/* REVISIT what could be done here? */
+	return ERROR_OK;
+}
+
+static int dpmv8_exec_opcode(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t *p_dscr)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	uint32_t dscr = dpm->dscr;
+	int retval;
+
+	if (p_dscr)
+		dscr = *p_dscr;
+
+	/* Wait for InstrCompl bit to be set */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_ITE) == 0) {
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
+			return retval;
+		}
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for aarch64_exec_opcode");
+			return ERROR_FAIL;
+		}
+	}
+
+	if (armv8_dpm_get_core_state(dpm) != ARM_STATE_AARCH64)
+		opcode = T32_FMTITR(opcode);
+
+	retval = mem_ap_write_u32(armv8->debug_ap,
+			armv8->debug_base + CPUV8_DBG_ITR, opcode);
+	if (retval != ERROR_OK)
+		return retval;
+
+	then = timeval_ms();
+	do {
+		retval = mem_ap_read_atomic_u32(armv8->debug_ap,
+				armv8->debug_base + CPUV8_DBG_DSCR, &dscr);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Could not read DSCR register");
+			return retval;
+		}
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for aarch64_exec_opcode");
+			return ERROR_FAIL;
+		}
+	} while ((dscr & DSCR_ITE) == 0);	/* Wait for InstrCompl bit to be set */
+
+	/* update dscr and el after each command execution */
+	dpm->dscr = dscr;
+	if (dpm->last_el != ((dscr >> 8) & 3))
+		LOG_DEBUG("EL %i -> %i", dpm->last_el, (dscr >> 8) & 3);
+	dpm->last_el = (dscr >> 8) & 3;
+
+	if (dscr & DSCR_ERR) {
+		LOG_ERROR("Opcode 0x%08"PRIx32", DSCR.ERR=1, DSCR.EL=%i", opcode, dpm->last_el);
+		armv8_dpm_handle_exception(dpm);
+		retval = ERROR_FAIL;
+	}
+
+	if (p_dscr)
+		*p_dscr = dscr;
+
+	return retval;
+}
+
+static int dpmv8_instr_execute(struct arm_dpm *dpm, uint32_t opcode)
+{
+	return dpmv8_exec_opcode(dpm, opcode, NULL);
+}
+
+static int dpmv8_instr_write_data_dcc(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	retval = dpmv8_write_dcc(armv8, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dpmv8_exec_opcode(dpm, opcode, 0);
+}
+
+static int dpmv8_instr_write_data_dcc_64(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	retval = dpmv8_write_dcc_64(armv8, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dpmv8_exec_opcode(dpm, opcode, 0);
+}
+
+static int dpmv8_instr_write_data_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	uint32_t dscr = DSCR_ITE;
+	int retval;
+
+	retval = dpmv8_write_dcc(armv8, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dpmv8_exec_opcode(dpm, armv8_opcode(armv8, READ_REG_DTRRX), &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* then the opcode, taking data from R0 */
+	return dpmv8_exec_opcode(dpm, opcode, &dscr);
+}
+
+static int dpmv8_instr_write_data_r0_64(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	if (dpm->arm->core_state != ARM_STATE_AARCH64)
+		return dpmv8_instr_write_data_r0(dpm, opcode, data);
+
+	/* transfer data from DCC to R0 */
+	retval = dpmv8_write_dcc_64(armv8, data);
+	if (retval == ERROR_OK)
+		retval = dpmv8_exec_opcode(dpm, ARMV8_MRS(SYSTEM_DBG_DBGDTR_EL0, 0), &dpm->dscr);
+
+	/* then the opcode, taking data from R0 */
+	if (retval == ERROR_OK)
+		retval = dpmv8_exec_opcode(dpm, opcode, &dpm->dscr);
+
+	return retval;
+}
+
+static int dpmv8_instr_cpsr_sync(struct arm_dpm *dpm)
+{
+	int retval;
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+
+	/* "Prefetch flush" after modifying execution status in CPSR */
+	retval = dpmv8_exec_opcode(dpm, armv8_opcode(armv8, ARMV8_OPC_DSB_SY), &dpm->dscr);
+	if (retval == ERROR_OK)
+		dpmv8_exec_opcode(dpm, armv8_opcode(armv8, ARMV8_OPC_ISB_SY), &dpm->dscr);
+	return retval;
+}
+
+static int dpmv8_instr_read_data_dcc(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t *data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	/* the opcode, writing data to DCC */
+	retval = dpmv8_exec_opcode(dpm, opcode, &dpm->dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dpmv8_read_dcc(armv8, data, &dpm->dscr);
+}
+
+static int dpmv8_instr_read_data_dcc_64(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t *data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	/* the opcode, writing data to DCC */
+	retval = dpmv8_exec_opcode(dpm, opcode, &dpm->dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dpmv8_read_dcc_64(armv8, data, &dpm->dscr);
+}
+
+static int dpmv8_instr_read_data_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t *data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	/* the opcode, writing data to R0 */
+	retval = dpmv8_exec_opcode(dpm, opcode, &dpm->dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write R0 to DCC */
+	retval = dpmv8_exec_opcode(dpm, armv8_opcode(armv8, WRITE_REG_DTRTX), &dpm->dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dpmv8_read_dcc(armv8, data, &dpm->dscr);
+}
+
+static int dpmv8_instr_read_data_r0_64(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t *data)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval;
+
+	if (dpm->arm->core_state != ARM_STATE_AARCH64) {
+		uint32_t tmp;
+		retval = dpmv8_instr_read_data_r0(dpm, opcode, &tmp);
+		if (retval == ERROR_OK)
+			*data = tmp;
+		return retval;
+	}
+
+	/* the opcode, writing data to R0 */
+	retval = dpmv8_exec_opcode(dpm, opcode, &dpm->dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write R0 to DCC */
+	retval = dpmv8_exec_opcode(dpm, ARMV8_MSR_GP(SYSTEM_DBG_DBGDTR_EL0, 0), &dpm->dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dpmv8_read_dcc_64(armv8, data, &dpm->dscr);
+}
+
+#if 0
+static int dpmv8_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
+	target_addr_t addr, uint32_t control)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	uint32_t vr = armv8->debug_base;
+	uint32_t cr = armv8->debug_base;
+	int retval;
+
+	switch (index_t) {
+		case 0 ... 15:	/* breakpoints */
+			vr += CPUV8_DBG_BVR_BASE;
+			cr += CPUV8_DBG_BCR_BASE;
+			break;
+		case 16 ... 31:	/* watchpoints */
+			vr += CPUV8_DBG_WVR_BASE;
+			cr += CPUV8_DBG_WCR_BASE;
+			index_t -= 16;
+			break;
+		default:
+			return ERROR_FAIL;
+	}
+	vr += 16 * index_t;
+	cr += 16 * index_t;
+
+	LOG_DEBUG("A8: bpwp enable, vr %08x cr %08x",
+		(unsigned) vr, (unsigned) cr);
+
+	retval = mem_ap_write_atomic_u32(armv8->debug_ap, vr, addr);
+	if (retval != ERROR_OK)
+		return retval;
+	return mem_ap_write_atomic_u32(armv8->debug_ap, cr, control);
+}
+#endif
+
+static int dpmv8_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	uint32_t cr;
+
+	switch (index_t) {
+		case 0 ... 15:
+			cr = armv8->debug_base + CPUV8_DBG_BCR_BASE;
+			break;
+		case 16 ... 31:
+			cr = armv8->debug_base + CPUV8_DBG_WCR_BASE;
+			index_t -= 16;
+			break;
+		default:
+			return ERROR_FAIL;
+	}
+	cr += 16 * index_t;
+
+	LOG_DEBUG("A: bpwp disable, cr %08x", (unsigned) cr);
+
+	/* clear control register */
+	return mem_ap_write_atomic_u32(armv8->debug_ap, cr, 0);
+}
+
+/*
+ * Coprocessor support
+ */
+
+/* Read coprocessor */
+static int dpmv8_mrc(struct target *target, int cpnum,
+	uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+	uint32_t *value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("MRC p%d, %d, r0, c%d, c%d, %d", cpnum,
+		(int) op1, (int) CRn,
+		(int) CRm, (int) op2);
+
+	/* read coprocessor register into R0; return via DCC */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int dpmv8_mcr(struct target *target, int cpnum,
+	uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+	uint32_t value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("MCR p%d, %d, r0, c%d, c%d, %d", cpnum,
+		(int) op1, (int) CRn,
+		(int) CRm, (int) op2);
+
+	/* read DCC into r0; then write coprocessor register from R0 */
+	retval = dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Register access utilities
+ */
+
+int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
+{
+	struct armv8_common *armv8 = (struct armv8_common *)dpm->arm->arch_info;
+	int retval = ERROR_OK;
+	unsigned int target_el;
+	enum arm_state core_state;
+	uint32_t cpsr;
+
+	/* restore previous mode */
+	if (mode == ARM_MODE_ANY) {
+		cpsr = buf_get_u32(dpm->arm->cpsr->value, 0, 32);
+
+		LOG_DEBUG("restoring mode, cpsr = 0x%08"PRIx32, cpsr);
+
+	} else {
+		LOG_DEBUG("setting mode 0x%"PRIx32, mode);
+
+		/* else force to the specified mode */
+		if (is_arm_mode(mode))
+			cpsr = mode;
+		else
+			cpsr = mode >> 4;
+	}
+
+	switch (cpsr & 0x1f) {
+	/* aarch32 modes */
+	case ARM_MODE_USR:
+		target_el = 0;
+		break;
+	case ARM_MODE_SVC:
+	case ARM_MODE_ABT:
+	case ARM_MODE_IRQ:
+	case ARM_MODE_FIQ:
+		target_el = 1;
+		break;
+	/*
+	 * TODO: handle ARM_MODE_HYP
+	 * case ARM_MODE_HYP:
+	 *      target_el = 2;
+	 *      break;
+	 */
+	case ARM_MODE_MON:
+		target_el = 3;
+		break;
+	/* aarch64 modes */
+	default:
+		target_el = (cpsr >> 2) & 3;
+	}
+
+	if (target_el > SYSTEM_CUREL_EL3) {
+		LOG_ERROR("%s: Invalid target exception level %i", __func__, target_el);
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("target_el = %i, last_el = %i", target_el, dpm->last_el);
+	if (target_el > dpm->last_el) {
+		retval = dpm->instr_execute(dpm,
+				armv8_opcode(armv8, ARMV8_OPC_DCPS) | target_el);
+
+		/* DCPS clobbers registers just like an exception taken */
+		armv8_dpm_handle_exception(dpm);
+	} else {
+		core_state = armv8_dpm_get_core_state(dpm);
+		if (core_state != ARM_STATE_AARCH64) {
+			/* cannot do DRPS/ERET when already in EL0 */
+			if (dpm->last_el != 0) {
+				/* load SPSR with the desired mode and execute DRPS */
+				LOG_DEBUG("SPSR = 0x%08"PRIx32, cpsr);
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV8_MSR_GP_xPSR_T1(1, 0, 15), cpsr);
+				if (retval == ERROR_OK)
+					retval = dpm->instr_execute(dpm, armv8_opcode(armv8, ARMV8_OPC_DRPS));
+			}
+		} else {
+			/*
+			 * need to execute multiple DRPS instructions until target_el
+			 * is reached
+			 */
+			while (retval == ERROR_OK && dpm->last_el != target_el) {
+				unsigned int cur_el = dpm->last_el;
+				retval = dpm->instr_execute(dpm, armv8_opcode(armv8, ARMV8_OPC_DRPS));
+				if (cur_el == dpm->last_el) {
+					LOG_INFO("Cannot reach EL %i, SPSR corrupted?", target_el);
+					break;
+				}
+			}
+		}
+
+		/* On executing DRPS, DSPSR and DLR become UNKNOWN, mark them as dirty */
+		dpm->arm->cpsr->dirty = true;
+		dpm->arm->pc->dirty = true;
+
+		/*
+		 * re-evaluate the core state, we might be in Aarch32 state now
+		 * we rely on dpm->dscr being up-to-date
+		 */
+		core_state = armv8_dpm_get_core_state(dpm);
+		armv8_select_opcodes(armv8, core_state == ARM_STATE_AARCH64);
+		armv8_select_reg_access(armv8, core_state == ARM_STATE_AARCH64);
+	}
+
+	return retval;
+}
+
+/*
+ * Common register read, relies on armv8_select_reg_access() having been called.
+ */
+static int dpmv8_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	uint64_t value_64;
+	int retval;
+
+	retval = armv8->read_reg_u64(armv8, regnum, &value_64);
+
+	if (retval == ERROR_OK) {
+		r->valid = true;
+		r->dirty = false;
+		buf_set_u64(r->value, 0, r->size, value_64);
+		if (r->size == 64)
+			LOG_DEBUG("READ: %s, %16.8llx", r->name, (unsigned long long) value_64);
+		else
+			LOG_DEBUG("READ: %s, %8.8x", r->name, (unsigned int) value_64);
+	}
+	return ERROR_OK;
+}
+
+/*
+ * Common register write, relies on armv8_select_reg_access() having been called.
+ */
+static int dpmv8_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	int retval = ERROR_FAIL;
+	uint64_t value_64;
+
+	value_64 = buf_get_u64(r->value, 0, r->size);
+
+	retval = armv8->write_reg_u64(armv8, regnum, value_64);
+	if (retval == ERROR_OK) {
+		r->dirty = false;
+		if (r->size == 64)
+			LOG_DEBUG("WRITE: %s, %16.8llx", r->name, (unsigned long long)value_64);
+		else
+			LOG_DEBUG("WRITE: %s, %8.8x", r->name, (unsigned int)value_64);
+	}
+
+	return ERROR_OK;
+}
+
+/**
+ * Read basic registers of the the current context:  R0 to R15, and CPSR;
+ * sets the core mode (such as USR or IRQ) and state (such as ARM or Thumb).
+ * In normal operation this is called on entry to halting debug state,
+ * possibly after some other operations supporting restore of debug state
+ * or making sure the CPU is fully idle (drain write buffer, etc).
+ */
+int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
+{
+	struct arm *arm = dpm->arm;
+	struct armv8_common *armv8 = (struct armv8_common *)arm->arch_info;
+	struct reg_cache *cache;
+	struct reg *r;
+	uint32_t cpsr;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	cache = arm->core_cache;
+
+	/* read R0 first (it's used for scratch), then CPSR */
+	r = cache->reg_list + ARMV8_R0;
+	if (!r->valid) {
+		retval = dpmv8_read_reg(dpm, r, ARMV8_R0);
+		if (retval != ERROR_OK)
+			goto fail;
+	}
+	r->dirty = true;
+
+	/* read R1, too, it will be clobbered during memory access */
+	r = cache->reg_list + ARMV8_R1;
+	if (!r->valid) {
+		retval = dpmv8_read_reg(dpm, r, ARMV8_R1);
+		if (retval != ERROR_OK)
+			goto fail;
+	}
+
+	/* read cpsr to r0 and get it back */
+	retval = dpm->instr_read_data_r0(dpm,
+			armv8_opcode(armv8, READ_REG_DSPSR), &cpsr);
+	if (retval != ERROR_OK)
+		goto fail;
+
+	/* update core mode and state */
+	armv8_set_cpsr(arm, cpsr);
+
+	for (unsigned int i = ARMV8_PC; i < cache->num_regs ; i++) {
+		struct arm_reg *arm_reg;
+
+		r = armv8_reg_current(arm, i);
+		if (r->valid)
+			continue;
+
+		/*
+		 * Only read registers that are available from the
+		 * current EL (or core mode).
+		 */
+		arm_reg = r->arch_info;
+		if (arm_reg->mode != ARM_MODE_ANY &&
+				dpm->last_el != armv8_curel_from_core_mode(arm_reg->mode))
+			continue;
+
+		retval = dpmv8_read_reg(dpm, r, i);
+		if (retval != ERROR_OK)
+			goto fail;
+
+	}
+
+fail:
+	dpm->finish(dpm);
+	return retval;
+}
+
+/* Avoid needless I/O ... leave breakpoints and watchpoints alone
+ * unless they're removed, or need updating because of single-stepping
+ * or running debugger code.
+ */
+static int dpmv8_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
+	struct dpm_bpwp *xp, int *set_p)
+{
+	int retval = ERROR_OK;
+	bool disable;
+
+	if (!set_p) {
+		if (!xp->dirty)
+			goto done;
+		xp->dirty = false;
+		/* removed or startup; we must disable it */
+		disable = true;
+	} else if (bpwp) {
+		if (!xp->dirty)
+			goto done;
+		/* disabled, but we must set it */
+		xp->dirty = disable = false;
+		*set_p = true;
+	} else {
+		if (!*set_p)
+			goto done;
+		/* set, but we must temporarily disable it */
+		xp->dirty = disable = true;
+		*set_p = false;
+	}
+
+	if (disable)
+		retval = dpm->bpwp_disable(dpm, xp->number);
+	else
+		retval = dpm->bpwp_enable(dpm, xp->number,
+				xp->address, xp->control);
+
+	if (retval != ERROR_OK)
+		LOG_ERROR("%s: can't %s HW %spoint %d",
+			disable ? "disable" : "enable",
+			target_name(dpm->arm->target),
+			(xp->number < 16) ? "break" : "watch",
+			xp->number & 0xf);
+done:
+	return retval;
+}
+
+static int dpmv8_add_breakpoint(struct target *target, struct breakpoint *bp);
+
+/**
+ * Writes all modified core registers for all processor modes.  In normal
+ * operation this is called on exit from halting debug state.
+ *
+ * @param dpm: represents the processor
+ * @param bpwp: true ensures breakpoints and watchpoints are set,
+ *	false ensures they are cleared
+ */
+int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
+{
+	struct arm *arm = dpm->arm;
+	struct reg_cache *cache = arm->core_cache;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* If we're managing hardware breakpoints for this core, enable
+	 * or disable them as requested.
+	 *
+	 * REVISIT We don't yet manage them for ANY cores.  Eventually
+	 * we should be able to assume we handle them; but until then,
+	 * cope with the hand-crafted breakpoint code.
+	 */
+	if (arm->target->type->add_breakpoint == dpmv8_add_breakpoint) {
+		for (unsigned i = 0; i < dpm->nbp; i++) {
+			struct dpm_bp *dbp = dpm->dbp + i;
+			struct breakpoint *bp = dbp->bp;
+
+			retval = dpmv8_maybe_update_bpwp(dpm, bpwp, &dbp->bpwp,
+					bp ? &bp->set : NULL);
+			if (retval != ERROR_OK)
+				goto done;
+		}
+	}
+
+	/* enable/disable watchpoints */
+	for (unsigned i = 0; i < dpm->nwp; i++) {
+		struct dpm_wp *dwp = dpm->dwp + i;
+		struct watchpoint *wp = dwp->wp;
+
+		retval = dpmv8_maybe_update_bpwp(dpm, bpwp, &dwp->bpwp,
+				wp ? &wp->set : NULL);
+		if (retval != ERROR_OK)
+			goto done;
+	}
+
+	/* NOTE:  writes to breakpoint and watchpoint registers might
+	 * be queued, and need (efficient/batched) flushing later.
+	 */
+
+	/* Restore original core mode and state */
+	retval = armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* check everything except our scratch register R0 */
+	for (unsigned i = 1; i < cache->num_regs; i++) {
+		struct arm_reg *r;
+
+		/* skip PC and CPSR */
+		if (i == ARMV8_PC || i == ARMV8_xPSR)
+			continue;
+		/* skip invalid */
+		if (!cache->reg_list[i].valid)
+			continue;
+		/* skip non-dirty */
+		if (!cache->reg_list[i].dirty)
+			continue;
+
+		/* skip all registers not on the current EL */
+		r = cache->reg_list[i].arch_info;
+		if (r->mode != ARM_MODE_ANY &&
+				dpm->last_el != armv8_curel_from_core_mode(r->mode))
+			continue;
+
+		retval = dpmv8_write_reg(dpm, &cache->reg_list[i], i);
+		if (retval != ERROR_OK)
+			break;
+	}
+
+	/* flush CPSR and PC */
+	if (retval == ERROR_OK)
+		retval = dpmv8_write_reg(dpm, &cache->reg_list[ARMV8_xPSR], ARMV8_xPSR);
+	if (retval == ERROR_OK)
+		retval = dpmv8_write_reg(dpm, &cache->reg_list[ARMV8_PC], ARMV8_PC);
+	/* flush R0 -- it's *very* dirty by now */
+	if (retval == ERROR_OK)
+		retval = dpmv8_write_reg(dpm, &cache->reg_list[0], 0);
+	if (retval == ERROR_OK)
+		dpm->instr_cpsr_sync(dpm);
+done:
+	dpm->finish(dpm);
+	return retval;
+}
+
+/*
+ * Standard ARM register accessors ... there are three methods
+ * in "struct arm", to support individual read/write and bulk read
+ * of registers.
+ */
+
+static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
+	int regnum, enum arm_mode mode)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = target_to_arm(target)->dpm;
+	int retval;
+	int max = arm->core_cache->num_regs;
+
+	if (regnum < 0 || regnum >= max)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	/*
+	 * REVISIT what happens if we try to read SPSR in a core mode
+	 * which has no such register?
+	 */
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dpmv8_read_reg(dpm, r, regnum);
+	if (retval != ERROR_OK)
+		goto fail;
+
+fail:
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
+	int regnum, enum arm_mode mode, uint8_t *value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = target_to_arm(target)->dpm;
+	int retval;
+	int max = arm->core_cache->num_regs;
+
+	if (regnum < 0 || regnum > max)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	/* REVISIT what happens if we try to write SPSR in a core mode
+	 * which has no such register?
+	 */
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dpmv8_write_reg(dpm, r, regnum);
+
+	/* always clean up, regardless of error */
+	dpm->finish(dpm);
+
+	return retval;
+}
+
+static int armv8_dpm_full_context(struct target *target)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	struct reg_cache *cache = arm->core_cache;
+	int retval;
+	bool did_read;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	do {
+		enum arm_mode mode = ARM_MODE_ANY;
+
+		did_read = false;
+
+		/* We "know" arm_dpm_read_current_registers() was called so
+		 * the unmapped registers (R0..R7, PC, AND CPSR) and some
+		 * view of R8..R14 are current.  We also "know" oddities of
+		 * register mapping: special cases for R8..R12 and SPSR.
+		 *
+		 * Pick some mode with unread registers and read them all.
+		 * Repeat until done.
+		 */
+		for (unsigned i = 0; i < cache->num_regs; i++) {
+			struct arm_reg *r;
+
+			if (cache->reg_list[i].valid)
+				continue;
+			r = cache->reg_list[i].arch_info;
+
+			/* may need to pick a mode and set CPSR */
+			if (!did_read) {
+				did_read = true;
+				mode = r->mode;
+
+				/* For regular (ARM_MODE_ANY) R8..R12
+				 * in case we've entered debug state
+				 * in FIQ mode we need to patch mode.
+				 */
+				if (mode != ARM_MODE_ANY)
+					retval = armv8_dpm_modeswitch(dpm, mode);
+				else
+					retval = armv8_dpm_modeswitch(dpm, ARM_MODE_USR);
+
+				if (retval != ERROR_OK)
+					goto done;
+			}
+			if (r->mode != mode)
+				continue;
+
+			/* CPSR was read, so "R16" must mean SPSR */
+			retval = dpmv8_read_reg(dpm,
+					&cache->reg_list[i],
+					(r->num == 16) ? 17 : r->num);
+			if (retval != ERROR_OK)
+				goto done;
+		}
+
+	} while (did_read);
+
+	retval = armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	/* (void) */ dpm->finish(dpm);
+done:
+	return retval;
+}
+
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Breakpoint and Watchpoint support.
+ *
+ * Hardware {break,watch}points are usually left active, to minimize
+ * debug entry/exit costs.  When they are set or cleared, it's done in
+ * batches.  Also, DPM-conformant hardware can update debug registers
+ * regardless of whether the CPU is running or halted ... though that
+ * fact isn't currently leveraged.
+ */
+
+static int dpmv8_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
+	uint32_t addr, uint32_t length)
+{
+	uint32_t control;
+
+	control = (1 << 0)	/* enable */
+		| (3 << 1);	/* both user and privileged access */
+
+	/* Match 1, 2, or all 4 byte addresses in this word.
+	 *
+	 * FIXME:  v7 hardware allows lengths up to 2 GB for BP and WP.
+	 * Support larger length, when addr is suitably aligned.  In
+	 * particular, allow watchpoints on 8 byte "double" values.
+	 *
+	 * REVISIT allow watchpoints on unaligned 2-bit values; and on
+	 * v7 hardware, unaligned 4-byte ones too.
+	 */
+	switch (length) {
+		case 1:
+			control |= (1 << (addr & 3)) << 5;
+			break;
+		case 2:
+			/* require 2-byte alignment */
+			if (!(addr & 1)) {
+				control |= (3 << (addr & 2)) << 5;
+				break;
+			}
+		/* FALL THROUGH */
+		case 4:
+			/* require 4-byte alignment */
+			if (!(addr & 3)) {
+				control |= 0xf << 5;
+				break;
+			}
+		/* FALL THROUGH */
+		default:
+			LOG_ERROR("unsupported {break,watch}point length/alignment");
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* other shared control bits:
+	 * bits 15:14 == 0 ... both secure and nonsecure states (v6.1+ only)
+	 * bit 20 == 0 ... not linked to a context ID
+	 * bit 28:24 == 0 ... not ignoring N LSBs (v7 only)
+	 */
+
+	xp->address = addr & ~3;
+	xp->control = control;
+	xp->dirty = true;
+
+	LOG_DEBUG("BPWP: addr %8.8" PRIx32 ", control %" PRIx32 ", number %d",
+		xp->address, control, xp->number);
+
+	/* hardware is updated in write_dirty_registers() */
+	return ERROR_OK;
+}
+
+static int dpmv8_add_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (bp->length < 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (!dpm->bpwp_enable)
+		return retval;
+
+	/* FIXME we need a generic solution for software breakpoints. */
+	if (bp->type == BKPT_SOFT)
+		LOG_DEBUG("using HW bkpt, not SW...");
+
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		if (!dpm->dbp[i].bp) {
+			retval = dpmv8_bpwp_setup(dpm, &dpm->dbp[i].bpwp,
+					bp->address, bp->length);
+			if (retval == ERROR_OK)
+				dpm->dbp[i].bp = bp;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpmv8_remove_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		if (dpm->dbp[i].bp == bp) {
+			dpm->dbp[i].bp = NULL;
+			dpm->dbp[i].bpwp.dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpmv8_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
+	struct watchpoint *wp)
+{
+	int retval;
+	struct dpm_wp *dwp = dpm->dwp + index_t;
+	uint32_t control;
+
+	/* this hardware doesn't support data value matching or masking */
+	if (wp->value || wp->mask != ~(uint32_t)0) {
+		LOG_DEBUG("watchpoint values and masking not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	retval = dpmv8_bpwp_setup(dpm, &dwp->bpwp, wp->address, wp->length);
+	if (retval != ERROR_OK)
+		return retval;
+
+	control = dwp->bpwp.control;
+	switch (wp->rw) {
+		case WPT_READ:
+			control |= 1 << 3;
+			break;
+		case WPT_WRITE:
+			control |= 2 << 3;
+			break;
+		case WPT_ACCESS:
+			control |= 3 << 3;
+			break;
+	}
+	dwp->bpwp.control = control;
+
+	dpm->dwp[index_t].wp = wp;
+
+	return retval;
+}
+
+static int dpmv8_add_watchpoint(struct target *target, struct watchpoint *wp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (dpm->bpwp_enable) {
+		for (unsigned i = 0; i < dpm->nwp; i++) {
+			if (!dpm->dwp[i].wp) {
+				retval = dpmv8_watchpoint_setup(dpm, i, wp);
+				break;
+			}
+		}
+	}
+
+	return retval;
+}
+
+static int dpmv8_remove_watchpoint(struct target *target, struct watchpoint *wp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+
+	for (unsigned i = 0; i < dpm->nwp; i++) {
+		if (dpm->dwp[i].wp == wp) {
+			dpm->dwp[i].wp = NULL;
+			dpm->dwp[i].bpwp.dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint64_t addr)
+{
+	switch (dpm->arm->core_state) {
+		case ARM_STATE_ARM:
+		case ARM_STATE_AARCH64:
+			addr -= 8;
+			break;
+		case ARM_STATE_THUMB:
+		case ARM_STATE_THUMB_EE:
+			addr -= 4;
+			break;
+		case ARM_STATE_JAZELLE:
+			/* ?? */
+			break;
+		default:
+			LOG_DEBUG("Unknown core_state");
+			break;
+	}
+	dpm->wp_pc = addr;
+}
+
+/*
+ * Handle exceptions taken in debug state. This happens mostly for memory
+ * accesses that violated a MMU policy. Taking an exception while in debug
+ * state clobbers certain state registers on the target exception level.
+ * Just mark those registers dirty so that they get restored on resume.
+ * This works both for Aarch32 and Aarch64 states.
+ *
+ * This function must not perform any actions that trigger another exception
+ * or a recursion will happen.
+ */
+void armv8_dpm_handle_exception(struct arm_dpm *dpm)
+{
+	struct armv8_common *armv8 = dpm->arm->arch_info;
+	struct reg_cache *cache = dpm->arm->core_cache;
+	enum arm_state core_state;
+	uint64_t dlr;
+	uint32_t dspsr;
+	unsigned int el;
+
+	static const int clobbered_regs_by_el[3][5] = {
+		{ ARMV8_PC, ARMV8_xPSR, ARMV8_ELR_EL1, ARMV8_ESR_EL1, ARMV8_SPSR_EL1 },
+		{ ARMV8_PC, ARMV8_xPSR, ARMV8_ELR_EL2, ARMV8_ESR_EL2, ARMV8_SPSR_EL2 },
+		{ ARMV8_PC, ARMV8_xPSR, ARMV8_ELR_EL3, ARMV8_ESR_EL3, ARMV8_SPSR_EL3 },
+	};
+
+	el = (dpm->dscr >> 8) & 3;
+
+	/* safety check, must not happen since EL0 cannot be a target for an exception */
+	if (el < SYSTEM_CUREL_EL1 || el > SYSTEM_CUREL_EL3) {
+		LOG_ERROR("%s: EL %i is invalid, DSCR corrupted?", __func__, el);
+		return;
+	}
+
+	/* Clear sticky error */
+	mem_ap_write_u32(armv8->debug_ap,
+		armv8->debug_base + CPUV8_DBG_DRCR, DRCR_CSE);
+
+	armv8->read_reg_u64(armv8, ARMV8_xPSR, &dlr);
+	dspsr = dlr;
+	armv8->read_reg_u64(armv8, ARMV8_PC, &dlr);
+
+	LOG_DEBUG("Exception taken to EL %i, DLR=0x%016"PRIx64" DSPSR=0x%08"PRIx32,
+			el, dlr, dspsr);
+
+	/* mark all clobbered registers as dirty */
+	for (int i = 0; i < 5; i++)
+		cache->reg_list[clobbered_regs_by_el[el-1][i]].dirty = true;
+
+	/*
+	 * re-evaluate the core state, we might be in Aarch64 state now
+	 * we rely on dpm->dscr being up-to-date
+	 */
+	core_state = armv8_dpm_get_core_state(dpm);
+	armv8_select_opcodes(armv8, core_state == ARM_STATE_AARCH64);
+	armv8_select_reg_access(armv8, core_state == ARM_STATE_AARCH64);
+
+	armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Other debug and support utilities
+ */
+
+void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
+{
+	struct target *target = dpm->arm->target;
+
+	dpm->dscr = dscr;
+	dpm->last_el = (dscr >> 8) & 3;
+
+	/* Examine debug reason */
+	switch (DSCR_ENTRY(dscr)) {
+		/* FALL THROUGH -- assume a v6 core in abort mode */
+		case DSCRV8_ENTRY_EXT_DEBUG:	/* EDBGRQ */
+			target->debug_reason = DBG_REASON_DBGRQ;
+			break;
+		case DSCRV8_ENTRY_HALT_STEP_EXECLU:	/* HALT step */
+		case DSCRV8_ENTRY_HALT_STEP_NORMAL: /* Halt step*/
+		case DSCRV8_ENTRY_HALT_STEP:
+			target->debug_reason = DBG_REASON_SINGLESTEP;
+			break;
+		case DSCRV8_ENTRY_HLT:	/* HLT instruction (software breakpoint) */
+		case DSCRV8_ENTRY_BKPT:	/* SW BKPT (?) */
+		case DSCRV8_ENTRY_RESET_CATCH:	/* Reset catch */
+		case DSCRV8_ENTRY_OS_UNLOCK:  /*OS unlock catch*/
+		case DSCRV8_ENTRY_EXCEPTION_CATCH:  /*exception catch*/
+		case DSCRV8_ENTRY_SW_ACCESS_DBG: /*SW access dbg register*/
+			target->debug_reason = DBG_REASON_BREAKPOINT;
+			break;
+		case DSCRV8_ENTRY_WATCHPOINT:	/* asynch watchpoint */
+			target->debug_reason = DBG_REASON_WATCHPOINT;
+			break;
+		default:
+			target->debug_reason = DBG_REASON_UNDEFINED;
+			break;
+	}
+
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Setup and management support.
+ */
+
+/**
+ * Hooks up this DPM to its associated target; call only once.
+ * Initially this only covers the register cache.
+ *
+ * Oh, and watchpoints.  Yeah.
+ */
+int armv8_dpm_setup(struct arm_dpm *dpm)
+{
+	struct arm *arm = dpm->arm;
+	struct target *target = arm->target;
+	struct reg_cache *cache;
+	arm->dpm = dpm;
+
+	/* register access setup */
+	arm->full_context = armv8_dpm_full_context;
+	arm->read_core_reg = armv8_dpm_read_core_reg;
+	arm->write_core_reg = armv8_dpm_write_core_reg;
+
+	if (arm->core_cache == NULL) {
+		cache = armv8_build_reg_cache(target);
+		if (!cache)
+			return ERROR_FAIL;
+	}
+
+	/* coprocessor access setup */
+	arm->mrc = dpmv8_mrc;
+	arm->mcr = dpmv8_mcr;
+
+	dpm->prepare = dpmv8_dpm_prepare;
+	dpm->finish = dpmv8_dpm_finish;
+
+	dpm->instr_execute = dpmv8_instr_execute;
+	dpm->instr_write_data_dcc = dpmv8_instr_write_data_dcc;
+	dpm->instr_write_data_dcc_64 = dpmv8_instr_write_data_dcc_64;
+	dpm->instr_write_data_r0 = dpmv8_instr_write_data_r0;
+	dpm->instr_write_data_r0_64 = dpmv8_instr_write_data_r0_64;
+	dpm->instr_cpsr_sync = dpmv8_instr_cpsr_sync;
+
+	dpm->instr_read_data_dcc = dpmv8_instr_read_data_dcc;
+	dpm->instr_read_data_dcc_64 = dpmv8_instr_read_data_dcc_64;
+	dpm->instr_read_data_r0 = dpmv8_instr_read_data_r0;
+	dpm->instr_read_data_r0_64 = dpmv8_instr_read_data_r0_64;
+
+	dpm->arm_reg_current = armv8_reg_current;
+
+/*	dpm->bpwp_enable = dpmv8_bpwp_enable; */
+	dpm->bpwp_disable = dpmv8_bpwp_disable;
+
+	/* breakpoint setup -- optional until it works everywhere */
+	if (!target->type->add_breakpoint) {
+		target->type->add_breakpoint = dpmv8_add_breakpoint;
+		target->type->remove_breakpoint = dpmv8_remove_breakpoint;
+	}
+
+	/* watchpoint setup */
+	target->type->add_watchpoint = dpmv8_add_watchpoint;
+	target->type->remove_watchpoint = dpmv8_remove_watchpoint;
+
+	/* FIXME add vector catch support */
+
+	dpm->nbp = 1 + ((dpm->didr >> 12) & 0xf);
+	dpm->dbp = calloc(dpm->nbp, sizeof *dpm->dbp);
+
+	dpm->nwp = 1 + ((dpm->didr >> 20) & 0xf);
+	dpm->dwp = calloc(dpm->nwp, sizeof *dpm->dwp);
+
+	if (!dpm->dbp || !dpm->dwp) {
+		free(dpm->dbp);
+		free(dpm->dwp);
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("%s: hardware has %d breakpoints, %d watchpoints",
+		target_name(target), dpm->nbp, dpm->nwp);
+
+	/* REVISIT ... and some of those breakpoints could match
+	 * execution context IDs...
+	 */
+
+	return ERROR_OK;
+}
+
+/**
+ * Reinitializes DPM state at the beginning of a new debug session
+ * or after a reset which may have affected the debug module.
+ */
+int armv8_dpm_initialize(struct arm_dpm *dpm)
+{
+	/* Disable all breakpoints and watchpoints at startup. */
+	if (dpm->bpwp_disable) {
+		unsigned i;
+
+		for (i = 0; i < dpm->nbp; i++) {
+			dpm->dbp[i].bpwp.number = i;
+			(void) dpm->bpwp_disable(dpm, i);
+		}
+		for (i = 0; i < dpm->nwp; i++) {
+			dpm->dwp[i].bpwp.number = 16 + i;
+			(void) dpm->bpwp_disable(dpm, 16 + i);
+		}
+	} else
+		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
+			target_name(dpm->arm->target));
+
+	return ERROR_OK;
+}
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
new file mode 100644
index 00000000..c0393592
--- /dev/null
+++ b/src/target/armv8_dpm.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2009 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef OPENOCD_TARGET_ARMV8_DPM_H
+#define OPENOCD_TARGET_ARMV8_DPM_H
+
+#include "arm_dpm.h"
+
+/* forward-declare struct armv8_common */
+struct armv8_common;
+
+/**
+ * This wraps an implementation of DPM primitives.  Each interface
+ * provider supplies a structure like this, which is the glue between
+ * upper level code and the lower level hardware access.
+ *
+ * It is a PRELIMINARY AND INCOMPLETE set of primitives, starting with
+ * support for CPU register access.
+ */
+int armv8_dpm_setup(struct arm_dpm *dpm);
+int armv8_dpm_initialize(struct arm_dpm *dpm);
+
+int armv8_dpm_read_current_registers(struct arm_dpm *);
+int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
+
+
+int armv8_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
+
+void armv8_dpm_report_wfar(struct arm_dpm *, uint64_t wfar);
+
+/* DSCR bits; see ARMv7a arch spec section C10.3.1.
+ * Not all v7 bits are valid in v6.
+ */
+#define DSCR_DEBUG_STATUS_MASK		(0x1F <<  0)
+#define DSCR_ERR					(0x1 <<  6)
+#define DSCR_SYS_ERROR_PEND			(0x1 <<  7)
+#define DSCR_CUR_EL					(0x3 <<  8)
+#define DSCR_EL_STATUS_MASK			(0xF << 10)
+#define DSCR_HDE					(0x1 << 14)
+#define DSCR_SDD					(0x1 << 16)
+#define DSCR_NON_SECURE             (0x1 << 18)
+#define DSCR_MA						(0x1 << 20)
+#define DSCR_TDA					(0x1 << 21)
+#define DSCR_INTDIS_MASK			(0x3 << 22)
+#define DSCR_ITE					(0x1 << 24)
+#define DSCR_PIPE_ADVANCE           (0x1 << 25)
+#define DSCR_TXU					(0x1 << 26)
+#define DSCR_RTO					(0x1 << 27) /* bit 28 is reserved */
+#define DSCR_ITO					(0x1 << 28)
+#define DSCR_DTR_TX_FULL            (0x1 << 29)
+#define DSCR_DTR_RX_FULL            (0x1 << 30) /* bit 31 is reserved */
+
+
+
+/* Methods of entry into debug mode */
+#define DSCRV8_ENTRY_NON_DEBUG			(0x2)
+#define DSCRV8_ENTRY_RESTARTING			(0x1)
+#define DSCRV8_ENTRY_BKPT				(0x7)
+#define DSCRV8_ENTRY_EXT_DEBUG			(0x13)
+#define DSCRV8_ENTRY_HALT_STEP_NORMAL	(0x1B)
+#define DSCRV8_ENTRY_HALT_STEP_EXECLU	(0x1F)
+#define DSCRV8_ENTRY_OS_UNLOCK			(0x23)
+#define DSCRV8_ENTRY_RESET_CATCH		(0x27)
+#define DSCRV8_ENTRY_WATCHPOINT			(0x2B)
+#define DSCRV8_ENTRY_HLT				(0x2F)
+#define DSCRV8_ENTRY_SW_ACCESS_DBG		(0x33)
+#define DSCRV8_ENTRY_EXCEPTION_CATCH	(0x37)
+#define DSCRV8_ENTRY_HALT_STEP			(0x3B)
+#define DSCRV8_HALT_MASK			(0x3C)
+
+/*DRCR registers*/
+#define DRCR_CSE				(1 << 2)
+#define DRCR_CSPA				(1 << 3)
+#define DRCR_CBRRQ				(1 << 4)
+
+
+/* DTR modes */
+#define DSCR_EXT_DCC_NON_BLOCKING     (0x0 << 20)
+#define DSCR_EXT_DCC_STALL_MODE       (0x1 << 20)
+#define DSCR_EXT_DCC_FAST_MODE        (0x2 << 20)  /* bits 22, 23 are reserved */
+
+
+/* DRCR (debug run control register) bits */
+#define DRCR_HALT				(1 << 0)
+#define DRCR_RESTART			(1 << 1)
+#define DRCR_CLEAR_EXCEPTIONS	(1 << 2)
+
+/* PRSR (processor debug status register) bits */
+#define PRSR_PU					(1 << 0)
+#define PRSR_SPD				(1 << 1)
+#define PRSR_RESET				(1 << 2)
+#define PRSR_SR					(1 << 3)
+#define PRSR_HALT				(1 << 4)
+#define PRSR_OSLK				(1 << 5)
+#define PRSR_DLK				(1 << 6)
+#define PRSR_EDAD				(1 << 7)
+#define PRSR_SDAD				(1 << 8)
+#define PRSR_EPMAD				(1 << 9)
+#define PRSR_SPMAD				(1 << 10)
+#define PRSR_SDR				(1 << 11)
+
+/* PRCR (processor debug control register) bits */
+#define PRCR_CORENPDRQ			(1 << 0)
+#define PRCR_CWRR				(1 << 2)
+#define PRCR_COREPURQ			(1 << 3)
+
+void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
+void armv8_dpm_handle_exception(struct arm_dpm *dpm);
+enum arm_state armv8_dpm_get_core_state(struct arm_dpm *dpm);
+
+#endif /* OPENOCD_TARGET_ARM_DPM_H */
diff --git a/src/target/armv8_opcodes.c b/src/target/armv8_opcodes.c
new file mode 100644
index 00000000..d3c0b3f5
--- /dev/null
+++ b/src/target/armv8_opcodes.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 by Matthias Welwarsky <matthias.welwarsky@sysgo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "armv8.h"
+#include "armv8_opcodes.h"
+
+static const uint32_t a64_opcodes[ARMV8_OPC_NUM] = {
+		[READ_REG_CTR]		= ARMV8_MRS(SYSTEM_CTR, 0),
+		[READ_REG_CLIDR]	= ARMV8_MRS(SYSTEM_CLIDR, 0),
+		[READ_REG_CSSELR]	= ARMV8_MRS(SYSTEM_CSSELR, 0),
+		[READ_REG_CCSIDR]	= ARMV8_MRS(SYSTEM_CCSIDR, 0),
+		[WRITE_REG_CSSELR]	= ARMV8_MSR_GP(SYSTEM_CSSELR, 0),
+		[READ_REG_MPIDR]	= ARMV8_MRS(SYSTEM_MPIDR, 0),
+		[READ_REG_DTRRX]	= ARMV8_MRS(SYSTEM_DBG_DTRRX_EL0, 0),
+		[WRITE_REG_DTRTX]	= ARMV8_MSR_GP(SYSTEM_DBG_DTRTX_EL0, 0),
+		[WRITE_REG_DSPSR]	= ARMV8_MSR_DSPSR(0),
+		[READ_REG_DSPSR]	= ARMV8_MRS_DSPSR(0),
+		[ARMV8_OPC_DSB_SY]	= ARMV8_DSB_SY,
+		[ARMV8_OPC_DCPS]	= ARMV8_DCPS(0, 11),
+		[ARMV8_OPC_DRPS]	= ARMV8_DRPS,
+		[ARMV8_OPC_ISB_SY]	= ARMV8_ISB,
+		[ARMV8_OPC_DCCISW]	= ARMV8_SYS(SYSTEM_DCCISW, 0),
+		[ARMV8_OPC_DCCIVAC]	= ARMV8_SYS(SYSTEM_DCCIVAC, 0),
+		[ARMV8_OPC_ICIVAU]	= ARMV8_SYS(SYSTEM_ICIVAU, 0),
+		[ARMV8_OPC_HLT]		= ARMV8_HLT(11),
+};
+
+static const uint32_t t32_opcodes[ARMV8_OPC_NUM] = {
+		[READ_REG_CTR]		= ARMV4_5_MRC(15, 0, 0, 0, 0, 1),
+		[READ_REG_CLIDR]	= ARMV4_5_MRC(15, 1, 0, 0, 0, 1),
+		[READ_REG_CSSELR]	= ARMV4_5_MRC(15, 2, 0, 0, 0, 0),
+		[READ_REG_CCSIDR]	= ARMV4_5_MRC(15, 1, 0, 0, 0, 0),
+		[WRITE_REG_CSSELR]	= ARMV4_5_MCR(15, 2, 0, 0, 0, 0),
+		[READ_REG_MPIDR]	= ARMV4_5_MRC(15, 0, 0, 0, 0, 5),
+		[READ_REG_DTRRX]	= ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+		[WRITE_REG_DTRTX]	= ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+		[WRITE_REG_DSPSR]	= ARMV8_MCR_DSPSR(0),
+		[READ_REG_DSPSR]	= ARMV8_MRC_DSPSR(0),
+		[ARMV8_OPC_DSB_SY]	= ARMV8_DSB_SY_T1,
+		[ARMV8_OPC_DCPS]	= ARMV8_DCPS_T1(0),
+		[ARMV8_OPC_DRPS]	= ARMV8_ERET_T1,
+		[ARMV8_OPC_ISB_SY]	= ARMV8_ISB_SY_T1,
+		[ARMV8_OPC_DCCISW]	= ARMV4_5_MCR(15, 0, 0, 7, 14, 2),
+		[ARMV8_OPC_DCCIVAC]	= ARMV4_5_MCR(15, 0, 0, 7, 14, 1),
+		[ARMV8_OPC_ICIVAU]	= ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+		[ARMV8_OPC_HLT]		= ARMV8_HLT_A1(11),
+};
+
+void armv8_select_opcodes(struct armv8_common *armv8, bool state_is_aarch64)
+{
+	if (state_is_aarch64)
+		armv8->opcodes = &a64_opcodes[0];
+	else
+		armv8->opcodes = &t32_opcodes[0];
+}
+
+uint32_t armv8_opcode(struct armv8_common *armv8, enum armv8_opcode code)
+{
+	if ((int)code >= ARMV8_OPC_NUM)
+		return -1;
+
+	return *(armv8->opcodes + code);
+}
diff --git a/src/target/armv8_opcodes.h b/src/target/armv8_opcodes.h
new file mode 100644
index 00000000..2d8ddd82
--- /dev/null
+++ b/src/target/armv8_opcodes.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2015 by pierrr kuo
+ * vichy.kuo@gmail.com
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef OPENOCD_TARGET_ARMV8_OPCODES_H
+#define OPENOCD_TARGET_ARMV8_OPCODES_H
+
+#include "arm_opcodes.h"
+
+#define SYSTEM_CUREL_MASK		0xC0
+#define SYSTEM_CUREL_SHIFT		6
+#define SYSTEM_CUREL_EL0		0x0
+#define SYSTEM_CUREL_EL1		0x1
+#define SYSTEM_CUREL_EL2		0x2
+#define SYSTEM_CUREL_EL3		0x3
+#define SYSTEM_CUREL_NONCH		0xF
+#define SYSTEM_AARCH64			0x1
+
+#define SYSTEM_AAR64_MODE_EL0t	0x0
+#define SYSTEM_AAR64_MODE_EL1t	0x4
+#define SYSTEM_AAR64_MODE_EL1h	0x5
+#define SYSTEM_AAR64_MODE_EL2t	0x8
+#define SYSTEM_AAR64_MODE_EL2h	0x9
+#define SYSTEM_AAR64_MODE_EL3t	0xC
+#define SYSTEM_AAR64_MODE_EL3h	0xd
+
+#define SYSTEM_DAIF			0b1101101000010001
+#define SYSTEM_DAIF_MASK		0x3C0
+#define SYSTEM_DAIF_SHIFT		6
+
+#define SYSTEM_ELR_EL1			0b1100001000000001
+#define SYSTEM_ELR_EL2			0b1110001000000001
+#define SYSTEM_ELR_EL3			0b1111001000000001
+
+#define SYSTEM_SCTLR_EL1	0b1100000010000000
+#define SYSTEM_SCTLR_EL2	0b1110000010000000
+#define SYSTEM_SCTLR_EL3	0b1111000010000000
+
+#define SYSTEM_FPCR			0b1101101000100000
+#define SYSTEM_FPSR			0b1101101000100001
+#define SYSTEM_DAIF			0b1101101000010001
+#define SYSTEM_NZCV			0b1101101000010000
+#define SYSTEM_SP_EL0			0b1100001000001000
+#define SYSTEM_SP_EL1			0b1110001000001000
+#define SYSTEM_SP_EL2			0b1111001000001000
+#define SYSTEM_SP_SEL			0b1100001000010000
+#define SYSTEM_SPSR_ABT			0b1110001000011001
+#define SYSTEM_SPSR_FIQ			0b1110001000011011
+#define SYSTEM_SPSR_IRQ			0b1110001000011000
+#define SYSTEM_SPSR_UND			0b1110001000011010
+
+#define SYSTEM_SPSR_EL1			0b1100001000000000
+#define SYSTEM_SPSR_EL2			0b1110001000000000
+#define SYSTEM_SPSR_EL3			0b1111001000000000
+
+#define SYSTEM_ISR_EL1			0b1100011000001000
+
+#define SYSTEM_DBG_DSPSR_EL0    0b1101101000101000
+#define SYSTEM_DBG_DLR_EL0		0b1101101000101001
+#define SYSTEM_DBG_DTRRX_EL0	0b1001100000101000
+#define SYSTEM_DBG_DTRTX_EL0	0b1001100000101000
+#define SYSTEM_DBG_DBGDTR_EL0	0b1001100000100000
+
+#define SYSTEM_CCSIDR			0b1100100000000000
+#define SYSTEM_CLIDR			0b1100100000000001
+#define SYSTEM_CSSELR			0b1101000000000000
+#define SYSTEM_CTYPE			0b1101100000000001
+#define SYSTEM_CTR				0b1101100000000001
+
+#define SYSTEM_DCCISW			0b0100001111110010
+#define SYSTEM_DCCSW			0b0100001111010010
+#define SYSTEM_ICIVAU			0b0101101110101001
+#define SYSTEM_DCCVAU			0b0101101111011001
+#define SYSTEM_DCCIVAC			0b0101101111110001
+
+#define SYSTEM_MPIDR			0b1100000000000101
+
+#define SYSTEM_TCR_EL1			0b1100000100000010
+#define SYSTEM_TCR_EL2			0b1110000100000010
+#define SYSTEM_TCR_EL3			0b1111000100000010
+
+#define SYSTEM_TTBR0_EL1		0b1100000100000000
+#define SYSTEM_TTBR0_EL2		0b1110000100000000
+#define SYSTEM_TTBR0_EL3		0b1111000100000000
+#define SYSTEM_TTBR1_EL1		0b1100000100000001
+
+/* ARMv8 address translation */
+#define SYSTEM_PAR_EL1			0b1100001110100000
+#define SYSTEM_ATS12E0R			0b0110001111000110
+#define SYSTEM_ATS12E1R			0b0110001111000100
+#define SYSTEM_ATS1E2R			0b0110001111000000
+#define SYSTEM_ATS1E3R			0b0111001111000000
+
+/* fault status and fault address */
+#define SYSTEM_FAR_EL1			0b1100001100000000
+#define SYSTEM_FAR_EL2			0b1110001100000000
+#define SYSTEM_FAR_EL3			0b1111001100000000
+#define SYSTEM_ESR_EL1			0b1100001010010000
+#define SYSTEM_ESR_EL2			0b1110001010010000
+#define SYSTEM_ESR_EL3			0b1111001010010000
+
+#define ARMV8_MRS_DSPSR(Rt)	(0xd53b4500 | (Rt))
+#define ARMV8_MSR_DSPSR(Rt)	(0xd51b4500 | (Rt))
+#define ARMV8_MRS_DLR(Rt)	(0xd53b4520 | (Rt))
+#define ARMV8_MSR_DLR(Rt)	(0xd51b4520 | (Rt))
+
+/* T32 instruction to access coprocessor registers */
+#define ARMV8_MCR_T1(cp, CRn, opc1, CRm, opc2, Rt) ARMV4_5_MCR(cp, opc1, Rt, CRn, CRm, opc2)
+#define ARMV8_MRC_T1(cp, CRn, opc1, CRm, opc2, Rt) ARMV4_5_MRC(cp, opc1, Rt, CRn, CRm, opc2)
+
+/* T32 instructions to access DSPSR and DLR */
+#define ARMV8_MRC_DSPSR(Rt) ARMV8_MRC_T1(15, 4, 3, 5, 0, Rt)
+#define ARMV8_MCR_DSPSR(Rt) ARMV8_MCR_T1(15, 4, 3, 5, 0, Rt)
+#define ARMV8_MRC_DLR(Rt)	ARMV8_MRC_T1(15, 4, 3, 5, 1, Rt)
+#define ARMV8_MCR_DLR(Rt)	ARMV8_MCR_T1(15, 4, 3, 5, 1, Rt)
+
+#define ARMV8_DCPS1(IM)		(0xd4a00001 | (((IM) & 0xFFFF) << 5))
+#define ARMV8_DCPS2(IM)		(0xd4a00002 | (((IM) & 0xFFFF) << 5))
+#define ARMV8_DCPS3(IM)		(0xd4a00003 | (((IM) & 0xFFFF) << 5))
+#define ARMV8_DCPS(EL, IM)	(0xd4a00000 | (((IM) & 0xFFFF) << 5) | EL)
+#define ARMV8_DCPS_T1(EL)	(0xf78f8000 | EL)
+#define ARMV8_DRPS		0xd6bf03e0
+#define ARMV8_ERET_T1		0xf3de8f00
+
+#define ARMV8_DSB_SY				0xd5033F9F
+#define ARMV8_DSB_SY_T1				0xf3bf8f4f
+#define ARMV8_ISB				0xd5033fdf
+#define ARMV8_ISB_SY_T1				0xf3bf8f6f
+
+#define ARMV8_MRS(System, Rt)	(0xd5300000 | ((System) << 5) | (Rt))
+/* ARM V8 Move to system register. */
+#define ARMV8_MSR_GP(System, Rt) \
+	(0xd5100000 | ((System) << 5) | (Rt))
+/* ARM V8 Move immediate to process state field. */
+#define ARMV8_MSR_IM(Op1, CRm, Op2) \
+	(0xd500401f | ((Op1) << 16)  | ((CRm) << 8) | ((Op2) << 5))
+
+#define ARMV8_MRS_T1(R, M1, Rd, M) (0xF3E08020 | (R << 20) | (M1 << 16) | (Rd << 8) | (M << 4))
+#define ARMV8_MRS_xPSR_T1(R, Rd) (0xF3EF8000 | (R << 20) | (Rd << 8))
+#define ARMV8_MSR_GP_T1(R, M1, Rd, M) (0xF3808020 | (R << 20) | (M1 << 8) | (Rd << 16) | (M << 4))
+#define ARMV8_MSR_GP_xPSR_T1(R, Rn, mask) (0xF3808000 | (R << 20) | (Rn << 16) | (mask << 8))
+
+#define ARMV8_BKPT(Im) (0xD4200000 | ((Im & 0xffff) << 5))
+#define ARMV8_HLT(Im) (0x0D4400000 | ((Im & 0xffff) << 5))
+#define ARMV8_HLT_A1(Im) (0xE1000070 | ((Im & 0xFFF0) << 4) | (Im & 0xF))
+
+#define ARMV8_MOVFSP_64(Rt) ((1 << 31) | 0x11000000 | (0x1f << 5) | (Rt))
+#define ARMV8_MOVTSP_64(Rt) ((1 << 31) | 0x11000000 | (Rt << 5) | (0x1F))
+#define ARMV8_MOVFSP_32(Rt) (0x11000000 | (0x1f << 5) | (Rt))
+#define ARMV8_MOVTSP_32(Rt) (0x11000000 | (Rt << 5) | (0x1F))
+
+#define ARMV8_SYS(System, Rt) (0xD5080000 | ((System) << 5) | Rt)
+
+enum armv8_opcode {
+	READ_REG_CTR,
+	READ_REG_CLIDR,
+	READ_REG_CSSELR,
+	READ_REG_CCSIDR,
+	WRITE_REG_CSSELR,
+	READ_REG_MPIDR,
+	READ_REG_DTRRX,
+	WRITE_REG_DTRTX,
+	WRITE_REG_DSPSR,
+	READ_REG_DSPSR,
+	ARMV8_OPC_DSB_SY,
+	ARMV8_OPC_DCPS,
+	ARMV8_OPC_DRPS,
+	ARMV8_OPC_ISB_SY,
+	ARMV8_OPC_DCCISW,
+	ARMV8_OPC_DCCIVAC,
+	ARMV8_OPC_ICIVAU,
+	ARMV8_OPC_HLT,
+	ARMV8_OPC_NUM,
+};
+
+extern uint32_t armv8_opcode(struct armv8_common *armv8, enum armv8_opcode);
+extern void armv8_select_opcodes(struct armv8_common *armv8, bool state_is_aarch64);
+
+#endif /* OPENOCD_TARGET_ARMV8_OPCODES_H */
diff --git a/src/target/avr32_ap7k.c b/src/target/avr32_ap7k.c
index 55d1efb4..f8da8d5a 100644
--- a/src/target/avr32_ap7k.c
+++ b/src/target/avr32_ap7k.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -314,7 +312,7 @@ static int avr32_ap7k_deassert_reset(struct target *target)
 }
 
 static int avr32_ap7k_resume(struct target *target, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution)
+	target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
 	struct breakpoint *breakpoint = NULL;
@@ -350,7 +348,7 @@ static int avr32_ap7k_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("unset breakpoint at 0x%8.8" TARGET_PRIxADDR "", breakpoint->address);
 #if 0
 			avr32_ap7k_unset_breakpoint(target, breakpoint);
 			avr32_ap7k_single_step_core(target);
@@ -396,7 +394,7 @@ static int avr32_ap7k_resume(struct target *target, int current,
 }
 
 static int avr32_ap7k_step(struct target *target, int current,
-	uint32_t address, int handle_breakpoints)
+	target_addr_t address, int handle_breakpoints)
 {
 	LOG_ERROR("%s: implement me", __func__);
 
@@ -433,12 +431,12 @@ static int avr32_ap7k_remove_watchpoint(struct target *target,
 	return ERROR_OK;
 }
 
-static int avr32_ap7k_read_memory(struct target *target, uint32_t address,
+static int avr32_ap7k_read_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("address: 0x%8.8" TARGET_PRIxADDR ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
 		address,
 		size,
 		count);
@@ -474,12 +472,12 @@ static int avr32_ap7k_read_memory(struct target *target, uint32_t address,
 	return ERROR_OK;
 }
 
-static int avr32_ap7k_write_memory(struct target *target, uint32_t address,
+static int avr32_ap7k_write_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("address: 0x%8.8" TARGET_PRIxADDR ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
 		address,
 		size,
 		count);
diff --git a/src/target/avr32_ap7k.h b/src/target/avr32_ap7k.h
index 1f952eb8..3f27534a 100644
--- a/src/target/avr32_ap7k.h
+++ b/src/target/avr32_ap7k.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef AVR32_AP7K
-#define AVR32_AP7K
+#ifndef OPENOCD_TARGET_AVR32_AP7K_H
+#define OPENOCD_TARGET_AVR32_AP7K_H
 
 struct target;
 
@@ -42,4 +40,4 @@ struct avr32_core_reg {
 	struct avr32_ap7k_common *avr32_common;
 };
 
-#endif	/*AVR32_AP7K*/
+#endif /* OPENOCD_TARGET_AVR32_AP7K_H */
diff --git a/src/target/avr32_jtag.c b/src/target/avr32_jtag.c
index 647afd5e..6526810e 100644
--- a/src/target/avr32_jtag.c
+++ b/src/target/avr32_jtag.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/avr32_jtag.h b/src/target/avr32_jtag.h
index b5fdeafa..b431ef4c 100644
--- a/src/target/avr32_jtag.h
+++ b/src/target/avr32_jtag.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef AVR32_JTAG
-#define AVR32_JTAG
+#ifndef OPENOCD_TARGET_AVR32_JTAG_H
+#define OPENOCD_TARGET_AVR32_JTAG_H
 
 #define	AVR32NUMCOREREGS	17
 
@@ -102,4 +100,4 @@ int avr32_ocd_clearbits(struct avr32_jtag *jtag, int reg, uint32_t bits);
 
 int avr32_jtag_exec(struct avr32_jtag *jtag_info, uint32_t inst);
 
-#endif /* AVR32_JTAG */
+#endif /* OPENOCD_TARGET_AVR32_JTAG_H */
diff --git a/src/target/avr32_mem.c b/src/target/avr32_mem.c
index a7797a29..71ec0b43 100644
--- a/src/target/avr32_mem.c
+++ b/src/target/avr32_mem.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/avr32_mem.h b/src/target/avr32_mem.h
index 4c36bdb3..f60a1217 100644
--- a/src/target/avr32_mem.h
+++ b/src/target/avr32_mem.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef AVR32_MEM
-#define AVR32_MEM
+#ifndef OPENOCD_TARGET_AVR32_MEM_H
+#define OPENOCD_TARGET_AVR32_MEM_H
 
 int avr32_jtag_read_memory32(struct avr32_jtag *jtag_info,
 		uint32_t addr, int count, uint32_t *buffer);
@@ -34,4 +32,4 @@ int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info,
 int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info,
 		uint32_t addr, int count, const uint8_t *buffer);
 
-#endif /* AVR32_MEM */
+#endif /* OPENOCD_TARGET_AVR32_MEM_H */
diff --git a/src/target/avr32_regs.c b/src/target/avr32_regs.c
index 901f4fed..7273822c 100644
--- a/src/target/avr32_regs.c
+++ b/src/target/avr32_regs.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/avr32_regs.h b/src/target/avr32_regs.h
index 6590dec9..cb492a9f 100644
--- a/src/target/avr32_regs.h
+++ b/src/target/avr32_regs.h
@@ -12,13 +12,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef AVR32_REGS
-#define AVR32_REGS
+#ifndef OPENOCD_TARGET_AVR32_REGS_H
+#define OPENOCD_TARGET_AVR32_REGS_H
 
 enum avr32_reg_nums {
 	AVR32_REG_R0 = 0,
@@ -43,4 +41,4 @@ enum avr32_reg_nums {
 int avr32_jtag_read_regs(struct avr32_jtag *jtag_info, uint32_t *regs);
 int avr32_jtag_write_regs(struct avr32_jtag *jtag_info, uint32_t *regs);
 
-#endif /* AVR32_REGS */
+#endif /* OPENOCD_TARGET_AVR32_REGS_H */
diff --git a/src/target/avrt.c b/src/target/avrt.c
index a4ce46b7..1e1898c7 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -35,9 +33,9 @@ static int avr_init_target(struct command_context *cmd_ctx, struct target *targe
 static int avr_arch_state(struct target *target);
 static int avr_poll(struct target *target);
 static int avr_halt(struct target *target);
-static int avr_resume(struct target *target, int current, uint32_t address,
+static int avr_resume(struct target *target, int current, target_addr_t address,
 		int handle_breakpoints, int debug_execution);
-static int avr_step(struct target *target, int current, uint32_t address,
+static int avr_step(struct target *target, int current, target_addr_t address,
 		int handle_breakpoints);
 
 static int avr_assert_reset(struct target *target);
@@ -118,14 +116,14 @@ static int avr_halt(struct target *target)
 	return ERROR_OK;
 }
 
-static int avr_resume(struct target *target, int current, uint32_t address,
+static int avr_resume(struct target *target, int current, target_addr_t address,
 		int handle_breakpoints, int debug_execution)
 {
 	LOG_DEBUG("%s", __func__);
 	return ERROR_OK;
 }
 
-static int avr_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
+static int avr_step(struct target *target, int current, target_addr_t address, int handle_breakpoints)
 {
 	LOG_DEBUG("%s", __func__);
 	return ERROR_OK;
diff --git a/src/target/avrt.h b/src/target/avrt.h
index 707b4816..3610eb5e 100644
--- a/src/target/avrt.h
+++ b/src/target/avrt.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef AVRT_H
-#define AVRT_H
+#ifndef OPENOCD_TARGET_AVRT_H
+#define OPENOCD_TARGET_AVRT_H
 
 #include <jtag/jtag.h>
 
@@ -36,4 +34,4 @@ int avr_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out);
 int avr_jtag_senddat(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out,
 		int len);
 
-#endif /* AVRT_H */
+#endif /* OPENOCD_TARGET_AVRT_H */
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index b854f1f0..7cf4a695 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -44,7 +42,7 @@ static const char * const watchpoint_rw_strings[] = {
 static int bpwp_unique_id;
 
 int breakpoint_add_internal(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t length,
 	enum breakpoint_type type)
 {
@@ -62,7 +60,7 @@ int breakpoint_add_internal(struct target *target,
 			 * breakpoint" ... check all the parameters before
 			 * succeeding.
 			 */
-			LOG_DEBUG("Duplicate Breakpoint address: 0x%08" PRIx32 " (BP %" PRIu32 ")",
+			LOG_DEBUG("Duplicate Breakpoint address: " TARGET_ADDR_FMT " (BP %" PRIu32 ")",
 				address, breakpoint->unique_id);
 			return ERROR_OK;
 		}
@@ -100,7 +98,7 @@ fail:
 			return retval;
 	}
 
-	LOG_DEBUG("added %s breakpoint at 0x%8.8" PRIx32 " of length 0x%8.8x, (BPID: %" PRIu32 ")",
+	LOG_DEBUG("added %s breakpoint at " TARGET_ADDR_FMT " of length 0x%8.8x, (BPID: %" PRIu32 ")",
 		breakpoint_type_strings[(*breakpoint_p)->type],
 		(*breakpoint_p)->address, (*breakpoint_p)->length,
 		(*breakpoint_p)->unique_id);
@@ -161,7 +159,7 @@ int context_breakpoint_add_internal(struct target *target,
 }
 
 int hybrid_breakpoint_add_internal(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t asid,
 	uint32_t length,
 	enum breakpoint_type type)
@@ -182,7 +180,7 @@ int hybrid_breakpoint_add_internal(struct target *target,
 				asid, breakpoint->unique_id);
 			return -1;
 		} else if ((breakpoint->address == address) && (breakpoint->asid == 0)) {
-			LOG_DEBUG("Duplicate Breakpoint IVA: 0x%08" PRIx32 " (BP %" PRIu32 ")",
+			LOG_DEBUG("Duplicate Breakpoint IVA: " TARGET_ADDR_FMT " (BP %" PRIu32 ")",
 				address, breakpoint->unique_id);
 			return -1;
 
@@ -210,7 +208,7 @@ int hybrid_breakpoint_add_internal(struct target *target,
 		return retval;
 	}
 	LOG_DEBUG(
-		"added %s Hybrid breakpoint at address 0x%8.8" PRIx32 " of length 0x%8.8x, (BPID: %" PRIu32 ")",
+		"added %s Hybrid breakpoint at address " TARGET_ADDR_FMT " of length 0x%8.8x, (BPID: %" PRIu32 ")",
 		breakpoint_type_strings[(*breakpoint_p)->type],
 		(*breakpoint_p)->address,
 		(*breakpoint_p)->length,
@@ -220,7 +218,7 @@ int hybrid_breakpoint_add_internal(struct target *target,
 }
 
 int breakpoint_add(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t length,
 	enum breakpoint_type type)
 {
@@ -265,7 +263,7 @@ int context_breakpoint_add(struct target *target,
 		return context_breakpoint_add_internal(target, asid, length, type);
 }
 int hybrid_breakpoint_add(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t asid,
 	uint32_t length,
 	enum breakpoint_type type)
@@ -312,7 +310,7 @@ static void breakpoint_free(struct target *target, struct breakpoint *breakpoint
 	free(breakpoint);
 }
 
-int breakpoint_remove_internal(struct target *target, uint32_t address)
+int breakpoint_remove_internal(struct target *target, target_addr_t address)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 
@@ -331,11 +329,11 @@ int breakpoint_remove_internal(struct target *target, uint32_t address)
 		return 1;
 	} else {
 		if (!target->smp)
-			LOG_ERROR("no breakpoint at address 0x%8.8" PRIx32 " found", address);
+			LOG_ERROR("no breakpoint at address " TARGET_ADDR_FMT " found", address);
 		return 0;
 	}
 }
-void breakpoint_remove(struct target *target, uint32_t address)
+void breakpoint_remove(struct target *target, target_addr_t address)
 {
 	int found = 0;
 	if (target->smp) {
@@ -348,7 +346,7 @@ void breakpoint_remove(struct target *target, uint32_t address)
 			head = head->next;
 		}
 		if (found == 0)
-			LOG_ERROR("no breakpoint at address 0x%8.8" PRIx32 " found", address);
+			LOG_ERROR("no breakpoint at address " TARGET_ADDR_FMT " found", address);
 	} else
 		breakpoint_remove_internal(target, address);
 }
@@ -377,7 +375,7 @@ void breakpoint_clear_target(struct target *target)
 
 }
 
-struct breakpoint *breakpoint_find(struct target *target, uint32_t address)
+struct breakpoint *breakpoint_find(struct target *target, target_addr_t address)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 
@@ -390,7 +388,7 @@ struct breakpoint *breakpoint_find(struct target *target, uint32_t address)
 	return NULL;
 }
 
-int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
+int watchpoint_add(struct target *target, target_addr_t address, uint32_t length,
 	enum watchpoint_rw rw, uint32_t value, uint32_t mask)
 {
 	struct watchpoint *watchpoint = target->watchpoints;
@@ -404,8 +402,8 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 				|| watchpoint->value != value
 				|| watchpoint->mask != mask
 				|| watchpoint->rw != rw) {
-				LOG_ERROR("address 0x%8.8" PRIx32
-					"already has watchpoint %d",
+				LOG_ERROR("address " TARGET_ADDR_FMT
+					" already has watchpoint %d",
 					address, watchpoint->unique_id);
 				return ERROR_FAIL;
 			}
@@ -438,7 +436,7 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 		default:
 			reason = "unrecognized error";
 bye:
-			LOG_ERROR("can't add %s watchpoint at 0x%8.8" PRIx32 ", %s",
+			LOG_ERROR("can't add %s watchpoint at " TARGET_ADDR_FMT ", %s",
 				watchpoint_rw_strings[(*watchpoint_p)->rw],
 				address, reason);
 			free(*watchpoint_p);
@@ -446,7 +444,7 @@ bye:
 			return retval;
 	}
 
-	LOG_DEBUG("added %s watchpoint at 0x%8.8" PRIx32
+	LOG_DEBUG("added %s watchpoint at " TARGET_ADDR_FMT
 		" of length 0x%8.8" PRIx32 " (WPID: %d)",
 		watchpoint_rw_strings[(*watchpoint_p)->rw],
 		(*watchpoint_p)->address,
@@ -477,7 +475,7 @@ static void watchpoint_free(struct target *target, struct watchpoint *watchpoint
 	free(watchpoint);
 }
 
-void watchpoint_remove(struct target *target, uint32_t address)
+void watchpoint_remove(struct target *target, target_addr_t address)
 {
 	struct watchpoint *watchpoint = target->watchpoints;
 
@@ -490,7 +488,7 @@ void watchpoint_remove(struct target *target, uint32_t address)
 	if (watchpoint)
 		watchpoint_free(target, watchpoint);
 	else
-		LOG_ERROR("no watchpoint at address 0x%8.8" PRIx32 " found", address);
+		LOG_ERROR("no watchpoint at address " TARGET_ADDR_FMT " found", address);
 }
 
 void watchpoint_clear_target(struct target *target)
@@ -501,7 +499,8 @@ void watchpoint_clear_target(struct target *target)
 		watchpoint_free(target, target->watchpoints);
 }
 
-int watchpoint_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *address)
+int watchpoint_hit(struct target *target, enum watchpoint_rw *rw,
+		   target_addr_t *address)
 {
 	int retval;
 	struct watchpoint *hit_watchpoint;
@@ -513,7 +512,7 @@ int watchpoint_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *addr
 	*rw = hit_watchpoint->rw;
 	*address = hit_watchpoint->address;
 
-	LOG_DEBUG("Found hit watchpoint at 0x%8.8" PRIx32 " (WPID: %d)",
+	LOG_DEBUG("Found hit watchpoint at " TARGET_ADDR_FMT " (WPID: %d)",
 		hit_watchpoint->address,
 		hit_watchpoint->unique_id);
 
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index 0246acd3..51bd05ab 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -13,13 +13,13 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef BREAKPOINTS_H
-#define BREAKPOINTS_H
+#ifndef OPENOCD_TARGET_BREAKPOINTS_H
+#define OPENOCD_TARGET_BREAKPOINTS_H
+
+#include <stdint.h>
 
 struct target;
 
@@ -33,7 +33,7 @@ enum watchpoint_rw {
 };
 
 struct breakpoint {
-	uint32_t address;
+	target_addr_t address;
 	uint32_t asid;
 	int length;
 	enum breakpoint_type type;
@@ -45,7 +45,7 @@ struct breakpoint {
 };
 
 struct watchpoint {
-	uint32_t address;
+	target_addr_t address;
 	uint32_t length;
 	uint32_t mask;
 	uint32_t value;
@@ -57,22 +57,23 @@ struct watchpoint {
 
 void breakpoint_clear_target(struct target *target);
 int breakpoint_add(struct target *target,
-		uint32_t address, uint32_t length, enum breakpoint_type type);
+		target_addr_t address, uint32_t length, enum breakpoint_type type);
 int context_breakpoint_add(struct target *target,
 		uint32_t asid, uint32_t length, enum breakpoint_type type);
 int hybrid_breakpoint_add(struct target *target,
-		uint32_t address, uint32_t asid, uint32_t length, enum breakpoint_type type);
-void breakpoint_remove(struct target *target, uint32_t address);
+		target_addr_t address, uint32_t asid, uint32_t length, enum breakpoint_type type);
+void breakpoint_remove(struct target *target, target_addr_t address);
 
-struct breakpoint *breakpoint_find(struct target *target, uint32_t address);
+struct breakpoint *breakpoint_find(struct target *target, target_addr_t address);
 
 void watchpoint_clear_target(struct target *target);
 int watchpoint_add(struct target *target,
-		uint32_t address, uint32_t length,
+		target_addr_t address, uint32_t length,
 		enum watchpoint_rw rw, uint32_t value, uint32_t mask);
-void watchpoint_remove(struct target *target, uint32_t address);
+void watchpoint_remove(struct target *target, target_addr_t address);
 
 /* report type and address of just hit watchpoint */
-int watchpoint_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *address);
+int watchpoint_hit(struct target *target, enum watchpoint_rw *rw,
+		target_addr_t *address);
 
-#endif /* BREAKPOINTS_H */
+#endif /* OPENOCD_TARGET_BREAKPOINTS_H */
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index c8d30361..31ec64e1 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -18,7 +18,7 @@
  *   michel.jaouen@stericsson.com : smp minimum support                    *
  *                                                                         *
  *   Copyright (C) Broadcom 2012                                           *
- *   ehunter@broadcom.com : Cortex R4 support                              *
+ *   ehunter@broadcom.com : Cortex-R4 support                              *
  *                                                                         *
  *   Copyright (C) 2013 Kamal Dasu                                         *
  *   kdasu.kdev@gmail.com                                                  *
@@ -34,9 +34,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  *                                                                         *
  *   Cortex-A8(tm) TRM, ARM DDI 0344H                                      *
  *   Cortex-A9(tm) TRM, ARM DDI 0407F                                      *
@@ -56,6 +54,8 @@
 #include "target_type.h"
 #include "arm_opcodes.h"
 #include "jtag/interface.h"
+#include "arm_semihosting.h"
+#include "jtag/swd.h"
 #include <helper/time_support.h>
 
 static int cortex_a_poll(struct target *target);
@@ -76,8 +76,8 @@ static int cortex_a_dap_write_coreregister_u32(struct target *target,
 static int cortex_a_mmu(struct target *target, int *enabled);
 static int cortex_a_mmu_modify(struct target *target, int enable);
 static int cortex_a_virt2phys(struct target *target,
-	uint32_t virt, uint32_t *phys);
-static int cortex_a_read_apb_ab_memory(struct target *target,
+	target_addr_t virt, target_addr_t *phys);
+static int cortex_a_read_cpu_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 
@@ -197,32 +197,6 @@ static int cortex_a_mmu_modify(struct target *target, int enable)
 	return retval;
 }
 
-/*
- * Cortex-A Basic debug access, very low level assumes state is saved
- */
-static int cortex_a8_init_debug_access(struct target *target)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	int retval;
-
-	LOG_DEBUG(" ");
-
-	/* Unlocking the debug registers for modification
-	 * The debugport might be uninitialised so try twice */
-	retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
-	if (retval != ERROR_OK) {
-		/* try again */
-		retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
-		if (retval == ERROR_OK)
-			LOG_USER(
-				"Locking debug access failed on first, but succeeded on second try.");
-	}
-
-	return retval;
-}
-
 /*
  * Cortex-A Basic debug access, very low level assumes state is saved
  */
@@ -230,47 +204,11 @@ static int cortex_a_init_debug_access(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	int retval;
-	uint32_t dbg_osreg;
-	uint32_t cortex_part_num;
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-
-	LOG_DEBUG(" ");
-	cortex_part_num = (cortex_a->cpuid & CORTEX_A_MIDR_PARTNUM_MASK) >>
-		CORTEX_A_MIDR_PARTNUM_SHIFT;
-
-	switch (cortex_part_num) {
-	case CORTEX_A7_PARTNUM:
-	case CORTEX_A15_PARTNUM:
-		retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-						    armv7a->debug_base + CPUDBG_OSLSR,
-						    &dbg_osreg);
-		if (retval != ERROR_OK)
-			return retval;
-
-		LOG_DEBUG("DBGOSLSR  0x%" PRIx32, dbg_osreg);
-
-		if (dbg_osreg & CPUDBG_OSLAR_LK_MASK)
-			/* Unlocking the DEBUG OS registers for modification */
-			retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
-							     armv7a->debug_base + CPUDBG_OSLAR,
-							     0);
-		break;
-
-	case CORTEX_A5_PARTNUM:
-	case CORTEX_A8_PARTNUM:
-	case CORTEX_A9_PARTNUM:
-	default:
-		retval = cortex_a8_init_debug_access(target);
-	}
-
-	if (retval != ERROR_OK)
-		return retval;
-	/* Clear Sticky Power Down status Bit in PRSR to enable access to
-	   the registers in the Core Power Domain */
-	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_PRSR, &dbg_osreg);
-	LOG_DEBUG("target->coreid %" PRId32 " DBGPRSR  0x%" PRIx32, target->coreid, dbg_osreg);
 
+	/* lock memory-mapped access to debug registers to prevent
+	 * software interference */
+	retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_LOCKACCESS, 0);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -300,7 +238,7 @@ static int cortex_a_wait_instrcmpl(struct target *target, uint32_t *dscr, bool f
 	 * Writes final value of DSCR into *dscr. Pass force to force always
 	 * reading DSCR at least once. */
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	while ((*dscr & DSCR_INSTR_COMP) == 0 || force) {
 		force = false;
 		int retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
@@ -343,7 +281,7 @@ static int cortex_a_exec_opcode(struct target *target,
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	do {
 		retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
@@ -432,7 +370,7 @@ static int cortex_a_dap_read_coreregister_u32(struct target *target,
 	}
 
 	/* Wait for DTRRXfull then read DTRRTX */
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
 		retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
@@ -575,7 +513,7 @@ static int cortex_a_read_dcc(struct cortex_a_common *a, uint32_t *data,
 		dscr = *dscr_p;
 
 	/* Wait for DTRRXfull */
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
 		retval = mem_ap_read_atomic_u32(a->armv7a_common.debug_ap,
 				a->armv7a_common.debug_base + CPUDBG_DSCR,
@@ -607,7 +545,7 @@ static int cortex_a_dpm_prepare(struct arm_dpm *dpm)
 	int retval;
 
 	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	for (;; ) {
 		retval = mem_ap_read_atomic_u32(a->armv7a_common.debug_ap,
 				a->armv7a_common.debug_base + CPUDBG_DSCR,
@@ -855,7 +793,8 @@ static int cortex_a_halt_smp(struct target *target)
 	head = target->head;
 	while (head != (struct target_list *)NULL) {
 		curr = head->target;
-		if ((curr != target) && (curr->state != TARGET_HALTED))
+		if ((curr != target) && (curr->state != TARGET_HALTED)
+			&& target_was_examined(curr))
 			retval += cortex_a_halt(curr);
 		head = head->next;
 	}
@@ -928,6 +867,10 @@ static int cortex_a_poll(struct target *target)
 					if (retval != ERROR_OK)
 						return retval;
 				}
+
+				if (arm_semihosting(target, &retval) != 0)
+					return retval;
+
 				target_call_event_callbacks(target,
 					TARGET_EVENT_HALTED);
 			}
@@ -947,12 +890,8 @@ static int cortex_a_poll(struct target *target)
 					TARGET_EVENT_DEBUG_HALTED);
 			}
 		}
-	} else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
+	} else
 		target->state = TARGET_RUNNING;
-	else {
-		LOG_DEBUG("Unknown target state dscr = 0x%08" PRIx32, dscr);
-		target->state = TARGET_UNKNOWN;
-	}
 
 	return retval;
 }
@@ -999,7 +938,7 @@ static int cortex_a_halt(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	for (;; ) {
 		retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
@@ -1019,7 +958,7 @@ static int cortex_a_halt(struct target *target)
 }
 
 static int cortex_a_internal_restore(struct target *target, int current,
-	uint32_t *address, int handle_breakpoints, int debug_execution)
+	target_addr_t *address, int handle_breakpoints, int debug_execution)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *arm = &armv7a->arm;
@@ -1074,6 +1013,9 @@ static int cortex_a_internal_restore(struct target *target, int current,
 		case ARM_STATE_JAZELLE:
 			LOG_ERROR("How do I resume into Jazelle state??");
 			return ERROR_FAIL;
+		case ARM_STATE_AARCH64:
+			LOG_ERROR("Shoudn't be in AARCH64 state");
+			return ERROR_FAIL;
 	}
 	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
 	buf_set_u32(arm->pc->value, 0, 32, resume_pc);
@@ -1146,7 +1088,7 @@ static int cortex_a_internal_restart(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	for (;; ) {
 		retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
@@ -1174,11 +1116,12 @@ static int cortex_a_restore_smp(struct target *target, int handle_breakpoints)
 	int retval = 0;
 	struct target_list *head;
 	struct target *curr;
-	uint32_t address;
+	target_addr_t address;
 	head = target->head;
 	while (head != (struct target_list *)NULL) {
 		curr = head->target;
-		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
+		if ((curr != target) && (curr->state != TARGET_RUNNING)
+			&& target_was_examined(curr)) {
 			/*  resume current address , not in step mode */
 			retval += cortex_a_internal_restore(curr, 1, &address,
 					handle_breakpoints, 0);
@@ -1191,7 +1134,7 @@ static int cortex_a_restore_smp(struct target *target, int handle_breakpoints)
 }
 
 static int cortex_a_resume(struct target *target, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution)
+	target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	int retval = 0;
 	/* dummy resume for smp toggle in order to reduce gdb impact  */
@@ -1215,11 +1158,11 @@ static int cortex_a_resume(struct target *target, int current,
 	if (!debug_execution) {
 		target->state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx32, address);
+		LOG_DEBUG("target resumed at " TARGET_ADDR_FMT, address);
 	} else {
 		target->state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx32, address);
+		LOG_DEBUG("target debug resumed at " TARGET_ADDR_FMT, address);
 	}
 
 	return ERROR_OK;
@@ -1228,7 +1171,7 @@ static int cortex_a_resume(struct target *target, int current,
 static int cortex_a_debug_entry(struct target *target)
 {
 	int i;
-	uint32_t regfile[16], cpsr, dscr;
+	uint32_t regfile[16], cpsr, spsr, dscr;
 	int retval = ERROR_OK;
 	struct working_area *regfile_working_area = NULL;
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
@@ -1277,6 +1220,7 @@ static int cortex_a_debug_entry(struct target *target)
 	if (cortex_a->fast_reg_read)
 		target_alloc_working_area(target, 64, &regfile_working_area);
 
+
 	/* First load register acessible through core debug port*/
 	if (!regfile_working_area)
 		retval = arm_dpm_read_current_registers(&armv7a->dpm);
@@ -1321,6 +1265,19 @@ static int cortex_a_debug_entry(struct target *target)
 		reg->dirty = reg->valid;
 	}
 
+	if (arm->spsr) {
+		/* read Saved PSR */
+		retval = cortex_a_dap_read_coreregister_u32(target, &spsr, 17);
+		/*  store current spsr */
+		if (retval != ERROR_OK)
+			return retval;
+
+		reg = arm->spsr;
+		buf_set_u32(reg->value, 0, 32, spsr);
+		reg->valid = 1;
+		reg->dirty = 0;
+	}
+
 #if 0
 /* TODO, Move this */
 	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
@@ -1411,7 +1368,7 @@ int cortex_a_set_dscr_bits(struct target *target, unsigned long bit_mask, unsign
 	return retval;
 }
 
-static int cortex_a_step(struct target *target, int current, uint32_t address,
+static int cortex_a_step(struct target *target, int current, target_addr_t address,
 	int handle_breakpoints)
 {
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
@@ -1468,7 +1425,7 @@ static int cortex_a_step(struct target *target, int current, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	while (target->state != TARGET_HALTED) {
 		retval = cortex_a_poll(target);
 		if (retval != ERROR_OK)
@@ -1927,6 +1884,10 @@ static int cortex_a_assert_reset(struct target *target)
 
 	LOG_DEBUG(" ");
 
+	/* This function can be called in "target not examined" state */
+
+	/* This function can be called in "target not examined" state */
+
 	/* Issue some kind of warm reset. */
 	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
 		/* allow scripts to override the reset event */
@@ -2038,7 +1999,8 @@ static int cortex_a_assert_reset(struct target *target)
 	}
 
 	/* registers are now invalid */
-	register_cache_invalidate(armv7a->arm.core_cache);
+	if (target_was_examined(target))
+		register_cache_invalidate(armv7a->arm.core_cache);
 
 	target->state = TARGET_RESET;
 
@@ -2089,21 +2051,26 @@ static int cortex_a_deassert_reset(struct target *target)
 		}
 	}
 
-	retval = cortex_a_poll(target);
-	if (retval != ERROR_OK)
-		return retval;
+	if (target_was_examined(target)) {
+		retval = cortex_a_poll(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	/* Check the requested state was achieved */
 	if (target->reset_halt) {
 		if (target->state != TARGET_HALTED) {
 				LOG_WARNING("%s: ran after reset and before halt ...",
 				target_name(target));
-			if (!(jtag_reset_config & RESET_HAS_SRST))
-				LOG_WARNING("SRST probably cause powerdown of debug domain - Try "
-								"using \'reset_config none\' to request a soft warm reset");
-			retval = target_halt(target);
-			if (retval != ERROR_OK)
-				return retval;
+				if (target_was_examined(target)) {
+					if (!(jtag_reset_config & RESET_HAS_SRST))
+						LOG_WARNING("SRST probably cause powerdown of debug domain - Try "
+									"using \'reset_config none\' to request a soft warm reset");
+					retval = target_halt(target);
+					if (retval != ERROR_OK)
+						return retval;
+				} else
+					target->state = TARGET_UNKNOWN;
 		}
 	}
 
@@ -2137,7 +2104,7 @@ static int cortex_a_wait_dscr_bits(struct target *target, uint32_t mask,
 {
 	/* Waits until the specified bit(s) of DSCR take on a specified value. */
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 	int retval;
 
 	while ((*dscr & mask) != value) {
@@ -2283,13 +2250,13 @@ static int cortex_a_dfsr_to_error_code(uint32_t dfsr)
 	}
 }
 
-static int cortex_a_write_apb_ab_memory_slow(struct target *target,
+static int cortex_a_write_cpu_memory_slow(struct target *target,
 	uint32_t size, uint32_t count, const uint8_t *buffer, uint32_t *dscr)
 {
 	/* Writes count objects of size size from *buffer. Old value of DSCR must
 	 * be in *dscr; updated to new value. This is slow because it works for
 	 * non-word-sized objects and (maybe) unaligned accesses. If size == 4 and
-	 * the address is aligned, cortex_a_write_apb_ab_memory_fast should be
+	 * the address is aligned, cortex_a_write_cpu_memory_fast should be
 	 * preferred.
 	 * Preconditions:
 	 * - Address is in R0.
@@ -2358,7 +2325,7 @@ static int cortex_a_write_apb_ab_memory_slow(struct target *target,
 	return ERROR_OK;
 }
 
-static int cortex_a_write_apb_ab_memory_fast(struct target *target,
+static int cortex_a_write_cpu_memory_fast(struct target *target,
 	uint32_t count, const uint8_t *buffer, uint32_t *dscr)
 {
 	/* Writes count objects of size 4 from *buffer. Old value of DSCR must be
@@ -2387,18 +2354,18 @@ static int cortex_a_write_apb_ab_memory_fast(struct target *target,
 			4, count, armv7a->debug_base + CPUDBG_DTRRX);
 }
 
-static int cortex_a_write_apb_ab_memory(struct target *target,
+static int cortex_a_write_cpu_memory(struct target *target,
 	uint32_t address, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
-	/* Write memory through APB-AP. */
+	/* Write memory through the CPU. */
 	int retval, final_retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *arm = &armv7a->arm;
 	uint32_t dscr, orig_dfar, orig_dfsr, fault_dscr, fault_dfar, fault_dfsr;
 	uint32_t address_mod = address % 4;
 
-	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx32 " size %"  PRIu32 " count %"  PRIu32,
+	LOG_DEBUG("Writing CPU memory address 0x%" PRIx32 " size %"  PRIu32 " count %"  PRIu32,
 			  address, size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
@@ -2410,7 +2377,7 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 
 	if ((size == 4) && (address_mod)) {
 		/* Read unaligned bytes at start - recurse with size=1 */
-		retval = cortex_a_write_apb_ab_memory(target, address, 1, 4 - address_mod, buffer);
+		retval = cortex_a_write_cpu_memory(target, address, 1, 4 - address_mod, buffer);
 		if (retval != ERROR_OK)
 			return retval;
 		address += (4 - address_mod);
@@ -2454,13 +2421,13 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 
 	if (size == 4) {
 		/* We are doing a word-aligned transfer, so use fast mode. - unalignment has already been handled */
-		retval = cortex_a_write_apb_ab_memory_fast(target, count, buffer, &dscr);
+		retval = cortex_a_write_cpu_memory_fast(target, count, buffer, &dscr);
 
 		address += (count<<2);
 		buffer  += (count<<2);
 	} else {
 		/* Use slow path. */
-		retval = cortex_a_write_apb_ab_memory_slow(target, size, count, buffer, &dscr);
+		retval = cortex_a_write_cpu_memory_slow(target, size, count, buffer, &dscr);
 	}
 
 out:
@@ -2538,7 +2505,7 @@ out:
 
 	/* Read unaligned bytes at end - recurse with size=1 */
 	if ((size == 4) && (address_mod)) {
-		retval = cortex_a_write_apb_ab_memory(target, address, 1, address_mod, buffer);
+		retval = cortex_a_write_cpu_memory(target, address, 1, address_mod, buffer);
 		if (final_retval == ERROR_OK)
 			final_retval = retval;
 
@@ -2549,13 +2516,13 @@ out:
 	return final_retval;
 }
 
-static int cortex_a_read_apb_ab_memory_slow(struct target *target,
+static int cortex_a_read_cpu_memory_slow(struct target *target,
 	uint32_t size, uint32_t count, uint8_t *buffer, uint32_t *dscr)
 {
 	/* Reads count objects of size size into *buffer. Old value of DSCR must be
 	 * in *dscr; updated to new value. This is slow because it works for
 	 * non-word-sized objects and (maybe) unaligned accesses. If size == 4 and
-	 * the address is aligned, cortex_a_read_apb_ab_memory_fast should be
+	 * the address is aligned, cortex_a_read_cpu_memory_fast should be
 	 * preferred.
 	 * Preconditions:
 	 * - Address is in R0.
@@ -2625,7 +2592,7 @@ static int cortex_a_read_apb_ab_memory_slow(struct target *target,
 	return ERROR_OK;
 }
 
-static int cortex_a_read_apb_ab_memory_fast(struct target *target,
+static int cortex_a_read_cpu_memory_fast(struct target *target,
 	uint32_t count, uint8_t *buffer, uint32_t *dscr)
 {
 	/* Reads count objects of size 4 into *buffer. Old value of DSCR must be in
@@ -2712,18 +2679,18 @@ static int cortex_a_read_apb_ab_memory_fast(struct target *target,
 	return ERROR_OK;
 }
 
-static int cortex_a_read_apb_ab_memory(struct target *target,
+static int cortex_a_read_cpu_memory(struct target *target,
 	uint32_t address, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
-	/* Read memory through APB-AP. */
+	/* Read memory through the CPU. */
 	int retval, final_retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *arm = &armv7a->arm;
 	uint32_t dscr, orig_dfar, orig_dfsr, fault_dscr, fault_dfar, fault_dfsr;
 	uint32_t address_mod = address % 4;
 
-	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx32 " size %"  PRIu32 " count %"  PRIu32,
+	LOG_DEBUG("Reading CPU memory address 0x%" PRIx32 " size %"  PRIu32 " count %"  PRIu32,
 			  address, size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
@@ -2735,7 +2702,7 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	if ((size == 4) && (address_mod)) {
 		/* Read unaligned bytes at start - recurse with size=1 */
-			retval = cortex_a_read_apb_ab_memory(target, address, 1, 4 - address_mod, buffer);
+			retval = cortex_a_read_cpu_memory(target, address, 1, 4 - address_mod, buffer);
 			if (retval != ERROR_OK)
 				return retval;
 			address += (4 - address_mod);
@@ -2779,13 +2746,13 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	if (size == 4) {
 		/* We are doing a word-aligned transfer, so use fast mode. - unalignment has already been handled */
-		retval = cortex_a_read_apb_ab_memory_fast(target, count, buffer, &dscr);
+		retval = cortex_a_read_cpu_memory_fast(target, count, buffer, &dscr);
 
 		address += (count << 2);
 		buffer  += (count << 2);
 	} else {
 		/* Use slow path. */
-		retval = cortex_a_read_apb_ab_memory_slow(target, size, count, buffer, &dscr);
+		retval = cortex_a_read_cpu_memory_slow(target, size, count, buffer, &dscr);
 	}
 
 out:
@@ -2851,7 +2818,7 @@ out:
 
 	if ((size == 4) && (address_mod)) {
 		/* Read unaligned bytes at end - recurse with size=1 */
-		retval = cortex_a_read_apb_ab_memory(target, address, 1, address_mod, buffer);
+		retval = cortex_a_read_cpu_memory(target, address, 1, address_mod, buffer);
 		buffer  += address_mod;
 	}
 
@@ -2863,49 +2830,57 @@ out:
 /*
  * Cortex-A Memory access
  *
- * This is same Cortex M3 but we must also use the correct
+ * This is same Cortex-M3 but we must also use the correct
  * ap number for every access.
  */
 
 static int cortex_a_read_phys_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	target_addr_t address, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
-	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	uint8_t apsel = swjdp->apsel;
+	int retval;
 
-	LOG_DEBUG("Reading memory at real address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32,
+	if (!count || !buffer)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	LOG_DEBUG("Reading memory at real address " TARGET_ADDR_FMT "; size %" PRId32 "; count %" PRId32,
 		address, size, count);
 
-	if (count && buffer) {
-		/* read memory through APB-AP */
-		cortex_a_prep_memaccess(target, 1);
-		retval = cortex_a_read_apb_ab_memory(target, address, size, count, buffer);
-		cortex_a_post_memaccess(target, 1);
-	}
+	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap->ap_num))
+		return mem_ap_read_buf(armv7a->memory_ap, buffer, size, count, address);
+
+	/* read memory through the CPU */
+	cortex_a_prep_memaccess(target, 1);
+	retval = cortex_a_read_cpu_memory(target, address, size, count, buffer);
+	cortex_a_post_memaccess(target, 1);
+
 	return retval;
 }
 
-static int cortex_a_read_memory(struct target *target, uint32_t address,
+static int cortex_a_read_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 
 	/* cortex_a handles unaligned memory access */
-	LOG_DEBUG("Reading memory at address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
-		size, count);
+	LOG_DEBUG("Reading memory at address " TARGET_ADDR_FMT "; size %" PRId32 "; count %" PRId32,
+		address, size, count);
 
 	cortex_a_prep_memaccess(target, 0);
-	retval = cortex_a_read_apb_ab_memory(target, address, size, count, buffer);
+	retval = cortex_a_read_cpu_memory(target, address, size, count, buffer);
 	cortex_a_post_memaccess(target, 0);
 
 	return retval;
 }
 
-static int cortex_a_read_memory_ahb(struct target *target, uint32_t address,
+static int cortex_a_read_memory_ahb(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int mmu_enabled = 0;
-	uint32_t virt, phys;
+	target_addr_t virt, phys;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
@@ -2915,8 +2890,8 @@ static int cortex_a_read_memory_ahb(struct target *target, uint32_t address,
 		return target_read_memory(target, address, size, count, buffer);
 
 	/* cortex_a handles unaligned memory access */
-	LOG_DEBUG("Reading memory at address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
-		size, count);
+	LOG_DEBUG("Reading memory at address " TARGET_ADDR_FMT "; size %" PRId32 "; count %" PRId32,
+		address, size, count);
 
 	/* determine if MMU was enabled on target stop */
 	if (!armv7a->is_armv7r) {
@@ -2931,7 +2906,8 @@ static int cortex_a_read_memory_ahb(struct target *target, uint32_t address,
 		if (retval != ERROR_OK)
 			return retval;
 
-		LOG_DEBUG("Reading at virtual address. Translating v:0x%" PRIx32 " to r:0x%" PRIx32,
+		LOG_DEBUG("Reading at virtual address. "
+			  "Translating v:" TARGET_ADDR_FMT " to r:" TARGET_ADDR_FMT,
 			  virt, phys);
 		address = phys;
 	}
@@ -2945,47 +2921,54 @@ static int cortex_a_read_memory_ahb(struct target *target, uint32_t address,
 }
 
 static int cortex_a_write_phys_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	target_addr_t address, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
-	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	uint8_t apsel = swjdp->apsel;
+	int retval;
 
-	LOG_DEBUG("Writing memory to real address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
-		size, count);
+	if (!count || !buffer)
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	if (count && buffer) {
-		/* write memory through APB-AP */
-		cortex_a_prep_memaccess(target, 1);
-		retval = cortex_a_write_apb_ab_memory(target, address, size, count, buffer);
-		cortex_a_post_memaccess(target, 1);
-	}
+	LOG_DEBUG("Writing memory to real address " TARGET_ADDR_FMT "; size %" PRId32 "; count %" PRId32,
+		address, size, count);
+
+	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap->ap_num))
+		return mem_ap_write_buf(armv7a->memory_ap, buffer, size, count, address);
+
+	/* write memory through the CPU */
+	cortex_a_prep_memaccess(target, 1);
+	retval = cortex_a_write_cpu_memory(target, address, size, count, buffer);
+	cortex_a_post_memaccess(target, 1);
 
 	return retval;
 }
 
-static int cortex_a_write_memory(struct target *target, uint32_t address,
+static int cortex_a_write_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 
 	/* cortex_a handles unaligned memory access */
-	LOG_DEBUG("Writing memory at address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
-		size, count);
+	LOG_DEBUG("Writing memory at address " TARGET_ADDR_FMT "; size %" PRId32 "; count %" PRId32,
+		address, size, count);
 
 	/* memory writes bypass the caches, must flush before writing */
 	armv7a_cache_auto_flush_on_write(target, address, size * count);
 
 	cortex_a_prep_memaccess(target, 0);
-	retval = cortex_a_write_apb_ab_memory(target, address, size, count, buffer);
+	retval = cortex_a_write_cpu_memory(target, address, size, count, buffer);
 	cortex_a_post_memaccess(target, 0);
 	return retval;
 }
 
-static int cortex_a_write_memory_ahb(struct target *target, uint32_t address,
+static int cortex_a_write_memory_ahb(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	int mmu_enabled = 0;
-	uint32_t virt, phys;
+	target_addr_t virt, phys;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
@@ -2995,8 +2978,8 @@ static int cortex_a_write_memory_ahb(struct target *target, uint32_t address,
 		return target_write_memory(target, address, size, count, buffer);
 
 	/* cortex_a handles unaligned memory access */
-	LOG_DEBUG("Writing memory at address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
-		size, count);
+	LOG_DEBUG("Writing memory at address " TARGET_ADDR_FMT "; size %" PRId32 "; count %" PRId32,
+		address, size, count);
 
 	/* determine if MMU was enabled on target stop */
 	if (!armv7a->is_armv7r) {
@@ -3011,7 +2994,8 @@ static int cortex_a_write_memory_ahb(struct target *target, uint32_t address,
 		if (retval != ERROR_OK)
 			return retval;
 
-		LOG_DEBUG("Writing to virtual address. Translating v:0x%" PRIx32 " to r:0x%" PRIx32,
+		LOG_DEBUG("Writing to virtual address. "
+			  "Translating v:" TARGET_ADDR_FMT " to r:" TARGET_ADDR_FMT,
 			  virt,
 			  phys);
 		address = phys;
@@ -3025,7 +3009,7 @@ static int cortex_a_write_memory_ahb(struct target *target, uint32_t address,
 	return retval;
 }
 
-static int cortex_a_read_buffer(struct target *target, uint32_t address,
+static int cortex_a_read_buffer(struct target *target, target_addr_t address,
 				uint32_t count, uint8_t *buffer)
 {
 	uint32_t size;
@@ -3059,7 +3043,7 @@ static int cortex_a_read_buffer(struct target *target, uint32_t address,
 	return ERROR_OK;
 }
 
-static int cortex_a_write_buffer(struct target *target, uint32_t address,
+static int cortex_a_write_buffer(struct target *target, target_addr_t address,
 				 uint32_t count, const uint8_t *buffer)
 {
 	uint32_t size;
@@ -3111,7 +3095,7 @@ static int cortex_a_handle_target_request(void *priv)
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 
 		/* check if we have data */
-		long long then = timeval_ms();
+		int64_t then = timeval_ms();
 		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
 			retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
 					armv7a->debug_base + CPUDBG_DTRTX, &request);
@@ -3139,9 +3123,10 @@ static int cortex_a_examine_first(struct target *target)
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
+
 	int i;
 	int retval = ERROR_OK;
-	uint32_t didr, ctypr, ttypr, cpuid, dbg_osreg;
+	uint32_t didr, cpuid, dbg_osreg;
 
 	retval = dap_dp_init(swjdp);
 	if (retval != ERROR_OK) {
@@ -3149,7 +3134,7 @@ static int cortex_a_examine_first(struct target *target)
 		return retval;
 	}
 
-	/* Search for the APB-AB - it is needed for access to debug registers */
+	/* Search for the APB-AP - it is needed for access to debug registers */
 	retval = dap_find_ap(swjdp, AP_TYPE_APB_AP, &armv7a->debug_ap);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Could not find APB-AP for debug access");
@@ -3173,11 +3158,10 @@ static int cortex_a_examine_first(struct target *target)
 		retval = mem_ap_init(armv7a->memory_ap);
 		if (retval == ERROR_OK)
 			armv7a->memory_ap_available = true;
-		else
-			LOG_WARNING("Could not initialize AHB-AP for memory access - using APB-AP");
-	} else {
-		/* AHB-AP not found - use APB-AP */
-		LOG_DEBUG("Could not find AHB-AP - using APB-AP for memory access");
+	}
+	if (retval != ERROR_OK) {
+		/* AHB-AP not found or unavailable - use the CPU */
+		LOG_DEBUG("No AHB-AP available for memory access");
 	}
 
 	if (!target->dbgbase_set) {
@@ -3204,79 +3188,69 @@ static int cortex_a_examine_first(struct target *target)
 		armv7a->debug_base = target->dbgbase;
 
 	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
-	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "CPUID");
-		return retval;
-	}
-
-	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CTYPR, &ctypr);
-	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "CTYPR");
-		return retval;
-	}
-
-	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_TTYPR, &ttypr);
+			armv7a->debug_base + CPUDBG_DIDR, &didr);
 	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "TTYPR");
+		LOG_DEBUG("Examine %s failed", "DIDR");
 		return retval;
 	}
 
 	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DIDR, &didr);
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "DIDR");
+		LOG_DEBUG("Examine %s failed", "CPUID");
 		return retval;
 	}
 
-	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
-	LOG_DEBUG("ctypr = 0x%08" PRIx32, ctypr);
-	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);
 	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
+	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
 
-	cortex_a->cpuid = cpuid;
-	cortex_a->ctypr = ctypr;
-	cortex_a->ttypr = ttypr;
 	cortex_a->didr = didr;
+	cortex_a->cpuid = cpuid;
 
-	/* Unlocking the debug registers */
-	if ((cpuid & CORTEX_A_MIDR_PARTNUM_MASK) >> CORTEX_A_MIDR_PARTNUM_SHIFT ==
-		CORTEX_A15_PARTNUM) {
-
-		retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
-						     armv7a->debug_base + CPUDBG_OSLAR,
-						     0);
-
-		if (retval != ERROR_OK)
-			return retval;
+	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
+				    armv7a->debug_base + CPUDBG_PRSR, &dbg_osreg);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_DEBUG("target->coreid %" PRId32 " DBGPRSR  0x%" PRIx32, target->coreid, dbg_osreg);
 
+	if ((dbg_osreg & PRSR_POWERUP_STATUS) == 0) {
+		LOG_ERROR("target->coreid %" PRId32 " powered down!", target->coreid);
+		target->state = TARGET_UNKNOWN; /* TARGET_NO_POWER? */
+		return ERROR_TARGET_INIT_FAILED;
 	}
-	/* Unlocking the debug registers */
-	if ((cpuid & CORTEX_A_MIDR_PARTNUM_MASK) >> CORTEX_A_MIDR_PARTNUM_SHIFT ==
-		CORTEX_A7_PARTNUM) {
 
-		retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
-						     armv7a->debug_base + CPUDBG_OSLAR,
-						     0);
+	if (dbg_osreg & PRSR_STICKY_RESET_STATUS)
+		LOG_DEBUG("target->coreid %" PRId32 " was reset!", target->coreid);
 
-		if (retval != ERROR_OK)
-			return retval;
-
-	}
+	/* Read DBGOSLSR and check if OSLK is implemented */
 	retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
-					    armv7a->debug_base + CPUDBG_PRSR, &dbg_osreg);
-
+				armv7a->debug_base + CPUDBG_OSLSR, &dbg_osreg);
 	if (retval != ERROR_OK)
 		return retval;
+	LOG_DEBUG("target->coreid %" PRId32 " DBGOSLSR 0x%" PRIx32, target->coreid, dbg_osreg);
 
-	LOG_DEBUG("target->coreid %" PRId32 " DBGPRSR  0x%" PRIx32, target->coreid, dbg_osreg);
+	/* check if OS Lock is implemented */
+	if ((dbg_osreg & OSLSR_OSLM) == OSLSR_OSLM0 || (dbg_osreg & OSLSR_OSLM) == OSLSR_OSLM1) {
+		/* check if OS Lock is set */
+		if (dbg_osreg & OSLSR_OSLK) {
+			LOG_DEBUG("target->coreid %" PRId32 " OSLock set! Trying to unlock", target->coreid);
+
+			retval = mem_ap_write_atomic_u32(armv7a->debug_ap,
+							armv7a->debug_base + CPUDBG_OSLAR,
+							0);
+			if (retval == ERROR_OK)
+				retval = mem_ap_read_atomic_u32(armv7a->debug_ap,
+							armv7a->debug_base + CPUDBG_OSLSR, &dbg_osreg);
+
+			/* if we fail to access the register or cannot reset the OSLK bit, bail out */
+			if (retval != ERROR_OK || (dbg_osreg & OSLSR_OSLK) != 0) {
+				LOG_ERROR("target->coreid %" PRId32 " OSLock sticky, core not powered?",
+						target->coreid);
+				target->state = TARGET_UNKNOWN; /* TARGET_NO_POWER? */
+				return ERROR_TARGET_INIT_FAILED;
+			}
+		}
+	}
 
 	armv7a->arm.core_type = ARM_MODE_MON;
 
@@ -3336,6 +3310,7 @@ static int cortex_a_init_target(struct command_context *cmd_ctx,
 	struct target *target)
 {
 	/* examine_first() does a bunch of this */
+	arm_semihosting_init(target);
 	return ERROR_OK;
 }
 
@@ -3425,7 +3400,7 @@ static int cortex_a_mmu(struct target *target, int *enabled)
 }
 
 static int cortex_a_virt2phys(struct target *target,
-	uint32_t virt, uint32_t *phys)
+	target_addr_t virt, target_addr_t *phys)
 {
 	int retval = ERROR_FAIL;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -3443,7 +3418,8 @@ static int cortex_a_virt2phys(struct target *target,
 		retval = cortex_a_mmu_modify(target, 1);
 		if (retval != ERROR_OK)
 			goto done;
-		retval = armv7a_mmu_translate_va_pa(target, virt,  phys, 1);
+		retval = armv7a_mmu_translate_va_pa(target, (uint32_t)virt,
+						    (uint32_t *)phys, 1);
 	}
 done:
 	return retval;
diff --git a/src/target/cortex_a.h b/src/target/cortex_a.h
index 1c63588e..ff034320 100644
--- a/src/target/cortex_a.h
+++ b/src/target/cortex_a.h
@@ -22,13 +22,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef CORTEX_A_H
-#define CORTEX_A_H
+#ifndef OPENOCD_TARGET_CORTEX_A_H
+#define OPENOCD_TARGET_CORTEX_A_H
 
 #include "armv7a.h"
 
@@ -99,8 +97,6 @@ struct cortex_a_common {
 	int fast_reg_read;
 
 	uint32_t cpuid;
-	uint32_t ctypr;
-	uint32_t ttypr;
 	uint32_t didr;
 
 	enum cortex_a_isrmasking_mode isrmasking_mode;
@@ -116,4 +112,4 @@ target_to_cortex_a(struct target *target)
 	return container_of(target->arch_info, struct cortex_a_common, armv7a_common.arm);
 }
 
-#endif /* CORTEX_A_H */
+#endif /* OPENOCD_TARGET_CORTEX_A_H */
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index 21e5b590..1f3d9562 100644
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  *                                                                         *
  *                                                                         *
  *   Cortex-M3(tm) TRM, ARM DDI 0337E (r1p1) and 0337G (r2p0)              *
@@ -170,12 +168,8 @@ static int cortex_m_single_step_core(struct target *target)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
-	uint32_t dhcsr_save;
 	int retval;
 
-	/* backup dhcsr reg */
-	dhcsr_save = cortex_m->dcb_dhcsr;
-
 	/* Mask interrupts before clearing halt, if done already.  This avoids
 	 * Erratum 377497 (fixed in r1p0) where setting MASKINTS while clearing
 	 * HALT can put the core into an unknown state.
@@ -193,7 +187,6 @@ static int cortex_m_single_step_core(struct target *target)
 	LOG_DEBUG(" ");
 
 	/* restore dhcsr reg */
-	cortex_m->dcb_dhcsr = dhcsr_save;
 	cortex_m_clear_halt(target);
 
 	return ERROR_OK;
@@ -244,7 +237,7 @@ static int cortex_m_endreset_event(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m->dcb_dhcsr & C_DEBUGEN)) {
-		retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		retval = cortex_m_write_debug_halt_mask(target, 0, C_HALT | C_STEP | C_MASKINTS);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -684,7 +677,7 @@ void cortex_m_enable_breakpoints(struct target *target)
 }
 
 static int cortex_m_resume(struct target *target, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution)
+	target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct breakpoint *breakpoint = NULL;
@@ -752,7 +745,7 @@ static int cortex_m_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (ID: %" PRIu32 ")",
+			LOG_DEBUG("unset breakpoint at " TARGET_ADDR_FMT " (ID: %" PRIu32 ")",
 				breakpoint->address,
 				breakpoint->unique_id);
 			cortex_m_unset_breakpoint(target, breakpoint);
@@ -784,7 +777,7 @@ static int cortex_m_resume(struct target *target, int current,
 
 /* int irqstepcount = 0; */
 static int cortex_m_step(struct target *target, int current,
-	uint32_t address, int handle_breakpoints)
+	target_addr_t address, int handle_breakpoints)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
@@ -983,6 +976,18 @@ static int cortex_m_assert_reset(struct target *target)
 
 	bool srst_asserted = false;
 
+	if (!target_was_examined(target)) {
+		if (jtag_reset_config & RESET_HAS_SRST) {
+			adapter_assert_reset();
+			if (target->reset_halt)
+				LOG_ERROR("Target not examined, will not halt after reset!");
+			return ERROR_OK;
+		} else {
+			LOG_ERROR("Target not examined, reset NOT asserted!");
+			return ERROR_FAIL;
+		}
+	}
+
 	if ((jtag_reset_config & RESET_HAS_SRST) &&
 	    (jtag_reset_config & RESET_SRST_NO_GATING)) {
 		adapter_assert_reset();
@@ -992,34 +997,23 @@ static int cortex_m_assert_reset(struct target *target)
 	/* Enable debug requests */
 	int retval;
 	retval = mem_ap_read_atomic_u32(armv7m->debug_ap, DCB_DHCSR, &cortex_m->dcb_dhcsr);
-	if (retval != ERROR_OK)
-		return retval;
-	if (!(cortex_m->dcb_dhcsr & C_DEBUGEN)) {
-		retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DHCSR, DBGKEY | C_DEBUGEN);
-		if (retval != ERROR_OK)
-			return retval;
-	}
+	/* Store important errors instead of failing and proceed to reset assert */
+
+	if (retval != ERROR_OK || !(cortex_m->dcb_dhcsr & C_DEBUGEN))
+		retval = cortex_m_write_debug_halt_mask(target, 0, C_HALT | C_STEP | C_MASKINTS);
 
 	/* If the processor is sleeping in a WFI or WFE instruction, the
 	 * C_HALT bit must be asserted to regain control */
-	if (cortex_m->dcb_dhcsr & S_SLEEP) {
-		retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
-		if (retval != ERROR_OK)
-			return retval;
-	}
+	if (retval == ERROR_OK && (cortex_m->dcb_dhcsr & S_SLEEP))
+		retval = cortex_m_write_debug_halt_mask(target, C_HALT, 0);
 
-	retval = mem_ap_write_u32(armv7m->debug_ap, DCB_DCRDR, 0);
-	if (retval != ERROR_OK)
-		return retval;
+	mem_ap_write_u32(armv7m->debug_ap, DCB_DCRDR, 0);
+	/* Ignore less important errors */
 
 	if (!target->reset_halt) {
 		/* Set/Clear C_MASKINTS in a separate operation */
-		if (cortex_m->dcb_dhcsr & C_MASKINTS) {
-			retval = mem_ap_write_atomic_u32(armv7m->debug_ap, DCB_DHCSR,
-					DBGKEY | C_DEBUGEN | C_HALT);
-			if (retval != ERROR_OK)
-				return retval;
-		}
+		if (cortex_m->dcb_dhcsr & C_MASKINTS)
+			cortex_m_write_debug_halt_mask(target, 0, C_MASKINTS);
 
 		/* clear any debug flags before resuming */
 		cortex_m_clear_halt(target);
@@ -1033,16 +1027,20 @@ static int cortex_m_assert_reset(struct target *target)
 		 * bad vector table entries.  Should this include MMERR or
 		 * other flags too?
 		 */
-		retval = mem_ap_write_atomic_u32(armv7m->debug_ap, DCB_DEMCR,
+		int retval2;
+		retval2 = mem_ap_write_atomic_u32(armv7m->debug_ap, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
-		if (retval != ERROR_OK)
-			return retval;
+		if (retval != ERROR_OK || retval2 != ERROR_OK)
+			LOG_INFO("AP write error, reset will not halt");
 	}
 
 	if (jtag_reset_config & RESET_HAS_SRST) {
 		/* default to asserting srst */
 		if (!srst_asserted)
 			adapter_assert_reset();
+
+		/* srst is asserted, ignore AP access errors */
+		retval = ERROR_OK;
 	} else {
 		/* Use a standard Cortex-M3 software reset mechanism.
 		 * We default to using VECRESET as it is supported on all current cores.
@@ -1057,27 +1055,24 @@ static int cortex_m_assert_reset(struct target *target)
 				"handler to reset any peripherals or configure hardware srst support.");
 		}
 
-		retval = mem_ap_write_atomic_u32(armv7m->debug_ap, NVIC_AIRCR,
+		int retval3;
+		retval3 = mem_ap_write_atomic_u32(armv7m->debug_ap, NVIC_AIRCR,
 				AIRCR_VECTKEY | ((reset_config == CORTEX_M_RESET_SYSRESETREQ)
 				? AIRCR_SYSRESETREQ : AIRCR_VECTRESET));
-		if (retval != ERROR_OK)
+		if (retval3 != ERROR_OK)
 			LOG_DEBUG("Ignoring AP write error right after reset");
 
-		retval = dap_dp_init(armv7m->debug_ap->dap);
-		if (retval != ERROR_OK) {
+		retval3 = dap_dp_init(armv7m->debug_ap->dap);
+		if (retval3 != ERROR_OK)
 			LOG_ERROR("DP initialisation failed");
-			return retval;
-		}
 
-		{
+		else {
 			/* I do not know why this is necessary, but it
 			 * fixes strange effects (step/resume cause NMI
 			 * after reset) on LM3S6918 -- Michael Schwingen
 			 */
 			uint32_t tmp;
-			retval = mem_ap_read_atomic_u32(armv7m->debug_ap, NVIC_AIRCR, &tmp);
-			if (retval != ERROR_OK)
-				return retval;
+			mem_ap_read_atomic_u32(armv7m->debug_ap, NVIC_AIRCR, &tmp);
 		}
 	}
 
@@ -1086,6 +1081,10 @@ static int cortex_m_assert_reset(struct target *target)
 
 	register_cache_invalidate(cortex_m->armv7m.arm.core_cache);
 
+	/* now return stored error code if any */
+	if (retval != ERROR_OK)
+		return retval;
+
 	if (target->reset_halt) {
 		retval = target_halt(target);
 		if (retval != ERROR_OK)
@@ -1108,7 +1107,8 @@ static int cortex_m_deassert_reset(struct target *target)
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 
 	if ((jtag_reset_config & RESET_HAS_SRST) &&
-	    !(jtag_reset_config & RESET_SRST_NO_GATING)) {
+	    !(jtag_reset_config & RESET_SRST_NO_GATING) &&
+		target_was_examined(target)) {
 		int retval = dap_dp_init(armv7m->debug_ap->dap);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("DP initialisation failed");
@@ -1192,7 +1192,7 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		breakpoint->set = true;
 	}
 
-	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)",
+	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: " TARGET_ADDR_FMT " Length: %d (set=%d)",
 		breakpoint->unique_id,
 		(int)(breakpoint->type),
 		breakpoint->address,
@@ -1213,7 +1213,7 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)",
+	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: " TARGET_ADDR_FMT " Length: %d (set=%d)",
 		breakpoint->unique_id,
 		(int)(breakpoint->type),
 		breakpoint->address,
@@ -1658,7 +1658,7 @@ static int cortex_m_store_core_reg_u32(struct target *target,
 	return ERROR_OK;
 }
 
-static int cortex_m_read_memory(struct target *target, uint32_t address,
+static int cortex_m_read_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
@@ -1672,7 +1672,7 @@ static int cortex_m_read_memory(struct target *target, uint32_t address,
 	return mem_ap_read_buf(armv7m->debug_ap, buffer, size, count, address);
 }
 
-static int cortex_m_write_memory(struct target *target, uint32_t address,
+static int cortex_m_write_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
@@ -1690,6 +1690,7 @@ static int cortex_m_init_target(struct command_context *cmd_ctx,
 	struct target *target)
 {
 	armv7m_build_reg_cache(target);
+	arm_semihosting_init(target);
 	return ERROR_OK;
 }
 
@@ -1702,6 +1703,7 @@ void cortex_m_deinit_target(struct target *target)
 	cortex_m_dwt_free(target);
 	armv7m_free_reg_cache(target);
 
+	free(target->private_config);
 	free(cortex_m);
 }
 
@@ -1882,6 +1884,11 @@ static void cortex_m_dwt_free(struct target *target)
 #define MVFR0_DEFAULT_M4 0x10110021
 #define MVFR1_DEFAULT_M4 0x11000011
 
+#define MVFR0_DEFAULT_M7_SP 0x10110021
+#define MVFR0_DEFAULT_M7_DP 0x10110221
+#define MVFR1_DEFAULT_M7_SP 0x11000011
+#define MVFR1_DEFAULT_M7_DP 0x12000011
+
 int cortex_m_examine(struct target *target)
 {
 	int retval;
@@ -1900,11 +1907,15 @@ int cortex_m_examine(struct target *target)
 			return retval;
 		}
 
-		/* Search for the MEM-AP */
-		retval = dap_find_ap(swjdp, AP_TYPE_AHB_AP, &armv7m->debug_ap);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("Could not find MEM-AP to control the core");
-			return retval;
+		if (cortex_m->apsel < 0) {
+			/* Search for the MEM-AP */
+			retval = dap_find_ap(swjdp, AP_TYPE_AHB_AP, &armv7m->debug_ap);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Could not find MEM-AP to control the core");
+				return retval;
+			}
+		} else {
+			armv7m->debug_ap = dap_ap(swjdp, cortex_m->apsel);
 		}
 
 		/* Leave (only) generic DAP stuff for debugport_init(); */
@@ -1928,23 +1939,42 @@ int cortex_m_examine(struct target *target)
 
 		LOG_DEBUG("Cortex-M%d r%" PRId8 "p%" PRId8 " processor detected",
 				i, (uint8_t)((cpuid >> 20) & 0xf), (uint8_t)((cpuid >> 0) & 0xf));
+		if (i == 7) {
+			uint8_t rev, patch;
+			rev = (cpuid >> 20) & 0xf;
+			patch = (cpuid >> 0) & 0xf;
+			if ((rev == 0) && (patch < 2))
+				LOG_WARNING("Silicon bug: single stepping will enter pending exception handler!");
+		}
 		LOG_DEBUG("cpuid: 0x%8.8" PRIx32 "", cpuid);
 
-		/* test for floating point feature on cortex-m4 */
 		if (i == 4) {
 			target_read_u32(target, MVFR0, &mvfr0);
 			target_read_u32(target, MVFR1, &mvfr1);
 
+			/* test for floating point feature on Cortex-M4 */
 			if ((mvfr0 == MVFR0_DEFAULT_M4) && (mvfr1 == MVFR1_DEFAULT_M4)) {
 				LOG_DEBUG("Cortex-M%d floating point feature FPv4_SP found", i);
 				armv7m->fp_feature = FPv4_SP;
 			}
+		} else if (i == 7) {
+			target_read_u32(target, MVFR0, &mvfr0);
+			target_read_u32(target, MVFR1, &mvfr1);
+
+			/* test for floating point features on Cortex-M7 */
+			if ((mvfr0 == MVFR0_DEFAULT_M7_SP) && (mvfr1 == MVFR1_DEFAULT_M7_SP)) {
+				LOG_DEBUG("Cortex-M%d floating point feature FPv5_SP found", i);
+				armv7m->fp_feature = FPv5_SP;
+			} else if ((mvfr0 == MVFR0_DEFAULT_M7_DP) && (mvfr1 == MVFR1_DEFAULT_M7_DP)) {
+				LOG_DEBUG("Cortex-M%d floating point feature FPv5_DP found", i);
+				armv7m->fp_feature = FPv5_DP;
+			}
 		} else if (i == 0) {
 			/* Cortex-M0 does not support unaligned memory access */
 			armv7m->arm.is_armv6m = true;
 		}
 
-		if (armv7m->fp_feature != FPv4_SP &&
+		if (armv7m->fp_feature == FP_NONE &&
 		    armv7m->arm.core_cache->num_regs > ARMV7M_NUM_CORE_REGS_NOFP) {
 			/* free unavailable FPU registers */
 			size_t idx;
@@ -1959,9 +1989,14 @@ int cortex_m_examine(struct target *target)
 			armv7m->arm.core_cache->num_regs = ARMV7M_NUM_CORE_REGS_NOFP;
 		}
 
-		if ((i == 4 || i == 3) && !armv7m->stlink) {
-			/* Cortex-M3/M4 has 4096 bytes autoincrement range */
-			armv7m->debug_ap->tar_autoincr_block = (1 << 12);
+		if (!armv7m->stlink) {
+			if (i == 3 || i == 4)
+				/* Cortex-M3/M4 have 4096 bytes autoincrement range,
+				 * s. ARM IHI 0031C: MEM-AP 7.2.2 */
+				armv7m->debug_ap->tar_autoincr_block = (1 << 12);
+			else if (i == 7)
+				/* Cortex-M7 has only 1024 bytes autoincrement range */
+				armv7m->debug_ap->tar_autoincr_block = (1 << 10);
 		}
 
 		/* Configure trace modules */
@@ -2144,6 +2179,13 @@ static int cortex_m_target_create(struct target *target, Jim_Interp *interp)
 	cortex_m->common_magic = CORTEX_M_COMMON_MAGIC;
 	cortex_m_init_arch_info(target, cortex_m, target->tap);
 
+	if (target->private_config != NULL) {
+		struct adiv5_private_config *pc =
+				(struct adiv5_private_config *)target->private_config;
+		cortex_m->apsel = pc->ap_num;
+	} else
+		cortex_m->apsel = -1;
+
 	return ERROR_OK;
 }
 
@@ -2433,6 +2475,7 @@ struct target_type cortexm_target = {
 
 	.commands = cortex_m_command_handlers,
 	.target_create = cortex_m_target_create,
+	.target_jim_configure = adiv5_jim_configure,
 	.init_target = cortex_m_init_target,
 	.examine = cortex_m_examine,
 	.deinit_target = cortex_m_deinit_target,
diff --git a/src/target/cortex_m.h b/src/target/cortex_m.h
index 36414c72..165c9d9f 100644
--- a/src/target/cortex_m.h
+++ b/src/target/cortex_m.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef CORTEX_M_H
-#define CORTEX_M_H
+#ifndef OPENOCD_TARGET_CORTEX_M_H
+#define OPENOCD_TARGET_CORTEX_M_H
 
 #include "armv7m.h"
 
@@ -191,6 +189,8 @@ struct cortex_m_common {
 	enum cortex_m_isrmasking_mode isrmasking_mode;
 
 	struct armv7m_common armv7m;
+
+	int apsel;
 };
 
 static inline struct cortex_m_common *
@@ -214,4 +214,4 @@ void cortex_m_enable_watchpoints(struct target *target);
 void cortex_m_dwt_setup(struct cortex_m_common *cm, struct target *target);
 void cortex_m_deinit_target(struct target *target);
 
-#endif /* CORTEX_M_H */
+#endif /* OPENOCD_TARGET_CORTEX_M_H */
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 1cb18cf1..1d728dff 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -1119,7 +1117,7 @@ static int dsp563xx_halt(struct target *target)
 
 static int dsp563xx_resume(struct target *target,
 	int current,
-	uint32_t address,
+	target_addr_t address,
 	int handle_breakpoints,
 	int debug_execution)
 {
@@ -1292,7 +1290,7 @@ static int dsp563xx_step_ex(struct target *target,
 
 static int dsp563xx_step(struct target *target,
 	int current,
-	uint32_t address,
+	target_addr_t address,
 	int handle_breakpoints)
 {
 	int err;
@@ -1376,7 +1374,7 @@ static int dsp563xx_deassert_reset(struct target *target)
 static int dsp563xx_run_algorithm(struct target *target,
 	int num_mem_params, struct mem_param *mem_params,
 	int num_reg_params, struct reg_param *reg_params,
-	uint32_t entry_point, uint32_t exit_point,
+	target_addr_t entry_point, target_addr_t exit_point,
 	int timeout_ms, void *arch_info)
 {
 	int i;
@@ -1594,7 +1592,7 @@ static int dsp563xx_read_memory_core(struct target *target,
 
 static int dsp563xx_read_memory(struct target *target,
 	int mem_type,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	uint8_t *buffer)
@@ -1662,7 +1660,7 @@ static int dsp563xx_read_memory(struct target *target,
 }
 
 static int dsp563xx_read_memory_default(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	uint8_t *buffer)
@@ -1673,7 +1671,7 @@ static int dsp563xx_read_memory_default(struct target *target,
 }
 
 static int dsp563xx_read_buffer_default(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint8_t *buffer)
 {
@@ -1684,7 +1682,7 @@ static int dsp563xx_read_buffer_default(struct target *target,
 
 static int dsp563xx_write_memory_core(struct target *target,
 	int mem_type,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	const uint8_t *buffer)
@@ -1696,7 +1694,7 @@ static int dsp563xx_write_memory_core(struct target *target,
 	const uint8_t *b;
 
 	LOG_DEBUG(
-		"memtype: %d address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+		"memtype: %d address: 0x%8.8" TARGET_PRIxADDR ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
 		mem_type,
 		address,
 		size,
@@ -1768,7 +1766,7 @@ static int dsp563xx_write_memory_core(struct target *target,
 
 static int dsp563xx_write_memory(struct target *target,
 	int mem_type,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	const uint8_t *buffer)
@@ -1836,7 +1834,7 @@ static int dsp563xx_write_memory(struct target *target,
 }
 
 static int dsp563xx_write_memory_default(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	uint32_t count,
 	const uint8_t *buffer)
@@ -1846,7 +1844,7 @@ static int dsp563xx_write_memory_default(struct target *target,
 }
 
 static int dsp563xx_write_buffer_default(struct target *target,
-	uint32_t address,
+	target_addr_t address,
 	uint32_t size,
 	const uint8_t *buffer)
 {
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
index 446ad3f5..4bb5acea 100644
--- a/src/target/dsp563xx.h
+++ b/src/target/dsp563xx.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef DSP563XX_H
-#define DSP563XX_H
+#ifndef OPENOCD_TARGET_DSP563XX_H
+#define OPENOCD_TARGET_DSP563XX_H
 
 #include <jtag/jtag.h>
 #include <target/dsp563xx_once.h>
@@ -72,4 +70,4 @@ static inline struct dsp563xx_common *target_to_dsp563xx(struct target *target)
 	return target->arch_info;
 }
 
-#endif /* DSP563XX_H */
+#endif /* OPENOCD_TARGET_DSP563XX_H */
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index aa8c9691..fe4927ba 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/dsp563xx_once.h b/src/target/dsp563xx_once.h
index 8835d553..da7f5e9b 100644
--- a/src/target/dsp563xx_once.h
+++ b/src/target/dsp563xx_once.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef DSP563XX_ONCE_H
-#define DSP563XX_ONCE_H
+#ifndef OPENOCD_TARGET_DSP563XX_ONCE_H
+#define OPENOCD_TARGET_DSP563XX_ONCE_H
 
 #include <jtag/jtag.h>
 
@@ -88,4 +86,4 @@ int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, int flush, uint32_t opcode
 /** double word instruction */
 int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, int flush, uint32_t opcode, uint32_t operand);
 
-#endif /* DSP563XX_ONCE_H */
+#endif /* OPENOCD_TARGET_DSP563XX_ONCE_H */
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 8a58cab4..a50f2cd4 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -16,9 +16,7 @@
  *  GNU General Public License for more details.                          *
  *                                                                        *
  *  You should have received a copy of the GNU General Public License     *
- *  along with this program; if not, write to the                         *
- *  Free Software Foundation, Inc.,                                       *
- *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -1003,17 +1001,17 @@ static int dsp5680xx_poll(struct target *target)
 			 __func__);
 		target->state = TARGET_UNKNOWN;
 		return ERROR_TARGET_FAILURE;
-	};
+	}
 	if (target->state == TARGET_UNKNOWN) {
 		LOG_ERROR("%s: Target status invalid - communication failure",
 			  __func__);
 		return ERROR_TARGET_FAILURE;
-	};
+	}
 	return ERROR_OK;
 }
 
 static int dsp5680xx_resume(struct target *target, int current,
-			    uint32_t address, int hb, int d)
+			    target_addr_t address, int hb, int d)
 {
 	if (target->state == TARGET_RUNNING) {
 		LOG_USER("Target already running.");
@@ -1170,7 +1168,7 @@ static int dsp5680xx_read_32_single(struct target *t, uint32_t a,
 	return retval;
 }
 
-static int dsp5680xx_read(struct target *t, uint32_t a, uint32_t size,
+static int dsp5680xx_read(struct target *t, target_addr_t a, uint32_t size,
 			  uint32_t count, uint8_t *buf)
 {
 	struct target *target = t;
@@ -1425,7 +1423,7 @@ static int dsp5680xx_write_32(struct target *t, uint32_t a, uint32_t c,
  *
  * @return
  */
-static int dsp5680xx_write(struct target *t, uint32_t a, uint32_t s, uint32_t c,
+static int dsp5680xx_write(struct target *t, target_addr_t a, uint32_t s, uint32_t c,
 			   const uint8_t *b)
 {
 	/* TODO Cannot write 32bit to odd address, will write 0x12345678  as 0x5678 0x0012 */
@@ -1470,7 +1468,7 @@ static int dsp5680xx_write(struct target *t, uint32_t a, uint32_t s, uint32_t c,
 	return retval;
 }
 
-static int dsp5680xx_write_buffer(struct target *t, uint32_t a, uint32_t size,
+static int dsp5680xx_write_buffer(struct target *t, target_addr_t a, uint32_t size,
 				  const uint8_t *b)
 {
 	check_halt_and_debug(t);
@@ -1487,7 +1485,7 @@ static int dsp5680xx_write_buffer(struct target *t, uint32_t a, uint32_t size,
  *
  * @return
  */
-static int dsp5680xx_read_buffer(struct target *t, uint32_t a, uint32_t size,
+static int dsp5680xx_read_buffer(struct target *t, target_addr_t a, uint32_t size,
 				 uint8_t *buf)
 {
 	check_halt_and_debug(t);
@@ -1507,7 +1505,7 @@ static int dsp5680xx_read_buffer(struct target *t, uint32_t a, uint32_t size,
  *
  * @return
  */
-static int dsp5680xx_checksum_memory(struct target *t, uint32_t a, uint32_t s,
+static int dsp5680xx_checksum_memory(struct target *t, target_addr_t a, uint32_t s,
 				     uint32_t *checksum)
 {
 	return ERROR_FAIL;
@@ -2264,7 +2262,7 @@ int dsp5680xx_f_lock(struct target *target)
 	return retval;
 }
 
-static int dsp5680xx_step(struct target *target, int current, uint32_t address,
+static int dsp5680xx_step(struct target *target, int current, target_addr_t address,
 			  int handle_breakpoints)
 {
 	err_check(ERROR_FAIL, DSP5680XX_ERROR_NOT_IMPLEMENTED_STEP,
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index cb3bf2a4..842796bc 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef DSP5680XX_H
-#define DSP5680XX_H
+#ifndef OPENOCD_TARGET_DSP5680XX_H
+#define OPENOCD_TARGET_DSP5680XX_H
 
 #include <jtag/jtag.h>
 
@@ -381,4 +379,4 @@ int dsp5680xx_f_lock(struct target *target);
  */
 int dsp5680xx_f_unlock(struct target *target);
 
-#endif /* DSP5680XX_H */
+#endif /* OPENOCD_TARGET_DSP5680XX_H */
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 4b3a05a8..09d6fc8a 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index f110e82e..39902fb3 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef EMBEDDED_ICE_H
-#define EMBEDDED_ICE_H
+#ifndef OPENOCD_TARGET_EMBEDDEDICE_H
+#define OPENOCD_TARGET_EMBEDDEDICE_H
 
 #include "arm7_9_common.h"
 
@@ -127,4 +125,4 @@ static inline void embeddedice_write_reg_inner(struct jtag_tap *tap, int reg_add
 void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, const uint8_t *buffer,
 		int little, int count);
 
-#endif /* EMBEDDED_ICE_H */
+#endif /* OPENOCD_TARGET_EMBEDDEDICE_H */
diff --git a/src/target/etb.c b/src/target/etb.c
index 56f5795b..dc25844b 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/etb.h b/src/target/etb.h
index d5cbd85c..680c8a1a 100644
--- a/src/target/etb.h
+++ b/src/target/etb.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ETB_H
-#define ETB_H
+#ifndef OPENOCD_TARGET_ETB_H
+#define OPENOCD_TARGET_ETB_H
 
 /* ETB registers */
 enum {
@@ -57,4 +55,4 @@ extern struct etm_capture_driver etb_capture_driver;
 
 struct reg_cache *etb_build_reg_cache(struct etb *etb);
 
-#endif /* ETB_H */
+#endif /* OPENOCD_TARGET_ETB_H */
diff --git a/src/target/etm.c b/src/target/etm.c
index 0246ae25..6a00c23a 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -1701,7 +1699,7 @@ COMMAND_HANDLER(handle_etm_image_command)
 
 COMMAND_HANDLER(handle_etm_dump_command)
 {
-	struct fileio file;
+	struct fileio *file;
 	struct target *target;
 	struct arm *arm;
 	struct etm_context *etm_ctx;
@@ -1741,24 +1739,24 @@ COMMAND_HANDLER(handle_etm_dump_command)
 	if (fileio_open(&file, CMD_ARGV[0], FILEIO_WRITE, FILEIO_BINARY) != ERROR_OK)
 		return ERROR_FAIL;
 
-	fileio_write_u32(&file, etm_ctx->capture_status);
-	fileio_write_u32(&file, etm_ctx->control);
-	fileio_write_u32(&file, etm_ctx->trace_depth);
+	fileio_write_u32(file, etm_ctx->capture_status);
+	fileio_write_u32(file, etm_ctx->control);
+	fileio_write_u32(file, etm_ctx->trace_depth);
 
 	for (i = 0; i < etm_ctx->trace_depth; i++) {
-		fileio_write_u32(&file, etm_ctx->trace_data[i].pipestat);
-		fileio_write_u32(&file, etm_ctx->trace_data[i].packet);
-		fileio_write_u32(&file, etm_ctx->trace_data[i].flags);
+		fileio_write_u32(file, etm_ctx->trace_data[i].pipestat);
+		fileio_write_u32(file, etm_ctx->trace_data[i].packet);
+		fileio_write_u32(file, etm_ctx->trace_data[i].flags);
 	}
 
-	fileio_close(&file);
+	fileio_close(file);
 
 	return ERROR_OK;
 }
 
 COMMAND_HANDLER(handle_etm_load_command)
 {
-	struct fileio file;
+	struct fileio *file;
 	struct target *target;
 	struct arm *arm;
 	struct etm_context *etm_ctx;
@@ -1789,15 +1787,15 @@ COMMAND_HANDLER(handle_etm_load_command)
 		return ERROR_FAIL;
 
 	size_t filesize;
-	int retval = fileio_size(&file, &filesize);
+	int retval = fileio_size(file, &filesize);
 	if (retval != ERROR_OK) {
-		fileio_close(&file);
+		fileio_close(file);
 		return retval;
 	}
 
 	if (filesize % 4) {
 		command_print(CMD_CTX, "size isn't a multiple of 4, no valid trace data");
-		fileio_close(&file);
+		fileio_close(file);
 		return ERROR_FAIL;
 	}
 
@@ -1808,28 +1806,28 @@ COMMAND_HANDLER(handle_etm_load_command)
 
 	{
 		uint32_t tmp;
-		fileio_read_u32(&file, &tmp); etm_ctx->capture_status = tmp;
-		fileio_read_u32(&file, &tmp); etm_ctx->control = tmp;
-		fileio_read_u32(&file, &etm_ctx->trace_depth);
+		fileio_read_u32(file, &tmp); etm_ctx->capture_status = tmp;
+		fileio_read_u32(file, &tmp); etm_ctx->control = tmp;
+		fileio_read_u32(file, &etm_ctx->trace_depth);
 	}
 	etm_ctx->trace_data = malloc(sizeof(struct etmv1_trace_data) * etm_ctx->trace_depth);
 	if (etm_ctx->trace_data == NULL) {
 		command_print(CMD_CTX, "not enough memory to perform operation");
-		fileio_close(&file);
+		fileio_close(file);
 		return ERROR_FAIL;
 	}
 
 	for (i = 0; i < etm_ctx->trace_depth; i++) {
 		uint32_t pipestat, packet, flags;
-		fileio_read_u32(&file, &pipestat);
-		fileio_read_u32(&file, &packet);
-		fileio_read_u32(&file, &flags);
+		fileio_read_u32(file, &pipestat);
+		fileio_read_u32(file, &packet);
+		fileio_read_u32(file, &flags);
 		etm_ctx->trace_data[i].pipestat = pipestat & 0xff;
 		etm_ctx->trace_data[i].packet = packet & 0xffff;
 		etm_ctx->trace_data[i].flags = flags;
 	}
 
-	fileio_close(&file);
+	fileio_close(file);
 
 	return ERROR_OK;
 }
diff --git a/src/target/etm.h b/src/target/etm.h
index ff7925bf..6a78b756 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ETM_H
-#define ETM_H
+#ifndef OPENOCD_TARGET_ETM_H
+#define OPENOCD_TARGET_ETM_H
 
 #include "trace.h"
 #include "arm_jtag.h"
@@ -223,4 +221,4 @@ extern const struct command_registration etm_command_handlers[];
 #define ERROR_ETM_CAPTURE_INIT_FAILED	(-1302)
 #define ERROR_ETM_ANALYSIS_FAILED	(-1303)
 
-#endif /* ETM_H */
+#endif /* OPENOCD_TARGET_ETM_H */
diff --git a/src/target/etm_dummy.c b/src/target/etm_dummy.c
index 0533d1e0..b18ce174 100644
--- a/src/target/etm_dummy.c
+++ b/src/target/etm_dummy.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/etm_dummy.h b/src/target/etm_dummy.h
index 450b5c18..5a1955f3 100644
--- a/src/target/etm_dummy.h
+++ b/src/target/etm_dummy.h
@@ -13,16 +13,14 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef ETM_DUMMY_H
-#define ETM_DUMMY_H
+#ifndef OPENOCD_TARGET_ETM_DUMMY_H
+#define OPENOCD_TARGET_ETM_DUMMY_H
 
 #include "etm.h"
 
 extern struct etm_capture_driver etm_dummy_capture_driver;
 
-#endif /* ETB_H */
+#endif /* OPENOCD_TARGET_ETM_DUMMY_H */
diff --git a/src/target/fa526.c b/src/target/fa526.c
index dfb29b8e..9f6b8055 100644
--- a/src/target/fa526.c
+++ b/src/target/fa526.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 9c204f04..6b14ab6a 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
@@ -64,6 +62,13 @@ static int feroceon_assert_reset(struct target *target)
 	struct arm7_9_common *arm7_9 = arm->arch_info;
 	int ud = arm7_9->use_dbgrq;
 
+	/* TODO: apply hw reset signal in not examined state */
+	if (!(target_was_examined(target))) {
+		LOG_WARNING("Reset is not asserted because the target is not examined.");
+		LOG_WARNING("Use a reset button or power cycle the target.");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	arm7_9->use_dbgrq = 0;
 	if (target->reset_halt)
 		arm7_9_halt(target);
@@ -455,7 +460,7 @@ static int feroceon_examine_debug_reason(struct target *target)
 }
 
 static int feroceon_bulk_write_memory(struct target *target,
-		uint32_t address, uint32_t count, const uint8_t *buffer)
+		target_addr_t address, uint32_t count, const uint8_t *buffer)
 {
 	int retval;
 	struct arm *arm = target->arch_info;
@@ -560,7 +565,7 @@ static int feroceon_bulk_write_memory(struct target *target,
 			buf_get_u32(arm->core_cache->reg_list[0].value, 0, 32);
 		if (endaddress != address + count*4) {
 			LOG_ERROR("DCC write failed,"
-				" expected end address 0x%08" PRIx32
+				" expected end address 0x%08" TARGET_PRIxADDR
 				" got 0x%0" PRIx32 "",
 				address + count*4, endaddress);
 			retval = ERROR_FAIL;
diff --git a/src/target/hla_target.c b/src/target/hla_target.c
index d0be966c..78dc8c51 100644
--- a/src/target/hla_target.c
+++ b/src/target/hla_target.c
@@ -18,9 +18,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -343,7 +341,7 @@ static int adapter_init_target(struct command_context *cmd_ctx,
 	LOG_DEBUG("%s", __func__);
 
 	armv7m_build_reg_cache(target);
-
+	arm_semihosting_init(target);
 	return ERROR_OK;
 }
 
@@ -586,7 +584,7 @@ static int adapter_halt(struct target *target)
 }
 
 static int adapter_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints,
+		target_addr_t address, int handle_breakpoints,
 		int debug_execution)
 {
 	int res;
@@ -596,8 +594,8 @@ static int adapter_resume(struct target *target, int current,
 	struct breakpoint *breakpoint = NULL;
 	struct reg *pc;
 
-	LOG_DEBUG("%s %d 0x%08" PRIx32 " %d %d", __func__, current, address,
-			handle_breakpoints, debug_execution);
+	LOG_DEBUG("%s %d " TARGET_ADDR_FMT " %d %d", __func__, current,
+			address, handle_breakpoints, debug_execution);
 
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
@@ -644,7 +642,7 @@ static int adapter_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (ID: %" PRIu32 ")",
+			LOG_DEBUG("unset breakpoint at " TARGET_ADDR_FMT " (ID: %" PRIu32 ")",
 					breakpoint->address,
 					breakpoint->unique_id);
 			cortex_m_unset_breakpoint(target, breakpoint);
@@ -677,7 +675,7 @@ static int adapter_resume(struct target *target, int current,
 }
 
 static int adapter_step(struct target *target, int current,
-		uint32_t address, int handle_breakpoints)
+		target_addr_t address, int handle_breakpoints)
 {
 	int res;
 	struct hl_interface_s *adapter = target_to_adapter(target);
@@ -740,7 +738,7 @@ static int adapter_step(struct target *target, int current,
 	return ERROR_OK;
 }
 
-static int adapter_read_memory(struct target *target, uint32_t address,
+static int adapter_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count,
 		uint8_t *buffer)
 {
@@ -749,12 +747,13 @@ static int adapter_read_memory(struct target *target, uint32_t address,
 	if (!count || !buffer)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	LOG_DEBUG("%s 0x%08" PRIx32 " %" PRIu32 " %" PRIu32, __func__, address, size, count);
+	LOG_DEBUG("%s " TARGET_ADDR_FMT " %" PRIu32 " %" PRIu32,
+			  __func__, address, size, count);
 
 	return adapter->layout->api->read_mem(adapter->handle, address, size, count, buffer);
 }
 
-static int adapter_write_memory(struct target *target, uint32_t address,
+static int adapter_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count,
 		const uint8_t *buffer)
 {
@@ -763,7 +762,8 @@ static int adapter_write_memory(struct target *target, uint32_t address,
 	if (!count || !buffer)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	LOG_DEBUG("%s 0x%08" PRIx32 " %" PRIu32 " %" PRIu32, __func__, address, size, count);
+	LOG_DEBUG("%s " TARGET_ADDR_FMT " %" PRIu32 " %" PRIu32,
+			  __func__, address, size, count);
 
 	return adapter->layout->api->write_mem(adapter->handle, address, size, count, buffer);
 }
diff --git a/src/target/image.c b/src/target/image.c
index fa51ce33..f97d9040 100644
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -22,9 +22,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -47,7 +45,7 @@
 static int autodetect_image_type(struct image *image, const char *url)
 {
 	int retval;
-	struct fileio fileio;
+	struct fileio *fileio;
 	size_t read_bytes;
 	uint8_t buffer[9];
 
@@ -55,13 +53,13 @@ static int autodetect_image_type(struct image *image, const char *url)
 	retval = fileio_open(&fileio, url, FILEIO_READ, FILEIO_BINARY);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = fileio_read(&fileio, 9, buffer, &read_bytes);
+	retval = fileio_read(fileio, 9, buffer, &read_bytes);
 
 	if (retval == ERROR_OK) {
 		if (read_bytes != 9)
 			retval = ERROR_FILEIO_OPERATION_FAILED;
 	}
-	fileio_close(&fileio);
+	fileio_close(fileio);
 
 	if (retval != ERROR_OK)
 		return retval;
@@ -122,7 +120,7 @@ static int image_ihex_buffer_complete_inner(struct image *image,
 	struct imagesection *section)
 {
 	struct image_ihex *ihex = image->type_private;
-	struct fileio *fileio = &ihex->fileio;
+	struct fileio *fileio = ihex->fileio;
 	uint32_t full_address = 0x0;
 	uint32_t cooked_bytes;
 	int i;
@@ -352,7 +350,7 @@ static int image_elf_read_headers(struct image *image)
 		return ERROR_FILEIO_OPERATION_FAILED;
 	}
 
-	retval = fileio_read(&elf->fileio, sizeof(Elf32_Ehdr), (uint8_t *)elf->header, &read_bytes);
+	retval = fileio_read(elf->fileio, sizeof(Elf32_Ehdr), (uint8_t *)elf->header, &read_bytes);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("cannot read ELF file header, read failed");
 		return ERROR_FILEIO_OPERATION_FAILED;
@@ -384,7 +382,7 @@ static int image_elf_read_headers(struct image *image)
 		return ERROR_IMAGE_FORMAT_ERROR;
 	}
 
-	retval = fileio_seek(&elf->fileio, field32(elf, elf->header->e_phoff));
+	retval = fileio_seek(elf->fileio, field32(elf, elf->header->e_phoff));
 	if (retval != ERROR_OK) {
 		LOG_ERROR("cannot seek to ELF program header table, read failed");
 		return retval;
@@ -396,7 +394,7 @@ static int image_elf_read_headers(struct image *image)
 		return ERROR_FILEIO_OPERATION_FAILED;
 	}
 
-	retval = fileio_read(&elf->fileio, elf->segment_count*sizeof(Elf32_Phdr),
+	retval = fileio_read(elf->fileio, elf->segment_count*sizeof(Elf32_Phdr),
 			(uint8_t *)elf->segments, &read_bytes);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("cannot read ELF segment headers, read failed");
@@ -486,12 +484,12 @@ static int image_elf_read_section(struct image *image,
 		LOG_DEBUG("read elf: size = 0x%zu at 0x%" PRIx32 "", read_size,
 			field32(elf, segment->p_offset) + offset);
 		/* read initialized area of the segment */
-		retval = fileio_seek(&elf->fileio, field32(elf, segment->p_offset) + offset);
+		retval = fileio_seek(elf->fileio, field32(elf, segment->p_offset) + offset);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("cannot find ELF segment content, seek failed");
 			return retval;
 		}
-		retval = fileio_read(&elf->fileio, read_size, buffer, &really_read);
+		retval = fileio_read(elf->fileio, read_size, buffer, &really_read);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("cannot read ELF segment content, read failed");
 			return retval;
@@ -511,7 +509,7 @@ static int image_mot_buffer_complete_inner(struct image *image,
 	struct imagesection *section)
 {
 	struct image_mot *mot = image->type_private;
-	struct fileio *fileio = &mot->fileio;
+	struct fileio *fileio = mot->fileio;
 	uint32_t full_address = 0x0;
 	uint32_t cooked_bytes;
 	int i;
@@ -708,9 +706,9 @@ int image_open(struct image *image, const char *url, const char *type_string)
 		if (retval != ERROR_OK)
 			return retval;
 		size_t filesize;
-		retval = fileio_size(&image_binary->fileio, &filesize);
+		retval = fileio_size(image_binary->fileio, &filesize);
 		if (retval != ERROR_OK) {
-			fileio_close(&image_binary->fileio);
+			fileio_close(image_binary->fileio);
 			return retval;
 		}
 
@@ -731,8 +729,8 @@ int image_open(struct image *image, const char *url, const char *type_string)
 		retval = image_ihex_buffer_complete(image);
 		if (retval != ERROR_OK) {
 			LOG_ERROR(
-				"failed buffering IHEX image, check daemon output for additional information");
-			fileio_close(&image_ihex->fileio);
+				"failed buffering IHEX image, check server output for additional information");
+			fileio_close(image_ihex->fileio);
 			return retval;
 		}
 	} else if (image->type == IMAGE_ELF) {
@@ -746,7 +744,7 @@ int image_open(struct image *image, const char *url, const char *type_string)
 
 		retval = image_elf_read_headers(image);
 		if (retval != ERROR_OK) {
-			fileio_close(&image_elf->fileio);
+			fileio_close(image_elf->fileio);
 			return retval;
 		}
 	} else if (image->type == IMAGE_MEMORY) {
@@ -782,8 +780,8 @@ int image_open(struct image *image, const char *url, const char *type_string)
 		retval = image_mot_buffer_complete(image);
 		if (retval != ERROR_OK) {
 			LOG_ERROR(
-				"failed buffering S19 image, check daemon output for additional information");
-			fileio_close(&image_mot->fileio);
+				"failed buffering S19 image, check server output for additional information");
+			fileio_close(image_mot->fileio);
 			return retval;
 		}
 	} else if (image->type == IMAGE_BUILDER) {
@@ -835,12 +833,12 @@ int image_read_section(struct image *image,
 			return ERROR_COMMAND_SYNTAX_ERROR;
 
 		/* seek to offset */
-		retval = fileio_seek(&image_binary->fileio, offset);
+		retval = fileio_seek(image_binary->fileio, offset);
 		if (retval != ERROR_OK)
 			return retval;
 
 		/* return requested bytes */
-		retval = fileio_read(&image_binary->fileio, size, buffer, size_read);
+		retval = fileio_read(image_binary->fileio, size, buffer, size_read);
 		if (retval != ERROR_OK)
 			return retval;
 	} else if (image->type == IMAGE_IHEX) {
@@ -945,11 +943,11 @@ void image_close(struct image *image)
 	if (image->type == IMAGE_BINARY) {
 		struct image_binary *image_binary = image->type_private;
 
-		fileio_close(&image_binary->fileio);
+		fileio_close(image_binary->fileio);
 	} else if (image->type == IMAGE_IHEX) {
 		struct image_ihex *image_ihex = image->type_private;
 
-		fileio_close(&image_ihex->fileio);
+		fileio_close(image_ihex->fileio);
 
 		if (image_ihex->buffer) {
 			free(image_ihex->buffer);
@@ -958,7 +956,7 @@ void image_close(struct image *image)
 	} else if (image->type == IMAGE_ELF) {
 		struct image_elf *image_elf = image->type_private;
 
-		fileio_close(&image_elf->fileio);
+		fileio_close(image_elf->fileio);
 
 		if (image_elf->header) {
 			free(image_elf->header);
@@ -979,7 +977,7 @@ void image_close(struct image *image)
 	} else if (image->type == IMAGE_SRECORD) {
 		struct image_mot *image_mot = image->type_private;
 
-		fileio_close(&image_mot->fileio);
+		fileio_close(image_mot->fileio);
 
 		if (image_mot->buffer) {
 			free(image_mot->buffer);
diff --git a/src/target/image.h b/src/target/image.h
index 5aeba2f7..9907a5f3 100644
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef IMAGE_H
-#define IMAGE_H
+#ifndef OPENOCD_TARGET_IMAGE_H
+#define OPENOCD_TARGET_IMAGE_H
 
 #include <helper/fileio.h>
 
@@ -48,7 +46,7 @@ enum image_type {
 };
 
 struct imagesection {
-	uint32_t base_address;
+	target_addr_t base_address;
 	uint32_t size;
 	int flags;
 	void *private;		/* private data */
@@ -66,11 +64,11 @@ struct image {
 };
 
 struct image_binary {
-	struct fileio fileio;
+	struct fileio *fileio;
 };
 
 struct image_ihex {
-	struct fileio fileio;
+	struct fileio *fileio;
 	uint8_t *buffer;
 };
 
@@ -81,7 +79,7 @@ struct image_memory {
 };
 
 struct image_elf {
-	struct fileio fileio;
+	struct fileio *fileio;
 	Elf32_Ehdr *header;
 	Elf32_Phdr *segments;
 	uint32_t segment_count;
@@ -89,7 +87,7 @@ struct image_elf {
 };
 
 struct image_mot {
-	struct fileio fileio;
+	struct fileio *fileio;
 	uint8_t *buffer;
 };
 
@@ -109,4 +107,4 @@ int image_calculate_checksum(uint8_t *buffer, uint32_t nbytes,
 #define ERROR_IMAGE_TEMPORARILY_UNAVAILABLE		(-1402)
 #define ERROR_IMAGE_CHECKSUM		(-1403)
 
-#endif /* IMAGE_H */
+#endif /* OPENOCD_TARGET_IMAGE_H */
diff --git a/src/target/lakemont.c b/src/target/lakemont.c
index 055d9434..2bd12fd4 100644
--- a/src/target/lakemont.c
+++ b/src/target/lakemont.c
@@ -1,11 +1,12 @@
 /*
- * Copyright(c) 2013 Intel Corporation.
+ * Copyright(c) 2013-2016 Intel Corporation.
  *
  * Adrian Burns (adrian.burns@intel.com)
  * Thomas Faust (thomas.faust@intel.com)
  * Ivan De Cesaris (ivan.de.cesaris@intel.com)
  * Julien Carreno (julien.carreno@intel.com)
  * Jeffrey Maxwell (jeffrey.r.maxwell@intel.com)
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,8 +19,7 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * Contact Information:
  * Intel Corporation
@@ -498,6 +498,12 @@ static int halt_prep(struct target *t)
 	if (write_hw_reg(t, DSAR, PM_DSAR, 0) != ERROR_OK)
 		return ERROR_FAIL;
 	LOG_DEBUG("write DSAR 0x%08" PRIx32, PM_DSAR);
+	if (write_hw_reg(t, CSB, PM_DSB, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write %s 0x%08" PRIx32, regs[CSB].name, PM_DSB);
+	if (write_hw_reg(t, CSL, PM_DSL, 0) != ERROR_OK)
+		return ERROR_FAIL;
+	LOG_DEBUG("write %s 0x%08" PRIx32, regs[CSL].name, PM_DSL);
 	if (write_hw_reg(t, DR7, PM_DR7, 0) != ERROR_OK)
 		return ERROR_FAIL;
 	LOG_DEBUG("write DR7 0x%08" PRIx32, PM_DR7);
@@ -511,8 +517,7 @@ static int halt_prep(struct target *t)
 	LOG_DEBUG("EFLAGS = 0x%08" PRIx32 ", VM86 = %d, IF = %d", eflags,
 			eflags & EFLAGS_VM86 ? 1 : 0,
 			eflags & EFLAGS_IF ? 1 : 0);
-	if (eflags & EFLAGS_VM86
-		|| eflags & EFLAGS_IF) {
+	if ((eflags & EFLAGS_VM86) || (eflags & EFLAGS_IF)) {
 		x86_32->pm_regs[I(EFLAGS)] = eflags & ~(EFLAGS_VM86 | EFLAGS_IF);
 		if (write_hw_reg(t, EFLAGS, x86_32->pm_regs[I(EFLAGS)], 0) != ERROR_OK)
 			return ERROR_FAIL;
@@ -530,14 +535,14 @@ static int halt_prep(struct target *t)
 		LOG_DEBUG("write CSAR_CPL to 0 0x%08" PRIx32, x86_32->pm_regs[I(CSAR)]);
 	}
 	if (ssar & SSAR_DPL) {
-		x86_32->pm_regs[I(SSAR)] = ssar & ~CSAR_DPL;
+		x86_32->pm_regs[I(SSAR)] = ssar & ~SSAR_DPL;
 		if (write_hw_reg(t, SSAR, x86_32->pm_regs[I(SSAR)], 0) != ERROR_OK)
 			return ERROR_FAIL;
 		LOG_DEBUG("write SSAR_CPL to 0 0x%08" PRIx32, x86_32->pm_regs[I(SSAR)]);
 	}
 
-	/* if cache's are enabled, disable and flush */
-	if (!(cr0 & CR0_CD)) {
+	/* if cache's are enabled, disable and flush, depending on the core version */
+	if (!(x86_32->core_type == LMT3_5) && !(cr0 & CR0_CD)) {
 		LOG_DEBUG("caching enabled CR0 = 0x%08" PRIx32, cr0);
 		if (cr0 & CR0_PG) {
 			x86_32->pm_regs[I(CR0)] = cr0 & ~CR0_PG;
@@ -563,6 +568,13 @@ static int do_halt(struct target *t)
 	t->state = TARGET_DEBUG_RUNNING;
 	if (enter_probemode(t) != ERROR_OK)
 		return ERROR_FAIL;
+
+	return lakemont_update_after_probemode_entry(t);
+}
+
+/* we need to expose the update to be able to complete the reset at SoC level */
+int lakemont_update_after_probemode_entry(struct target *t)
+{
 	if (save_context(t) != ERROR_OK)
 		return ERROR_FAIL;
 	if (halt_prep(t) != ERROR_OK)
@@ -677,16 +689,16 @@ static int write_hw_reg(struct target *t, int reg, uint32_t regval, uint8_t cach
 			arch_info->op,
 			regval);
 
-	scan.out[0] = RDWRPDR;
 	x86_32->flush = 0; /* dont flush scans till we have a batch */
-	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
-		return ERROR_FAIL;
-	if (drscan(t, reg_buf, scan.out, PDR_SIZE) != ERROR_OK)
-		return ERROR_FAIL;
 	if (submit_reg_pir(t, reg) != ERROR_OK)
 		return ERROR_FAIL;
 	if (submit_instruction_pir(t, SRAMACCESS) != ERROR_OK)
 		return ERROR_FAIL;
+	scan.out[0] = RDWRPDR;
+	if (irscan(t, scan.out, NULL, LMT_IRLEN) != ERROR_OK)
+		return ERROR_FAIL;
+	if (drscan(t, reg_buf, scan.out, PDR_SIZE) != ERROR_OK)
+		return ERROR_FAIL;
 	x86_32->flush = 1;
 	if (submit_instruction_pir(t, PDR2SRAM) != ERROR_OK)
 		return ERROR_FAIL;
@@ -982,7 +994,7 @@ int lakemont_halt(struct target *t)
 	}
 }
 
-int lakemont_resume(struct target *t, int current, uint32_t address,
+int lakemont_resume(struct target *t, int current, target_addr_t address,
 			int handle_breakpoints, int debug_execution)
 {
 	struct breakpoint *bp = NULL;
@@ -1024,7 +1036,7 @@ int lakemont_resume(struct target *t, int current, uint32_t address,
 }
 
 int lakemont_step(struct target *t, int current,
-			uint32_t address, int handle_breakpoints)
+			target_addr_t address, int handle_breakpoints)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	uint32_t eflags = buf_get_u32(x86_32->cache->reg_list[EFLAGS].value, 0, 32);
diff --git a/src/target/lakemont.h b/src/target/lakemont.h
index 30b34b3f..98efd44a 100644
--- a/src/target/lakemont.h
+++ b/src/target/lakemont.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2013 Intel Corporation.
+ * Copyright(c) 2013-2016 Intel Corporation.
  *
  * Adrian Burns (adrian.burns@intel.com)
  * Thomas Faust (thomas.faust@intel.com)
@@ -18,8 +18,7 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * Contact Information:
  * Intel Corporation
@@ -30,8 +29,9 @@
  * This is the interface to the probemode operations for Lakemont 1 (LMT1).
  */
 
-#ifndef LAKEMONT_H
-#define LAKEMONT_H
+#ifndef OPENOCD_TARGET_LAKEMONT_H
+#define OPENOCD_TARGET_LAKEMONT_H
+
 #include <jtag/jtag.h>
 #include <helper/types.h>
 
@@ -95,11 +95,12 @@ int lakemont_init_arch_info(struct target *t, struct x86_32_common *x86_32);
 int lakemont_poll(struct target *t);
 int lakemont_arch_state(struct target *t);
 int lakemont_halt(struct target *t);
-int lakemont_resume(struct target *t, int current, uint32_t address,
+int lakemont_resume(struct target *t, int current, target_addr_t address,
 			int handle_breakpoints, int debug_execution);
 int lakemont_step(struct target *t, int current,
-			uint32_t address, int handle_breakpoints);
+			target_addr_t address, int handle_breakpoints);
 int lakemont_reset_assert(struct target *t);
 int lakemont_reset_deassert(struct target *t);
+int lakemont_update_after_probemode_entry(struct target *t);
 
-#endif /* LAKEMONT_H */
+#endif /* OPENOCD_TARGET_LAKEMONT_H */
diff --git a/src/target/ls1_sap.c b/src/target/ls1_sap.c
new file mode 100644
index 00000000..bc46ed4d
--- /dev/null
+++ b/src/target/ls1_sap.c
@@ -0,0 +1,243 @@
+/***************************************************************************
+ *   Copyright (C) 2015 by Esben Haabendal                                 *
+ *   eha@deif.com                                                          *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "target.h"
+#include "target_type.h"
+
+#include <jtag/jtag.h>
+
+struct ls1_sap {
+	struct jtag_tap *tap;
+};
+
+static int ls1_sap_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct ls1_sap *ls1_sap = calloc(1, sizeof(struct ls1_sap));
+
+	ls1_sap->tap = target->tap;
+	target->arch_info = ls1_sap;
+
+	return ERROR_OK;
+}
+
+static int ls1_sap_init_target(struct command_context *cmd_ctx, struct target *target)
+{
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static int ls1_sap_arch_state(struct target *target)
+{
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static int ls1_sap_poll(struct target *target)
+{
+	if ((target->state == TARGET_UNKNOWN) ||
+	    (target->state == TARGET_RUNNING) ||
+	    (target->state == TARGET_DEBUG_RUNNING))
+		target->state = TARGET_HALTED;
+
+	return ERROR_OK;
+}
+
+static int ls1_sap_halt(struct target *target)
+{
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static int ls1_sap_resume(struct target *target, int current, target_addr_t address,
+		int handle_breakpoints, int debug_execution)
+{
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static int ls1_sap_step(struct target *target, int current, target_addr_t address,
+				int handle_breakpoints)
+{
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static int ls1_sap_assert_reset(struct target *target)
+{
+	target->state = TARGET_RESET;
+
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static int ls1_sap_deassert_reset(struct target *target)
+{
+	target->state = TARGET_RUNNING;
+
+	LOG_DEBUG("%s", __func__);
+	return ERROR_OK;
+}
+
+static void ls1_sap_set_instr(struct jtag_tap *tap, uint32_t new_instr)
+{
+	struct scan_field field;
+
+	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) == new_instr)
+		return;
+
+	field.num_bits = tap->ir_length;
+	uint8_t *t = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
+	field.out_value = t;
+	buf_set_u32(t, 0, field.num_bits, new_instr);
+	field.in_value = NULL;
+	jtag_add_ir_scan(tap, &field, TAP_IDLE);
+	free(t);
+}
+
+static void ls1_sap_set_addr_high(struct jtag_tap *tap, uint16_t addr_high)
+{
+	struct scan_field field;
+	uint8_t buf[2];
+
+	ls1_sap_set_instr(tap, 0x21);
+
+	field.num_bits = 16;
+	field.out_value = buf;
+	buf_set_u32(buf, 0, 16, addr_high);
+	field.in_value = NULL;
+	field.check_value = NULL;
+	field.check_mask = NULL;
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+}
+
+static void ls1_sap_memory_cmd(struct jtag_tap *tap, uint32_t address,
+			       int32_t size, bool rnw)
+{
+	struct scan_field field;
+	uint8_t cmd[8];
+
+	ls1_sap_set_instr(tap, 0x24);
+
+	field.num_bits = 64;
+	field.out_value = cmd;
+	buf_set_u64(cmd, 0, 9, 0);
+	buf_set_u64(cmd, 9, 3, size);
+	buf_set_u64(cmd, 12, 1, rnw);
+	buf_set_u64(cmd, 13, 3, 0);
+	buf_set_u64(cmd, 16, 32, address);
+	buf_set_u64(cmd, 48, 16, 0);
+	field.in_value = NULL;
+	field.check_value = NULL;
+	field.check_mask = NULL;
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+}
+
+static void ls1_sap_memory_read(struct jtag_tap *tap, uint32_t size,
+				uint8_t *value)
+{
+	struct scan_field field;
+
+	ls1_sap_set_instr(tap, 0x25);
+
+	field.num_bits = 8 * size;
+	field.out_value = NULL;
+	field.in_value = value;
+	field.check_value = NULL;
+	field.check_mask = NULL;
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+}
+
+static void ls1_sap_memory_write(struct jtag_tap *tap, uint32_t size,
+				 const uint8_t *value)
+{
+	struct scan_field field;
+
+	ls1_sap_set_instr(tap, 0x25);
+
+	field.num_bits = 8 * size;
+	field.out_value = value;
+	field.in_value = NULL;
+	field.check_value = NULL;
+	field.check_mask = NULL;
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+}
+
+static int ls1_sap_read_memory(struct target *target, target_addr_t address,
+			       uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	LOG_DEBUG("Reading memory at physical address 0x%" TARGET_PRIxADDR
+		  "; size %" PRId32 "; count %" PRId32, address, size, count);
+
+	if (count == 0 || buffer == NULL)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	ls1_sap_set_addr_high(target->tap, 0);
+
+	while (count--) {
+		ls1_sap_memory_cmd(target->tap, address, size, true);
+		ls1_sap_memory_read(target->tap, size, buffer);
+		address += size;
+		buffer += size;
+	}
+
+	return jtag_execute_queue();
+}
+
+static int ls1_sap_write_memory(struct target *target, target_addr_t address,
+				uint32_t size, uint32_t count,
+				const uint8_t *buffer)
+{
+	LOG_DEBUG("Writing memory at physical address 0x%" TARGET_PRIxADDR
+		  "; size %" PRId32 "; count %" PRId32, address, size, count);
+
+
+	if (count == 0 || buffer == NULL)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	ls1_sap_set_addr_high(target->tap, 0);
+
+	while (count--) {
+		ls1_sap_memory_cmd(target->tap, address, size, false);
+		ls1_sap_memory_write(target->tap, size, buffer);
+		address += size;
+		buffer += size;
+	}
+
+	return jtag_execute_queue();
+}
+
+struct target_type ls1_sap_target = {
+	.name = "ls1_sap",
+
+	.target_create = ls1_sap_target_create,
+	.init_target = ls1_sap_init_target,
+
+	.poll = ls1_sap_poll,
+	.arch_state = ls1_sap_arch_state,
+
+	.halt = ls1_sap_halt,
+	.resume = ls1_sap_resume,
+	.step = ls1_sap_step,
+
+	.assert_reset = ls1_sap_assert_reset,
+	.deassert_reset = ls1_sap_deassert_reset,
+
+	.read_memory = ls1_sap_read_memory,
+	.write_memory = ls1_sap_write_memory,
+};
diff --git a/src/target/mips32.c b/src/target/mips32.c
index 5a0e2a3a..93fb4e64 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -21,9 +21,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -36,7 +34,7 @@
 #include "register.h"
 
 static const char *mips_isa_strings[] = {
-	"MIPS32", "MIPS16e"
+	"MIPS32", "MIPS16", "", "MICRO MIPS32",
 };
 
 #define MIPS32_GDB_DUMMY_FP_REG 1
@@ -377,6 +375,7 @@ int mips32_init_arch_info(struct target *target, struct mips32_common *mips32, s
 	target->arch_info = mips32;
 	mips32->common_magic = MIPS32_COMMON_MAGIC;
 	mips32->fast_data_area = NULL;
+	mips32->isa_imp = MIPS32_ONLY;	/* default */
 
 	/* has breakpoint/watchpoint unit been scanned */
 	mips32->bp_scanned = 0;
@@ -385,16 +384,18 @@ int mips32_init_arch_info(struct target *target, struct mips32_common *mips32, s
 	mips32->ejtag_info.tap = tap;
 	mips32->read_core_reg = mips32_read_core_reg;
 	mips32->write_core_reg = mips32_write_core_reg;
-
-	mips32->ejtag_info.scan_delay = 2000000;	/* Initial default value */
+	/* if unknown endianness defaults to little endian, 1 */
+	mips32->ejtag_info.endianness = target->endianness == TARGET_BIG_ENDIAN ? 0 : 1;
+	mips32->ejtag_info.scan_delay = MIPS32_SCAN_DELAY_LEGACY_MODE;
 	mips32->ejtag_info.mode = 0;			/* Initial default value */
-
+	mips32->ejtag_info.isa = 0;	/* isa on debug mips32, updated by poll function */
+	mips32->ejtag_info.config_regs = 0;	/* no config register read */
 	return ERROR_OK;
 }
 
 /* run to exit point. return error if exit point was not reached. */
-static int mips32_run_and_wait(struct target *target, uint32_t entry_point,
-		int timeout_ms, uint32_t exit_point, struct mips32_common *mips32)
+static int mips32_run_and_wait(struct target *target, target_addr_t entry_point,
+		int timeout_ms, target_addr_t exit_point, struct mips32_common *mips32)
 {
 	uint32_t pc;
 	int retval;
@@ -427,8 +428,8 @@ static int mips32_run_and_wait(struct target *target, uint32_t entry_point,
 
 int mips32_run_algorithm(struct target *target, int num_mem_params,
 		struct mem_param *mem_params, int num_reg_params,
-		struct reg_param *reg_params, uint32_t entry_point,
-		uint32_t exit_point, int timeout_ms, void *arch_info)
+		struct reg_param *reg_params, target_addr_t entry_point,
+		target_addr_t exit_point, int timeout_ms, void *arch_info)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips32_algorithm *mips32_algorithm_info = arch_info;
@@ -698,57 +699,109 @@ int mips32_enable_interrupts(struct target *target, int enable)
 	return ERROR_OK;
 }
 
-int mips32_checksum_memory(struct target *target, uint32_t address,
+/* read config to config3 cp0 registers and log isa implementation */
+int mips32_read_config_regs(struct target *target)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	if (ejtag_info->config_regs == 0)
+		for (int i = 0; i != 4; i++) {
+			int retval = mips32_cp0_read(ejtag_info, &ejtag_info->config[i], 16, i);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("isa info not available, failed to read cp0 config register: %" PRId32, i);
+				ejtag_info->config_regs = 0;
+				return retval;
+			}
+			ejtag_info->config_regs = i + 1;
+			if ((ejtag_info->config[i] & (1 << 31)) == 0)
+				break;	/* no more config registers implemented */
+		}
+	else
+		return ERROR_OK;	/* already succesfully read */
+
+	LOG_DEBUG("read  %"PRId32" config registers", ejtag_info->config_regs);
+
+	if (ejtag_info->impcode & EJTAG_IMP_MIPS16) {
+		mips32->isa_imp = MIPS32_MIPS16;
+		LOG_USER("MIPS32 with MIPS16 support implemented");
+
+	} else if (ejtag_info->config_regs >= 4) {	/* config3 implemented */
+		unsigned isa_imp = (ejtag_info->config[3] & MIPS32_CONFIG3_ISA_MASK) >> MIPS32_CONFIG3_ISA_SHIFT;
+		if (isa_imp == 1) {
+			mips32->isa_imp = MMIPS32_ONLY;
+			LOG_USER("MICRO MIPS32 only implemented");
+
+		} else if (isa_imp != 0) {
+			mips32->isa_imp = MIPS32_MMIPS32;
+			LOG_USER("MIPS32 and MICRO MIPS32 implemented");
+		}
+	}
+
+	if (mips32->isa_imp == MIPS32_ONLY)	/* initial default value */
+		LOG_USER("MIPS32 only implemented");
+
+	return ERROR_OK;
+}
+int mips32_checksum_memory(struct target *target, target_addr_t address,
 		uint32_t count, uint32_t *checksum)
 {
 	struct working_area *crc_algorithm;
 	struct reg_param reg_params[2];
 	struct mips32_algorithm mips32_info;
 
-	/* see contrib/loaders/checksum/mips32.s for src */
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
-	static const uint32_t mips_crc_code[] = {
-		0x248C0000,		/* addiu	$t4, $a0, 0 */
-		0x24AA0000,		/* addiu	$t2, $a1, 0 */
-		0x2404FFFF,		/* addiu	$a0, $zero, 0xffffffff */
-		0x10000010,		/* beq		$zero, $zero, ncomp */
-		0x240B0000,		/* addiu	$t3, $zero, 0 */
+	/* see contrib/loaders/checksum/mips32.s for src */
+	uint32_t isa = ejtag_info->isa ? 1 : 0;
+
+	uint32_t mips_crc_code[] = {
+		MIPS32_ADDIU(isa, 12, 4, 0),			/* addiu	$t4, $a0, 0 */
+		MIPS32_ADDIU(isa, 10, 5, 0),			/* addiu	$t2, $a1, 0 */
+		MIPS32_ADDIU(isa, 4, 0, 0xFFFF),		/* addiu	$a0, $zero, 0xffff */
+		MIPS32_BEQ(isa, 0, 0, 0x10 << isa),		/* beq		$zero, $zero, ncomp */
+		MIPS32_ADDIU(isa, 11, 0, 0),			/* addiu	$t3, $zero, 0 */
 						/* nbyte: */
-		0x81850000,		/* lb		$a1, ($t4) */
-		0x218C0001,		/* addi		$t4, $t4, 1 */
-		0x00052E00,		/* sll		$a1, $a1, 24 */
-		0x3C0204C1,		/* lui		$v0, 0x04c1 */
-		0x00852026,		/* xor		$a0, $a0, $a1 */
-		0x34471DB7,		/* ori		$a3, $v0, 0x1db7 */
-		0x00003021,		/* addu		$a2, $zero, $zero */
-						/* loop: */
-		0x00044040,		/* sll		$t0, $a0, 1 */
-		0x24C60001,		/* addiu	$a2, $a2, 1 */
-		0x28840000,		/* slti		$a0, $a0, 0 */
-		0x01074826,		/* xor		$t1, $t0, $a3 */
-		0x0124400B,		/* movn		$t0, $t1, $a0 */
-		0x28C30008,		/* slti		$v1, $a2, 8 */
-		0x1460FFF9,		/* bne		$v1, $zero, loop */
-		0x01002021,		/* addu		$a0, $t0, $zero */
-						/* ncomp: */
-		0x154BFFF0,		/* bne		$t2, $t3, nbyte */
-		0x256B0001,		/* addiu	$t3, $t3, 1 */
-		0x7000003F,		/* sdbbp */
+		MIPS32_LB(isa, 5, 0, 12),			/* lb		$a1, ($t4) */
+		MIPS32_ADDI(isa, 12, 12, 1),			/* addi		$t4, $t4, 1 */
+		MIPS32_SLL(isa, 5, 5, 24),			/* sll		$a1, $a1, 24 */
+		MIPS32_LUI(isa, 2, 0x04c1),			/* lui		$v0, 0x04c1 */
+		MIPS32_XOR(isa, 4, 4, 5),			/* xor		$a0, $a0, $a1 */
+		MIPS32_ORI(isa, 7, 2, 0x1db7),			/* ori		$a3, $v0, 0x1db7 */
+		MIPS32_ADDU(isa, 6, 0, 0),			/* addu		$a2, $zero, $zero */
+						/* loop */
+		MIPS32_SLL(isa, 8, 4, 1),			/* sll		$t0, $a0, 1 */
+		MIPS32_ADDIU(isa, 6, 6, 1),			/* addiu	$a2, $a2, 1 */
+		MIPS32_SLTI(isa, 4, 4, 0),			/* slti		$a0, $a0, 0 */
+		MIPS32_XOR(isa, 9, 8, 7),			/* xor		$t1, $t0, $a3 */
+		MIPS32_MOVN(isa, 8, 9, 4),			/* movn		$t0, $t1, $a0 */
+		MIPS32_SLTI(isa, 3, 6, 8),			/* slti		$v1, $a2, 8 */
+		MIPS32_BNE(isa, 3, 0, NEG16(7 << isa)),		/* bne		$v1, $zero, loop */
+		MIPS32_ADDU(isa, 4, 8, 0),			/* addu		$a0, $t0, $zero */
+						/* ncomp */
+		MIPS32_BNE(isa, 10, 11, NEG16(16 << isa)),	/* bne		$t2, $t3, nbyte */
+		MIPS32_ADDIU(isa, 11, 11, 1),			/* addiu	$t3, $t3, 1 */
+		MIPS32_SDBBP(isa),
 	};
 
 	/* make sure we have a working area */
 	if (target_alloc_working_area(target, sizeof(mips_crc_code), &crc_algorithm) != ERROR_OK)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
+	pracc_swap16_array(ejtag_info, mips_crc_code, ARRAY_SIZE(mips_crc_code));
+
 	/* convert mips crc code into a buffer in target endianness */
 	uint8_t mips_crc_code_8[sizeof(mips_crc_code)];
 	target_buffer_set_u32_array(target, mips_crc_code_8,
 					ARRAY_SIZE(mips_crc_code), mips_crc_code);
 
-	target_write_buffer(target, crc_algorithm->address, sizeof(mips_crc_code), mips_crc_code_8);
+	int retval = target_write_buffer(target, crc_algorithm->address, sizeof(mips_crc_code), mips_crc_code_8);
+	if (retval != ERROR_OK)
+		return retval;
 
 	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
-	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
+	mips32_info.isa_mode = isa ? MIPS32_ISA_MMIPS32 : MIPS32_ISA_MIPS32;	/* run isa as in debug mode */
 
 	init_reg_param(&reg_params[0], "r4", 32, PARAM_IN_OUT);
 	buf_set_u32(reg_params[0].value, 0, 32, address);
@@ -758,9 +811,8 @@ int mips32_checksum_memory(struct target *target, uint32_t address,
 
 	int timeout = 20000 * (1 + (count / (1024 * 1024)));
 
-	int retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
-			crc_algorithm->address, crc_algorithm->address + (sizeof(mips_crc_code) - 4), timeout,
-			&mips32_info);
+	retval = target_run_algorithm(target, 0, NULL, 2, reg_params, crc_algorithm->address,
+				      crc_algorithm->address + (sizeof(mips_crc_code) - 4), timeout, &mips32_info);
 
 	if (retval == ERROR_OK)
 		*checksum = buf_get_u32(reg_params[0].value, 0, 32);
@@ -773,37 +825,51 @@ int mips32_checksum_memory(struct target *target, uint32_t address,
 	return retval;
 }
 
-/** Checks whether a memory region is zeroed. */
+/** Checks whether a memory region is erased. */
 int mips32_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *blank)
+		target_addr_t address, uint32_t count, uint32_t *blank, uint8_t erased_value)
 {
 	struct working_area *erase_check_algorithm;
 	struct reg_param reg_params[3];
 	struct mips32_algorithm mips32_info;
 
-	static const uint32_t erase_check_code[] = {
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+
+	if (erased_value != 0xff) {
+		LOG_ERROR("Erase value 0x%02" PRIx8 " not yet supported for MIPS32",
+			erased_value);
+		return ERROR_FAIL;
+	}
+	uint32_t isa = ejtag_info->isa ? 1 : 0;
+	uint32_t erase_check_code[] = {
 						/* nbyte: */
-		0x80880000,		/* lb		$t0, ($a0) */
-		0x00C83024,		/* and		$a2, $a2, $t0 */
-		0x24A5FFFF,		/* addiu	$a1, $a1, -1 */
-		0x14A0FFFC,		/* bne		$a1, $zero, nbyte */
-		0x24840001,		/* addiu	$a0, $a0, 1 */
-		0x7000003F		/* sdbbp */
+		MIPS32_LB(isa, 8, 0, 4),			/* lb		$t0, ($a0) */
+		MIPS32_AND(isa, 6, 6, 8),			/* and		$a2, $a2, $t0 */
+		MIPS32_ADDIU(isa, 5, 5, NEG16(1)),		/* addiu	$a1, $a1, -1 */
+		MIPS32_BNE(isa, 5, 0, NEG16(4 << isa)),		/* bne		$a1, $zero, nbyte */
+		MIPS32_ADDIU(isa, 4, 4, 1),			/* addiu	$a0, $a0, 1 */
+		MIPS32_SDBBP(isa)				/* sdbbp */
 	};
 
 	/* make sure we have a working area */
 	if (target_alloc_working_area(target, sizeof(erase_check_code), &erase_check_algorithm) != ERROR_OK)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
+	pracc_swap16_array(ejtag_info, erase_check_code, ARRAY_SIZE(erase_check_code));
+
 	/* convert erase check code into a buffer in target endianness */
 	uint8_t erase_check_code_8[sizeof(erase_check_code)];
 	target_buffer_set_u32_array(target, erase_check_code_8,
 					ARRAY_SIZE(erase_check_code), erase_check_code);
 
-	target_write_buffer(target, erase_check_algorithm->address, sizeof(erase_check_code), erase_check_code_8);
+	int retval = target_write_buffer(target, erase_check_algorithm->address,
+						sizeof(erase_check_code), erase_check_code_8);
+	if (retval != ERROR_OK)
+		return retval;
 
 	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
-	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
+	mips32_info.isa_mode = isa ? MIPS32_ISA_MMIPS32 : MIPS32_ISA_MIPS32;
 
 	init_reg_param(&reg_params[0], "r4", 32, PARAM_OUT);
 	buf_set_u32(reg_params[0].value, 0, 32, address);
@@ -812,12 +878,10 @@ int mips32_blank_check_memory(struct target *target,
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 
 	init_reg_param(&reg_params[2], "r6", 32, PARAM_IN_OUT);
-	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
+	buf_set_u32(reg_params[2].value, 0, 32, erased_value);
 
-	int retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-			erase_check_algorithm->address,
-			erase_check_algorithm->address + (sizeof(erase_check_code) - 4),
-			10000, &mips32_info);
+	retval = target_run_algorithm(target, 0, NULL, 3, reg_params, erase_check_algorithm->address,
+			erase_check_algorithm->address + (sizeof(erase_check_code) - 4), 10000, &mips32_info);
 
 	if (retval == ERROR_OK)
 		*blank = buf_get_u32(reg_params[2].value, 0, 32);
@@ -913,7 +977,7 @@ COMMAND_HANDLER(mips32_handle_scan_delay_command)
 			return ERROR_COMMAND_SYNTAX_ERROR;
 
 	command_print(CMD_CTX, "scan delay: %d nsec", ejtag_info->scan_delay);
-	if (ejtag_info->scan_delay >= 2000000) {
+	if (ejtag_info->scan_delay >= MIPS32_SCAN_DELAY_LEGACY_MODE) {
 		ejtag_info->mode = 0;
 		command_print(CMD_CTX, "running in legacy mode");
 	} else {
diff --git a/src/target/mips32.h b/src/target/mips32.h
index 56f4fb4e..928598f4 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -18,13 +18,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MIPS32_H
-#define MIPS32_H
+#ifndef OPENOCD_TARGET_MIPS32_H
+#define OPENOCD_TARGET_MIPS32_H
 
 #include "target.h"
 #include "mips32_pracc.h"
@@ -60,9 +58,14 @@
 #define MIPS32_CONFIG1_DL_SHIFT 10
 #define MIPS32_CONFIG1_DL_MASK (0x7 << MIPS32_CONFIG1_DL_SHIFT)
 
+#define MIPS32_CONFIG3_ISA_SHIFT	14
+#define MIPS32_CONFIG3_ISA_MASK		(3 << MIPS32_CONFIG3_ISA_SHIFT)
+
 #define MIPS32_ARCH_REL1 0x0
 #define MIPS32_ARCH_REL2 0x1
 
+#define MIPS32_SCAN_DELAY_LEGACY_MODE 2000000
+
 /* offsets into mips32 core register cache */
 enum {
 	MIPS32_PC = 37,
@@ -73,6 +76,14 @@ enum {
 enum mips32_isa_mode {
 	MIPS32_ISA_MIPS32 = 0,
 	MIPS32_ISA_MIPS16E = 1,
+	MIPS32_ISA_MMIPS32 = 3,
+};
+
+enum mips32_isa_imp {
+	MIPS32_ONLY = 0,
+	MMIPS32_ONLY = 1,
+	MIPS32_MIPS16 = 2,
+	MIPS32_MMIPS32 = 3,
 };
 
 struct mips32_comparator {
@@ -88,6 +99,7 @@ struct mips32_common {
 	struct mips_ejtag ejtag_info;
 	uint32_t core_regs[MIPS32NUMCOREREGS];
 	enum mips32_isa_mode isa_mode;
+	enum mips32_isa_imp isa_imp;
 
 	/* working area for fastdata access */
 	struct working_area *fast_data_area;
@@ -122,44 +134,49 @@ struct mips32_algorithm {
 	enum mips32_isa_mode isa_mode;
 };
 
-#define MIPS32_OP_ADDIU 0x21
-#define MIPS32_OP_ANDI	0x0C
-#define MIPS32_OP_BEQ	0x04
-#define MIPS32_OP_BGTZ	0x07
-#define MIPS32_OP_BNE	0x05
-#define MIPS32_OP_ADDI	0x08
-#define MIPS32_OP_AND	0x24
-#define MIPS32_OP_CACHE	0x2F
-#define MIPS32_OP_COP0	0x10
-#define MIPS32_OP_J	0x02
-#define MIPS32_OP_JR	0x08
-#define MIPS32_OP_LUI	0x0F
-#define MIPS32_OP_LW	0x23
-#define MIPS32_OP_LBU	0x24
-#define MIPS32_OP_LHU	0x25
-#define MIPS32_OP_MFHI	0x10
-#define MIPS32_OP_MTHI	0x11
-#define MIPS32_OP_MFLO	0x12
-#define MIPS32_OP_MTLO	0x13
-#define MIPS32_OP_RDHWR 0x3B
-#define MIPS32_OP_SB	0x28
-#define MIPS32_OP_SH	0x29
-#define MIPS32_OP_SW	0x2B
-#define MIPS32_OP_ORI	0x0D
-#define MIPS32_OP_XORI	0x0E
-#define MIPS32_OP_XOR	0x26
-#define MIPS32_OP_SLTU  0x2B
-#define MIPS32_OP_SRL	0x03
-#define MIPS32_OP_SYNCI	0x1F
-
-#define MIPS32_OP_REGIMM	0x01
-#define MIPS32_OP_SDBBP		0x3F
-#define MIPS32_OP_SPECIAL	0x00
-#define MIPS32_OP_SPECIAL2	0x07
-#define MIPS32_OP_SPECIAL3	0x1F
-
-#define MIPS32_COP0_MF	0x00
-#define MIPS32_COP0_MT	0x04
+#define MIPS32_OP_ADDU	0x21u
+#define MIPS32_OP_ADDIU	0x09u
+#define MIPS32_OP_ANDI	0x0Cu
+#define MIPS32_OP_BEQ	0x04u
+#define MIPS32_OP_BGTZ	0x07u
+#define MIPS32_OP_BNE	0x05u
+#define MIPS32_OP_ADDI	0x08u
+#define MIPS32_OP_AND	0x24u
+#define MIPS32_OP_CACHE	0x2Fu
+#define MIPS32_OP_COP0	0x10u
+#define MIPS32_OP_J	0x02u
+#define MIPS32_OP_JR	0x08u
+#define MIPS32_OP_LUI	0x0Fu
+#define MIPS32_OP_LW	0x23u
+#define MIPS32_OP_LB	0x20u
+#define MIPS32_OP_LBU	0x24u
+#define MIPS32_OP_LHU	0x25u
+#define MIPS32_OP_MFHI	0x10u
+#define MIPS32_OP_MTHI	0x11u
+#define MIPS32_OP_MFLO	0x12u
+#define MIPS32_OP_MTLO	0x13u
+#define MIPS32_OP_RDHWR	0x3Bu
+#define MIPS32_OP_SB	0x28u
+#define MIPS32_OP_SH	0x29u
+#define MIPS32_OP_SW	0x2Bu
+#define MIPS32_OP_ORI	0x0Du
+#define MIPS32_OP_XORI	0x0Eu
+#define MIPS32_OP_XOR	0x26u
+#define MIPS32_OP_SLTU	0x2Bu
+#define MIPS32_OP_SRL	0x03u
+#define MIPS32_OP_SYNCI	0x1Fu
+#define MIPS32_OP_SLL	0x00u
+#define MIPS32_OP_SLTI	0x0Au
+#define MIPS32_OP_MOVN	0x0Bu
+
+#define MIPS32_OP_REGIMM	0x01u
+#define MIPS32_OP_SDBBP	0x3Fu
+#define MIPS32_OP_SPECIAL	0x00u
+#define MIPS32_OP_SPECIAL2	0x07u
+#define MIPS32_OP_SPECIAL3	0x1Fu
+
+#define MIPS32_COP0_MF	0x00u
+#define MIPS32_COP0_MT	0x04u
 
 #define MIPS32_R_INST(opcode, rs, rt, rd, shamt, funct) \
 	(((opcode) << 26) | ((rs) << 21) | ((rt) << 16) | ((rd) << 11) | ((shamt) << 6) | (funct))
@@ -167,41 +184,52 @@ struct mips32_algorithm {
 	(((opcode) << 26) | ((rs) << 21) | ((rt) << 16) | (immd))
 #define MIPS32_J_INST(opcode, addr)	(((opcode) << 26) | (addr))
 
-#define MIPS32_NOP						0
-#define MIPS32_ADDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
-#define MIPS32_ADDU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADDIU)
-#define MIPS32_AND(reg, off, val)		MIPS32_R_INST(0, off, val, reg, 0, MIPS32_OP_AND)
-#define MIPS32_ANDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ANDI, src, tar, val)
-#define MIPS32_B(off)					MIPS32_BEQ(0, 0, off)
-#define MIPS32_BEQ(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
-#define MIPS32_BGTZ(reg, off)			MIPS32_I_INST(MIPS32_OP_BGTZ, reg, 0, off)
-#define MIPS32_BNE(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
-#define MIPS32_CACHE(op, off, base)		MIPS32_I_INST(MIPS32_OP_CACHE, base, op, off)
-#define MIPS32_J(tar)				MIPS32_J_INST(MIPS32_OP_J, tar)
-#define MIPS32_JR(reg)					MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
-#define MIPS32_MFC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
-#define MIPS32_MTC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
-#define MIPS32_LBU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
-#define MIPS32_LHU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
-#define MIPS32_LUI(reg, val)			MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
-#define MIPS32_LW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LW, base, reg, off)
-#define MIPS32_MFLO(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFLO)
-#define MIPS32_MFHI(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
-#define MIPS32_MTLO(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
-#define MIPS32_MTHI(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
-#define MIPS32_ORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
-#define MIPS32_XORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_XORI, src, tar, val)
-#define MIPS32_RDHWR(tar, dst)			MIPS32_R_INST(MIPS32_OP_SPECIAL3, 0, tar, dst, 0, MIPS32_OP_RDHWR)
-#define MIPS32_SB(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
-#define MIPS32_SH(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
-#define MIPS32_SW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
-#define MIPS32_XOR(reg, val1, val2)		MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
-#define MIPS32_SRL(reg, src, off)		MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
-#define MIPS32_SLTU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_SLTU)
-#define MIPS32_SYNCI(off, base)			MIPS32_I_INST(MIPS32_OP_REGIMM, base, MIPS32_OP_SYNCI, off)
-
-#define MIPS32_SYNC			0xF
-#define MIPS32_SYNCI_STEP	0x1	/* reg num od address step size to be used with synci instruction */
+#define MIPS32_ISA_NOP				0
+#define MIPS32_ISA_ADDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
+#define MIPS32_ISA_ADDIU(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDIU, src, tar, val)
+#define MIPS32_ISA_ADDU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADDU)
+#define MIPS32_ISA_AND(dst, src, tar)		MIPS32_R_INST(0, src, tar, dst, 0, MIPS32_OP_AND)
+#define MIPS32_ISA_ANDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ANDI, src, tar, val)
+
+#define MIPS32_ISA_B(off)			MIPS32_ISA_BEQ(0, 0, off)
+#define MIPS32_ISA_BEQ(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
+#define MIPS32_ISA_BGTZ(reg, off)		MIPS32_I_INST(MIPS32_OP_BGTZ, reg, 0, off)
+#define MIPS32_ISA_BNE(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
+#define MIPS32_ISA_CACHE(op, off, base)		MIPS32_I_INST(MIPS32_OP_CACHE, base, op, off)
+#define MIPS32_ISA_J(tar)			MIPS32_J_INST(MIPS32_OP_J, (0x0FFFFFFFu & (tar)) >> 2)
+#define MIPS32_ISA_JR(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
+
+#define MIPS32_ISA_LB(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LB, base, reg, off)
+#define MIPS32_ISA_LBU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
+#define MIPS32_ISA_LHU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
+#define MIPS32_ISA_LUI(reg, val)		MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
+#define MIPS32_ISA_LW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LW, base, reg, off)
+
+#define MIPS32_ISA_MFC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
+#define MIPS32_ISA_MTC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
+#define MIPS32_ISA_MFLO(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFLO)
+#define MIPS32_ISA_MFHI(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
+#define MIPS32_ISA_MTLO(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
+#define MIPS32_ISA_MTHI(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
+
+#define MIPS32_ISA_MOVN(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_MOVN)
+#define MIPS32_ISA_ORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
+#define MIPS32_ISA_RDHWR(tar, dst)		MIPS32_R_INST(MIPS32_OP_SPECIAL3, 0, tar, dst, 0, MIPS32_OP_RDHWR)
+#define MIPS32_ISA_SB(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
+#define MIPS32_ISA_SH(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
+#define MIPS32_ISA_SW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
+
+#define MIPS32_ISA_SLL(dst, src, sa)		MIPS32_R_INST(MIPS32_OP_SPECIAL, 0, src, dst, sa, MIPS32_OP_SLL)
+#define MIPS32_ISA_SLTI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_SLTI, src, tar, val)
+#define MIPS32_ISA_SLTU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_SLTU)
+#define MIPS32_ISA_SRL(reg, src, off)		MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
+#define MIPS32_ISA_SYNC				0xFu
+#define MIPS32_ISA_SYNCI(off, base)		MIPS32_I_INST(MIPS32_OP_REGIMM, base, MIPS32_OP_SYNCI, off)
+
+#define MIPS32_ISA_XOR(reg, val1, val2)		MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
+#define MIPS32_ISA_XORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_XORI, src, tar, val)
+
+#define MIPS32_ISA_SYNCI_STEP		0x1	/* reg num od address step size to be used with synci instruction */
 
 /**
  * Cache operations definitions
@@ -213,9 +241,158 @@ struct mips32_algorithm {
 #define MIPS32_CACHE_I_HIT_INVALIDATE ((0x0 << 0) | (0x4 << 2))
 
 /* ejtag specific instructions */
-#define MIPS32_DRET					0x4200001F
-#define MIPS32_SDBBP				0x7000003F	/* MIPS32_J_INST(MIPS32_OP_SPECIAL2, MIPS32_OP_SDBBP) */
-#define MIPS16_SDBBP				0xE801
+#define MIPS32_ISA_DRET				0x4200001Fu
+/* MIPS32_ISA_J_INST(MIPS32_ISA_OP_SPECIAL2, MIPS32_ISA_OP_SDBBP) */
+#define MIPS32_ISA_SDBBP			0x7000003Fu
+#define MIPS16_ISA_SDBBP			0xE801u
+
+/*MICRO MIPS INSTRUCTIONS, see doc MD00582 */
+#define POOL32A					0X00u
+#define POOL32AXf				0x3Cu
+#define POOL32B					0x08u
+#define POOL32I					0x10u
+#define MMIPS32_OP_ADDI			0x04u
+#define MMIPS32_OP_ADDIU		0x0Cu
+#define MMIPS32_OP_ADDU			0x150u
+#define MMIPS32_OP_AND			0x250u
+#define MMIPS32_OP_ANDI			0x34u
+#define MMIPS32_OP_BEQ			0x25u
+#define MMIPS32_OP_BGTZ			0x06u
+#define MMIPS32_OP_BNE			0x2Du
+#define MMIPS32_OP_CACHE		0x06u
+#define MMIPS32_OP_J			0x35u
+#define MMIPS32_OP_JALR			0x03Cu
+#define MMIPS32_OP_LB			0x07u
+#define MMIPS32_OP_LBU			0x05u
+#define MMIPS32_OP_LHU			0x0Du
+#define MMIPS32_OP_LUI			0x0Du
+#define MMIPS32_OP_LW			0x3Fu
+#define MMIPS32_OP_MFC0			0x03u
+#define MMIPS32_OP_MTC0			0x0Bu
+#define MMIPS32_OP_MFLO			0x075u
+#define MMIPS32_OP_MFHI			0x035u
+#define MMIPS32_OP_MTLO			0x0F5u
+#define MMIPS32_OP_MTHI			0x0B5u
+#define MMIPS32_OP_MOVN			0x018u
+#define MMIPS32_OP_ORI			0x14u
+#define MMIPS32_OP_RDHWR		0x1ACu
+#define MMIPS32_OP_SB			0x06u
+#define MMIPS32_OP_SH			0x0Eu
+#define MMIPS32_OP_SW			0x3Eu
+#define MMIPS32_OP_SLTU			0x390u
+#define MMIPS32_OP_SLL			0x000u
+#define MMIPS32_OP_SLTI			0x24u
+#define MMIPS32_OP_SRL			0x040u
+#define MMIPS32_OP_SYNCI		0x10u
+#define MMIPS32_OP_XOR			0x310u
+#define MMIPS32_OP_XORI			0x1Cu
+
+#define MMIPS32_ADDI(tar, src, val)		MIPS32_I_INST(MMIPS32_OP_ADDI, tar, src, val)
+#define MMIPS32_ADDIU(tar, src, val)		MIPS32_I_INST(MMIPS32_OP_ADDIU, tar, src, val)
+#define MMIPS32_ADDU(dst, src, tar)		MIPS32_R_INST(POOL32A, tar, src, dst, 0, MMIPS32_OP_ADDU)
+#define MMIPS32_AND(dst, src, tar)		MIPS32_R_INST(POOL32A, tar, src, dst, 0, MMIPS32_OP_AND)
+#define MMIPS32_ANDI(tar, src, val)		MIPS32_I_INST(MMIPS32_OP_ANDI, tar, src, val)
+
+#define MMIPS32_B(off)				MMIPS32_BEQ(0, 0, off)
+#define MMIPS32_BEQ(src, tar, off)		MIPS32_I_INST(MMIPS32_OP_BEQ, tar, src, off)
+#define MMIPS32_BGTZ(reg, off)			MIPS32_I_INST(POOL32I, MMIPS32_OP_BGTZ, reg, off)
+#define MMIPS32_BNE(src, tar, off)		MIPS32_I_INST(MMIPS32_OP_BNE, tar, src, off)
+#define MMIPS32_CACHE(op, off, base)		MIPS32_R_INST(POOL32B, op, base, MMIPS32_OP_CACHE << 1, 0, off)
+
+#define MMIPS32_J(tar)				MIPS32_J_INST(MMIPS32_OP_J, ((0x07FFFFFFu & ((tar) >> 1))))
+#define MMIPS32_JR(reg)				MIPS32_R_INST(POOL32A, 0, reg, 0, MMIPS32_OP_JALR, POOL32AXf)
+#define MMIPS32_LB(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_LB, reg, base, off)
+#define MMIPS32_LBU(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_LBU, reg, base, off)
+#define MMIPS32_LHU(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_LHU, reg, base, off)
+#define MMIPS32_LUI(reg, val)			MIPS32_I_INST(POOL32I, MMIPS32_OP_LUI, reg, val)
+#define MMIPS32_LW(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_LW, reg, base, off)
+
+#define MMIPS32_MFC0(gpr, cpr, sel)		MIPS32_R_INST(POOL32A, gpr, cpr, sel, MMIPS32_OP_MFC0, POOL32AXf)
+#define MMIPS32_MFLO(reg)			MIPS32_R_INST(POOL32A, 0, reg, 0, MMIPS32_OP_MFLO, POOL32AXf)
+#define MMIPS32_MFHI(reg)			MIPS32_R_INST(POOL32A, 0, reg, 0, MMIPS32_OP_MFHI, POOL32AXf)
+#define MMIPS32_MTC0(gpr, cpr, sel)		MIPS32_R_INST(POOL32A, gpr, cpr, sel, MMIPS32_OP_MTC0, POOL32AXf)
+#define MMIPS32_MTLO(reg)			MIPS32_R_INST(POOL32A, 0, reg, 0, MMIPS32_OP_MTLO, POOL32AXf)
+#define MMIPS32_MTHI(reg)			MIPS32_R_INST(POOL32A, 0, reg, 0, MMIPS32_OP_MTHI, POOL32AXf)
+
+#define MMIPS32_MOVN(dst, src, tar)		MIPS32_R_INST(POOL32A, tar, src, dst, 0, MMIPS32_OP_MOVN)
+#define MMIPS32_NOP				0
+#define MMIPS32_ORI(tar, src, val)		MIPS32_I_INST(MMIPS32_OP_ORI, tar, src, val)
+#define MMIPS32_RDHWR(tar, dst)			MIPS32_R_INST(POOL32A, dst, tar, 0, MMIPS32_OP_RDHWR, POOL32AXf)
+#define MMIPS32_SB(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_SB, reg, base, off)
+#define MMIPS32_SH(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_SH, reg, base, off)
+#define MMIPS32_SW(reg, off, base)		MIPS32_I_INST(MMIPS32_OP_SW, reg, base, off)
+
+#define MMIPS32_SRL(reg, src, off)		MIPS32_R_INST(POOL32A, reg, src, off, 0, MMIPS32_OP_SRL)
+#define MMIPS32_SLTU(dst, src, tar)		MIPS32_R_INST(POOL32A, tar, src, dst, 0, MMIPS32_OP_SLTU)
+#define MMIPS32_SYNCI(off, base)		MIPS32_I_INST(POOL32I, MMIPS32_OP_SYNCI, base, off)
+#define MMIPS32_SLL(dst, src, sa)		MIPS32_R_INST(POOL32A, dst, src, sa, 0, MMIPS32_OP_SLL)
+#define MMIPS32_SLTI(tar, src, val)		MIPS32_I_INST(MMIPS32_OP_SLTI, tar, src, val)
+#define MMIPS32_SYNC				0x00001A7Cu /* MIPS32_R_INST(POOL32A, 0, 0, 0, 0x1ADu, POOL32AXf) */
+
+#define MMIPS32_XOR(reg, val1, val2)		MIPS32_R_INST(POOL32A, val1, val2, reg, 0, MMIPS32_OP_XOR)
+#define MMIPS32_XORI(tar, src, val)		MIPS32_I_INST(MMIPS32_OP_XORI, tar, src, val)
+
+#define MMIPS32_SYNCI_STEP	0x1u	/* reg num od address step size to be used with synci instruction */
+
+
+/* ejtag specific instructions */
+#define MMIPS32_DRET			0x0000E37Cu	/* MIPS32_R_INST(POOL32A, 0, 0, 0, 0x38D, POOL32AXf) */
+#define MMIPS32_SDBBP			0x0000DB7Cu	/* MIPS32_R_INST(POOL32A, 0, 0, 0, 0x1BD, POOL32AXf) */
+#define MMIPS16_SDBBP			0x46C0u		/* POOL16C instr */
+
+/* instruction code with isa selection */
+#define MIPS32_NOP				0	/* same for both isa's */
+#define MIPS32_ADDI(isa, tar, src, val)		(isa ? MMIPS32_ADDI(tar, src, val) : MIPS32_ISA_ADDI(tar, src, val))
+#define MIPS32_ADDIU(isa, tar, src, val)	(isa ? MMIPS32_ADDIU(tar, src, val) : MIPS32_ISA_ADDIU(tar, src, val))
+#define MIPS32_ADDU(isa, dst, src, tar)		(isa ? MMIPS32_ADDU(dst, src, tar) : MIPS32_ISA_ADDU(dst, src, tar))
+#define MIPS32_AND(isa, dst, src, tar)		(isa ? MMIPS32_AND(dst, src, tar) : MIPS32_ISA_AND(dst, src, tar))
+#define MIPS32_ANDI(isa, tar, src, val)		(isa ? MMIPS32_ANDI(tar, src, val) : MIPS32_ISA_ANDI(tar, src, val))
+
+#define MIPS32_B(isa, off)			(isa ? MMIPS32_B(off) : MIPS32_ISA_B(off))
+#define MIPS32_BEQ(isa, src, tar, off)		(isa ? MMIPS32_BEQ(src, tar, off) : MIPS32_ISA_BEQ(src, tar, off))
+#define MIPS32_BGTZ(isa, reg, off)		(isa ? MMIPS32_BGTZ(reg, off) : MIPS32_ISA_BGTZ(reg, off))
+#define MIPS32_BNE(isa, src, tar, off)		(isa ? MMIPS32_BNE(src, tar, off) : MIPS32_ISA_BNE(src, tar, off))
+#define MIPS32_CACHE(isa, op, off, base)	(isa ? MMIPS32_CACHE(op, off, base) : MIPS32_ISA_CACHE(op, off, base))
+
+#define MIPS32_J(isa, tar)			(isa ? MMIPS32_J(tar) : MIPS32_ISA_J(tar))
+#define MIPS32_JR(isa, reg)			(isa ? MMIPS32_JR(reg) : MIPS32_ISA_JR(reg))
+#define MIPS32_LB(isa, reg, off, base)		(isa ? MMIPS32_LB(reg, off, base) : MIPS32_ISA_LB(reg, off, base))
+#define MIPS32_LBU(isa, reg, off, base)		(isa ? MMIPS32_LBU(reg, off, base) : MIPS32_ISA_LBU(reg, off, base))
+#define MIPS32_LHU(isa, reg, off, base)		(isa ? MMIPS32_LHU(reg, off, base) : MIPS32_ISA_LHU(reg, off, base))
+#define MIPS32_LW(isa, reg, off, base)		(isa ? MMIPS32_LW(reg, off, base) : MIPS32_ISA_LW(reg, off, base))
+#define MIPS32_LUI(isa, reg, val)		(isa ? MMIPS32_LUI(reg, val) : MIPS32_ISA_LUI(reg, val))
+
+#define MIPS32_MFC0(isa, gpr, cpr, sel)		(isa ? MMIPS32_MFC0(gpr, cpr, sel) : MIPS32_ISA_MFC0(gpr, cpr, sel))
+#define MIPS32_MTC0(isa, gpr, cpr, sel)		(isa ? MMIPS32_MTC0(gpr, cpr, sel) : MIPS32_ISA_MTC0(gpr, cpr, sel))
+#define MIPS32_MFLO(isa, reg)			(isa ? MMIPS32_MFLO(reg) : MIPS32_ISA_MFLO(reg))
+#define MIPS32_MFHI(isa, reg)			(isa ? MMIPS32_MFHI(reg) : MIPS32_ISA_MFHI(reg))
+#define MIPS32_MTLO(isa, reg)			(isa ? MMIPS32_MTLO(reg) : MIPS32_ISA_MTLO(reg))
+#define MIPS32_MTHI(isa, reg)			(isa ? MMIPS32_MTHI(reg) : MIPS32_ISA_MTHI(reg))
+
+#define MIPS32_MOVN(isa, dst, src, tar)		(isa ? MMIPS32_MOVN(dst, src, tar) : MIPS32_ISA_MOVN(dst, src, tar))
+#define MIPS32_ORI(isa, tar, src, val)		(isa ? MMIPS32_ORI(tar, src, val) : MIPS32_ISA_ORI(tar, src, val))
+#define MIPS32_RDHWR(isa, tar, dst)		(isa ? MMIPS32_RDHWR(tar, dst) : MIPS32_ISA_RDHWR(tar, dst))
+#define MIPS32_SB(isa, reg, off, base)		(isa ? MMIPS32_SB(reg, off, base) : MIPS32_ISA_SB(reg, off, base))
+#define MIPS32_SH(isa, reg, off, base)		(isa ? MMIPS32_SH(reg, off, base) : MIPS32_ISA_SH(reg, off, base))
+#define MIPS32_SW(isa, reg, off, base)		(isa ? MMIPS32_SW(reg, off, base) : MIPS32_ISA_SW(reg, off, base))
+
+#define MIPS32_SLL(isa, dst, src, sa)		(isa ? MMIPS32_SLL(dst, src, sa) : MIPS32_ISA_SLL(dst, src, sa))
+#define MIPS32_SLTI(isa, tar, src, val)		(isa ? MMIPS32_SLTI(tar, src, val) : MIPS32_ISA_SLTI(tar, src, val))
+#define MIPS32_SLTU(isa, dst, src, tar)		(isa ? MMIPS32_SLTU(dst, src, tar) : MIPS32_ISA_SLTU(dst, src, tar))
+#define MIPS32_SRL(isa, reg, src, off)		(isa ? MMIPS32_SRL(reg, src, off) : MIPS32_ISA_SRL(reg, src, off))
+
+#define MIPS32_SYNCI(isa, off, base)		(isa ? MMIPS32_SYNCI(off, base) : MIPS32_ISA_SYNCI(off, base))
+#define MIPS32_SYNC(isa)			(isa ? MMIPS32_SYNC : MIPS32_ISA_SYNC)
+#define MIPS32_XOR(isa, reg, val1, val2)	(isa ? MMIPS32_XOR(reg, val1, val2) : MIPS32_ISA_XOR(reg, val1, val2))
+#define MIPS32_XORI(isa, tar, src, val)		(isa ? MMIPS32_XORI(tar, src, val) : MIPS32_ISA_XORI(tar, src, val))
+
+#define MIPS32_SYNCI_STEP			0x1
+
+/* ejtag specific instructions */
+#define MIPS32_DRET(isa)			(isa ? MMIPS32_DRET : MIPS32_ISA_DRET)
+#define MIPS32_SDBBP(isa)			(isa ? MMIPS32_SDBBP : MIPS32_ISA_SDBBP)
+
+#define MIPS16_SDBBP(isa)			(isa ? MMIPS16_SDBBP : MIPS16_ISA_SDBBP)
 
 extern const struct command_registration mips32_command_handlers[];
 
@@ -232,7 +409,7 @@ struct reg_cache *mips32_build_reg_cache(struct target *target);
 int mips32_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
+		target_addr_t entry_point, target_addr_t exit_point,
 		int timeout_ms, void *arch_info);
 
 int mips32_configure_break_unit(struct target *target);
@@ -241,14 +418,16 @@ int mips32_enable_interrupts(struct target *target, int enable);
 
 int mips32_examine(struct target *target);
 
+int mips32_read_config_regs(struct target *target);
+
 int mips32_register_commands(struct command_context *cmd_ctx);
 
 int mips32_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
-int mips32_checksum_memory(struct target *target, uint32_t address,
+int mips32_checksum_memory(struct target *target, target_addr_t address,
 		uint32_t count, uint32_t *checksum);
 int mips32_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *blank);
+		target_addr_t address, uint32_t count, uint32_t *blank, uint8_t erased_value);
 
-#endif	/*MIPS32_H*/
+#endif /* OPENOCD_TARGET_MIPS32_H */
diff --git a/src/target/mips32_dmaacc.c b/src/target/mips32_dmaacc.c
index c2fea21d..220ea94f 100644
--- a/src/target/mips32_dmaacc.c
+++ b/src/target/mips32_dmaacc.c
@@ -18,9 +18,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/mips32_dmaacc.h b/src/target/mips32_dmaacc.h
index 45d5b361..70fe2a77 100644
--- a/src/target/mips32_dmaacc.h
+++ b/src/target/mips32_dmaacc.h
@@ -18,13 +18,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MIPS32_DMAACC_H
-#define MIPS32_DMAACC_H
+#ifndef OPENOCD_TARGET_MIPS32_DMAACC_H
+#define OPENOCD_TARGET_MIPS32_DMAACC_H
 
 #include "mips_ejtag.h"
 
@@ -40,4 +38,4 @@ int mips32_dmaacc_read_mem(struct mips_ejtag *ejtag_info,
 int mips32_dmaacc_write_mem(struct mips_ejtag *ejtag_info,
 		uint32_t addr, int size, int count, const void *buf);
 
-#endif
+#endif /* OPENOCD_TARGET_MIPS32_DMAACC_H */
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index e97626cb..790c8dc9 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -20,9 +20,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /*
@@ -75,77 +73,61 @@
 #include "mips32.h"
 #include "mips32_pracc.h"
 
-struct mips32_pracc_context {
-	uint32_t *local_oparam;
-	int num_oparam;
-	const uint32_t *code;
-	int code_len;
-	uint32_t stack[32];
-	int stack_offset;
-	struct mips_ejtag *ejtag_info;
-};
-
-static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
+static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info)
 {
-	uint32_t ejtag_ctrl;
-	long long then = timeval_ms();
+	int64_t then = timeval_ms();
 
 	/* wait for the PrAcc to become "1" */
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 
 	while (1) {
-		ejtag_ctrl = ejtag_info->ejtag_ctrl;
-		int retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		ejtag_info->pa_ctrl = ejtag_info->ejtag_ctrl;
+		int retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_info->pa_ctrl);
 		if (retval != ERROR_OK)
 			return retval;
 
-		if (ejtag_ctrl & EJTAG_CTRL_PRACC)
+		if (ejtag_info->pa_ctrl & EJTAG_CTRL_PRACC)
 			break;
 
-		int timeout = timeval_ms() - then;
+		int64_t timeout = timeval_ms() - then;
 		if (timeout > 1000) {
 			LOG_DEBUG("DEBUGMODULE: No memory access in progress!");
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
 
-	*ctrl = ejtag_ctrl;
 	return ERROR_OK;
 }
 
 /* Shift in control and address for a new processor access, save them in ejtag_info */
 static int mips32_pracc_read_ctrl_addr(struct mips_ejtag *ejtag_info)
 {
-	int retval = wait_for_pracc_rw(ejtag_info, &ejtag_info->pa_ctrl);
+	int retval = wait_for_pracc_rw(ejtag_info);
 	if (retval != ERROR_OK)
 		return retval;
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
-	ejtag_info->pa_addr = 0;
-	retval = mips_ejtag_drscan_32(ejtag_info, &ejtag_info->pa_addr);
 
-	return retval;
+	ejtag_info->pa_addr = 0;
+	return  mips_ejtag_drscan_32(ejtag_info, &ejtag_info->pa_addr);
 }
 
 /* Finish processor access */
-static int mips32_pracc_finish(struct mips_ejtag *ejtag_info)
+static void mips32_pracc_finish(struct mips_ejtag *ejtag_info)
 {
 	uint32_t ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32_out(ejtag_info, ctrl);
-
-	return jtag_execute_queue();
 }
 
 int mips32_pracc_clean_text_jump(struct mips_ejtag *ejtag_info)
 {
-	uint32_t jt_code = MIPS32_J((0x0FFFFFFF & MIPS32_PRACC_TEXT) >> 2);
-	int retval;
-
+	uint32_t jt_code = MIPS32_J(ejtag_info->isa, MIPS32_PRACC_TEXT);
+	pracc_swap16_array(ejtag_info, &jt_code, 1);
 	/* do 3 0/nops to clean pipeline before a jump to pracc text, NOP in delay slot */
 	for (int i = 0; i != 5; i++) {
 		/* Wait for pracc */
-		retval = wait_for_pracc_rw(ejtag_info, &ejtag_info->pa_ctrl);
+		int retval = wait_for_pracc_rw(ejtag_info);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -155,33 +137,33 @@ int mips32_pracc_clean_text_jump(struct mips_ejtag *ejtag_info)
 		mips_ejtag_drscan_32_out(ejtag_info, data);
 
 		/* finish pa */
-		retval = mips32_pracc_finish(ejtag_info);
-		if (retval != ERROR_OK)
-			return retval;
+		mips32_pracc_finish(ejtag_info);
 	}
 
-	if (ejtag_info->mode != 0)	/* done, queued mode won't work with lexra cores */
+	if (ejtag_info->mode != 0)	/* async mode support only for MIPS ... */
 		return ERROR_OK;
 
-	retval = mips32_pracc_read_ctrl_addr(ejtag_info);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (ejtag_info->pa_addr != MIPS32_PRACC_TEXT) {			/* LEXRA/BMIPS ?, shift out another NOP */
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
-		mips_ejtag_drscan_32_out(ejtag_info, MIPS32_NOP);
-		retval = mips32_pracc_finish(ejtag_info);
+	for (int i = 0; i != 2; i++) {
+		int retval = mips32_pracc_read_ctrl_addr(ejtag_info);
 		if (retval != ERROR_OK)
 			return retval;
+
+		if (ejtag_info->pa_addr != MIPS32_PRACC_TEXT) {	/* LEXRA/BMIPS ?, shift out another NOP, max 2 */
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
+			mips_ejtag_drscan_32_out(ejtag_info, MIPS32_NOP);
+			mips32_pracc_finish(ejtag_info);
+		} else
+			break;
 	}
 
 	return ERROR_OK;
 }
 
-int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx, uint32_t *param_out)
+int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx,
+					uint32_t *param_out, bool check_last)
 {
 	int code_count = 0;
-	int store_pending = 0;		/* increases with every store instruction at dmseg, decreases with every store pa */
+	int store_pending = 0;		/* increases with every store instr at dmseg, decreases with every store pa */
 	uint32_t max_store_addr = 0;	/* for store pa address testing */
 	bool restart = 0;		/* restarting control */
 	int restart_count = 0;
@@ -204,12 +186,12 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 			LOG_DEBUG("restarting code");
 		}
 
-		retval = mips32_pracc_read_ctrl_addr(ejtag_info);		/* update current pa info: control and address */
+		retval = mips32_pracc_read_ctrl_addr(ejtag_info); /* update current pa info: control and address */
 		if (retval != ERROR_OK)
 			return retval;
 
 		/* Check for read or write access */
-		if (ejtag_info->pa_ctrl & EJTAG_CTRL_PRNW) {						/* write/store access */
+		if (ejtag_info->pa_ctrl & EJTAG_CTRL_PRNW) {				/* write/store access */
 			/* Check for pending store from a previous store instruction at dmseg */
 			if (store_pending == 0) {
 				LOG_DEBUG("unexpected write at address %" PRIx32, ejtag_info->pa_addr);
@@ -220,8 +202,8 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 					return ERROR_JTAG_DEVICE_ERROR;
 			} else {
 				/* check address */
-				if (ejtag_info->pa_addr < MIPS32_PRACC_PARAM_OUT || ejtag_info->pa_addr > max_store_addr) {
-
+				if (ejtag_info->pa_addr < MIPS32_PRACC_PARAM_OUT ||
+						ejtag_info->pa_addr > max_store_addr) {
 					LOG_DEBUG("writing at unexpected address %" PRIx32, ejtag_info->pa_addr);
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
@@ -245,7 +227,8 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 							ejtag_info->pa_addr, MIPS32_PRACC_TEXT + code_count * 4);
 
 					/* restart code execution only in some cases */
-					if (code_count == 1 && ejtag_info->pa_addr == MIPS32_PRACC_TEXT && restart_count == 0) {
+					if (code_count == 1 && ejtag_info->pa_addr == MIPS32_PRACC_TEXT &&
+										restart_count == 0) {
 						LOG_DEBUG("restarting, without clean jump");
 						restart_count++;
 						code_count = 0;
@@ -254,18 +237,17 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 						restart = 1;
 						continue;
 					}
-
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
 				/* check for store instruction at dmseg */
-				uint32_t store_addr = ctx->pracc_list[ctx->max_code + code_count];
+				uint32_t store_addr = ctx->pracc_list[code_count].addr;
 				if (store_addr != 0) {
 					if (store_addr > max_store_addr)
 						max_store_addr = store_addr;
 					store_pending++;
 				}
 
-				instr = ctx->pracc_list[code_count++];
+				instr = ctx->pracc_list[code_count++].instr;
 				if (code_count == ctx->code_count)	/* last instruction, start final check */
 					final_check = 1;
 
@@ -283,13 +265,14 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 					}
 				} else {
 					if (ejtag_info->pa_addr != (MIPS32_PRACC_TEXT + code_count * 4)) {
-						LOG_DEBUG("unexpected read address in final check: %" PRIx32 ", expected: %x",
-							  ejtag_info->pa_addr, MIPS32_PRACC_TEXT + code_count * 4);
+						LOG_DEBUG("unexpected read address in final check: %"
+							PRIx32 ", expected: %x", ejtag_info->pa_addr,
+							MIPS32_PRACC_TEXT + code_count * 4);
 						return ERROR_JTAG_DEVICE_ERROR;
 					}
 				}
 				if (!pass) {
-					if ((code_count - ctx->code_count) > 1) {	 /* allow max 2 instruction delay slot */
+					if ((code_count - ctx->code_count) > 1) { /* allow max 2 instr delay slot */
 						LOG_DEBUG("failed to jump back to pracc text");
 						return ERROR_JTAG_DEVICE_ERROR;
 					}
@@ -307,12 +290,10 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ct
 			mips_ejtag_drscan_32_out(ejtag_info, instr);
 		}
 		/* finish processor access, let the processor eat! */
-		retval = mips32_pracc_finish(ejtag_info);
-		if (retval != ERROR_OK)
-			return retval;
+		mips32_pracc_finish(ejtag_info);
 
-		if (instr == MIPS32_DRET)	/* after leaving debug mode nothing to do */
-			return ERROR_OK;
+		if (final_check && !check_last)			/* last instr, don't check, execute and exit */
+			return jtag_execute_queue();
 
 		if (store_pending == 0 && pass) {	/* store access done, but after passing pracc text */
 			LOG_DEBUG("warning: store access pass pracc text");
@@ -326,34 +307,63 @@ inline void pracc_queue_init(struct pracc_queue_info *ctx)
 	ctx->retval = ERROR_OK;
 	ctx->code_count = 0;
 	ctx->store_count = 0;
-
-	ctx->pracc_list = malloc(2 * ctx->max_code * sizeof(uint32_t));
-	if (ctx->pracc_list == NULL) {
-		LOG_ERROR("Out of memory");
-		ctx->retval = ERROR_FAIL;
-	}
+	ctx->max_code = 0;
+	ctx->pracc_list = NULL;
+	ctx->isa = ctx->ejtag_info->isa ? 1 : 0;
 }
 
-inline void pracc_add(struct pracc_queue_info *ctx, uint32_t addr, uint32_t instr)
+void pracc_add(struct pracc_queue_info *ctx, uint32_t addr, uint32_t instr)
 {
-	ctx->pracc_list[ctx->max_code + ctx->code_count] = addr;
-	ctx->pracc_list[ctx->code_count++] = instr;
+	if (ctx->retval != ERROR_OK)	/* On previous out of memory, return */
+		return;
+	if (ctx->code_count == ctx->max_code) {
+		void *p = realloc(ctx->pracc_list, sizeof(pa_list) * (ctx->max_code + PRACC_BLOCK));
+		if (p) {
+			ctx->max_code += PRACC_BLOCK;
+			ctx->pracc_list = p;
+		} else {
+			ctx->retval = ERROR_FAIL;	/* Out of memory */
+			return;
+		}
+	}
+	ctx->pracc_list[ctx->code_count].instr = instr;
+	ctx->pracc_list[ctx->code_count++].addr = addr;
 	if (addr)
 		ctx->store_count++;
 }
 
+void pracc_add_li32(struct pracc_queue_info *ctx, uint32_t reg_num, uint32_t data, bool optimize)
+{
+	if (LOWER16(data) == 0 && optimize)
+		pracc_add(ctx, 0, MIPS32_LUI(ctx->isa, reg_num, UPPER16(data)));	/* load only upper value */
+	else if (UPPER16(data) == 0 && optimize)
+		pracc_add(ctx, 0, MIPS32_ORI(ctx->isa, reg_num, 0, LOWER16(data)));	/* load only lower */
+	else {
+		pracc_add(ctx, 0, MIPS32_LUI(ctx->isa, reg_num, UPPER16(data)));	/* load upper and lower */
+		pracc_add(ctx, 0, MIPS32_ORI(ctx->isa, reg_num, reg_num, LOWER16(data)));
+	}
+}
+
 inline void pracc_queue_free(struct pracc_queue_info *ctx)
 {
-	if (ctx->code_count > ctx->max_code)	/* Only for internal check, will be erased */
-		LOG_ERROR("Internal error, code count: %d > max code: %d", ctx->code_count, ctx->max_code);
 	if (ctx->pracc_list != NULL)
 		free(ctx->pracc_list);
 }
 
-int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx, uint32_t *buf)
+int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx,
+					uint32_t *buf, bool check_last)
 {
+	if (ctx->retval != ERROR_OK) {
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
+
+	if (ejtag_info->isa && ejtag_info->endianness)
+		for (int i = 0; i != ctx->code_count; i++)
+			ctx->pracc_list[i].instr = SWAP16(ctx->pracc_list[i].instr);
+
 	if (ejtag_info->mode == 0)
-		return mips32_pracc_exec(ejtag_info, ctx, buf);
+		return mips32_pracc_exec(ejtag_info, ctx, buf, check_last);
 
 	union scan_in {
 		uint8_t scan_96[12];
@@ -376,16 +386,16 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ALL);
 
 	int scan_count = 0;
-	for (int i = 0; i != 2 * ctx->code_count; i++) {
-		uint32_t data = 0;
-		if (i & 1u) {			/* Check store address from previous instruction, if not the first */
-			if (i < 2 || 0 == ctx->pracc_list[ctx->max_code + (i / 2) - 1])
-				continue;
-		} else
-			data = ctx->pracc_list[i / 2];
-
+	for (int i = 0; i != ctx->code_count; i++) {
 		jtag_add_clocks(num_clocks);
-		mips_ejtag_add_scan_96(ejtag_info, ejtag_ctrl, data, scan_in[scan_count++].scan_96);
+		mips_ejtag_add_scan_96(ejtag_info, ejtag_ctrl, ctx->pracc_list[i].instr,
+				       scan_in[scan_count++].scan_96);
+
+		/* Check store address from previous instruction, if not the first */
+		if (i > 0 && ctx->pracc_list[i - 1].addr) {
+			jtag_add_clocks(num_clocks);
+			mips_ejtag_add_scan_96(ejtag_info, ejtag_ctrl, 0, scan_in[scan_count++].scan_96);
+		}
 	}
 
 	int retval = jtag_execute_queue();		/* execute queued scans */
@@ -394,24 +404,35 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 
 	uint32_t fetch_addr = MIPS32_PRACC_TEXT;		/* start address */
 	scan_count = 0;
-	for (int i = 0; i != 2 * ctx->code_count; i++) {				/* verify every pracc access */
-		uint32_t store_addr = 0;
-		if (i & 1u) {			/* Read store addres from previous instruction, if not the first */
-			store_addr = ctx->pracc_list[ctx->max_code + (i / 2) - 1];
-			if (i < 2 || 0 == store_addr)
-				continue;
-		}
-
+	for (int i = 0; i != ctx->code_count; i++) {				/* verify every pracc access */
+		/* check pracc bit */
 		ejtag_ctrl = buf_get_u32(scan_in[scan_count].scan_32.ctrl, 0, 32);
+		uint32_t addr = buf_get_u32(scan_in[scan_count].scan_32.addr, 0, 32);
 		if (!(ejtag_ctrl & EJTAG_CTRL_PRACC)) {
 			LOG_ERROR("Error: access not pending  count: %d", scan_count);
 			retval = ERROR_FAIL;
 			goto exit;
 		}
+		if (ejtag_ctrl & EJTAG_CTRL_PRNW) {
+			LOG_ERROR("Not a fetch/read access, count: %d", scan_count);
+			retval = ERROR_FAIL;
+			goto exit;
+		}
+		if (addr != fetch_addr) {
+			LOG_ERROR("Fetch addr mismatch, read: %" PRIx32 " expected: %" PRIx32 " count: %d",
+					  addr, fetch_addr, scan_count);
+			retval = ERROR_FAIL;
+			goto exit;
+		}
+		fetch_addr += 4;
+		scan_count++;
 
-		uint32_t addr = buf_get_u32(scan_in[scan_count].scan_32.addr, 0, 32);
+		/* check if previous intrucction is a store instruction at dmesg */
+		if (i > 0 && ctx->pracc_list[i - 1].addr) {
+			uint32_t store_addr = ctx->pracc_list[i - 1].addr;
+			ejtag_ctrl = buf_get_u32(scan_in[scan_count].scan_32.ctrl, 0, 32);
+			addr = buf_get_u32(scan_in[scan_count].scan_32.addr, 0, 32);
 
-		if (store_addr != 0) {
 			if (!(ejtag_ctrl & EJTAG_CTRL_PRNW)) {
 				LOG_ERROR("Not a store/write access, count: %d", scan_count);
 				retval = ERROR_FAIL;
@@ -419,28 +440,14 @@ int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_in
 			}
 			if (addr != store_addr) {
 				LOG_ERROR("Store address mismatch, read: %" PRIx32 " expected: %" PRIx32 " count: %d",
-						addr, store_addr, scan_count);
+							      addr, store_addr, scan_count);
 				retval = ERROR_FAIL;
 				goto exit;
 			}
 			int buf_index = (addr - MIPS32_PRACC_PARAM_OUT) / 4;
 			buf[buf_index] = buf_get_u32(scan_in[scan_count].scan_32.data, 0, 32);
-
-		} else {
-			if (ejtag_ctrl & EJTAG_CTRL_PRNW) {
-				LOG_ERROR("Not a fetch/read access, count: %d", scan_count);
-				retval = ERROR_FAIL;
-				goto exit;
-			}
-			if (addr != fetch_addr) {
-				LOG_ERROR("Fetch addr mismatch, read: %" PRIx32 " expected: %" PRIx32 " count: %d",
-					  addr, fetch_addr, scan_count);
-				retval = ERROR_FAIL;
-				goto exit;
-			}
-			fetch_addr += 4;
+			scan_count++;
 		}
-		scan_count++;
 	}
 exit:
 	free(scan_in);
@@ -449,23 +456,19 @@ exit:
 
 int mips32_pracc_read_u32(struct mips_ejtag *ejtag_info, uint32_t addr, uint32_t *buf)
 {
-	struct pracc_queue_info ctx = {.max_code = 8};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
-	pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));			/* $15 = MIPS32_PRACC_BASE_ADDR */
-	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16((addr + 0x8000))));		/* load  $8 with modified upper address */
-	pracc_add(&ctx, 0, MIPS32_LW(8, LOWER16(addr), 8));				/* lw $8, LOWER16(addr)($8) */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, PRACC_UPPER_BASE_ADDR));	/* $15 = MIPS32_PRACC_BASE_ADDR */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 8, UPPER16((addr + 0x8000)))); /* load  $8 with modified upper addr */
+	pracc_add(&ctx, 0, MIPS32_LW(ctx.isa, 8, LOWER16(addr), 8));			/* lw $8, LOWER16(addr)($8) */
 	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT,
-				MIPS32_SW(8, PRACC_OUT_OFFSET, 15));			/* sw $8,PRACC_OUT_OFFSET($15) */
-	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 of $8 */
-	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));		/* restore lower 16 of $8 */
-	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
+				MIPS32_SW(ctx.isa, 8, PRACC_OUT_OFFSET, 15));	/* sw $8,PRACC_OUT_OFFSET($15) */
+	pracc_add_li32(&ctx, 8, ejtag_info->reg8, 0);				/* restore $8 */
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));				/* move COP0 DeSave to $15 */
 
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, buf);
-exit:
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, buf, 1);
 	pracc_queue_free(&ctx);
 	return ctx.retval;
 }
@@ -475,12 +478,10 @@ int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size
 	if (count == 1 && size == 4)
 		return mips32_pracc_read_u32(ejtag_info, addr, (uint32_t *)buf);
 
-	uint32_t *data = NULL;
-	struct pracc_queue_info ctx = {.max_code = 256 * 3 + 8 + 1};	/* alloc memory for the worst case */
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
+	uint32_t *data = NULL;
 	if (size != 4) {
 		data = malloc(256 * sizeof(uint32_t));
 		if (data == NULL) {
@@ -496,45 +497,44 @@ int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size
 	while (count) {
 		ctx.code_count = 0;
 		ctx.store_count = 0;
+
 		int this_round_count = (count > 256) ? 256 : count;
 		uint32_t last_upper_base_addr = UPPER16((addr + 0x8000));
 
-		pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));			/* $15 = MIPS32_PRACC_BASE_ADDR */
-		pracc_add(&ctx, 0, MIPS32_LUI(9, last_upper_base_addr));		/* load the upper memory address in $9 */
+		pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, PRACC_UPPER_BASE_ADDR)); /* $15 = MIPS32_PRACC_BASE_ADDR */
+		pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 9, last_upper_base_addr));	/* upper memory addr to $9 */
 
 		for (int i = 0; i != this_round_count; i++) {			/* Main code loop */
 			uint32_t upper_base_addr = UPPER16((addr + 0x8000));
-			if (last_upper_base_addr != upper_base_addr) {			/* if needed, change upper address in $9 */
-				pracc_add(&ctx, 0, MIPS32_LUI(9, upper_base_addr));
+			if (last_upper_base_addr != upper_base_addr) {	/* if needed, change upper addr in $9 */
+				pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 9, upper_base_addr));
 				last_upper_base_addr = upper_base_addr;
 			}
 
-			if (size == 4)
-				pracc_add(&ctx, 0, MIPS32_LW(8, LOWER16(addr), 9));		/* load from memory to $8 */
+			if (size == 4)				/* load from memory to $8 */
+				pracc_add(&ctx, 0, MIPS32_LW(ctx.isa, 8, LOWER16(addr), 9));
 			else if (size == 2)
-				pracc_add(&ctx, 0, MIPS32_LHU(8, LOWER16(addr), 9));
+				pracc_add(&ctx, 0, MIPS32_LHU(ctx.isa, 8, LOWER16(addr), 9));
 			else
-				pracc_add(&ctx, 0, MIPS32_LBU(8, LOWER16(addr), 9));
+				pracc_add(&ctx, 0, MIPS32_LBU(ctx.isa, 8, LOWER16(addr), 9));
 
-			pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + i * 4,
-					  MIPS32_SW(8, PRACC_OUT_OFFSET + i * 4, 15));		/* store $8 at param out */
+			pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + i * 4,			/* store $8 at param out */
+					  MIPS32_SW(ctx.isa, 8, PRACC_OUT_OFFSET + i * 4, 15));
 			addr += size;
 		}
-		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 bits of reg 8 */
-		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 bits of reg 8 */
-		pracc_add(&ctx, 0, MIPS32_LUI(9, UPPER16(ejtag_info->reg9)));		/* restore upper 16 bits of reg 9 */
-		pracc_add(&ctx, 0, MIPS32_ORI(9, 9, LOWER16(ejtag_info->reg9)));	/* restore lower 16 bits of reg 9 */
+		pracc_add_li32(&ctx, 8, ejtag_info->reg8, 0);				/* restore $8 */
+		pracc_add_li32(&ctx, 9, ejtag_info->reg9, 0);				/* restore $9 */
 
-		pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));				/* jump to start */
-		pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* restore $15 from DeSave */
+		pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));	/* jump to start */
+		pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));			/* restore $15 from DeSave */
 
 		if (size == 4) {
-			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, buf32);
+			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, buf32, 1);
 			if (ctx.retval != ERROR_OK)
 				goto exit;
 			buf32 += this_round_count;
 		} else {
-			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, data);
+			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, data, 1);
 			if (ctx.retval != ERROR_OK)
 				goto exit;
 
@@ -557,68 +557,37 @@ exit:
 
 int mips32_cp0_read(struct mips_ejtag *ejtag_info, uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel)
 {
-	struct pracc_queue_info ctx = {.max_code = 7};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
-	pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));			/* $15 = MIPS32_PRACC_BASE_ADDR */
-	pracc_add(&ctx, 0, MIPS32_MFC0(8, 0, 0) | (cp0_reg << 11) | cp0_sel);	/* move COP0 [cp0_reg select] to $8 */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, PRACC_UPPER_BASE_ADDR));	/* $15 = MIPS32_PRACC_BASE_ADDR */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 8, cp0_reg, cp0_sel));		/* move cp0 reg / sel to $8 */
 	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT,
-				MIPS32_SW(8, PRACC_OUT_OFFSET, 15));			/* store $8 to pracc_out */
-	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
-	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 bits  of $8 */
-	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));		/* restore lower 16 bits of $8 */
+				MIPS32_SW(ctx.isa, 8, PRACC_OUT_OFFSET, 15));	/* store $8 to pracc_out */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));				/* restore $15 from DeSave */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 8, UPPER16(ejtag_info->reg8)));	/* restore upper 16 bits  of $8 */
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_ORI(ctx.isa, 8, 8, LOWER16(ejtag_info->reg8))); /* restore lower 16 bits of $8 */
 
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, val);
-exit:
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, val, 1);
 	pracc_queue_free(&ctx);
 	return ctx.retval;
-
-	/**
-	 * Note that our input parametes cp0_reg and cp0_sel
-	 * are numbers (not gprs) which make part of mfc0 instruction opcode.
-	 *
-	 * These are not fix, but can be different for each mips32_cp0_read() function call,
-	 * and that is why we must insert them directly into opcode,
-	 * i.e. we can not pass it on EJTAG microprogram stack (via param_in),
-	 * and put them into the gprs later from MIPS32_PRACC_STACK
-	 * because mfc0 do not use gpr as a parameter for the cp0_reg and select part,
-	 * but plain (immediate) number.
-	 *
-	 * MIPS32_MTC0 is implemented via MIPS32_R_INST macro.
-	 * In order to insert our parameters, we must change rd and funct fields.
-	 *
-	 * code[2] |= (cp0_reg << 11) | cp0_sel;   change rd and funct of MIPS32_R_INST macro
-	 **/
 }
 
 int mips32_cp0_write(struct mips_ejtag *ejtag_info, uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel)
 {
-	struct pracc_queue_info ctx = {.max_code = 6};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
-	pracc_add(&ctx, 0, MIPS32_LUI(15, UPPER16(val)));				/* Load val to $15 */
-	pracc_add(&ctx, 0, MIPS32_ORI(15, 15, LOWER16(val)));
+	pracc_add_li32(&ctx, 15, val, 0);				/* Load val to $15 */
 
-	pracc_add(&ctx, 0, MIPS32_MTC0(15, 0, 0) | (cp0_reg << 11) | cp0_sel);	/* write cp0 reg / sel */
+	pracc_add(&ctx, 0, MIPS32_MTC0(ctx.isa, 15, cp0_reg, cp0_sel));		/* write $15 to cp0 reg / sel */
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));			/* restore $15 from DeSave */
 
-	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
-
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
-exit:
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 1);
 	pracc_queue_free(&ctx);
 	return ctx.retval;
-
-	/**
-	 * Note that MIPS32_MTC0 macro is implemented via MIPS32_R_INST macro.
-	 * In order to insert our parameters, we must change rd and funct fields.
-	 * code[3] |= (cp0_reg << 11) | cp0_sel;   change rd and funct fields of MIPS32_R_INST macro
-	 **/
 }
 
 /**
@@ -651,26 +620,25 @@ exit:
 static int mips32_pracc_synchronize_cache(struct mips_ejtag *ejtag_info,
 					 uint32_t start_addr, uint32_t end_addr, int cached, int rel)
 {
-	struct pracc_queue_info ctx = {.max_code = 256 * 2 + 5};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
+
 	/** Find cache line size in bytes */
 	uint32_t clsiz;
 	if (rel) {	/* Release 2 (rel = 1) */
-		pracc_add(&ctx, 0, MIPS32_LUI(15, PRACC_UPPER_BASE_ADDR));			/* $15 = MIPS32_PRACC_BASE_ADDR */
+		pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, PRACC_UPPER_BASE_ADDR)); /* $15 = MIPS32_PRACC_BASE_ADDR */
 
-		pracc_add(&ctx, 0, MIPS32_RDHWR(8, MIPS32_SYNCI_STEP));			/* load synci_step value to $8 */
+		pracc_add(&ctx, 0, MIPS32_RDHWR(ctx.isa, 8, MIPS32_SYNCI_STEP)); /* load synci_step value to $8 */
 
 		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT,
-				MIPS32_SW(8, PRACC_OUT_OFFSET, 15));			/* store $8 to pracc_out */
+				MIPS32_SW(ctx.isa, 8, PRACC_OUT_OFFSET, 15));		/* store $8 to pracc_out */
 
-		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));			/* restore upper 16 bits  of $8 */
-		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));		/* restore lower 16 bits of $8 */
-		pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-		pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* move COP0 DeSave to $15 */
+		pracc_add_li32(&ctx, 8, ejtag_info->reg8, 0);				/* restore $8 */
 
-		ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, &clsiz);
+		pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));	/* jump to start */
+		pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));			/* restore $15 from DeSave */
+
+		ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, &clsiz, 1);
 		if (ctx.retval != ERROR_OK)
 			goto exit;
 
@@ -703,47 +671,50 @@ static int mips32_pracc_synchronize_cache(struct mips_ejtag *ejtag_info,
 	end_addr |= clsiz - 1;
 
 	ctx.code_count = 0;
+	ctx.store_count = 0;
+
 	int count = 0;
 	uint32_t last_upper_base_addr = UPPER16((start_addr + 0x8000));
 
-	pracc_add(&ctx, 0, MIPS32_LUI(15, last_upper_base_addr));		/* load upper memory base address to $15 */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, last_upper_base_addr)); /* load upper memory base addr to $15 */
 
 	while (start_addr <= end_addr) {						/* main loop */
 		uint32_t upper_base_addr = UPPER16((start_addr + 0x8000));
-		if (last_upper_base_addr != upper_base_addr) {				/* if needed, change upper address in $15 */
-			pracc_add(&ctx, 0, MIPS32_LUI(15, upper_base_addr));
+		if (last_upper_base_addr != upper_base_addr) {		/* if needed, change upper addr in $15 */
+			pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, upper_base_addr));
 			last_upper_base_addr = upper_base_addr;
 		}
-		if (rel)
-			pracc_add(&ctx, 0, MIPS32_SYNCI(LOWER16(start_addr), 15));		/* synci instruction, offset($15) */
+		if (rel)			/* synci instruction, offset($15) */
+			pracc_add(&ctx, 0, MIPS32_SYNCI(ctx.isa, LOWER16(start_addr), 15));
 
 		else {
-			if (cached == 3)
-				pracc_add(&ctx, 0, MIPS32_CACHE(MIPS32_CACHE_D_HIT_WRITEBACK,
-							LOWER16(start_addr), 15));		/* cache Hit_Writeback_D, offset($15) */
-
-			pracc_add(&ctx, 0, MIPS32_CACHE(MIPS32_CACHE_I_HIT_INVALIDATE,
-							LOWER16(start_addr), 15));		/* cache Hit_Invalidate_I, offset($15) */
+			if (cached == 3)	/* cache Hit_Writeback_D, offset($15) */
+				pracc_add(&ctx, 0, MIPS32_CACHE(ctx.isa, MIPS32_CACHE_D_HIT_WRITEBACK,
+							LOWER16(start_addr), 15));
+			/* cache Hit_Invalidate_I, offset($15) */
+			pracc_add(&ctx, 0, MIPS32_CACHE(ctx.isa, MIPS32_CACHE_I_HIT_INVALIDATE,
+							LOWER16(start_addr), 15));
 		}
 		start_addr += clsiz;
 		count++;
-		if (count == 256 && start_addr <= end_addr) {				/* more ?, then execute code list */
-			pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));		/* jump to start */
-			pracc_add(&ctx, 0, MIPS32_NOP);						/* nop in delay slot */
+		if (count == 256 && start_addr <= end_addr) {			/* more ?, then execute code list */
+			pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));	/* to start */
+			pracc_add(&ctx, 0, MIPS32_NOP);					/* nop in delay slot */
 
-			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+			ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 1);
 			if (ctx.retval != ERROR_OK)
 				goto exit;
 
-			ctx.code_count = 0;
+			ctx.code_count = 0;	/* reset counters for another loop */
+			ctx.store_count = 0;
 			count = 0;
 		}
 	}
-	pracc_add(&ctx, 0, MIPS32_SYNC);
-	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));					/* restore $15 from DeSave*/
+	pracc_add(&ctx, 0, MIPS32_SYNC(ctx.isa));
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));				/* restore $15 from DeSave*/
 
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 1);
 exit:
 	pracc_queue_free(&ctx);
 	return ctx.retval;
@@ -752,10 +723,8 @@ exit:
 static int mips32_pracc_write_mem_generic(struct mips_ejtag *ejtag_info,
 		uint32_t addr, int size, int count, const void *buf)
 {
-	struct pracc_queue_info ctx = {.max_code = 128 * 3 + 5 + 1};	/* alloc memory for the worst case */
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
 	const uint32_t *buf32 = buf;
 	const uint16_t *buf16 = buf;
@@ -764,50 +733,43 @@ static int mips32_pracc_write_mem_generic(struct mips_ejtag *ejtag_info,
 	while (count) {
 		ctx.code_count = 0;
 		ctx.store_count = 0;
+
 		int this_round_count = (count > 128) ? 128 : count;
 		uint32_t last_upper_base_addr = UPPER16((addr + 0x8000));
-
-		pracc_add(&ctx, 0, MIPS32_LUI(15, last_upper_base_addr));		/* load $15 with memory base address */
+			      /* load $15 with memory base address */
+		pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, last_upper_base_addr));
 
 		for (int i = 0; i != this_round_count; i++) {
 			uint32_t upper_base_addr = UPPER16((addr + 0x8000));
-			if (last_upper_base_addr != upper_base_addr) {
-				pracc_add(&ctx, 0, MIPS32_LUI(15, upper_base_addr));	/* if needed, change upper address in $15*/
+			if (last_upper_base_addr != upper_base_addr) {	/* if needed, change upper address in $15*/
+				pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 15, upper_base_addr));
 				last_upper_base_addr = upper_base_addr;
 			}
 
-			if (size == 4) {			/* for word writes check if one half word is 0 and load it accordingly */
-				if (LOWER16(*buf32) == 0)
-					pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(*buf32)));		/* load only upper value */
-				else if (UPPER16(*buf32) == 0)
-						pracc_add(&ctx, 0, MIPS32_ORI(8, 0, LOWER16(*buf32)));	/* load only lower */
-				else {
-					pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(*buf32)));		/* load upper and lower */
-					pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(*buf32)));
-				}
-				pracc_add(&ctx, 0, MIPS32_SW(8, LOWER16(addr), 15));		/* store word to memory */
+			if (size == 4) {
+				pracc_add_li32(&ctx, 8, *buf32, 1);		/* load with li32, optimize */
+				pracc_add(&ctx, 0, MIPS32_SW(ctx.isa, 8, LOWER16(addr), 15)); /* store word to mem */
 				buf32++;
 
 			} else if (size == 2) {
-				pracc_add(&ctx, 0, MIPS32_ORI(8, 0, *buf16));		/* load lower value */
-				pracc_add(&ctx, 0, MIPS32_SH(8, LOWER16(addr), 15));	/* store half word to memory */
+				pracc_add(&ctx, 0, MIPS32_ORI(ctx.isa, 8, 0, *buf16));		/* load lower value */
+				pracc_add(&ctx, 0, MIPS32_SH(ctx.isa, 8, LOWER16(addr), 15)); /* store half word */
 				buf16++;
 
 			} else {
-				pracc_add(&ctx, 0, MIPS32_ORI(8, 0, *buf8));		/* load lower value */
-				pracc_add(&ctx, 0, MIPS32_SB(8, LOWER16(addr), 15));	/* store byte to memory */
+				pracc_add(&ctx, 0, MIPS32_ORI(ctx.isa, 8, 0, *buf8));		/* load lower value */
+				pracc_add(&ctx, 0, MIPS32_SB(ctx.isa, 8, LOWER16(addr), 15));	/* store byte */
 				buf8++;
 			}
 			addr += size;
 		}
 
-		pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 bits of reg 8 */
-		pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 bits of reg 8 */
+		pracc_add_li32(&ctx, 8, ejtag_info->reg8, 0);				/* restore $8 */
 
-		pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));				/* jump to start */
-		pracc_add(&ctx, 0, MIPS32_MFC0(15, 31, 0));				/* restore $15 from DeSave */
+		pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));	/* jump to start */
+		pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 15, 31, 0));			/* restore $15 from DeSave */
 
-		ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+		ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 1);
 		if (ctx.retval != ERROR_OK)
 			goto exit;
 		count -= this_round_count;
@@ -874,95 +836,77 @@ int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int siz
 
 int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 {
-	static const uint32_t cp0_write_code[] = {
-		MIPS32_MTC0(1, 12, 0),							/* move $1 to status */
-		MIPS32_MTLO(1),									/* move $1 to lo */
-		MIPS32_MTHI(1),									/* move $1 to hi */
-		MIPS32_MTC0(1, 8, 0),							/* move $1 to badvaddr */
-		MIPS32_MTC0(1, 13, 0),							/* move $1 to cause*/
-		MIPS32_MTC0(1, 24, 0),							/* move $1 to depc (pc) */
-	};
-
-	struct pracc_queue_info ctx = {.max_code = 37 * 2 + 7 + 1};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
-	/* load registers 2 to 31 with lui and ori instructions, check if some instructions can be saved */
-	for (int i = 2; i < 32; i++) {
-		if (LOWER16((regs[i])) == 0)					/* if lower half word is 0, lui instruction only */
-			pracc_add(&ctx, 0, MIPS32_LUI(i, UPPER16((regs[i]))));
-		else if (UPPER16((regs[i])) == 0)					/* if upper half word is 0, ori with $0 only*/
-			pracc_add(&ctx, 0, MIPS32_ORI(i, 0, LOWER16((regs[i]))));
-		else {									/* default, load with lui and ori instructions */
-			pracc_add(&ctx, 0, MIPS32_LUI(i, UPPER16((regs[i]))));
-			pracc_add(&ctx, 0, MIPS32_ORI(i, i, LOWER16((regs[i]))));
-		}
-	}
+	uint32_t cp0_write_code[] = {
+		MIPS32_MTC0(ctx.isa, 1, 12, 0),					/* move $1 to status */
+		MIPS32_MTLO(ctx.isa, 1),						/* move $1 to lo */
+		MIPS32_MTHI(ctx.isa, 1),						/* move $1 to hi */
+		MIPS32_MTC0(ctx.isa, 1, 8, 0),					/* move $1 to badvaddr */
+		MIPS32_MTC0(ctx.isa, 1, 13, 0),					/* move $1 to cause*/
+		MIPS32_MTC0(ctx.isa, 1, 24, 0),					/* move $1 to depc (pc) */
+	};
+
+	/* load registers 2 to 31 with li32, optimize */
+	for (int i = 2; i < 32; i++)
+		pracc_add_li32(&ctx, i, regs[i], 1);
 
 	for (int i = 0; i != 6; i++) {
-		pracc_add(&ctx, 0, MIPS32_LUI(1, UPPER16((regs[i + 32]))));		/* load CPO value in $1, with lui and ori */
-		pracc_add(&ctx, 0, MIPS32_ORI(1, 1, LOWER16((regs[i + 32]))));
-		pracc_add(&ctx, 0, cp0_write_code[i]);					/* write value from $1 to CPO register */
+		pracc_add_li32(&ctx, 1, regs[i + 32], 0);	/* load CPO value in $1 */
+		pracc_add(&ctx, 0, cp0_write_code[i]);			/* write value from $1 to CPO register */
 	}
-	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));				/* load $15 in DeSave */
-	pracc_add(&ctx, 0, MIPS32_LUI(1, UPPER16((regs[1]))));			/* load upper half word in $1 */
-	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_ORI(1, 1, LOWER16((regs[1]))));		/* load lower half word in $1 */
+	pracc_add(&ctx, 0, MIPS32_MTC0(ctx.isa, 15, 31, 0));				/* load $15 in DeSave */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 1, UPPER16((regs[1]))));		/* load upper half word in $1 */
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_ORI(ctx.isa, 1, 1, LOWER16((regs[1]))));	/* load lower half word in $1 */
 
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 1);
 
 	ejtag_info->reg8 = regs[8];
 	ejtag_info->reg9 = regs[9];
-exit:
 	pracc_queue_free(&ctx);
 	return ctx.retval;
 }
 
 int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 {
-	static int cp0_read_code[] = {
-		MIPS32_MFC0(8, 12, 0),							/* move status to $8 */
-		MIPS32_MFLO(8),									/* move lo to $8 */
-		MIPS32_MFHI(8),									/* move hi to $8 */
-		MIPS32_MFC0(8, 8, 0),							/* move badvaddr to $8 */
-		MIPS32_MFC0(8, 13, 0),							/* move cause to $8 */
-		MIPS32_MFC0(8, 24, 0),							/* move depc (pc) to $8 */
-	};
-
-	struct pracc_queue_info ctx = {.max_code = 49};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
-	pracc_add(&ctx, 0, MIPS32_MTC0(1, 31, 0));						/* move $1 to COP0 DeSave */
-	pracc_add(&ctx, 0, MIPS32_LUI(1, PRACC_UPPER_BASE_ADDR));				/* $1 = MIP32_PRACC_BASE_ADDR */
+	uint32_t cp0_read_code[] = {
+		MIPS32_MFC0(ctx.isa, 8, 12, 0),					/* move status to $8 */
+		MIPS32_MFLO(ctx.isa, 8),						/* move lo to $8 */
+		MIPS32_MFHI(ctx.isa, 8),						/* move hi to $8 */
+		MIPS32_MFC0(ctx.isa, 8, 8, 0),					/* move badvaddr to $8 */
+		MIPS32_MFC0(ctx.isa, 8, 13, 0),					/* move cause to $8 */
+		MIPS32_MFC0(ctx.isa, 8, 24, 0),					/* move depc (pc) to $8 */
+	};
+
+	pracc_add(&ctx, 0, MIPS32_MTC0(ctx.isa, 1, 31, 0));				/* move $1 to COP0 DeSave */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 1, PRACC_UPPER_BASE_ADDR));	/* $1 = MIP32_PRACC_BASE_ADDR */
 
 	for (int i = 2; i != 32; i++)					/* store GPR's 2 to 31 */
 		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + (i * 4),
-				  MIPS32_SW(i, PRACC_OUT_OFFSET + (i * 4), 1));
+				  MIPS32_SW(ctx.isa, i, PRACC_OUT_OFFSET + (i * 4), 1));
 
 	for (int i = 0; i != 6; i++) {
 		pracc_add(&ctx, 0, cp0_read_code[i]);				/* load COP0 needed registers to $8 */
 		pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + (i + 32) * 4,			/* store $8 at PARAM OUT */
-				  MIPS32_SW(8, PRACC_OUT_OFFSET + (i + 32) * 4, 1));
+				  MIPS32_SW(ctx.isa, 8, PRACC_OUT_OFFSET + (i + 32) * 4, 1));
 	}
-	pracc_add(&ctx, 0, MIPS32_MFC0(8, 31, 0));					/* move DeSave to $8, reg1 value */
-	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + 4,					/* store reg1 value from $8 to param out */
-			  MIPS32_SW(8, PRACC_OUT_OFFSET + 4, 1));
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 8, 31, 0));			/* move DeSave to $8, reg1 value */
+	pracc_add(&ctx, MIPS32_PRACC_PARAM_OUT + 4,			/* store reg1 value from $8 to param out */
+			  MIPS32_SW(ctx.isa, 8, PRACC_OUT_OFFSET + 4, 1));
 
-	pracc_add(&ctx, 0, MIPS32_MFC0(1, 31, 0));					/* move COP0 DeSave to $1, restore reg1 */
-	pracc_add(&ctx, 0, MIPS32_B(NEG16(ctx.code_count + 1)));					/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_MTC0(15, 31, 0));					/* load $15 in DeSave */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 1, 31, 0));		/* move COP0 DeSave to $1, restore reg1 */
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_MTC0(ctx.isa, 15, 31, 0));				/* load $15 in DeSave */
 
-	if (ejtag_info->mode == 0)
-		ctx.store_count++;	/* Needed by legacy code, due to offset from reg0 */
-
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, regs);
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, regs, 1);
 
 	ejtag_info->reg8 = regs[8];	/* reg8 is saved but not restored, next called function should restore it */
 	ejtag_info->reg9 = regs[9];
-exit:
 	pracc_queue_free(&ctx);
 	return ctx.retval;
 }
@@ -977,70 +921,61 @@ exit:
 int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_area *source,
 		int write_t, uint32_t addr, int count, uint32_t *buf)
 {
+	uint32_t isa = ejtag_info->isa ? 1 : 0;
 	uint32_t handler_code[] = {
-		/* caution when editing, table is modified below */
 		/* r15 points to the start of this code */
-		MIPS32_SW(8, MIPS32_FASTDATA_HANDLER_SIZE - 4, 15),
-		MIPS32_SW(9, MIPS32_FASTDATA_HANDLER_SIZE - 8, 15),
-		MIPS32_SW(10, MIPS32_FASTDATA_HANDLER_SIZE - 12, 15),
-		MIPS32_SW(11, MIPS32_FASTDATA_HANDLER_SIZE - 16, 15),
+		MIPS32_SW(isa, 8, MIPS32_FASTDATA_HANDLER_SIZE - 4, 15),
+		MIPS32_SW(isa, 9, MIPS32_FASTDATA_HANDLER_SIZE - 8, 15),
+		MIPS32_SW(isa, 10, MIPS32_FASTDATA_HANDLER_SIZE - 12, 15),
+		MIPS32_SW(isa, 11, MIPS32_FASTDATA_HANDLER_SIZE - 16, 15),
 		/* start of fastdata area in t0 */
-		MIPS32_LUI(8, UPPER16(MIPS32_PRACC_FASTDATA_AREA)),
-		MIPS32_ORI(8, 8, LOWER16(MIPS32_PRACC_FASTDATA_AREA)),
-		MIPS32_LW(9, 0, 8),								/* start addr in t1 */
-		MIPS32_LW(10, 0, 8),							/* end addr to t2 */
-														/* loop: */
-		/* 8 */ MIPS32_LW(11, 0, 0),					/* lw t3,[t8 | r9] */
-		/* 9 */ MIPS32_SW(11, 0, 0),					/* sw t3,[r9 | r8] */
-		MIPS32_BNE(10, 9, NEG16(3)),					/* bne $t2,t1,loop */
-		MIPS32_ADDI(9, 9, 4),							/* addi t1,t1,4 */
-
-		MIPS32_LW(8, MIPS32_FASTDATA_HANDLER_SIZE - 4, 15),
-		MIPS32_LW(9, MIPS32_FASTDATA_HANDLER_SIZE - 8, 15),
-		MIPS32_LW(10, MIPS32_FASTDATA_HANDLER_SIZE - 12, 15),
-		MIPS32_LW(11, MIPS32_FASTDATA_HANDLER_SIZE - 16, 15),
-
-		MIPS32_LUI(15, UPPER16(MIPS32_PRACC_TEXT)),
-		MIPS32_ORI(15, 15, LOWER16(MIPS32_PRACC_TEXT)),
-		MIPS32_JR(15),								/* jr start */
-		MIPS32_MFC0(15, 31, 0),						/* move COP0 DeSave to $15 */
+		MIPS32_LUI(isa, 8, UPPER16(MIPS32_PRACC_FASTDATA_AREA)),
+		MIPS32_ORI(isa, 8, 8, LOWER16(MIPS32_PRACC_FASTDATA_AREA)),
+		MIPS32_LW(isa, 9, 0, 8),						/* start addr in t1 */
+		MIPS32_LW(isa, 10, 0, 8),						/* end addr to t2 */
+					/* loop: */
+		write_t ? MIPS32_LW(isa, 11, 0, 8) : MIPS32_LW(isa, 11, 0, 9),	/* from xfer area : from memory */
+		write_t ? MIPS32_SW(isa, 11, 0, 9) : MIPS32_SW(isa, 11, 0, 8),	/* to memory      : to xfer area */
+
+		MIPS32_BNE(isa, 10, 9, NEG16(3 << isa)),			/* bne $t2,t1,loop */
+		MIPS32_ADDI(isa, 9, 9, 4),					/* addi t1,t1,4 */
+
+		MIPS32_LW(isa, 8, MIPS32_FASTDATA_HANDLER_SIZE - 4, 15),
+		MIPS32_LW(isa, 9, MIPS32_FASTDATA_HANDLER_SIZE - 8, 15),
+		MIPS32_LW(isa, 10, MIPS32_FASTDATA_HANDLER_SIZE - 12, 15),
+		MIPS32_LW(isa, 11, MIPS32_FASTDATA_HANDLER_SIZE - 16, 15),
+
+		MIPS32_LUI(isa, 15, UPPER16(MIPS32_PRACC_TEXT)),
+		MIPS32_ORI(isa, 15, 15, LOWER16(MIPS32_PRACC_TEXT) | isa),	/* isa bit for JR instr */
+		MIPS32_JR(isa, 15),								/* jr start */
+		MIPS32_MFC0(isa, 15, 31, 0),					/* move COP0 DeSave to $15 */
 	};
 
-	uint32_t jmp_code[] = {
-		/* 0 */ MIPS32_LUI(15, 0),		/* addr of working area added below */
-		/* 1 */ MIPS32_ORI(15, 15, 0),	/* addr of working area added below */
-		MIPS32_JR(15),					/* jump to ram program */
-		MIPS32_NOP,
-	};
-
-	int retval, i;
-	uint32_t val, ejtag_ctrl, address;
-
 	if (source->size < MIPS32_FASTDATA_HANDLER_SIZE)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
-	if (write_t) {
-		handler_code[8] = MIPS32_LW(11, 0, 8);	/* load data from probe at fastdata area */
-		handler_code[9] = MIPS32_SW(11, 0, 9);	/* store data to RAM @ r9 */
-	} else {
-		handler_code[8] = MIPS32_LW(11, 0, 9);	/* load data from RAM @ r9 */
-		handler_code[9] = MIPS32_SW(11, 0, 8);	/* store data to probe at fastdata area */
-	}
-
-	/* write program into RAM */
+	pracc_swap16_array(ejtag_info, handler_code, ARRAY_SIZE(handler_code));
+		/* write program into RAM */
 	if (write_t != ejtag_info->fast_access_save) {
 		mips32_pracc_write_mem(ejtag_info, source->address, 4, ARRAY_SIZE(handler_code), handler_code);
 		/* save previous operation to speed to any consecutive read/writes */
 		ejtag_info->fast_access_save = write_t;
 	}
 
-	LOG_DEBUG("%s using 0x%.8" PRIx32 " for write handler", __func__, source->address);
+	LOG_DEBUG("%s using 0x%.8" TARGET_PRIxADDR " for write handler", __func__, source->address);
+
+	uint32_t jmp_code[] = {
+		MIPS32_LUI(isa, 15, UPPER16(source->address)),			/* load addr of jump in $15 */
+		MIPS32_ORI(isa, 15, 15, LOWER16(source->address) | isa),	/* isa bit for JR instr */
+		MIPS32_JR(isa, 15),						/* jump to ram program */
+		isa ? MIPS32_XORI(isa, 15, 15, 1) : MIPS32_NOP,	/* drop isa bit, needed for LW/SW instructions */
+	};
 
-	jmp_code[0] |= UPPER16(source->address);
-	jmp_code[1] |= LOWER16(source->address);
+	pracc_swap16_array(ejtag_info, jmp_code, ARRAY_SIZE(jmp_code));
 
-	for (i = 0; i < (int) ARRAY_SIZE(jmp_code); i++) {
-		retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl);
+	/* execute jump code, with no address check */
+	for (unsigned i = 0; i < ARRAY_SIZE(jmp_code); i++) {
+		int retval = wait_for_pracc_rw(ejtag_info);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -1048,32 +983,24 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 		mips_ejtag_drscan_32_out(ejtag_info, jmp_code[i]);
 
 		/* Clear the access pending bit (let the processor eat!) */
-		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
-		mips_ejtag_drscan_32_out(ejtag_info, ejtag_ctrl);
+		mips32_pracc_finish(ejtag_info);
 	}
 
-	/* wait PrAcc pending bit for FASTDATA write */
-	retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl);
+	/* wait PrAcc pending bit for FASTDATA write, read address */
+	int retval = mips32_pracc_read_ctrl_addr(ejtag_info);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* next fetch to dmseg should be in FASTDATA_AREA, check */
-	address = 0;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
-	retval = mips_ejtag_drscan_32(ejtag_info, &address);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (address != MIPS32_PRACC_FASTDATA_AREA)
+	if (ejtag_info->pa_addr != MIPS32_PRACC_FASTDATA_AREA)
 		return ERROR_FAIL;
 
 	/* Send the load start address */
-	val = addr;
+	uint32_t val = addr;
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA);
 	mips_ejtag_fastdata_scan(ejtag_info, 1, &val);
 
-	retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl);
+	retval = wait_for_pracc_rw(ejtag_info);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1086,11 +1013,9 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	if (ejtag_info->mode != 0)
 		num_clocks = ((uint64_t)(ejtag_info->scan_delay) * jtag_get_speed_khz() + 500000) / 1000000;
 
-	for (i = 0; i < count; i++) {
+	for (int i = 0; i < count; i++) {
 		jtag_add_clocks(num_clocks);
-		retval = mips_ejtag_fastdata_scan(ejtag_info, write_t, buf++);
-		if (retval != ERROR_OK)
-			return retval;
+		mips_ejtag_fastdata_scan(ejtag_info, write_t, buf++);
 	}
 
 	retval = jtag_execute_queue();
@@ -1099,17 +1024,11 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 		return retval;
 	}
 
-	retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl);
-	if (retval != ERROR_OK)
-		return retval;
-
-	address = 0;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
-	retval = mips_ejtag_drscan_32(ejtag_info, &address);
+	retval = mips32_pracc_read_ctrl_addr(ejtag_info);
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (address != MIPS32_PRACC_TEXT)
+	if (ejtag_info->pa_addr != MIPS32_PRACC_TEXT)
 		LOG_ERROR("mini program did not return to start");
 
 	return retval;
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index eab5f73e..888c847c 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -18,13 +18,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MIPS32_PRACC_H
-#define MIPS32_PRACC_H
+#ifndef OPENOCD_TARGET_MIPS32_PRACC_H
+#define OPENOCD_TARGET_MIPS32_PRACC_H
 
 #include <target/mips32.h>
 #include <target/mips_ejtag.h>
@@ -36,26 +34,40 @@
 #define MIPS32_PRACC_PARAM_OUT			0xFF202000
 
 #define PRACC_UPPER_BASE_ADDR			(MIPS32_PRACC_BASE_ADDR >> 16)
+#define PRACC_MAX_CODE				(MIPS32_PRACC_PARAM_OUT - MIPS32_PRACC_TEXT)
+#define PRACC_MAX_INSTRUCTIONS			(PRACC_MAX_CODE / 4)
 #define PRACC_OUT_OFFSET			(MIPS32_PRACC_PARAM_OUT - MIPS32_PRACC_BASE_ADDR)
 
 #define MIPS32_FASTDATA_HANDLER_SIZE	0x80
 #define UPPER16(uint32_t)				(uint32_t >> 16)
 #define LOWER16(uint32_t)				(uint32_t & 0xFFFF)
 #define NEG16(v)						(((~(v)) + 1) & 0xFFFF)
+#define SWAP16(v)				((LOWER16(v) << 16) | (UPPER16(v)))
 /*#define NEG18(v) (((~(v)) + 1) & 0x3FFFF)*/
 
+#define PRACC_BLOCK	128	/* 1 Kbyte */
+
+typedef struct {
+	uint32_t instr;
+	uint32_t addr;
+} pa_list;
+
 struct pracc_queue_info {
+	struct mips_ejtag *ejtag_info;
+	unsigned isa;
 	int retval;
-	const int max_code;
 	int code_count;
 	int store_count;
-	uint32_t *pracc_list;	/* Code and store addresses */
+	int max_code;		/* max intstructions with currently allocated memory */
+	pa_list *pracc_list;	/* Code and store addresses at dmseg */
 };
+
 void pracc_queue_init(struct pracc_queue_info *ctx);
 void pracc_add(struct pracc_queue_info *ctx, uint32_t addr, uint32_t instr);
+void pracc_add_li32(struct pracc_queue_info *ctx, uint32_t reg_num, uint32_t data, bool optimize);
 void pracc_queue_free(struct pracc_queue_info *ctx);
 int mips32_pracc_queue_exec(struct mips_ejtag *ejtag_info,
-			    struct pracc_queue_info *ctx, uint32_t *buf);
+			    struct pracc_queue_info *ctx, uint32_t *buf, bool check_last);
 
 int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info,
 		uint32_t addr, int size, int count, void *buf);
@@ -67,7 +79,8 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
 int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs);
 
-int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx, uint32_t *param_out);
+int mips32_pracc_exec(struct mips_ejtag *ejtag_info, struct pracc_queue_info *ctx,
+				uint32_t *param_out, bool check_last);
 
 /**
  * \b mips32_cp0_read
@@ -101,4 +114,11 @@ int mips32_cp0_read(struct mips_ejtag *ejtag_info,
 int mips32_cp0_write(struct mips_ejtag *ejtag_info,
 		uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel);
 
-#endif
+static inline void pracc_swap16_array(struct mips_ejtag *ejtag_info, uint32_t *buf, int count)
+{
+	if (ejtag_info->isa && ejtag_info->endianness)
+		for (int i = 0; i != count; i++)
+			buf[i] = SWAP16(buf[i]);
+}
+
+#endif /* OPENOCD_TARGET_MIPS32_PRACC_H */
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 2a16193f..03a09529 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -17,9 +17,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -30,74 +28,40 @@
 #include "mips_ejtag.h"
 #include "mips32_dmaacc.h"
 
-void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
+void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, uint32_t new_instr)
 {
-	struct jtag_tap *tap;
+	assert(ejtag_info->tap != NULL);
+	struct jtag_tap *tap = ejtag_info->tap;
 
-	tap = ejtag_info->tap;
-	assert(tap != NULL);
+	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != new_instr) {
 
-	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != (uint32_t)new_instr) {
 		struct scan_field field;
-		uint8_t t[4];
-
 		field.num_bits = tap->ir_length;
+
+		uint8_t t[4];
 		field.out_value = t;
 		buf_set_u32(t, 0, field.num_bits, new_instr);
+
 		field.in_value = NULL;
 
 		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 	}
 }
 
-int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
+int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info)
 {
-	struct scan_field field;
-	uint8_t r[4];
-
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE);
 
-	field.num_bits = 32;
-	field.out_value = NULL;
-	field.in_value = r;
-
-	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
-
-	int retval;
-	retval = jtag_execute_queue();
-	if (retval != ERROR_OK) {
-		LOG_ERROR("register read failed");
-		return retval;
-	}
-
-	*idcode = buf_get_u32(field.in_value, 0, 32);
-
-	return ERROR_OK;
+	ejtag_info->idcode = 0;
+	return mips_ejtag_drscan_32(ejtag_info, &ejtag_info->idcode);
 }
 
-static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
+int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info)
 {
-	struct scan_field field;
-	uint8_t r[4];
-
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE);
 
-	field.num_bits = 32;
-	field.out_value = NULL;
-	field.in_value = r;
-
-	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
-
-	int retval;
-	retval = jtag_execute_queue();
-	if (retval != ERROR_OK) {
-		LOG_ERROR("register read failed");
-		return retval;
-	}
-
-	*impcode = buf_get_u32(field.in_value, 0, 32);
-
-	return ERROR_OK;
+	ejtag_info->impcode = 0;
+	return mips_ejtag_drscan_32(ejtag_info, &ejtag_info->impcode);
 }
 
 void mips_ejtag_add_scan_96(struct mips_ejtag *ejtag_info, uint32_t ctrl, uint32_t data, uint8_t *in_scan_buf)
@@ -123,91 +87,73 @@ void mips_ejtag_add_scan_96(struct mips_ejtag *ejtag_info, uint32_t ctrl, uint32
 	keep_alive();
 }
 
-int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
+void mips_ejtag_drscan_32_queued(struct mips_ejtag *ejtag_info, uint32_t data_out, uint8_t *data_in)
 {
-	struct jtag_tap *tap;
-	tap  = ejtag_info->tap;
-	assert(tap != NULL);
+	assert(ejtag_info->tap != NULL);
+	struct jtag_tap *tap = ejtag_info->tap;
 
 	struct scan_field field;
-	uint8_t t[4], r[4];
-	int retval;
-
 	field.num_bits = 32;
-	field.out_value = t;
-	buf_set_u32(t, 0, field.num_bits, *data);
-	field.in_value = r;
 
+	uint8_t scan_out[4];
+	field.out_value = scan_out;
+	buf_set_u32(scan_out, 0, field.num_bits, data_out);
+
+	field.in_value = data_in;
 	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
-	retval = jtag_execute_queue();
+	keep_alive();
+}
+
+int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
+{
+	uint8_t scan_in[4];
+	mips_ejtag_drscan_32_queued(ejtag_info, *data, scan_in);
+
+	int retval = jtag_execute_queue();
 	if (retval != ERROR_OK) {
 		LOG_ERROR("register read failed");
 		return retval;
 	}
 
-	*data = buf_get_u32(field.in_value, 0, 32);
-
-	keep_alive();
-
+	*data = buf_get_u32(scan_in, 0, 32);
 	return ERROR_OK;
 }
 
 void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data)
 {
-	uint8_t t[4];
-	struct jtag_tap *tap;
-	tap  = ejtag_info->tap;
-	assert(tap != NULL);
-
-	struct scan_field field;
-
-	field.num_bits = 32;
-	field.out_value = t;
-	buf_set_u32(t, 0, field.num_bits, data);
-
-	field.in_value = NULL;
-
-	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
+	mips_ejtag_drscan_32_queued(ejtag_info, data, NULL);
 }
 
-int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
+int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint8_t *data)
 {
-	struct jtag_tap *tap;
-	tap  = ejtag_info->tap;
-	assert(tap != NULL);
+	assert(ejtag_info->tap != NULL);
+	struct jtag_tap *tap = ejtag_info->tap;
 
 	struct scan_field field;
-	uint8_t t[4] = {0, 0, 0, 0}, r[4];
-	int retval;
-
 	field.num_bits = 8;
-	field.out_value = t;
-	buf_set_u32(t, 0, field.num_bits, *data);
-	field.in_value = r;
+
+	field.out_value = data;
+	field.in_value = data;
 
 	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
-	retval = jtag_execute_queue();
+	int retval = jtag_execute_queue();
 	if (retval != ERROR_OK) {
 		LOG_ERROR("register read failed");
 		return retval;
 	}
-
-	*data = buf_get_u32(field.in_value, 0, 32);
-
 	return ERROR_OK;
 }
 
 void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data)
 {
-	struct jtag_tap *tap;
-	tap  = ejtag_info->tap;
-	assert(tap != NULL);
+	assert(ejtag_info->tap != NULL);
+	struct jtag_tap *tap = ejtag_info->tap;
 
 	struct scan_field field;
-
 	field.num_bits = 8;
+
 	field.out_value = &data;
 	field.in_value = NULL;
 
@@ -217,23 +163,20 @@ void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data)
 /* Set (to enable) or clear (to disable stepping) the SSt bit (bit 8) in Cp0 Debug reg (reg 23, sel 0) */
 int mips_ejtag_config_step(struct mips_ejtag *ejtag_info, int enable_step)
 {
-	struct pracc_queue_info ctx = {.max_code = 7};
+	struct pracc_queue_info ctx = {.ejtag_info = ejtag_info};
 	pracc_queue_init(&ctx);
-	if (ctx.retval != ERROR_OK)
-		goto exit;
 
-	pracc_add(&ctx, 0, MIPS32_MFC0(8, 23, 0));			/* move COP0 Debug to $8 */
-	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, 0x0100));			/* set SSt bit in debug reg */
+	pracc_add(&ctx, 0, MIPS32_MFC0(ctx.isa, 8, 23, 0));			/* move COP0 Debug to $8 */
+	pracc_add(&ctx, 0, MIPS32_ORI(ctx.isa, 8, 8, 0x0100));			/* set SSt bit in debug reg */
 	if (!enable_step)
-		pracc_add(&ctx, 0, MIPS32_XORI(8, 8, 0x0100));		/* clear SSt bit in debug reg */
+		pracc_add(&ctx, 0, MIPS32_XORI(ctx.isa, 8, 8, 0x0100));		/* clear SSt bit in debug reg */
 
-	pracc_add(&ctx, 0, MIPS32_MTC0(8, 23, 0));			/* move $8 to COP0 Debug */
-	pracc_add(&ctx, 0, MIPS32_LUI(8, UPPER16(ejtag_info->reg8)));		/* restore upper 16 bits  of $8 */
-	pracc_add(&ctx, 0, MIPS32_B(NEG16((ctx.code_count + 1))));			/* jump to start */
-	pracc_add(&ctx, 0, MIPS32_ORI(8, 8, LOWER16(ejtag_info->reg8)));	/* restore lower 16 bits of $8 */
+	pracc_add(&ctx, 0, MIPS32_MTC0(ctx.isa, 8, 23, 0));			/* move $8 to COP0 Debug */
+	pracc_add(&ctx, 0, MIPS32_LUI(ctx.isa, 8, UPPER16(ejtag_info->reg8)));	/* restore upper 16 bits  of $8 */
+	pracc_add(&ctx, 0, MIPS32_B(ctx.isa, NEG16((ctx.code_count + 1) << ctx.isa)));		/* jump to start */
+	pracc_add(&ctx, 0, MIPS32_ORI(ctx.isa, 8, 8, LOWER16(ejtag_info->reg8))); /* restore lower 16 bits of $8 */
 
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
-exit:
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 1);
 	pracc_queue_free(&ctx);
 	return ctx.retval;
 }
@@ -292,11 +235,11 @@ error:
 
 int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info)
 {
-	uint32_t pracc_list[] = {MIPS32_DRET, 0};
-	struct pracc_queue_info ctx = {.max_code = 1, .pracc_list = pracc_list, .code_count = 1, .store_count = 0};
+	pa_list pracc_list = {.instr = MIPS32_DRET(ejtag_info->isa), .addr = 0};
+	struct pracc_queue_info ctx = {.max_code = 1, .pracc_list = &pracc_list, .code_count = 1, .store_count = 0};
 
 	/* execute our dret instruction */
-	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL);
+	ctx.retval = mips32_pracc_queue_exec(ejtag_info, &ctx, NULL, 0); /* shift out instr, omit last check */
 
 	/* pic32mx workaround, false pending at low core clock */
 	jtag_add_sleep(1000);
@@ -391,12 +334,11 @@ static void ejtag_main_print_imp(struct mips_ejtag *ejtag_info)
 
 int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 {
-	int retval;
-
-	retval = mips_ejtag_get_impcode(ejtag_info, &ejtag_info->impcode);
-	if (retval != ERROR_OK)
+	int retval = mips_ejtag_get_impcode(ejtag_info);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("impcode read failed");
 		return retval;
-	LOG_DEBUG("impcode: 0x%8.8" PRIx32 "", ejtag_info->impcode);
+	}
 
 	/* get ejtag version */
 	ejtag_info->ejtag_version = ((ejtag_info->impcode >> 29) & 0x07);
@@ -446,22 +388,22 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 
 int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data)
 {
-	struct jtag_tap *tap;
-
-	tap = ejtag_info->tap;
-	assert(tap != NULL);
+	assert(ejtag_info->tap != NULL);
+	struct jtag_tap *tap = ejtag_info->tap;
 
 	struct scan_field fields[2];
-	uint8_t spracc = 0;
-	uint8_t t[4] = {0, 0, 0, 0};
 
 	/* fastdata 1-bit register */
 	fields[0].num_bits = 1;
+
+	uint8_t spracc = 0;
 	fields[0].out_value = &spracc;
 	fields[0].in_value = NULL;
 
 	/* processor access data register 32 bit */
 	fields[1].num_bits = 32;
+
+	uint8_t t[4] = {0, 0, 0, 0};
 	fields[1].out_value = t;
 
 	if (write_t) {
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 3e0d8310..71f5c1b4 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -15,13 +15,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MIPS_EJTAG
-#define MIPS_EJTAG
+#ifndef OPENOCD_TARGET_MIPS_EJTAG_H
+#define OPENOCD_TARGET_MIPS_EJTAG_H
 
 #include <jtag/jtag.h>
 
@@ -60,6 +58,7 @@
 #define EJTAG_CTRL_DERR			(1 << 10)
 #define EJTAG_CTRL_DSTRT		(1 << 11)
 #define EJTAG_CTRL_JTAGBRK		(1 << 12)
+#define EJTAG_CTRL_DBGISA		(1 << 13)
 #define EJTAG_CTRL_SETDEV		(1 << 14)
 #define EJTAG_CTRL_PROBEN		(1 << 15)
 #define EJTAG_CTRL_PRRST		(1 << 16)
@@ -144,7 +143,7 @@
 #define EJTAG_V20_IBC_OFFS		0x4	/* IBC Offset */
 #define EJTAG_V20_IBM_OFFS		0x8
 #define EJTAG_V20_IBAn_STEP		0x10	/* Offset for next channel */
-#define EJTAG_V20_DBS			0xFF30008
+#define EJTAG_V20_DBS			0xFF300008
 #define EJTAG_V20_DBA0			0xFF300200
 #define EJTAG_V20_DBC_OFFS		0x4
 #define EJTAG_V20_DBM_OFFS		0x8
@@ -184,6 +183,9 @@ struct mips_ejtag {
 	uint32_t idcode;
 	uint32_t ejtag_ctrl;
 	int fast_access_save;
+	uint32_t config_regs;	/* number of config registers read */
+	uint32_t config[4];	/* cp0 config to config3 */
+
 	uint32_t reg8;
 	uint32_t reg9;
 	unsigned scan_delay;
@@ -191,6 +193,8 @@ struct mips_ejtag {
 	uint32_t pa_ctrl;
 	uint32_t pa_addr;
 	unsigned int ejtag_version;
+	uint32_t isa;
+	uint32_t endianness;
 
 	/* Memory-Mapped Registers. This addresses are not same on different
 	 * EJTAG versions. */
@@ -212,17 +216,16 @@ struct mips_ejtag {
 	uint32_t ejtag_dba_step_size;	/* size of step till next *DBAn register. */
 };
 
-void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info,
-		int new_instr);
+void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, uint32_t new_instr);
 int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);
-int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode);
+int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info);
 void mips_ejtag_add_scan_96(struct mips_ejtag *ejtag_info,
 			    uint32_t ctrl, uint32_t data, uint8_t *in_scan_buf);
 void mips_ejtag_drscan_32_out(struct mips_ejtag *ejtag_info, uint32_t data);
 int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data);
 void mips_ejtag_drscan_8_out(struct mips_ejtag *ejtag_info, uint8_t data);
-int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data);
+int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint8_t *data);
 int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data);
 
 int mips_ejtag_init(struct mips_ejtag *ejtag_info);
@@ -234,4 +237,4 @@ static inline void mips_le_to_h_u32(jtag_callback_data_t arg)
 	*((uint32_t *)arg) = le_to_h_u32(in);
 }
 
-#endif /* MIPS_EJTAG */
+#endif /* OPENOCD_TARGET_MIPS_EJTAG_H */
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 5b740cc4..7d1c06cf 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -20,9 +20,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -43,10 +41,10 @@ static int mips_m4k_set_breakpoint(struct target *target,
 static int mips_m4k_unset_breakpoint(struct target *target,
 		struct breakpoint *breakpoint);
 static int mips_m4k_internal_restore(struct target *target, int current,
-		uint32_t address, int handle_breakpoints,
+		target_addr_t address, int handle_breakpoints,
 		int debug_execution);
 static int mips_m4k_halt(struct target *target);
-static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
+static int mips_m4k_bulk_write_memory(struct target *target, target_addr_t address,
 		uint32_t count, const uint8_t *buffer);
 
 static int mips_m4k_examine_debug_reason(struct target *target)
@@ -110,11 +108,14 @@ static int mips_m4k_debug_entry(struct target *target)
 	/* attempt to find halt reason */
 	mips_m4k_examine_debug_reason(target);
 
+	mips32_read_config_regs(target);
+
 	/* default to mips32 isa, it will be changed below if required */
 	mips32->isa_mode = MIPS32_ISA_MIPS32;
 
-	if (ejtag_info->impcode & EJTAG_IMP_MIPS16)
-		mips32->isa_mode = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1);
+	/* other than mips32 only and isa bit set ? */
+	if (mips32->isa_imp && buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1))
+		mips32->isa_mode = mips32->isa_imp == 2 ? MIPS32_ISA_MIPS16E : MIPS32_ISA_MMIPS32;
 
 	LOG_DEBUG("entered debug state at PC 0x%" PRIx32 ", target->state: %s",
 			buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32),
@@ -197,6 +198,8 @@ static int mips_m4k_poll(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
+	ejtag_info->isa = (ejtag_ctrl & EJTAG_CTRL_DBGISA) ? 1 : 0;
+
 	/* clear this bit before handling polling
 	 * as after reset registers will read zero */
 	if (ejtag_ctrl & EJTAG_CTRL_ROCC) {
@@ -302,6 +305,13 @@ static int mips_m4k_assert_reset(struct target *target)
 	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
 	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
 
+	/* TODO: apply hw reset signal in not examined state */
+	if (!(target_was_examined(target))) {
+		LOG_WARNING("Reset is not asserted because the target is not examined.");
+		LOG_WARNING("Use a reset button or power cycle the target.");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
 
@@ -424,7 +434,7 @@ static int mips_m4k_restore_smp(struct target *target, uint32_t address, int han
 }
 
 static int mips_m4k_internal_restore(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
+		target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -444,12 +454,13 @@ static int mips_m4k_internal_restore(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current) {
+		mips_m4k_isa_filter(mips32->isa_imp, &address);
 		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
 		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
 		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
 	}
 
-	if (ejtag_info->impcode & EJTAG_IMP_MIPS16)
+	if ((mips32->isa_imp > 1) &&  debug_execution)	/* if more than one isa supported */
 		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1, mips32->isa_mode);
 
 	if (!current)
@@ -464,7 +475,8 @@ static int mips_m4k_internal_restore(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("unset breakpoint at " TARGET_ADDR_FMT "",
+					  breakpoint->address);
 			mips_m4k_unset_breakpoint(target, breakpoint);
 			mips_m4k_single_step_core(target);
 			mips_m4k_set_breakpoint(target, breakpoint);
@@ -495,7 +507,7 @@ static int mips_m4k_internal_restore(struct target *target, int current,
 }
 
 static int mips_m4k_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
+		target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	int retval = ERROR_OK;
 
@@ -522,7 +534,7 @@ static int mips_m4k_resume(struct target *target, int current,
 }
 
 static int mips_m4k_step(struct target *target, int current,
-		uint32_t address, int handle_breakpoints)
+		target_addr_t address, int handle_breakpoints)
 {
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -536,6 +548,7 @@ static int mips_m4k_step(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current) {
+		mips_m4k_isa_filter(mips32->isa_imp, &address);
 		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
 		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
 		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
@@ -618,6 +631,11 @@ static int mips_m4k_set_breakpoint(struct target *target,
 		comparator_list[bp_num].used = 1;
 		comparator_list[bp_num].bp_value = breakpoint->address;
 
+		if (breakpoint->length != 4)			/* make sure isa bit set */
+			comparator_list[bp_num].bp_value |= 1;
+		else						/* make sure isa bit cleared */
+			comparator_list[bp_num].bp_value &= ~1;
+
 		/* EJTAG 2.0 uses 30bit IBA. First 2 bits are reserved.
 		 * Warning: there is no IB ASID registers in 2.0.
 		 * Do not set it! :) */
@@ -635,41 +653,77 @@ static int mips_m4k_set_breakpoint(struct target *target,
 				  bp_num, comparator_list[bp_num].bp_value);
 	} else if (breakpoint->type == BKPT_SOFT) {
 		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
-		if (breakpoint->length == 4) {
+
+		uint32_t isa_req = breakpoint->length & 1;	/* micro mips request bit */
+		uint32_t bplength = breakpoint->length & ~1;	/* drop micro mips request bit for length */
+		uint32_t bpaddr = breakpoint->address & ~1;	/* drop isa bit from address, if set */
+
+		if (bplength == 4) {
 			uint32_t verify = 0xffffffff;
+			uint32_t sdbbp32_instr = MIPS32_SDBBP(isa_req);
+			if (ejtag_info->endianness && isa_req)
+				sdbbp32_instr = SWAP16(sdbbp32_instr);
 
-			retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
-					breakpoint->orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = target_write_u32(target, breakpoint->address, MIPS32_SDBBP);
-			if (retval != ERROR_OK)
-				return retval;
+			if ((breakpoint->address & 3) == 0) {	/* word alligned */
 
-			retval = target_read_u32(target, breakpoint->address, &verify);
-			if (retval != ERROR_OK)
-				return retval;
-			if (verify != MIPS32_SDBBP) {
-				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx32
-						" - check that memory is read/writable", breakpoint->address);
+				retval = target_read_memory(target, bpaddr, bplength, 1, breakpoint->orig_instr);
+				if (retval != ERROR_OK)
+					return retval;
+
+				retval = target_write_u32(target, bpaddr, sdbbp32_instr);
+				if (retval != ERROR_OK)
+					return retval;
+
+				retval = target_read_u32(target, bpaddr, &verify);
+				if (retval != ERROR_OK)
+					return retval;
+
+				if (verify != sdbbp32_instr)
+					verify = 0;
+
+			} else {	/* 16 bit aligned */
+				retval = target_read_memory(target, bpaddr, 2, 2, breakpoint->orig_instr);
+				if (retval != ERROR_OK)
+					return retval;
+
+				uint8_t sdbbp_buf[4];
+				target_buffer_set_u32(target, sdbbp_buf, sdbbp32_instr);
+
+				retval = target_write_memory(target, bpaddr, 2, 2, sdbbp_buf);
+				if (retval != ERROR_OK)
+					return retval;
+
+				retval = target_read_memory(target, bpaddr, 2, 2, sdbbp_buf);
+				if (retval != ERROR_OK)
+					return retval;
+
+				if (target_buffer_get_u32(target, sdbbp_buf) != sdbbp32_instr)
+					verify = 0;
+			}
+
+			if (verify == 0) {
+				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx64
+					" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
+
 		} else {
 			uint16_t verify = 0xffff;
 
-			retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
-					breakpoint->orig_instr);
+			retval = target_read_memory(target, bpaddr, bplength, 1, breakpoint->orig_instr);
 			if (retval != ERROR_OK)
 				return retval;
-			retval = target_write_u16(target, breakpoint->address, MIPS16_SDBBP);
+
+			retval = target_write_u16(target, bpaddr, MIPS16_SDBBP(isa_req));
 			if (retval != ERROR_OK)
 				return retval;
 
-			retval = target_read_u16(target, breakpoint->address, &verify);
+			retval = target_read_u16(target, bpaddr, &verify);
 			if (retval != ERROR_OK)
 				return retval;
-			if (verify != MIPS16_SDBBP) {
-				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx32
+
+			if (verify != MIPS16_SDBBP(isa_req)) {
+				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx64
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -712,46 +766,58 @@ static int mips_m4k_unset_breakpoint(struct target *target,
 
 	} else {
 		/* restore original instruction (kept in target endianness) */
+		uint32_t isa_req = breakpoint->length & 1;
+		uint32_t bplength = breakpoint->length & ~1;
+		uint8_t current_instr[4];
 		LOG_DEBUG("bpid: %" PRIu32, breakpoint->unique_id);
-		if (breakpoint->length == 4) {
-			uint32_t current_instr;
-
-			/* check that user program has not modified breakpoint instruction */
-			retval = target_read_memory(target, breakpoint->address, 4, 1,
-					(uint8_t *)&current_instr);
-			if (retval != ERROR_OK)
-				return retval;
-
-			/**
-			 * target_read_memory() gets us data in _target_ endianess.
-			 * If we want to use this data on the host for comparisons with some macros
-			 * we must first transform it to _host_ endianess using target_buffer_get_u32().
-			 */
-			current_instr = target_buffer_get_u32(target, (uint8_t *)&current_instr);
-
-			if (current_instr == MIPS32_SDBBP) {
-				retval = target_write_memory(target, breakpoint->address, 4, 1,
-						breakpoint->orig_instr);
+		if (bplength == 4) {
+			uint32_t sdbbp32_instr =  MIPS32_SDBBP(isa_req);
+			if (ejtag_info->endianness && isa_req)
+				sdbbp32_instr = SWAP16(sdbbp32_instr);
+
+			if ((breakpoint->address & 3) == 0) {		/* 32bit aligned */
+				/* check that user program has not modified breakpoint instruction */
+				retval = target_read_memory(target, breakpoint->address, 4, 1, current_instr);
+				if (retval != ERROR_OK)
+					return retval;
+				/**
+				* target_read_memory() gets us data in _target_ endianess.
+				* If we want to use this data on the host for comparisons with some macros
+				* we must first transform it to _host_ endianess using target_buffer_get_u16().
+				*/
+				if (sdbbp32_instr == target_buffer_get_u32(target, current_instr)) {
+					retval = target_write_memory(target, breakpoint->address, 4, 1,
+										breakpoint->orig_instr);
+					if (retval != ERROR_OK)
+						return retval;
+				}
+			} else {	/* 16bit alligned */
+				retval = target_read_memory(target, breakpoint->address, 2, 2, current_instr);
 				if (retval != ERROR_OK)
 					return retval;
+
+				if (sdbbp32_instr == target_buffer_get_u32(target, current_instr)) {
+					retval = target_write_memory(target, breakpoint->address, 2, 2,
+										breakpoint->orig_instr);
+					if (retval != ERROR_OK)
+						return retval;
+				}
 			}
 		} else {
-			uint16_t current_instr;
-
 			/* check that user program has not modified breakpoint instruction */
-			retval = target_read_memory(target, breakpoint->address, 2, 1,
-					(uint8_t *)&current_instr);
+			retval = target_read_memory(target, breakpoint->address, 2, 1, current_instr);
 			if (retval != ERROR_OK)
 				return retval;
-			current_instr = target_buffer_get_u16(target, (uint8_t *)&current_instr);
-			if (current_instr == MIPS16_SDBBP) {
+
+			if (target_buffer_get_u16(target, current_instr) == MIPS16_SDBBP(isa_req)) {
 				retval = target_write_memory(target, breakpoint->address, 2, 1,
-						breakpoint->orig_instr);
+									breakpoint->orig_instr);
 				if (retval != ERROR_OK)
 					return retval;
 			}
 		}
 	}
+
 	breakpoint->set = 0;
 
 	return ERROR_OK;
@@ -761,6 +827,12 @@ static int mips_m4k_add_breakpoint(struct target *target, struct breakpoint *bre
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 
+	if ((breakpoint->length > 5 || breakpoint->length < 2) ||		/* out of range */
+		(breakpoint->length == 4 && (breakpoint->address & 2)) ||	/* mips32 unaligned */
+		(mips32->isa_imp == MIPS32_ONLY && breakpoint->length != 4) ||	/* misp32 specific */
+		((mips32->isa_imp & 1) != (breakpoint->length & 1)))		/* isa not implemented */
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
 	if (breakpoint->type == BKPT_HARD) {
 		if (mips32->num_inst_bpoints_avail < 1) {
 			LOG_INFO("no hardware breakpoint available");
@@ -944,13 +1016,13 @@ static void mips_m4k_enable_watchpoints(struct target *target)
 	}
 }
 
-static int mips_m4k_read_memory(struct target *target, uint32_t address,
+static int mips_m4k_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
 			address, size, count);
 
 	if (target->state != TARGET_HALTED) {
@@ -1003,13 +1075,13 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 	return retval;
 }
 
-static int mips_m4k_write_memory(struct target *target, uint32_t address,
+static int mips_m4k_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
 			address, size, count);
 
 	if (target->state != TARGET_HALTED) {
@@ -1102,39 +1174,33 @@ static int mips_m4k_target_create(struct target *target, Jim_Interp *interp)
 
 static int mips_m4k_examine(struct target *target)
 {
-	int retval;
 	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
 	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
-	uint32_t idcode = 0;
 
 	if (!target_was_examined(target)) {
-		retval = mips_ejtag_get_idcode(ejtag_info, &idcode);
-		if (retval != ERROR_OK)
+		int retval = mips_ejtag_get_idcode(ejtag_info);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("idcode read failed");
 			return retval;
-		ejtag_info->idcode = idcode;
-
-		if (((idcode >> 1) & 0x7FF) == 0x29) {
+		}
+		if (((ejtag_info->idcode >> 1) & 0x7FF) == 0x29) {
 			/* we are using a pic32mx so select ejtag port
 			 * as it is not selected by default */
 			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
-			LOG_DEBUG("PIC32MX Detected - using EJTAG Interface");
+			LOG_DEBUG("PIC32 Detected - using EJTAG Interface");
 			mips_m4k->is_pic32mx = true;
 		}
 	}
 
 	/* init rest of ejtag interface */
-	retval = mips_ejtag_init(ejtag_info);
+	int retval = mips_ejtag_init(ejtag_info);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mips32_examine(target);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return ERROR_OK;
+	return mips32_examine(target);
 }
 
-static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
+static int mips_m4k_bulk_write_memory(struct target *target, target_addr_t address,
 		uint32_t count, const uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -1143,7 +1209,8 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	int retval;
 	int write_t = 1;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, count);
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", count: 0x%8.8" PRIx32 "",
+			  address, count);
 
 	/* check alignment */
 	if (address & 0x3u)
@@ -1170,8 +1237,8 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 
 	if (address <= fast_data_area->address + fast_data_area->size &&
 			fast_data_area->address <= address + count) {
-		LOG_ERROR("fast_data (0x%8.8" PRIx32 ") is within write area "
-			  "(0x%8.8" PRIx32 "-0x%8.8" PRIx32 ").",
+		LOG_ERROR("fast_data (" TARGET_ADDR_FMT ") is within write area "
+			  "(" TARGET_ADDR_FMT "-" TARGET_ADDR_FMT ").",
 			  fast_data_area->address, address, address + count);
 		LOG_ERROR("Change work-area-phys or load_image address!");
 		return ERROR_FAIL;
@@ -1334,7 +1401,7 @@ COMMAND_HANDLER(mips_m4k_handle_scan_delay_command)
 			return ERROR_COMMAND_SYNTAX_ERROR;
 
 	command_print(CMD_CTX, "scan delay: %d nsec", ejtag_info->scan_delay);
-	if (ejtag_info->scan_delay >= 20000000) {
+	if (ejtag_info->scan_delay >= MIPS32_SCAN_DELAY_LEGACY_MODE) {
 		ejtag_info->mode = 0;
 		command_print(CMD_CTX, "running in legacy mode");
 	} else {
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index de990599..ea09ae52 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -18,13 +18,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef MIPS_M4K_H
-#define MIPS_M4K_H
+#ifndef OPENOCD_TARGET_MIPS_M4K_H
+#define OPENOCD_TARGET_MIPS_M4K_H
 
 struct target;
 
@@ -43,6 +41,17 @@ target_to_m4k(struct target *target)
 			struct mips_m4k_common, mips32);
 }
 
+static inline void mips_m4k_isa_filter(enum mips32_isa_imp isa_imp, target_addr_t  *addr)
+{
+	if (isa_imp <= 1) {	/* if only one isa implemented */
+		target_addr_t address = (*addr & ~1) | isa_imp;
+
+		if (address != *addr) {
+			LOG_USER("Warning: isa bit changed due to isa not implemented");
+			*addr = address;
+		}
+	}
+}
 extern const struct command_registration mips_m4k_command_handlers[];
 
-#endif	/*MIPS_M4K_H*/
+#endif /* OPENOCD_TARGET_MIPS_M4K_H */
diff --git a/src/target/nds32.c b/src/target/nds32.c
index b6c5f612..e4bb17f9 100644
--- a/src/target/nds32.c
+++ b/src/target/nds32.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -825,7 +823,7 @@ int nds32_read_memory(struct target *target, uint32_t address,
 	return aice_read_mem_unit(aice, address, size, count, buffer);
 }
 
-int nds32_read_phys_memory(struct target *target, uint32_t address,
+int nds32_read_phys_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct aice_port_s *aice = target_to_aice(target);
@@ -934,7 +932,7 @@ int nds32_write_memory(struct target *target, uint32_t address,
 	return aice_write_mem_unit(aice, address, size, count, buffer);
 }
 
-int nds32_write_phys_memory(struct target *target, uint32_t address,
+int nds32_write_phys_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct aice_port_s *aice = target_to_aice(target);
@@ -1676,7 +1674,7 @@ int nds32_init_arch_info(struct target *target, struct nds32 *nds32)
 	return ERROR_OK;
 }
 
-int nds32_virtual_to_physical(struct target *target, uint32_t address, uint32_t *physical)
+int nds32_virtual_to_physical(struct target *target, target_addr_t address, target_addr_t *physical)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
 
@@ -1694,7 +1692,7 @@ int nds32_virtual_to_physical(struct target *target, uint32_t address, uint32_t
 	return ERROR_FAIL;
 }
 
-int nds32_cache_sync(struct target *target, uint32_t address, uint32_t length)
+int nds32_cache_sync(struct target *target, target_addr_t address, uint32_t length)
 {
 	struct aice_port_s *aice = target_to_aice(target);
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -1740,7 +1738,7 @@ int nds32_cache_sync(struct target *target, uint32_t address, uint32_t length)
 			/* Because PSW.IT is turned off under debug exception, address MUST
 			 * be physical address.  L1I_VA_INVALIDATE uses PSW.IT to decide
 			 * address translation or not. */
-			uint32_t physical_addr;
+			target_addr_t physical_addr;
 			if (ERROR_FAIL == target->type->virt2phys(target, cur_address,
 						&physical_addr))
 				return ERROR_FAIL;
@@ -1766,7 +1764,7 @@ uint32_t nds32_nextpc(struct nds32 *nds32, int current, uint32_t address)
 }
 
 int nds32_step(struct target *target, int current,
-		uint32_t address, int handle_breakpoints)
+		target_addr_t address, int handle_breakpoints)
 {
 	LOG_DEBUG("target->state: %s",
 			target_state_name(target));
@@ -1780,7 +1778,7 @@ int nds32_step(struct target *target, int current,
 
 	address = nds32_nextpc(nds32, current, address);
 
-	LOG_DEBUG("STEP PC %08" PRIx32 "%s", address, !current ? "!" : "");
+	LOG_DEBUG("STEP PC %08" TARGET_PRIxADDR "%s", address, !current ? "!" : "");
 
 	/** set DSSIM */
 	uint32_t ir14_value;
@@ -2122,9 +2120,9 @@ int nds32_poll(struct target *target)
 }
 
 int nds32_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
+		target_addr_t address, int handle_breakpoints, int debug_execution)
 {
-	LOG_DEBUG("current %d address %08" PRIx32
+	LOG_DEBUG("current %d address %08" TARGET_PRIxADDR
 			" handle_breakpoints %d"
 			" debug_execution %d",
 			current, address, handle_breakpoints, debug_execution);
@@ -2138,7 +2136,7 @@ int nds32_resume(struct target *target, int current,
 
 	address = nds32_nextpc(nds32, current, address);
 
-	LOG_DEBUG("RESUME PC %08" PRIx32 "%s", address, !current ? "!" : "");
+	LOG_DEBUG("RESUME PC %08" TARGET_PRIxADDR "%s", address, !current ? "!" : "");
 
 	if (!debug_execution)
 		target_free_all_working_areas(target);
@@ -2199,6 +2197,13 @@ int nds32_assert_reset(struct target *target)
 	struct aice_port_s *aice = target_to_aice(target);
 	struct nds32_cpu_version *cpu_version = &(nds32->cpu_version);
 
+	/* TODO: apply hw reset signal in not examined state */
+	if (!(target_was_examined(target))) {
+		LOG_WARNING("Reset is not asserted because the target is not examined.");
+		LOG_WARNING("Use a reset button or power cycle the target.");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	if (target->reset_halt) {
 		if ((nds32->soft_reset_halt)
 			|| (nds32->edm.version < 0x51)
diff --git a/src/target/nds32.h b/src/target/nds32.h
index e4161e93..141dbf4c 100644
--- a/src/target/nds32.h
+++ b/src/target/nds32.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __NDS32_H__
-#define __NDS32_H__
+#ifndef OPENOCD_TARGET_NDS32_H
+#define OPENOCD_TARGET_NDS32_H
 
 #include <jtag/jtag.h>
 #include "target.h"
@@ -402,23 +400,23 @@ extern int nds32_get_mapped_reg(struct nds32 *nds32, unsigned regnum, uint32_t *
 extern int nds32_set_mapped_reg(struct nds32 *nds32, unsigned regnum, uint32_t value);
 
 extern int nds32_edm_config(struct nds32 *nds32);
-extern int nds32_cache_sync(struct target *target, uint32_t address, uint32_t length);
+extern int nds32_cache_sync(struct target *target, target_addr_t address, uint32_t length);
 extern int nds32_mmu(struct target *target, int *enabled);
-extern int nds32_virtual_to_physical(struct target *target, uint32_t address,
-		uint32_t *physical);
-extern int nds32_read_phys_memory(struct target *target, uint32_t address,
+extern int nds32_virtual_to_physical(struct target *target, target_addr_t address,
+		target_addr_t *physical);
+extern int nds32_read_phys_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer);
-extern int nds32_write_phys_memory(struct target *target, uint32_t address,
+extern int nds32_write_phys_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer);
 extern uint32_t nds32_nextpc(struct nds32 *nds32, int current, uint32_t address);
 extern int nds32_examine_debug_reason(struct nds32 *nds32);
 extern int nds32_step(struct target *target, int current,
-		uint32_t address, int handle_breakpoints);
+		target_addr_t address, int handle_breakpoints);
 extern int nds32_target_state(struct nds32 *nds32, enum target_state *state);
 extern int nds32_halt(struct target *target);
 extern int nds32_poll(struct target *target);
 extern int nds32_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution);
+		target_addr_t address, int handle_breakpoints, int debug_execution);
 extern int nds32_assert_reset(struct target *target);
 extern int nds32_init(struct nds32 *nds32);
 extern int nds32_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fileio_info);
@@ -456,4 +454,4 @@ static inline bool nds32_reach_max_interrupt_level(struct nds32 *nds32)
 	return nds32->max_interrupt_level == nds32->current_interrupt_level;
 }
 
-#endif /* __NDS32_H__ */
+#endif /* OPENOCD_TARGET_NDS32_H */
diff --git a/src/target/nds32_aice.c b/src/target/nds32_aice.c
index cfb6d86c..e494a3e1 100644
--- a/src/target/nds32_aice.c
+++ b/src/target/nds32_aice.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -44,8 +42,8 @@ int aice_write_reg_64(struct aice_port_s *aice, uint32_t num, uint64_t val)
 	return aice->port->api->write_reg_64(aice->coreid, num, val);
 }
 
-int aice_read_tlb(struct aice_port_s *aice, uint32_t virtual_address,
-		uint32_t *physical_address)
+int aice_read_tlb(struct aice_port_s *aice, target_addr_t virtual_address,
+		target_addr_t *physical_address)
 {
 	if (aice->port->api->read_tlb == NULL) {
 		LOG_WARNING("Not implemented: %s", __func__);
diff --git a/src/target/nds32_aice.h b/src/target/nds32_aice.h
index d5356433..5ea3b161 100644
--- a/src/target/nds32_aice.h
+++ b/src/target/nds32_aice.h
@@ -13,19 +13,18 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_AICE_H__
-#define __NDS32_AICE_H__
+
+#ifndef OPENOCD_TARGET_NDS32_AICE_H
+#define OPENOCD_TARGET_NDS32_AICE_H
 
 #include <jtag/aice/aice_port.h>
 
 int aice_read_reg_64(struct aice_port_s *aice, uint32_t num, uint64_t *val);
 int aice_write_reg_64(struct aice_port_s *aice, uint32_t num, uint64_t val);
-int aice_read_tlb(struct aice_port_s *aice, uint32_t virtual_address,
-		uint32_t *physical_address);
+int aice_read_tlb(struct aice_port_s *aice, target_addr_t virtual_address,
+		target_addr_t *physical_address);
 int aice_cache_ctl(struct aice_port_s *aice, uint32_t subtype, uint32_t address);
 int aice_set_retry_times(struct aice_port_s *aice, uint32_t a_retry_times);
 int aice_program_edm(struct aice_port_s *aice, char *command_sequence);
@@ -159,4 +158,4 @@ static inline int aice_set_data_endian(struct aice_port_s *aice,
 	return aice->port->api->set_data_endian(aice->coreid, target_data_endian);
 }
 
-#endif
+#endif /* OPENOCD_TARGET_NDS32_AICE_H */
diff --git a/src/target/nds32_cmd.c b/src/target/nds32_cmd.c
index faf9e0ae..500651db 100644
--- a/src/target/nds32_cmd.c
+++ b/src/target/nds32_cmd.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -818,7 +816,7 @@ static int jim_nds32_bulk_read(Jim_Interp *interp, int argc, Jim_Obj * const *ar
 	uint32_t *data = malloc(count * sizeof(uint32_t));
 	int result;
 	result = target_read_buffer(target, address, count * 4, (uint8_t *)data);
-	char data_str[11];
+	char data_str[12];
 
 	jim_wide i;
 	Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
@@ -846,7 +844,7 @@ static int jim_nds32_read_edm_sr(Jim_Interp *interp, int argc, Jim_Obj * const *
 	}
 
 	int e;
-	char *edm_sr_name;
+	const char *edm_sr_name;
 	int edm_sr_name_len;
 	e = Jim_GetOpt_String(&goi, &edm_sr_name, &edm_sr_name_len);
 	if (e != JIM_OK)
@@ -892,7 +890,7 @@ static int jim_nds32_write_edm_sr(Jim_Interp *interp, int argc, Jim_Obj * const
 	}
 
 	int e;
-	char *edm_sr_name;
+	const char *edm_sr_name;
 	int edm_sr_name_len;
 	e = Jim_GetOpt_String(&goi, &edm_sr_name, &edm_sr_name_len);
 	if (e != JIM_OK)
diff --git a/src/target/nds32_cmd.h b/src/target/nds32_cmd.h
index 44d361e5..543ba54c 100644
--- a/src/target/nds32_cmd.h
+++ b/src/target/nds32_cmd.h
@@ -13,15 +13,14 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __NDS32_CMD_H__
-#define __NDS32_CMD_H__
+#ifndef OPENOCD_TARGET_NDS32_CMD_H
+#define OPENOCD_TARGET_NDS32_CMD_H
+
 #include <helper/command.h>
 
 extern const struct command_registration nds32_command_handlers[];
 
-#endif /* __NDS32_CMD_H__ */
+#endif /* OPENOCD_TARGET_NDS32_CMD_H */
diff --git a/src/target/nds32_disassembler.c b/src/target/nds32_disassembler.c
index 8565f855..f27aba2c 100644
--- a/src/target/nds32_disassembler.c
+++ b/src/target/nds32_disassembler.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/nds32_disassembler.h b/src/target/nds32_disassembler.h
index ac0222e6..9117cbb0 100644
--- a/src/target/nds32_disassembler.h
+++ b/src/target/nds32_disassembler.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef __NDS32_DISASSEMBLER_H__
-#define __NDS32_DISASSEMBLER_H__
+#ifndef OPENOCD_TARGET_NDS32_DISASSEMBLER_H
+#define OPENOCD_TARGET_NDS32_DISASSEMBLER_H
 
 #include <target/nds32.h>
 
@@ -55,4 +53,4 @@ int nds32_read_opcode(struct nds32 *nds32, uint32_t address, uint32_t *value);
 int nds32_evaluate_opcode(struct nds32 *nds32, uint32_t opcode, uint32_t address,
 		struct nds32_instruction *instruction);
 
-#endif /* __NDS32_DISASSEMBLER_H__ */
+#endif /* OPENOCD_TARGET_NDS32_DISASSEMBLER_H */
diff --git a/src/target/nds32_edm.h b/src/target/nds32_edm.h
index 1eab7b00..1dec190f 100644
--- a/src/target/nds32_edm.h
+++ b/src/target/nds32_edm.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_EDM_H__
-#define __NDS32_EDM_H__
+
+#ifndef OPENOCD_TARGET_NDS32_EDM_H
+#define OPENOCD_TARGET_NDS32_EDM_H
 
 /**
  * @file
@@ -113,4 +112,4 @@ enum nds_memory_select {
 #define NDS_EDMSW_WDV		(1 << 0)
 #define NDS_EDMSW_RDV		(1 << 1)
 
-#endif /* __NDS32_EDM_H__ */
+#endif /* OPENOCD_TARGET_NDS32_EDM_H */
diff --git a/src/target/nds32_insn.h b/src/target/nds32_insn.h
index 08d3c5ca..eb666451 100644
--- a/src/target/nds32_insn.h
+++ b/src/target/nds32_insn.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_INSN_H__
-#define __NDS32_INSN_H__
 
+#ifndef OPENOCD_TARGET_NDS32_INSN_H
+#define OPENOCD_TARGET_NDS32_INSN_H
 
 #define NOP						(0x40000009)
 #define DSB						(0x64000008)
@@ -77,5 +75,4 @@
 extern const int NDS32_BREAK_16;
 extern const int NDS32_BREAK_32;
 
-
-#endif /* __NDS32_INSN_H__ */
+#endif /* OPENOCD_TARGET_NDS32_INSN_H */
diff --git a/src/target/nds32_reg.c b/src/target/nds32_reg.c
index f82ffbfc..7cefcb1a 100644
--- a/src/target/nds32_reg.c
+++ b/src/target/nds32_reg.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
diff --git a/src/target/nds32_reg.h b/src/target/nds32_reg.h
index 1c61b616..8808cd24 100644
--- a/src/target/nds32_reg.h
+++ b/src/target/nds32_reg.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_REG_H__
-#define __NDS32_REG_H__
+
+#ifndef OPENOCD_TARGET_NDS32_REG_H
+#define OPENOCD_TARGET_NDS32_REG_H
 
 #define SRIDX(a, b, c)			((a << 7) | (b << 3) | c)
 #define NDS32_REGISTER_DISABLE		(0x0)
@@ -323,4 +322,4 @@ const char *nds32_reg_simple_name(uint32_t number);
 const char *nds32_reg_symbolic_name(uint32_t number);
 bool nds32_reg_exception(uint32_t number, uint32_t value);
 
-#endif
+#endif /* OPENOCD_TARGET_NDS32_REG_H */
diff --git a/src/target/nds32_tlb.c b/src/target/nds32_tlb.c
index 58322cf1..c4bce1a6 100644
--- a/src/target/nds32_tlb.c
+++ b/src/target/nds32_tlb.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -24,8 +22,8 @@
 #include "nds32_aice.h"
 #include "nds32_tlb.h"
 
-int nds32_probe_tlb(struct nds32 *nds32, const uint32_t virtual_address,
-		uint32_t *physical_address)
+int nds32_probe_tlb(struct nds32 *nds32, const target_addr_t virtual_address,
+		target_addr_t *physical_address)
 {
 	struct target *target = nds32->target;
 	struct aice_port_s *aice = target_to_aice(target);
@@ -40,8 +38,8 @@ struct page_table_walker_info_s page_table_info[PAGE_SIZE_NUM] = {
 	{0xFF000000, 22, 0x00FFE000, 11, 0x00001FFF, 0xFFFFF000, 0xFFFFE000, 0xFFFFE000},
 };
 
-int nds32_walk_page_table(struct nds32 *nds32, const uint32_t virtual_address,
-		uint32_t *physical_address)
+int nds32_walk_page_table(struct nds32 *nds32, const target_addr_t virtual_address,
+		target_addr_t *physical_address)
 {
 	struct target *target = nds32->target;
 	uint32_t value_mr1;
diff --git a/src/target/nds32_tlb.h b/src/target/nds32_tlb.h
index 59e11573..62512c11 100644
--- a/src/target/nds32_tlb.h
+++ b/src/target/nds32_tlb.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_TLB_H__
-#define __NDS32_TLB_H__
+
+#ifndef OPENOCD_TARGET_NDS32_TLB_H
+#define OPENOCD_TARGET_NDS32_TLB_H
 
 #include "nds32.h"
 
@@ -40,9 +39,9 @@ struct page_table_walker_info_s {
 	uint32_t ppn_mask;
 };
 
-extern int nds32_probe_tlb(struct nds32 *nds32, const uint32_t virtual_address,
-		uint32_t *physical_address);
-extern int nds32_walk_page_table(struct nds32 *nds32, const uint32_t virtual_address,
-		uint32_t *physical_address);
+extern int nds32_probe_tlb(struct nds32 *nds32, const target_addr_t virtual_address,
+		target_addr_t *physical_address);
+extern int nds32_walk_page_table(struct nds32 *nds32, const target_addr_t virtual_address,
+		target_addr_t *physical_address);
 
-#endif
+#endif /* OPENOCD_TARGET_NDS32_TLB_H */
diff --git a/src/target/nds32_v2.c b/src/target/nds32_v2.c
index ac2aad0b..29489a03 100644
--- a/src/target/nds32_v2.c
+++ b/src/target/nds32_v2.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -114,7 +112,7 @@ static int nds32_v2_activate_hardware_breakpoint(struct target *target)
 				/* enable breakpoint (physical address) */
 				aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + hbr_index, 0xA);
 
-			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" TARGET_PRIxADDR, hbr_index,
 					bp->address);
 
 			hbr_index++;
@@ -141,7 +139,7 @@ static int nds32_v2_deactivate_hardware_breakpoint(struct target *target)
 		else
 			return ERROR_FAIL;
 
-		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" TARGET_PRIxADDR, hbr_index,
 				bp->address);
 
 		hbr_index++;
@@ -186,7 +184,7 @@ static int nds32_v2_activate_hardware_watchpoint(struct target *target)
 		/* set value */
 		aice_write_debug_reg(aice, NDS_EDM_SR_BPV0 + wp_num, 0);
 
-		LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx32 " mask %08" PRIx32, wp_num,
+		LOG_DEBUG("Add hardware watchpoint %" PRId32 " at %08" TARGET_PRIxADDR " mask %08" PRIx32, wp_num,
 				wp->address, wp->mask);
 
 	}
@@ -206,7 +204,7 @@ static int nds32_v2_deactivate_hardware_watchpoint(struct target *target)
 		/* disable watchpoint */
 		aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, 0x0);
 
-		LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx32 " mask %08" PRIx32,
+		LOG_DEBUG("Remove hardware watchpoint %" PRId32 " at %08" TARGET_PRIxADDR " mask %08" PRIx32,
 				wp_num, wp->address, wp->mask);
 	}
 
@@ -407,7 +405,7 @@ static int nds32_v2_deassert_reset(struct target *target)
 }
 
 static int nds32_v2_checksum_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *checksum)
+		target_addr_t address, uint32_t count, uint32_t *checksum)
 {
 	LOG_WARNING("Not implemented: %s", __func__);
 
@@ -563,8 +561,8 @@ static int nds32_v2_run_algorithm(struct target *target,
 		struct mem_param *mem_params,
 		int num_reg_params,
 		struct reg_param *reg_params,
-		uint32_t entry_point,
-		uint32_t exit_point,
+		target_addr_t entry_point,
+		target_addr_t exit_point,
 		int timeout_ms,
 		void *arch_info)
 {
@@ -637,11 +635,11 @@ static int nds32_v2_examine(struct target *target)
 	return ERROR_OK;
 }
 
-static int nds32_v2_translate_address(struct target *target, uint32_t *address)
+static int nds32_v2_translate_address(struct target *target, target_addr_t *address)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
 	struct nds32_memory *memory = &(nds32->memory);
-	uint32_t physical_address;
+	target_addr_t physical_address;
 
 	/* Following conditions need to do address translation
 	 * 1. BUS mode
@@ -658,7 +656,7 @@ static int nds32_v2_translate_address(struct target *target, uint32_t *address)
 	return ERROR_OK;
 }
 
-static int nds32_v2_read_buffer(struct target *target, uint32_t address,
+static int nds32_v2_read_buffer(struct target *target, target_addr_t address,
 		uint32_t size, uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -678,7 +676,7 @@ static int nds32_v2_read_buffer(struct target *target, uint32_t address,
 	return nds32_read_buffer(target, address, size, buffer);
 }
 
-static int nds32_v2_write_buffer(struct target *target, uint32_t address,
+static int nds32_v2_write_buffer(struct target *target, target_addr_t address,
 		uint32_t size, const uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -698,7 +696,7 @@ static int nds32_v2_write_buffer(struct target *target, uint32_t address,
 	return nds32_write_buffer(target, address, size, buffer);
 }
 
-static int nds32_v2_read_memory(struct target *target, uint32_t address,
+static int nds32_v2_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -718,7 +716,7 @@ static int nds32_v2_read_memory(struct target *target, uint32_t address,
 	return nds32_read_memory(target, address, size, count, buffer);
 }
 
-static int nds32_v2_write_memory(struct target *target, uint32_t address,
+static int nds32_v2_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
diff --git a/src/target/nds32_v2.h b/src/target/nds32_v2.h
index b3980557..dcc08c29 100644
--- a/src/target/nds32_v2.h
+++ b/src/target/nds32_v2.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_V2_H__
-#define __NDS32_V2_H__
+
+#ifndef OPENOCD_TARGET_NDS32_V2_H
+#define OPENOCD_TARGET_NDS32_V2_H
 
 #include "nds32.h"
 
@@ -40,5 +39,4 @@ static inline struct nds32_v2_common *target_to_nds32_v2(struct target *target)
 	return container_of(target->arch_info, struct nds32_v2_common, nds32);
 }
 
-
-#endif	/* __NDS32_V2_H__ */
+#endif /* OPENOCD_TARGET_NDS32_V2_H */
diff --git a/src/target/nds32_v3.c b/src/target/nds32_v3.c
index 22466501..e5d146bb 100644
--- a/src/target/nds32_v3.c
+++ b/src/target/nds32_v3.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -55,7 +53,7 @@ static int nds32_v3_activate_hardware_breakpoint(struct target *target)
 				/* enable breakpoint (physical address) */
 				aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + hbr_index, 0xA);
 
-			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" TARGET_PRIxADDR, hbr_index,
 					bp->address);
 		} else {
 			return ERROR_FAIL;
@@ -83,7 +81,7 @@ static int nds32_v3_deactivate_hardware_breakpoint(struct target *target)
 			return ERROR_FAIL;
 		}
 
-		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" TARGET_PRIxADDR, hbr_index,
 				bp->address);
 	}
 
@@ -130,7 +128,7 @@ static int nds32_v3_activate_hardware_watchpoint(struct target *target)
 			/* set value */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPV0 + wp_num, 0);
 
-			LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx32 " mask %08" PRIx32,
+			LOG_DEBUG("Add hardware watchpoint %" PRId32 " at %08" TARGET_PRIxADDR " mask %08" PRIx32,
 					wp_num, wp->address, wp->mask);
 
 			wp_num++;
@@ -171,7 +169,7 @@ static int nds32_v3_deactivate_hardware_watchpoint(struct target *target)
 			/* disable watchpoint */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, 0x0);
 
-			LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx32
+			LOG_DEBUG("Remove hardware watchpoint %" PRId32 " at %08" TARGET_PRIxADDR
 					" mask %08" PRIx32, wp_num,
 					wp->address, wp->mask);
 			wp_num++;
diff --git a/src/target/nds32_v3.h b/src/target/nds32_v3.h
index 7476b202..a5df8fe5 100644
--- a/src/target/nds32_v3.h
+++ b/src/target/nds32_v3.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_V3_H__
-#define __NDS32_V3_H__
+
+#ifndef OPENOCD_TARGET_NDS32_V3_H
+#define OPENOCD_TARGET_NDS32_V3_H
 
 #include "nds32.h"
 
@@ -43,4 +42,4 @@ static inline struct nds32_v3_common *target_to_nds32_v3(struct target *target)
 	return container_of(target->arch_info, struct nds32_v3_common, nds32);
 }
 
-#endif	/* __NDS32_V3_H__ */
+#endif /* OPENOCD_TARGET_NDS32_V3_H */
diff --git a/src/target/nds32_v3_common.c b/src/target/nds32_v3_common.c
index 6dc20982..271ffdd1 100644
--- a/src/target/nds32_v3_common.c
+++ b/src/target/nds32_v3_common.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -370,7 +368,7 @@ int nds32_v3_target_request_data(struct target *target,
 }
 
 int nds32_v3_checksum_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *checksum)
+		target_addr_t address, uint32_t count, uint32_t *checksum)
 {
 	LOG_WARNING("Not implemented: %s", __func__);
 
@@ -436,8 +434,8 @@ int nds32_v3_run_algorithm(struct target *target,
 		struct mem_param *mem_params,
 		int num_reg_params,
 		struct reg_param *reg_params,
-		uint32_t entry_point,
-		uint32_t exit_point,
+		target_addr_t entry_point,
+		target_addr_t exit_point,
 		int timeout_ms,
 		void *arch_info)
 {
@@ -446,7 +444,7 @@ int nds32_v3_run_algorithm(struct target *target,
 	return ERROR_FAIL;
 }
 
-int nds32_v3_read_buffer(struct target *target, uint32_t address,
+int nds32_v3_read_buffer(struct target *target, target_addr_t address,
 		uint32_t size, uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -458,7 +456,7 @@ int nds32_v3_read_buffer(struct target *target, uint32_t address,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	uint32_t physical_address;
+	target_addr_t physical_address;
 	/* BUG: If access range crosses multiple pages, the translation will not correct
 	 * for second page or so. */
 
@@ -504,7 +502,7 @@ int nds32_v3_read_buffer(struct target *target, uint32_t address,
 	return result;
 }
 
-int nds32_v3_write_buffer(struct target *target, uint32_t address,
+int nds32_v3_write_buffer(struct target *target, target_addr_t address,
 		uint32_t size, const uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -516,7 +514,7 @@ int nds32_v3_write_buffer(struct target *target, uint32_t address,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	uint32_t physical_address;
+	target_addr_t physical_address;
 	/* BUG: If access range crosses multiple pages, the translation will not correct
 	 * for second page or so. */
 
@@ -566,7 +564,7 @@ int nds32_v3_write_buffer(struct target *target, uint32_t address,
 	return nds32_write_buffer(target, address, size, buffer);
 }
 
-int nds32_v3_read_memory(struct target *target, uint32_t address,
+int nds32_v3_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -578,7 +576,7 @@ int nds32_v3_read_memory(struct target *target, uint32_t address,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	uint32_t physical_address;
+	target_addr_t physical_address;
 	/* BUG: If access range crosses multiple pages, the translation will not correct
 	 * for second page or so. */
 
@@ -624,7 +622,7 @@ int nds32_v3_read_memory(struct target *target, uint32_t address,
 	return result;
 }
 
-int nds32_v3_write_memory(struct target *target, uint32_t address,
+int nds32_v3_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct nds32 *nds32 = target_to_nds32(target);
@@ -636,7 +634,7 @@ int nds32_v3_write_memory(struct target *target, uint32_t address,
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	uint32_t physical_address;
+	target_addr_t physical_address;
 	/* BUG: If access range crosses multiple pages, the translation will not correct
 	 * for second page or so. */
 
diff --git a/src/target/nds32_v3_common.h b/src/target/nds32_v3_common.h
index fd4a5907..23393e55 100644
--- a/src/target/nds32_v3_common.h
+++ b/src/target/nds32_v3_common.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_V3_COMMON_H__
-#define __NDS32_V3_COMMON_H__
+
+#ifndef OPENOCD_TARGET_NDS32_V3_COMMON_H
+#define OPENOCD_TARGET_NDS32_V3_COMMON_H
 
 #include "target.h"
 
@@ -35,7 +34,7 @@ void nds32_v3_common_register_callback(struct nds32_v3_common_callback *callback
 int nds32_v3_target_request_data(struct target *target,
 		uint32_t size, uint8_t *buffer);
 int nds32_v3_checksum_memory(struct target *target,
-		uint32_t address, uint32_t count, uint32_t *checksum);
+		target_addr_t address, uint32_t count, uint32_t *checksum);
 int nds32_v3_hit_watchpoint(struct target *target,
 		struct watchpoint **hit_watchpoint);
 int nds32_v3_target_create_common(struct target *target, struct nds32 *nds32);
@@ -44,19 +43,19 @@ int nds32_v3_run_algorithm(struct target *target,
 		struct mem_param *mem_params,
 		int num_reg_params,
 		struct reg_param *reg_params,
-		uint32_t entry_point,
-		uint32_t exit_point,
+		target_addr_t entry_point,
+		target_addr_t exit_point,
 		int timeout_ms,
 		void *arch_info);
-int nds32_v3_read_buffer(struct target *target, uint32_t address,
+int nds32_v3_read_buffer(struct target *target, target_addr_t address,
 		uint32_t size, uint8_t *buffer);
-int nds32_v3_write_buffer(struct target *target, uint32_t address,
+int nds32_v3_write_buffer(struct target *target, target_addr_t address,
 		uint32_t size, const uint8_t *buffer);
-int nds32_v3_read_memory(struct target *target, uint32_t address,
+int nds32_v3_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer);
-int nds32_v3_write_memory(struct target *target, uint32_t address,
+int nds32_v3_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer);
 int nds32_v3_init_target(struct command_context *cmd_ctx,
 		struct target *target);
 
-#endif	/* __NDS32_V3_COMMON_H__ */
+#endif /* OPENOCD_TARGET_NDS32_V3_COMMON_H */
diff --git a/src/target/nds32_v3m.c b/src/target/nds32_v3m.c
index accc8d05..86903a51 100644
--- a/src/target/nds32_v3m.c
+++ b/src/target/nds32_v3m.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -52,7 +50,7 @@ static int nds32_v3m_activate_hardware_breakpoint(struct target *target)
 				/* enable breakpoint (physical address) */
 				aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + brp_num, 0xA);
 
-			LOG_DEBUG("Add hardware BP %u at %08" PRIx32, brp_num,
+			LOG_DEBUG("Add hardware BP %u at %08" TARGET_PRIxADDR, brp_num,
 					bp->address);
 
 			brp_num--;
@@ -80,7 +78,7 @@ static int nds32_v3m_deactivate_hardware_breakpoint(struct target *target)
 		else
 			return ERROR_FAIL;
 
-		LOG_DEBUG("Remove hardware BP %u at %08" PRIx32, brp_num,
+		LOG_DEBUG("Remove hardware BP %u at %08" TARGET_PRIxADDR, brp_num,
 				bp->address);
 
 		brp_num--;
@@ -127,7 +125,7 @@ static int nds32_v3m_activate_hardware_watchpoint(struct target *target)
 			/* enable watchpoint */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, wp_config);
 
-			LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx32
+			LOG_DEBUG("Add hardware watchpoint %" PRId32 " at %08" TARGET_PRIxADDR
 					" mask %08" PRIx32, wp_num, wp->address, wp->mask);
 
 			wp_num++;
@@ -168,7 +166,7 @@ static int nds32_v3m_deactivate_hardware_watchpoint(struct target *target)
 			/* disable watchpoint */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, 0x0);
 
-			LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx32
+			LOG_DEBUG("Remove hardware watchpoint %" PRId32 " at %08" TARGET_PRIxADDR
 					" mask %08" PRIx32, wp_num, wp->address, wp->mask);
 			wp_num++;
 		} else if (nds32_v3m->nds32.global_stop) {
diff --git a/src/target/nds32_v3m.h b/src/target/nds32_v3m.h
index d72c2ad4..1e7427c4 100644
--- a/src/target/nds32_v3m.h
+++ b/src/target/nds32_v3m.h
@@ -13,12 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
-#ifndef __NDS32_V3M_H__
-#define __NDS32_V3M_H__
+
+#ifndef OPENOCD_TARGET_NDS32_V3M_H
+#define OPENOCD_TARGET_NDS32_V3M_H
 
 #include "nds32.h"
 
@@ -49,5 +48,4 @@ static inline struct nds32_v3m_common *target_to_nds32_v3m(struct target *target
 	return container_of(target->arch_info, struct nds32_v3m_common, nds32);
 }
 
-
-#endif	/* __NDS32_V3M_H__ */
+#endif /* OPENOCD_TARGET_NDS32_V3M_H */
diff --git a/src/target/oocd_trace.c b/src/target/oocd_trace.c
index e723efe0..627366d5 100644
--- a/src/target/oocd_trace.c
+++ b/src/target/oocd_trace.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/oocd_trace.h b/src/target/oocd_trace.h
index 5773674d..e7584e4c 100644
--- a/src/target/oocd_trace.h
+++ b/src/target/oocd_trace.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef OOCD_TRACE_H
-#define OOCD_TRACE_H
+#ifndef OPENOCD_TARGET_OOCD_TRACE_H
+#define OPENOCD_TARGET_OOCD_TRACE_H
 
 #include <termios.h>
 
@@ -52,4 +50,4 @@ struct oocd_trace {
 
 extern struct etm_capture_driver oocd_trace_capture_driver;
 
-#endif /* OOCD_TRACE_TRACE_H */
+#endif /* OPENOCD_TARGET_OOCD_TRACE_H */
diff --git a/src/target/openrisc/Makefile.am b/src/target/openrisc/Makefile.am
index b00a30d6..5a2549a5 100644
--- a/src/target/openrisc/Makefile.am
+++ b/src/target/openrisc/Makefile.am
@@ -1,18 +1,12 @@
-include $(top_srcdir)/common.mk
-
-noinst_LTLIBRARIES = libopenrisc.la
-libopenrisc_la_SOURCES = $(OPENRISC_SRC)
-
-OPENRISC_SRC = \
-	or1k.c \
-	or1k_du_adv.c \
-	or1k_tap_mohor.c \
-	or1k_tap_vjtag.c \
-	or1k_tap_xilinx_bscan.c \
-	jsp_server.c
-
-noinst_HEADERS = \
-	or1k.h \
-	or1k_du.h \
-	or1k_tap.h \
-	jsp_server.h
+noinst_LTLIBRARIES += %D%/libopenrisc.la
+%C%_libopenrisc_la_SOURCES = \
+	%D%/or1k.c \
+	%D%/or1k_du_adv.c \
+	%D%/or1k_tap_mohor.c \
+	%D%/or1k_tap_vjtag.c \
+	%D%/or1k_tap_xilinx_bscan.c \
+	%D%/jsp_server.c \
+	%D%/or1k.h \
+	%D%/or1k_du.h \
+	%D%/or1k_tap.h \
+	%D%/jsp_server.h
diff --git a/src/target/openrisc/jsp_server.c b/src/target/openrisc/jsp_server.c
index 83e03ae3..2d90114f 100644
--- a/src/target/openrisc/jsp_server.c
+++ b/src/target/openrisc/jsp_server.c
@@ -15,9 +15,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -90,7 +88,6 @@ static int jsp_new_connection(struct connection *connection)
 	telnet_connection->closed = 0;
 	telnet_connection->line_size = 0;
 	telnet_connection->line_cursor = 0;
-	telnet_connection->option_size = 0;
 	telnet_connection->state = TELNET_STATE_DATA;
 
 	/* negotiate telnet options */
diff --git a/src/target/openrisc/jsp_server.h b/src/target/openrisc/jsp_server.h
index 3e7c1145..f8e71215 100644
--- a/src/target/openrisc/jsp_server.h
+++ b/src/target/openrisc/jsp_server.h
@@ -1,5 +1,5 @@
-#ifndef _JSP_SERVER_H_
-#define _JSP_SERVER_H_
+#ifndef OPENOCD_TARGET_OPENRISC_JSP_SERVER_H
+#define OPENOCD_TARGET_OPENRISC_JSP_SERVER_H
 
 #include "or1k_tap.h"
 #include "or1k.h"
@@ -14,4 +14,4 @@ struct jsp_service {
 int jsp_init(struct or1k_jtag *jtag_info, char *banner);
 int jsp_register_commands(struct command_context *cmd_ctx);
 
-#endif	/* _JSP_SERVER_H_ */
+#endif /* OPENOCD_TARGET_OPENRISC_JSP_SERVER_H */
diff --git a/src/target/openrisc/or1k.c b/src/target/openrisc/or1k.c
index 33de63e2..3895ddfa 100644
--- a/src/target/openrisc/or1k.c
+++ b/src/target/openrisc/or1k.c
@@ -18,6 +18,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -858,7 +861,7 @@ static int or1k_resume_or_step(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("Unset breakpoint at 0x%08" PRIx32, breakpoint->address);
+			LOG_DEBUG("Unset breakpoint at 0x%08" TARGET_PRIxADDR, breakpoint->address);
 			retval = or1k_remove_breakpoint(target, breakpoint);
 			if (retval != ERROR_OK)
 				return retval;
@@ -894,7 +897,8 @@ static int or1k_resume_or_step(struct target *target, int current,
 }
 
 static int or1k_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
+		       target_addr_t address, int handle_breakpoints,
+		       int debug_execution)
 {
 	return or1k_resume_or_step(target, current, address,
 				   handle_breakpoints,
@@ -903,7 +907,7 @@ static int or1k_resume(struct target *target, int current,
 }
 
 static int or1k_step(struct target *target, int current,
-		     uint32_t address, int handle_breakpoints)
+		     target_addr_t address, int handle_breakpoints)
 {
 	return or1k_resume_or_step(target, current, address,
 				   handle_breakpoints,
@@ -919,7 +923,7 @@ static int or1k_add_breakpoint(struct target *target,
 	struct or1k_du *du_core = or1k_to_du(or1k);
 	uint8_t data;
 
-	LOG_DEBUG("Adding breakpoint: addr 0x%08" PRIx32 ", len %d, type %d, set: %d, id: %" PRId32,
+	LOG_DEBUG("Adding breakpoint: addr 0x%08" TARGET_PRIxADDR ", len %d, type %d, set: %d, id: %" PRId32,
 		  breakpoint->address, breakpoint->length, breakpoint->type,
 		  breakpoint->set, breakpoint->unique_id);
 
@@ -934,7 +938,7 @@ static int or1k_add_breakpoint(struct target *target,
 					 1,
 					 &data);
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while reading the instruction at 0x%08" PRIx32,
+		LOG_ERROR("Error while reading the instruction at 0x%08" TARGET_PRIxADDR,
 			   breakpoint->address);
 		return retval;
 	}
@@ -955,14 +959,15 @@ static int or1k_add_breakpoint(struct target *target,
 					  or1k_trap_insn);
 
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while writing OR1K_TRAP_INSTR at 0x%08" PRIx32,
+		LOG_ERROR("Error while writing OR1K_TRAP_INSTR at 0x%08" TARGET_PRIxADDR,
 			   breakpoint->address);
 		return retval;
 	}
 
 	/* invalidate instruction cache */
+	uint32_t addr = breakpoint->address;
 	retval = du_core->or1k_jtag_write_cpu(&or1k->jtag,
-			OR1K_ICBIR_CPU_REG_ADD, 1, &breakpoint->address);
+			OR1K_ICBIR_CPU_REG_ADD, 1, &addr);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Error while invalidating the ICACHE");
 		return retval;
@@ -977,7 +982,7 @@ static int or1k_remove_breakpoint(struct target *target,
 	struct or1k_common *or1k = target_to_or1k(target);
 	struct or1k_du *du_core = or1k_to_du(or1k);
 
-	LOG_DEBUG("Removing breakpoint: addr 0x%08" PRIx32 ", len %d, type %d, set: %d, id: %" PRId32,
+	LOG_DEBUG("Removing breakpoint: addr 0x%08" TARGET_PRIxADDR ", len %d, type %d, set: %d, id: %" PRId32,
 		  breakpoint->address, breakpoint->length, breakpoint->type,
 		  breakpoint->set, breakpoint->unique_id);
 
@@ -993,14 +998,15 @@ static int or1k_remove_breakpoint(struct target *target,
 					  breakpoint->orig_instr);
 
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while writing back the instruction at 0x%08" PRIx32,
+		LOG_ERROR("Error while writing back the instruction at 0x%08" TARGET_PRIxADDR,
 			   breakpoint->address);
 		return retval;
 	}
 
 	/* invalidate instruction cache */
+	uint32_t addr = breakpoint->address;
 	retval = du_core->or1k_jtag_write_cpu(&or1k->jtag,
-			OR1K_ICBIR_CPU_REG_ADD, 1, &breakpoint->address);
+			OR1K_ICBIR_CPU_REG_ADD, 1, &addr);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Error while invalidating the ICACHE");
 		return retval;
@@ -1023,13 +1029,13 @@ static int or1k_remove_watchpoint(struct target *target,
 	return ERROR_OK;
 }
 
-static int or1k_read_memory(struct target *target, uint32_t address,
+static int or1k_read_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct or1k_common *or1k = target_to_or1k(target);
 	struct or1k_du *du_core = or1k_to_du(or1k);
 
-	LOG_DEBUG("Read memory at 0x%08" PRIx32 ", size: %" PRIu32 ", count: 0x%08" PRIx32, address, size, count);
+	LOG_DEBUG("Read memory at 0x%08" TARGET_PRIxADDR ", size: %" PRIu32 ", count: 0x%08" PRIx32, address, size, count);
 
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("Target not halted");
@@ -1050,13 +1056,13 @@ static int or1k_read_memory(struct target *target, uint32_t address,
 	return du_core->or1k_jtag_read_memory(&or1k->jtag, address, size, count, buffer);
 }
 
-static int or1k_write_memory(struct target *target, uint32_t address,
+static int or1k_write_memory(struct target *target, target_addr_t address,
 		uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct or1k_common *or1k = target_to_or1k(target);
 	struct or1k_du *du_core = or1k_to_du(or1k);
 
-	LOG_DEBUG("Write memory at 0x%08" PRIx32 ", size: %" PRIu32 ", count: 0x%08" PRIx32, address, size, count);
+	LOG_DEBUG("Write memory at 0x%08" TARGET_PRIxADDR ", size: %" PRIu32 ", count: 0x%08" PRIx32, address, size, count);
 
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("Target not halted");
@@ -1200,7 +1206,7 @@ int or1k_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *file
 	return ERROR_FAIL;
 }
 
-static int or1k_checksum_memory(struct target *target, uint32_t address,
+static int or1k_checksum_memory(struct target *target, target_addr_t address,
 		uint32_t count, uint32_t *checksum) {
 
 	return ERROR_FAIL;
diff --git a/src/target/openrisc/or1k.h b/src/target/openrisc/or1k.h
index 25024dc3..c456ccbe 100644
--- a/src/target/openrisc/or1k.h
+++ b/src/target/openrisc/or1k.h
@@ -18,10 +18,13 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef OR1K_H
-#define OR1K_H
+#ifndef OPENOCD_TARGET_OPENRISC_OR1K_H
+#define OPENOCD_TARGET_OPENRISC_OR1K_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -152,4 +155,4 @@ enum or1k_debug_reg_nums {
  */
 #define OR1K_ICBIR_CPU_REG_ADD ((4 << 11) + 2)             /* IC Block Invalidate Register 0x2002 */
 
-#endif
+#endif /* OPENOCD_TARGET_OPENRISC_OR1K_H */
diff --git a/src/target/openrisc/or1k_du.h b/src/target/openrisc/or1k_du.h
index cc22fdb9..9828b0d2 100644
--- a/src/target/openrisc/or1k_du.h
+++ b/src/target/openrisc/or1k_du.h
@@ -11,10 +11,13 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef OR1K_DU
-#define OR1K_DU
+#ifndef OPENOCD_TARGET_OPENRISC_OR1K_DU_H
+#define OPENOCD_TARGET_OPENRISC_OR1K_DU_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -72,5 +75,4 @@ int or1k_adv_jtag_jsp_xfer(struct or1k_jtag *jtag_info,
 				  int *out_len, unsigned char *out_buffer,
 				  int *in_len, unsigned char *in_buffer);
 
-#endif
-
+#endif /* OPENOCD_TARGET_OPENRISC_OR1K_DU_H */
diff --git a/src/target/openrisc/or1k_du_adv.c b/src/target/openrisc/or1k_du_adv.c
index e4681ffb..bdd6fc8c 100644
--- a/src/target/openrisc/or1k_du_adv.c
+++ b/src/target/openrisc/or1k_du_adv.c
@@ -19,6 +19,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/openrisc/or1k_tap.h b/src/target/openrisc/or1k_tap.h
index cce11897..2cf7da80 100644
--- a/src/target/openrisc/or1k_tap.h
+++ b/src/target/openrisc/or1k_tap.h
@@ -11,10 +11,13 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef _OR1K_TAP_H_
-#define _OR1K_TAP_H_
+#ifndef OPENOCD_TARGET_OPENRISC_OR1K_TAP_H
+#define OPENOCD_TARGET_OPENRISC_OR1K_TAP_H
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
@@ -36,4 +39,4 @@ struct or1k_tap_ip {
 	const char *name;
 };
 
-#endif
+#endif /* OPENOCD_TARGET_OPENRISC_OR1K_TAP_H */
diff --git a/src/target/openrisc/or1k_tap_mohor.c b/src/target/openrisc/or1k_tap_mohor.c
index b654b1b5..1415e321 100644
--- a/src/target/openrisc/or1k_tap_mohor.c
+++ b/src/target/openrisc/or1k_tap_mohor.c
@@ -11,6 +11,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/openrisc/or1k_tap_vjtag.c b/src/target/openrisc/or1k_tap_vjtag.c
index c3b942b2..607451a7 100644
--- a/src/target/openrisc/or1k_tap_vjtag.c
+++ b/src/target/openrisc/or1k_tap_vjtag.c
@@ -11,6 +11,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/openrisc/or1k_tap_xilinx_bscan.c b/src/target/openrisc/or1k_tap_xilinx_bscan.c
index 1e90b939..a77c65ef 100644
--- a/src/target/openrisc/or1k_tap_xilinx_bscan.c
+++ b/src/target/openrisc/or1k_tap_xilinx_bscan.c
@@ -11,6 +11,9 @@
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/quark_d20xx.c b/src/target/quark_d20xx.c
new file mode 100644
index 00000000..42d3b8c7
--- /dev/null
+++ b/src/target/quark_d20xx.c
@@ -0,0 +1,115 @@
+/*
+ * Copyright(c) 2015-2016 Intel Corporation.
+ *
+ * Jessica Gomez (jessica.gomez.hernandez@intel.com)
+ * Ivan De Cesaris (ivan.de.cesaris@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Contact Information:
+ * Intel Corporation
+ */
+
+/*
+ * @file
+ * Debugger for Intel Quark D20xx
+ * The CPU TAP (Lakemont TAP) is used for software debug and the CLTAP is
+ * used for SoC level operations.
+ *
+ * Reference document:
+ * Intel Quark microcontroller D2000 Debug Operations (web search for doc num 333241)
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <helper/log.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "breakpoints.h"
+#include "lakemont.h"
+#include "x86_32_common.h"
+
+int quark_d20xx_target_create(struct target *t, Jim_Interp *interp)
+{
+	struct x86_32_common *x86_32 = calloc(1, sizeof(struct x86_32_common));
+	if (x86_32 == NULL) {
+		LOG_ERROR("%s out of memory", __func__);
+		return ERROR_FAIL;
+	}
+	x86_32_common_init_arch_info(t, x86_32);
+	lakemont_init_arch_info(t, x86_32);
+	x86_32->core_type = LMT3_5;
+	return ERROR_OK;
+}
+
+int quark_d20xx_init_target(struct command_context *cmd_ctx, struct target *t)
+{
+	return lakemont_init_target(cmd_ctx, t);
+}
+
+static int quark_d20xx_reset_deassert(struct target *t)
+{
+	int retval;
+
+	/* Can't detect if a warm reset happened while halted but we can make the
+	 * openocd and target state consistent here if in probe mode already
+	 */
+	if (!check_not_halted(t)) {
+		retval = lakemont_update_after_probemode_entry(t);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("%s core state update fail", __func__);
+			return retval;
+		}
+		/* resume target if reset mode is run */
+		if (!t->reset_halt) {
+			retval = lakemont_resume(t, 1, 0, 0, 0);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("%s could not resume target", __func__);
+				return retval;
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+struct target_type quark_d20xx_target = {
+	.name = "quark_d20xx",
+	.target_create = quark_d20xx_target_create,
+	.init_target = quark_d20xx_init_target,
+	/* lakemont probemode specific code */
+	.poll = lakemont_poll,
+	.arch_state = lakemont_arch_state,
+	.halt = lakemont_halt,
+	.resume = lakemont_resume,
+	.step = lakemont_step,
+	.assert_reset = lakemont_reset_assert,
+	.deassert_reset = quark_d20xx_reset_deassert,
+	/* common x86 code */
+	.commands = x86_32_command_handlers,
+	.get_gdb_reg_list = x86_32_get_gdb_reg_list,
+	.read_memory = x86_32_common_read_memory,
+	.write_memory = x86_32_common_write_memory,
+	.add_breakpoint = x86_32_common_add_breakpoint,
+	.remove_breakpoint = x86_32_common_remove_breakpoint,
+	.add_watchpoint = x86_32_common_add_watchpoint,
+	.remove_watchpoint = x86_32_common_remove_watchpoint,
+	.virt2phys = x86_32_common_virt2phys,
+	.read_phys_memory = x86_32_common_read_phys_mem,
+	.write_phys_memory = x86_32_common_write_phys_mem,
+	.mmu = x86_32_common_mmu,
+};
diff --git a/src/target/quark_x10xx.c b/src/target/quark_x10xx.c
index 9a1ccb65..189f6cc6 100644
--- a/src/target/quark_x10xx.c
+++ b/src/target/quark_x10xx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2013 Intel Corporation.
+ * Copyright(c) 2013-2016 Intel Corporation.
  *
  * Adrian Burns (adrian.burns@intel.com)
  * Thomas Faust (thomas.faust@intel.com)
@@ -18,8 +18,7 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * Contact Information:
  * Intel Corporation
@@ -61,6 +60,7 @@ int quark_x10xx_target_create(struct target *t, Jim_Interp *interp)
 	}
 	x86_32_common_init_arch_info(t, x86_32);
 	lakemont_init_arch_info(t, x86_32);
+	x86_32->core_type = LMT1;
 	return ERROR_OK;
 }
 
diff --git a/src/target/register.c b/src/target/register.c
index 1c1717c8..1d63e12f 100644
--- a/src/target/register.c
+++ b/src/target/register.c
@@ -16,9 +16,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/register.h b/src/target/register.h
index 7bac69b5..dc18e9a8 100644
--- a/src/target/register.h
+++ b/src/target/register.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef REGISTER_H
-#define REGISTER_H
+#ifndef OPENOCD_TARGET_REGISTER_H
+#define OPENOCD_TARGET_REGISTER_H
 
 struct target;
 
@@ -116,17 +114,32 @@ struct reg_data_type {
 };
 
 struct reg {
+	/* Canonical name of the register. */
 	const char *name;
+	/* Number that gdb uses to access this register. */
 	uint32_t number;
+	/* TODO. This should probably be const. */
 	struct reg_feature *feature;
+	/* TODO: When true, the caller will save this register before running any algorithm. */
 	bool caller_save;
+	/* Pointer to place where the value is stored, in the format understood by
+	 * the binarybuffer.h functions. */
 	void *value;
+	/* The stored value needs to be written to the target. */
 	bool dirty;
+	/* When true, value is valid. */
 	bool valid;
+	/* When false, the register doesn't actually exist in the target. */
 	bool exist;
+	/* Size of the register in bits. */
 	uint32_t size;
+	/* Used for generating XML description of registers. Can be set to NULL for
+	 * targets that don't use that. */
 	struct reg_data_type *reg_data_type;
+	/* Used for generating XML description of registers. Can be set to NULL for
+	 * targets that don't use that. */
 	const char *group;
+	/* Pointer to architecture-specific info for this register. */
 	void *arch_info;
 	const struct reg_arch_type *type;
 };
@@ -151,4 +164,4 @@ void register_cache_invalidate(struct reg_cache *cache);
 
 void register_init_dummy(struct reg *reg);
 
-#endif /* REGISTER_H */
+#endif /* OPENOCD_TARGET_REGISTER_H */
diff --git a/src/target/smp.c b/src/target/smp.c
index da9ee8b4..bdf81a0e 100644
--- a/src/target/smp.c
+++ b/src/target/smp.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -66,7 +64,8 @@ int gdb_read_smp_packet(struct connection *connection,
 			char hex_buffer[len * 2 + 1];
 			uint8_t buffer[len];
 			buf_set_u32(buffer, 0, len * 8, target->gdb_service->core[0]);
-			int pkt_len = hexify(hex_buffer, (char *)buffer, sizeof(buffer), sizeof(hex_buffer));
+			size_t pkt_len = hexify(hex_buffer, buffer, sizeof(buffer),
+				sizeof(hex_buffer));
 
 			retval = gdb_put_packet(connection, hex_buffer, pkt_len);
 		}
diff --git a/src/target/smp.h b/src/target/smp.h
index 69a5cd85..c3e6c6ce 100644
--- a/src/target/smp.h
+++ b/src/target/smp.h
@@ -13,11 +13,12 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
+#ifndef OPENOCD_TARGET_SMP_H
+#define OPENOCD_TARGET_SMP_H
+
 #include "server/server.h"
 
 int gdb_read_smp_packet(struct connection *connection,
@@ -25,3 +26,4 @@ int gdb_read_smp_packet(struct connection *connection,
 int gdb_write_smp_packet(struct connection *connection,
 		char const *packet, int packet_size);
 
+#endif /* OPENOCD_TARGET_SMP_H */
diff --git a/src/target/startup.tcl b/src/target/startup.tcl
index cf2813ba..9bbc6e32 100644
--- a/src/target/startup.tcl
+++ b/src/target/startup.tcl
@@ -65,7 +65,7 @@ proc ocd_process_reset_inner { MODE } {
 	foreach t $targets {
 		if {![using_jtag] || [jtag tapisenabled [$t cget -chain-position]]} {
 			$t invoke-event examine-start
-			set err [catch "$t arp_examine"]
+			set err [catch "$t arp_examine allow-defer"]
 			if { $err == 0 } {
 				$t invoke-event examine-end
 			}
@@ -111,6 +111,12 @@ proc ocd_process_reset_inner { MODE } {
 				continue
 			}
 
+			# don't wait for targets where examination is deferred
+			# they can not be halted anyway at this point
+			if { ![$t was_examined] && [$t examine_deferred] } {
+				continue
+			}
+
 			# Wait upto 1 second for target to halt.  Why 1sec? Cause
 			# the JTAG tap reset signal might be hooked to a slow
 			# resistor/capacitor circuit - and it might take a while
@@ -135,6 +141,12 @@ proc ocd_process_reset_inner { MODE } {
 				continue
 			}
 
+			# don't wait for targets where examination is deferred
+			# they can not be halted anyway at this point
+			if { ![$t was_examined] && [$t examine_deferred] } {
+				continue
+			}
+
 			set err [catch "$t arp_waitstate halted 5000"]
 			# Did it halt?
 			if { $err == 0 } {
diff --git a/src/target/target.c b/src/target/target.c
index 09dcf6f1..57ce1e20 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -34,9 +34,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -60,9 +58,9 @@
 /* default halt wait timeout (ms) */
 #define DEFAULT_HALT_TIMEOUT 5000
 
-static int target_read_buffer_default(struct target *target, uint32_t address,
+static int target_read_buffer_default(struct target *target, target_addr_t address,
 		uint32_t count, uint8_t *buffer);
-static int target_write_buffer_default(struct target *target, uint32_t address,
+static int target_write_buffer_default(struct target *target, target_addr_t address,
 		uint32_t count, const uint8_t *buffer);
 static int target_array2mem(Jim_Interp *interp, struct target *target,
 		int argc, Jim_Obj * const *argv);
@@ -91,8 +89,10 @@ extern struct target_type dragonite_target;
 extern struct target_type xscale_target;
 extern struct target_type cortexm_target;
 extern struct target_type cortexa_target;
+extern struct target_type aarch64_target;
 extern struct target_type cortexr4_target;
 extern struct target_type arm11_target;
+extern struct target_type ls1_sap_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
@@ -105,6 +105,7 @@ extern struct target_type nds32_v3_target;
 extern struct target_type nds32_v3m_target;
 extern struct target_type or1k_target;
 extern struct target_type quark_x10xx_target;
+extern struct target_type quark_d20xx_target;
 
 static struct target_type *target_types[] = {
 	&arm7tdmi_target,
@@ -122,6 +123,7 @@ static struct target_type *target_types[] = {
 	&cortexa_target,
 	&cortexr4_target,
 	&arm11_target,
+	&ls1_sap_target,
 	&mips_m4k_target,
 	&avr_target,
 	&dsp563xx_target,
@@ -134,6 +136,10 @@ static struct target_type *target_types[] = {
 	&nds32_v3m_target,
 	&or1k_target,
 	&quark_x10xx_target,
+	&quark_d20xx_target,
+#if BUILD_TARGET64
+	&aarch64_target,
+#endif
 	NULL,
 };
 
@@ -282,6 +288,10 @@ const char *target_state_name(struct target *t)
 		LOG_ERROR("Invalid target state: %d", (int)(t->state));
 		cp = "(*BUG*unknown*BUG*)";
 	}
+
+	if (!target_was_examined(t) && t->defer_examine)
+		cp = "examine deferred";
+
 	return cp;
 }
 
@@ -531,7 +541,7 @@ int target_poll(struct target *target)
 		if (target->state == TARGET_HALTED)
 			target->halt_issued = false;
 		else {
-			long long t = timeval_ms() - target->halt_issued_time;
+			int64_t t = timeval_ms() - target->halt_issued_time;
 			if (t > DEFAULT_HALT_TIMEOUT) {
 				target->halt_issued = false;
 				LOG_INFO("Halt timed out, wake up GDB.");
@@ -592,7 +602,8 @@ int target_halt(struct target *target)
  * hand the infrastructure for running such helpers might use this
  * procedure but rely on hardware breakpoint to detect termination.)
  */
-int target_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
+int target_resume(struct target *target, int current, target_addr_t address,
+		int handle_breakpoints, int debug_execution)
 {
 	int retval;
 
@@ -663,7 +674,7 @@ static int target_process_reset(struct command_context *cmd_ctx, enum target_res
 }
 
 static int identity_virt2phys(struct target *target,
-		uint32_t virtual, uint32_t *physical)
+		target_addr_t virtual, target_addr_t *physical)
 {
 	*physical = virtual;
 	return ERROR_OK;
@@ -730,6 +741,9 @@ int target_examine(void)
 			continue;
 		}
 
+		if (target->defer_examine)
+			continue;
+
 		retval = target_examine_one(target);
 		if (retval != ERROR_OK)
 			return retval;
@@ -1013,11 +1027,20 @@ int target_run_flash_async_algorithm(struct target *target,
 		retval = retval2;
 	}
 
+	if (retval == ERROR_OK) {
+		/* check if algorithm set rp = 0 after fifo writer loop finished */
+		retval = target_read_u32(target, rp_addr, &rp);
+		if (retval == ERROR_OK && rp == 0) {
+			LOG_ERROR("flash write algorithm aborted by target");
+			retval = ERROR_FLASH_OPERATION_FAILED;
+		}
+	}
+
 	return retval;
 }
 
 int target_read_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1056,7 +1079,7 @@ int target_read_memory(struct target *target,
 			curr_elem = curr_elem->next_elem;
 		} while (curr_elem != NULL);
 		if (count*size != bytes_read) {
-			LOG_WARNING("Ignoring read of non readable area - Request address: 0x%X, "
+			LOG_WARNING("Ignoring read of non readable area - Request address: " TARGET_ADDR_FMT ", "
 						"Request size %d. Bytes successfully read: %d", address, count*size, (int)bytes_read);
 		}
 		return ERROR_OK;
@@ -1067,7 +1090,7 @@ int target_read_memory(struct target *target,
 }
 
 int target_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1081,7 +1104,7 @@ int target_read_phys_memory(struct target *target,
 }
 
 int target_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1119,7 +1142,7 @@ int target_write_memory(struct target *target,
 			curr_elem = curr_elem->next_elem;
 		} while (curr_elem != NULL);
 		if (count*size != bytes_written) {
-			LOG_WARNING("Ignoring write to non writable area - Request address: 0x%X, "
+			LOG_WARNING("Ignoring write to non writable area - Request address: " TARGET_ADDR_FMT ", "
 						"Request size %d. Bytes successfully written: %d", address, count*size, (int)bytes_written);
 		}
 		return ERROR_OK;
@@ -1130,7 +1153,7 @@ int target_write_memory(struct target *target,
 }
 
 int target_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1147,7 +1170,7 @@ int target_add_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
 	if ((target->state != TARGET_HALTED) && (breakpoint->type != BKPT_HARD)) {
-		LOG_WARNING("target %s is not halted", target_name(target));
+		LOG_WARNING("target %s is not halted (add breakpoint)", target_name(target));
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->add_breakpoint(target, breakpoint);
@@ -1157,7 +1180,7 @@ int target_add_context_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target_name(target));
+		LOG_WARNING("target %s is not halted (add context breakpoint)", target_name(target));
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->add_context_breakpoint(target, breakpoint);
@@ -1167,7 +1190,7 @@ int target_add_hybrid_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target_name(target));
+		LOG_WARNING("target %s is not halted (add hybrid breakpoint)", target_name(target));
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->add_hybrid_breakpoint(target, breakpoint);
@@ -1183,7 +1206,7 @@ int target_add_watchpoint(struct target *target,
 		struct watchpoint *watchpoint)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target_name(target));
+		LOG_WARNING("target %s is not halted (add watchpoint)", target_name(target));
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->add_watchpoint(target, watchpoint);
@@ -1197,7 +1220,7 @@ int target_hit_watchpoint(struct target *target,
 		struct watchpoint **hit_watchpoint)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target->cmd_name);
+		LOG_WARNING("target %s is not halted (hit watchpoint)", target->cmd_name);
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
@@ -1218,7 +1241,7 @@ int target_get_gdb_reg_list(struct target *target,
 	return target->type->get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
 }
 int target_step(struct target *target,
-		int current, uint32_t address, int handle_breakpoints)
+		int current, target_addr_t address, int handle_breakpoints)
 {
 	return target->type->step(target, current, address, handle_breakpoints);
 }
@@ -1226,7 +1249,7 @@ int target_step(struct target *target,
 int target_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fileio_info)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target->cmd_name);
+		LOG_WARNING("target %s is not halted (gdb fileio)", target->cmd_name);
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->get_gdb_fileio_info(target, fileio_info);
@@ -1235,7 +1258,7 @@ int target_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fi
 int target_gdb_fileio_end(struct target *target, int retcode, int fileio_errno, bool ctrl_c)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target->cmd_name);
+		LOG_WARNING("target %s is not halted (gdb fileio end)", target->cmd_name);
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->gdb_fileio_end(target, retcode, fileio_errno, ctrl_c);
@@ -1245,7 +1268,7 @@ int target_profiling(struct target *target, uint32_t *samples,
 			uint32_t max_num_samples, uint32_t *num_samples, uint32_t seconds)
 {
 	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target %s is not halted", target->cmd_name);
+		LOG_WARNING("target %s is not halted (profiling)", target->cmd_name);
 		return ERROR_TARGET_NOT_HALTED;
 	}
 	return target->type->profiling(target, samples, max_num_samples,
@@ -1689,7 +1712,7 @@ static void print_wa_layout(struct target *target)
 	struct working_area *c = target->working_areas;
 
 	while (c) {
-		LOG_DEBUG("%c%c 0x%08"PRIx32"-0x%08"PRIx32" (%"PRIu32" bytes)",
+		LOG_DEBUG("%c%c " TARGET_ADDR_FMT "-" TARGET_ADDR_FMT " (%" PRIu32 " bytes)",
 			c->backup ? 'b' : ' ', c->free ? ' ' : '*',
 			c->address, c->address + c->size - 1, c->size);
 		c = c->next;
@@ -1774,7 +1797,7 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 		if (!enabled) {
 			if (target->working_area_phys_spec) {
 				LOG_DEBUG("MMU disabled, using physical "
-					"address for working memory 0x%08"PRIx32,
+					"address for working memory " TARGET_ADDR_FMT,
 					target->working_area_phys);
 				target->working_area = target->working_area_phys;
 			} else {
@@ -1785,7 +1808,7 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 		} else {
 			if (target->working_area_virt_spec) {
 				LOG_DEBUG("MMU enabled, using virtual "
-					"address for working memory 0x%08"PRIx32,
+					"address for working memory " TARGET_ADDR_FMT,
 					target->working_area_virt);
 				target->working_area = target->working_area_virt;
 			} else {
@@ -1828,7 +1851,8 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 	/* Split the working area into the requested size */
 	target_split_working_area(c, size);
 
-	LOG_DEBUG("allocated new working area of %"PRIu32" bytes at address 0x%08"PRIx32, size, c->address);
+	LOG_DEBUG("allocated new working area of %" PRIu32 " bytes at address " TARGET_ADDR_FMT,
+			  size, c->address);
 
 	if (target->backup_working_area) {
 		if (c->backup == NULL) {
@@ -1872,7 +1896,7 @@ static int target_restore_working_area(struct target *target, struct working_are
 	if (target->backup_working_area && area->backup != NULL) {
 		retval = target_write_memory(target, area->address, 4, area->size / 4, area->backup);
 		if (retval != ERROR_OK)
-			LOG_ERROR("failed to restore %"PRIu32" bytes of working area at address 0x%08"PRIx32,
+			LOG_ERROR("failed to restore %" PRIu32 " bytes of working area at address " TARGET_ADDR_FMT,
 					area->size, area->address);
 	}
 
@@ -1896,7 +1920,7 @@ static int target_free_working_area_restore(struct target *target, struct workin
 
 	area->free = true;
 
-	LOG_DEBUG("freed %"PRIu32" bytes of working area at address 0x%08"PRIx32,
+	LOG_DEBUG("freed %" PRIu32 " bytes of working area at address " TARGET_ADDR_FMT,
 			area->size, area->address);
 
 	/* mark user pointer invalid */
@@ -1918,6 +1942,17 @@ int target_free_working_area(struct target *target, struct working_area *area)
 	return target_free_working_area_restore(target, area, 1);
 }
 
+static void target_destroy(struct target *target)
+{
+	if (target->type->deinit_target)
+		target->type->deinit_target(target);
+
+	free(target->type);
+	free(target->trace_info);
+	free(target->cmd_name);
+	free(target);
+}
+
 void target_quit(void)
 {
 	struct target_event_callback *pe = target_event_callbacks;
@@ -1936,11 +1971,15 @@ void target_quit(void)
 	}
 	target_timer_callbacks = NULL;
 
-	for (struct target *target = all_targets;
-	     target; target = target->next) {
-		if (target->type->deinit_target)
-			target->type->deinit_target(target);
+	for (struct target *target = all_targets; target;) {
+		struct target *tmp;
+
+		tmp = target->next;
+		target_destroy(target);
+		target = tmp;
 	}
+
+	all_targets = NULL;
 }
 
 /* free resources and restore memory, if restoring memory fails,
@@ -1998,13 +2037,10 @@ int target_arch_state(struct target *target)
 {
 	int retval;
 	if (target == NULL) {
-		LOG_USER("No target has been configured");
+		LOG_WARNING("No target has been configured");
 		return ERROR_OK;
 	}
 
-	LOG_USER("%s: target state: %s", target_name(target),
-		 target_state_name(target));
-
 	if (target->state != TARGET_HALTED)
 		return ERROR_OK;
 
@@ -2081,10 +2117,10 @@ static int target_profiling_default(struct target *target, uint32_t *samples,
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_write_buffer(struct target *target, uint32_t address, uint32_t size, const uint8_t *buffer)
+int target_write_buffer(struct target *target, target_addr_t address, uint32_t size, const uint8_t *buffer)
 {
-	LOG_DEBUG("writing buffer of %i byte at 0x%8.8x",
-			(int)size, (unsigned)address);
+	LOG_DEBUG("writing buffer of %" PRIi32 " byte at " TARGET_ADDR_FMT,
+			  size, address);
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -2095,17 +2131,18 @@ int target_write_buffer(struct target *target, uint32_t address, uint32_t size,
 		return ERROR_OK;
 
 	if ((address + size - 1) < address) {
-		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR("address + size wrapped(0x%08x, 0x%08x)",
-				  (unsigned)address,
-				  (unsigned)size);
+		/* GDB can request this when e.g. PC is 0xfffffffc */
+		LOG_ERROR("address + size wrapped (" TARGET_ADDR_FMT ", 0x%08" PRIx32 ")",
+				  address,
+				  size);
 		return ERROR_FAIL;
 	}
 
 	return target->type->write_buffer(target, address, size, buffer);
 }
 
-static int target_write_buffer_default(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
+static int target_write_buffer_default(struct target *target,
+	target_addr_t address, uint32_t count, const uint8_t *buffer)
 {
 	uint32_t size;
 
@@ -2142,10 +2179,10 @@ static int target_write_buffer_default(struct target *target, uint32_t address,
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_read_buffer(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
+int target_read_buffer(struct target *target, target_addr_t address, uint32_t size, uint8_t *buffer)
 {
-	LOG_DEBUG("reading buffer of %i byte at 0x%8.8x",
-			  (int)size, (unsigned)address);
+	LOG_DEBUG("reading buffer of %" PRIi32 " byte at " TARGET_ADDR_FMT,
+			  size, address);
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -2156,8 +2193,8 @@ int target_read_buffer(struct target *target, uint32_t address, uint32_t size, u
 		return ERROR_OK;
 
 	if ((address + size - 1) < address) {
-		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR("address + size wrapped(0x%08" PRIx32 ", 0x%08" PRIx32 ")",
+		/* GDB can request this when e.g. PC is 0xfffffffc */
+		LOG_ERROR("address + size wrapped (" TARGET_ADDR_FMT ", 0x%08" PRIx32 ")",
 				  address,
 				  size);
 		return ERROR_FAIL;
@@ -2166,7 +2203,7 @@ int target_read_buffer(struct target *target, uint32_t address, uint32_t size, u
 	return target->type->read_buffer(target, address, size, buffer);
 }
 
-static int target_read_buffer_default(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+static int target_read_buffer_default(struct target *target, target_addr_t address, uint32_t count, uint8_t *buffer)
 {
 	uint32_t size;
 
@@ -2199,7 +2236,7 @@ static int target_read_buffer_default(struct target *target, uint32_t address, u
 	return ERROR_OK;
 }
 
-int target_checksum_memory(struct target *target, uint32_t address, uint32_t size, uint32_t* crc)
+int target_checksum_memory(struct target *target, target_addr_t address, uint32_t size, uint32_t* crc)
 {
 	uint8_t *buffer;
 	int retval;
@@ -2214,7 +2251,7 @@ int target_checksum_memory(struct target *target, uint32_t address, uint32_t siz
 	if (retval != ERROR_OK) {
 		buffer = malloc(size);
 		if (buffer == NULL) {
-			LOG_ERROR("error allocating buffer for section (%d bytes)", (int)size);
+			LOG_ERROR("error allocating buffer for section (%" PRId32 " bytes)", size);
 			return ERROR_COMMAND_SYNTAX_ERROR;
 		}
 		retval = target_read_buffer(target, address, size, buffer);
@@ -2239,7 +2276,8 @@ int target_checksum_memory(struct target *target, uint32_t address, uint32_t siz
 	return retval;
 }
 
-int target_blank_check_memory(struct target *target, uint32_t address, uint32_t size, uint32_t* blank)
+int target_blank_check_memory(struct target *target, target_addr_t address, uint32_t size, uint32_t* blank,
+	uint8_t erased_value)
 {
 	int retval;
 	if (!target_was_examined(target)) {
@@ -2250,12 +2288,12 @@ int target_blank_check_memory(struct target *target, uint32_t address, uint32_t
 	if (target->type->blank_check_memory == 0)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
-	retval = target->type->blank_check_memory(target, address, size, blank);
+	retval = target->type->blank_check_memory(target, address, size, blank, erased_value);
 
 	return retval;
 }
 
-int target_read_u64(struct target *target, uint64_t address, uint64_t *value)
+int target_read_u64(struct target *target, target_addr_t address, uint64_t *value)
 {
 	uint8_t value_buf[8];
 	if (!target_was_examined(target)) {
@@ -2267,19 +2305,19 @@ int target_read_u64(struct target *target, uint64_t address, uint64_t *value)
 
 	if (retval == ERROR_OK) {
 		*value = target_buffer_get_u64(target, value_buf);
-		LOG_DEBUG("address: 0x%" PRIx64 ", value: 0x%16.16" PRIx64 "",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%16.16" PRIx64 "",
 				  address,
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%" PRIx64 " failed",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT " failed",
 				  address);
 	}
 
 	return retval;
 }
 
-int target_read_u32(struct target *target, uint32_t address, uint32_t *value)
+int target_read_u32(struct target *target, target_addr_t address, uint32_t *value)
 {
 	uint8_t value_buf[4];
 	if (!target_was_examined(target)) {
@@ -2291,19 +2329,19 @@ int target_read_u32(struct target *target, uint32_t address, uint32_t *value)
 
 	if (retval == ERROR_OK) {
 		*value = target_buffer_get_u32(target, value_buf);
-		LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%8.8" PRIx32 "",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%8.8" PRIx32 "",
 				  address,
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%8.8" PRIx32 " failed",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT " failed",
 				  address);
 	}
 
 	return retval;
 }
 
-int target_read_u16(struct target *target, uint32_t address, uint16_t *value)
+int target_read_u16(struct target *target, target_addr_t address, uint16_t *value)
 {
 	uint8_t value_buf[2];
 	if (!target_was_examined(target)) {
@@ -2315,19 +2353,19 @@ int target_read_u16(struct target *target, uint32_t address, uint16_t *value)
 
 	if (retval == ERROR_OK) {
 		*value = target_buffer_get_u16(target, value_buf);
-		LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%4.4x",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%4.4" PRIx16,
 				  address,
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%8.8" PRIx32 " failed",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT " failed",
 				  address);
 	}
 
 	return retval;
 }
 
-int target_read_u8(struct target *target, uint32_t address, uint8_t *value)
+int target_read_u8(struct target *target, target_addr_t address, uint8_t *value)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -2337,19 +2375,19 @@ int target_read_u8(struct target *target, uint32_t address, uint8_t *value)
 	int retval = target_read_memory(target, address, 1, 1, value);
 
 	if (retval == ERROR_OK) {
-		LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%2.2x",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%2.2" PRIx8,
 				  address,
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%8.8" PRIx32 " failed",
+		LOG_DEBUG("address: " TARGET_ADDR_FMT " failed",
 				  address);
 	}
 
 	return retval;
 }
 
-int target_write_u64(struct target *target, uint64_t address, uint64_t value)
+int target_write_u64(struct target *target, target_addr_t address, uint64_t value)
 {
 	int retval;
 	uint8_t value_buf[8];
@@ -2358,7 +2396,7 @@ int target_write_u64(struct target *target, uint64_t address, uint64_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%" PRIx64 ", value: 0x%16.16" PRIx64 "",
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%16.16" PRIx64 "",
 			  address,
 			  value);
 
@@ -2370,7 +2408,7 @@ int target_write_u64(struct target *target, uint64_t address, uint64_t value)
 	return retval;
 }
 
-int target_write_u32(struct target *target, uint32_t address, uint32_t value)
+int target_write_u32(struct target *target, target_addr_t address, uint32_t value)
 {
 	int retval;
 	uint8_t value_buf[4];
@@ -2379,7 +2417,7 @@ int target_write_u32(struct target *target, uint32_t address, uint32_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%8.8" PRIx32 "",
 			  address,
 			  value);
 
@@ -2391,7 +2429,7 @@ int target_write_u32(struct target *target, uint32_t address, uint32_t value)
 	return retval;
 }
 
-int target_write_u16(struct target *target, uint32_t address, uint16_t value)
+int target_write_u16(struct target *target, target_addr_t address, uint16_t value)
 {
 	int retval;
 	uint8_t value_buf[2];
@@ -2400,7 +2438,7 @@ int target_write_u16(struct target *target, uint32_t address, uint16_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%8.8x",
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%8.8" PRIx16,
 			  address,
 			  value);
 
@@ -2412,7 +2450,7 @@ int target_write_u16(struct target *target, uint32_t address, uint16_t value)
 	return retval;
 }
 
-int target_write_u8(struct target *target, uint32_t address, uint8_t value)
+int target_write_u8(struct target *target, target_addr_t address, uint8_t value)
 {
 	int retval;
 	if (!target_was_examined(target)) {
@@ -2420,7 +2458,7 @@ int target_write_u8(struct target *target, uint32_t address, uint8_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%2.2x",
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%2.2" PRIx8,
 			  address, value);
 
 	retval = target_write_memory(target, address, 1, 1, &value);
@@ -2430,6 +2468,87 @@ int target_write_u8(struct target *target, uint32_t address, uint8_t value)
 	return retval;
 }
 
+int target_write_phys_u64(struct target *target, target_addr_t address, uint64_t value)
+{
+	int retval;
+	uint8_t value_buf[8];
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%16.16" PRIx64 "",
+			  address,
+			  value);
+
+	target_buffer_set_u64(target, value_buf, value);
+	retval = target_write_phys_memory(target, address, 8, 1, value_buf);
+	if (retval != ERROR_OK)
+		LOG_DEBUG("failed: %i", retval);
+
+	return retval;
+}
+
+int target_write_phys_u32(struct target *target, target_addr_t address, uint32_t value)
+{
+	int retval;
+	uint8_t value_buf[4];
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%8.8" PRIx32 "",
+			  address,
+			  value);
+
+	target_buffer_set_u32(target, value_buf, value);
+	retval = target_write_phys_memory(target, address, 4, 1, value_buf);
+	if (retval != ERROR_OK)
+		LOG_DEBUG("failed: %i", retval);
+
+	return retval;
+}
+
+int target_write_phys_u16(struct target *target, target_addr_t address, uint16_t value)
+{
+	int retval;
+	uint8_t value_buf[2];
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%8.8" PRIx16,
+			  address,
+			  value);
+
+	target_buffer_set_u16(target, value_buf, value);
+	retval = target_write_phys_memory(target, address, 2, 1, value_buf);
+	if (retval != ERROR_OK)
+		LOG_DEBUG("failed: %i", retval);
+
+	return retval;
+}
+
+int target_write_phys_u8(struct target *target, target_addr_t address, uint8_t value)
+{
+	int retval;
+	if (!target_was_examined(target)) {
+		LOG_ERROR("Target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", value: 0x%2.2" PRIx8,
+			  address, value);
+
+	retval = target_write_phys_memory(target, address, 1, 1, &value);
+	if (retval != ERROR_OK)
+		LOG_DEBUG("failed: %i", retval);
+
+	return retval;
+}
+
 static int find_target(struct command_context *cmd_ctx, const char *name)
 {
 	struct target *target = get_target(name);
@@ -2516,9 +2635,9 @@ static int sense_handler(void)
 	if (powerRestored)
 		runPowerRestore = 1;
 
-	long long current = timeval_ms();
-	static long long lastPower;
-	int waitMore = lastPower + 2000 > current;
+	int64_t current = timeval_ms();
+	static int64_t lastPower;
+	bool waitMore = lastPower + 2000 > current;
 	if (powerDropout && !waitMore) {
 		runPowerDropout = 1;
 		lastPower = current;
@@ -2531,7 +2650,7 @@ static int sense_handler(void)
 	int srstDeasserted;
 	srstDeasserted = prevSrstAsserted && !srstAsserted;
 
-	static long long lastSrst;
+	static int64_t lastSrst;
 	waitMore = lastSrst + 2000 > current;
 	if (srstDeasserted && !waitMore) {
 		runSrstDeasserted = 1;
@@ -2841,8 +2960,8 @@ COMMAND_HANDLER(handle_wait_halt_command)
 int target_wait_state(struct target *target, enum target_state state, int ms)
 {
 	int retval;
-	long long then = 0, cur;
-	int once = 1;
+	int64_t then = 0, cur;
+	bool once = true;
 
 	for (;;) {
 		retval = target_poll(target);
@@ -2852,7 +2971,7 @@ int target_wait_state(struct target *target, enum target_state state, int ms)
 			break;
 		cur = timeval_ms();
 		if (once) {
-			once = 0;
+			once = false;
 			then = timeval_ms();
 			LOG_DEBUG("waiting for target %s...",
 				Jim_Nvp_value2name_simple(nvp_target_state, state)->name);
@@ -2933,9 +3052,9 @@ COMMAND_HANDLER(handle_resume_command)
 	/* with no CMD_ARGV, resume from current pc, addr = 0,
 	 * with one arguments, addr = CMD_ARGV[0],
 	 * handle breakpoints, not debugging */
-	uint32_t addr = 0;
+	target_addr_t addr = 0;
 	if (CMD_ARGC == 1) {
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+		COMMAND_PARSE_ADDRESS(CMD_ARGV[0], addr);
 		current = 0;
 	}
 
@@ -2952,10 +3071,10 @@ COMMAND_HANDLER(handle_step_command)
 	/* with no CMD_ARGV, step from current pc, addr = 0,
 	 * with one argument addr = CMD_ARGV[0],
 	 * handle breakpoints, debugging */
-	uint32_t addr = 0;
+	target_addr_t addr = 0;
 	int current_pc = 1;
 	if (CMD_ARGC == 1) {
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+		COMMAND_PARSE_ADDRESS(CMD_ARGV[0], addr);
 		current_pc = 0;
 	}
 
@@ -2965,7 +3084,7 @@ COMMAND_HANDLER(handle_step_command)
 }
 
 static void handle_md_output(struct command_context *cmd_ctx,
-		struct target *target, uint32_t address, unsigned size,
+		struct target *target, target_addr_t address, unsigned size,
 		unsigned count, const uint8_t *buffer)
 {
 	const unsigned line_bytecnt = 32;
@@ -2976,14 +3095,17 @@ static void handle_md_output(struct command_context *cmd_ctx,
 
 	const char *value_fmt;
 	switch (size) {
+	case 8:
+		value_fmt = "%16.16"PRIx64" ";
+		break;
 	case 4:
-		value_fmt = "%8.8x ";
+		value_fmt = "%8.8"PRIx64" ";
 		break;
 	case 2:
-		value_fmt = "%4.4x ";
+		value_fmt = "%4.4"PRIx64" ";
 		break;
 	case 1:
-		value_fmt = "%2.2x ";
+		value_fmt = "%2.2"PRIx64" ";
 		break;
 	default:
 		/* "can't happen", caller checked */
@@ -2995,13 +3117,16 @@ static void handle_md_output(struct command_context *cmd_ctx,
 		if (i % line_modulo == 0) {
 			output_len += snprintf(output + output_len,
 					sizeof(output) - output_len,
-					"0x%8.8x: ",
-					(unsigned)(address + (i*size)));
+					TARGET_ADDR_FMT ": ",
+					(address + (i * size)));
 		}
 
-		uint32_t value = 0;
+		uint64_t value = 0;
 		const uint8_t *value_ptr = buffer + i * size;
 		switch (size) {
+		case 8:
+			value = target_buffer_get_u64(target, value_ptr);
+			break;
 		case 4:
 			value = target_buffer_get_u32(target, value_ptr);
 			break;
@@ -3029,6 +3154,9 @@ COMMAND_HANDLER(handle_md_command)
 
 	unsigned size = 0;
 	switch (CMD_NAME[2]) {
+	case 'd':
+		size = 8;
+		break;
 	case 'w':
 		size = 4;
 		break;
@@ -3044,7 +3172,7 @@ COMMAND_HANDLER(handle_md_command)
 
 	bool physical = strcmp(CMD_ARGV[0], "phys") == 0;
 	int (*fn)(struct target *target,
-			uint32_t address, uint32_t size_value, uint32_t count, uint8_t *buffer);
+			target_addr_t address, uint32_t size_value, uint32_t count, uint8_t *buffer);
 	if (physical) {
 		CMD_ARGC--;
 		CMD_ARGV++;
@@ -3054,8 +3182,8 @@ COMMAND_HANDLER(handle_md_command)
 	if ((CMD_ARGC < 1) || (CMD_ARGC > 2))
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t address;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	target_addr_t address;
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], address);
 
 	unsigned count = 1;
 	if (CMD_ARGC == 2)
@@ -3074,14 +3202,14 @@ COMMAND_HANDLER(handle_md_command)
 }
 
 typedef int (*target_write_fn)(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 static int target_fill_mem(struct target *target,
-		uint32_t address,
+		target_addr_t address,
 		target_write_fn fn,
 		unsigned data_size,
 		/* value */
-		uint32_t b,
+		uint64_t b,
 		/* count */
 		unsigned c)
 {
@@ -3096,6 +3224,9 @@ static int target_fill_mem(struct target *target,
 
 	for (unsigned i = 0; i < chunk_size; i++) {
 		switch (data_size) {
+		case 8:
+			target_buffer_set_u64(target, target_buf + i * data_size, b);
+			break;
 		case 4:
 			target_buffer_set_u32(target, target_buf + i * data_size, b);
 			break;
@@ -3144,11 +3275,11 @@ COMMAND_HANDLER(handle_mw_command)
 	if ((CMD_ARGC < 2) || (CMD_ARGC > 3))
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t address;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	target_addr_t address;
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], address);
 
-	uint32_t value;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+	target_addr_t value;
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[1], value);
 
 	unsigned count = 1;
 	if (CMD_ARGC == 3)
@@ -3157,6 +3288,9 @@ COMMAND_HANDLER(handle_mw_command)
 	struct target *target = get_current_target(CMD_CTX);
 	unsigned wordsize;
 	switch (CMD_NAME[2]) {
+		case 'd':
+			wordsize = 8;
+			break;
 		case 'w':
 			wordsize = 4;
 			break;
@@ -3174,7 +3308,7 @@ COMMAND_HANDLER(handle_mw_command)
 }
 
 static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
-		uint32_t *min_address, uint32_t *max_address)
+		target_addr_t *min_address, target_addr_t *max_address)
 {
 	if (CMD_ARGC < 1 || CMD_ARGC > 5)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -3182,8 +3316,8 @@ static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
 	/* a base address isn't always necessary,
 	 * default to 0x0 (i.e. don't relocate) */
 	if (CMD_ARGC >= 2) {
-		uint32_t addr;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], addr);
+		target_addr_t addr;
+		COMMAND_PARSE_ADDRESS(CMD_ARGV[1], addr);
 		image->base_address = addr;
 		image->base_address_set = 1;
 	} else
@@ -3192,9 +3326,9 @@ static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
 	image->start_address_set = 0;
 
 	if (CMD_ARGC >= 4)
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], *min_address);
+		COMMAND_PARSE_ADDRESS(CMD_ARGV[3], *min_address);
 	if (CMD_ARGC == 5) {
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[4], *max_address);
+		COMMAND_PARSE_ADDRESS(CMD_ARGV[4], *max_address);
 		/* use size (given) to find max (required) */
 		*max_address += *min_address;
 	}
@@ -3210,8 +3344,8 @@ COMMAND_HANDLER(handle_load_image_command)
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint32_t image_size;
-	uint32_t min_address = 0;
-	uint32_t max_address = 0xffffffff;
+	target_addr_t min_address = 0;
+	target_addr_t max_address = -1;
 	int i;
 	struct image image;
 
@@ -3226,7 +3360,7 @@ COMMAND_HANDLER(handle_load_image_command)
 	duration_start(&bench);
 
 	if (image_open(&image, CMD_ARGV[0], (CMD_ARGC >= 3) ? CMD_ARGV[2] : NULL) != ERROR_OK)
-		return ERROR_OK;
+		return ERROR_FAIL;
 
 	image_size = 0x0;
 	retval = ERROR_OK;
@@ -3236,6 +3370,7 @@ COMMAND_HANDLER(handle_load_image_command)
 			command_print(CMD_CTX,
 						  "error allocating buffer for section (%d bytes)",
 						  (int)(image.sections[i].size));
+			retval = ERROR_FAIL;
 			break;
 		}
 
@@ -3269,7 +3404,7 @@ COMMAND_HANDLER(handle_load_image_command)
 				break;
 			}
 			image_size += length;
-			command_print(CMD_CTX, "%u bytes written at address 0x%8.8" PRIx32 "",
+			command_print(CMD_CTX, "%u bytes written at address " TARGET_ADDR_FMT "",
 					(unsigned int)length,
 					image.sections[i].base_address + offset);
 		}
@@ -3291,18 +3426,18 @@ COMMAND_HANDLER(handle_load_image_command)
 
 COMMAND_HANDLER(handle_dump_image_command)
 {
-	struct fileio fileio;
+	struct fileio *fileio;
 	uint8_t *buffer;
 	int retval, retvaltemp;
-	uint32_t address, size;
+	target_addr_t address, size;
 	struct duration bench;
 	struct target *target = get_current_target(CMD_CTX);
 
 	if (CMD_ARGC != 3)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], address);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], size);
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[1], address);
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[2], size);
 
 	uint32_t buf_size = (size > 4096) ? 4096 : size;
 	buffer = malloc(buf_size);
@@ -3324,7 +3459,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 		if (retval != ERROR_OK)
 			break;
 
-		retval = fileio_write(&fileio, this_run_size, buffer, &size_written);
+		retval = fileio_write(fileio, this_run_size, buffer, &size_written);
 		if (retval != ERROR_OK)
 			break;
 
@@ -3336,7 +3471,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK)) {
 		size_t filesize;
-		retval = fileio_size(&fileio, &filesize);
+		retval = fileio_size(fileio, &filesize);
 		if (retval != ERROR_OK)
 			return retval;
 		command_print(CMD_CTX,
@@ -3344,14 +3479,20 @@ COMMAND_HANDLER(handle_dump_image_command)
 				duration_elapsed(&bench), duration_kbps(&bench, filesize));
 	}
 
-	retvaltemp = fileio_close(&fileio);
+	retvaltemp = fileio_close(fileio);
 	if (retvaltemp != ERROR_OK)
 		return retvaltemp;
 
 	return retval;
 }
 
-static COMMAND_HELPER(handle_verify_image_command_internal, int verify, int verify_checksum_only)
+enum verify_mode {
+	IMAGE_TEST = 0,
+	IMAGE_VERIFY = 1,
+	IMAGE_CHECKSUM_ONLY = 2
+};
+
+static COMMAND_HELPER(handle_verify_image_command_internal, enum verify_mode verify)
 {
 	uint8_t *buffer;
 	size_t buf_cnt;
@@ -3377,8 +3518,8 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify, int veri
 	duration_start(&bench);
 
 	if (CMD_ARGC >= 2) {
-		uint32_t addr;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], addr);
+		target_addr_t addr;
+		COMMAND_PARSE_ADDRESS(CMD_ARGV[1], addr);
 		image.base_address = addr;
 		image.base_address_set = 1;
 	} else {
@@ -3409,7 +3550,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify, int veri
 			break;
 		}
 
-		if (verify) {
+		if (verify >= IMAGE_VERIFY) {
 			/* calculate checksum of image */
 			retval = image_calculate_checksum(buffer, buf_cnt, &checksum);
 			if (retval != ERROR_OK) {
@@ -3422,7 +3563,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify, int veri
 				free(buffer);
 				break;
 			}
-			if ((checksum != mem_checksum) && (verify_checksum_only == 1)) {
+			if ((checksum != mem_checksum) && (verify == IMAGE_CHECKSUM_ONLY)) {
 				LOG_ERROR("checksum mismatch");
 				free(buffer);
 				retval = ERROR_FAIL;
@@ -3468,7 +3609,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify, int veri
 				free(data);
 			}
 		} else {
-			command_print(CMD_CTX, "address 0x%08" PRIx32 " length 0x%08zx",
+			command_print(CMD_CTX, "address " TARGET_ADDR_FMT " length 0x%08zx",
 						  image.sections[i].base_address,
 						  buf_cnt);
 		}
@@ -3494,17 +3635,17 @@ done:
 
 COMMAND_HANDLER(handle_verify_image_checksum_command)
 {
-	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 1, 1);
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, IMAGE_CHECKSUM_ONLY);
 }
 
 COMMAND_HANDLER(handle_verify_image_command)
 {
-	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 1, 0);
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, IMAGE_VERIFY);
 }
 
 COMMAND_HANDLER(handle_test_image_command)
 {
-	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, 0, 0);
+	return CALL_COMMAND_HANDLER(handle_verify_image_command_internal, IMAGE_TEST);
 }
 
 static int handle_bp_command_list(struct command_context *cmd_ctx)
@@ -3515,7 +3656,7 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 		if (breakpoint->type == BKPT_SOFT) {
 			char *buf = buf_to_str(breakpoint->orig_instr,
 					breakpoint->length, 16);
-			command_print(cmd_ctx, "IVA breakpoint: 0x%8.8" PRIx32 ", 0x%x, %i, 0x%s",
+			command_print(cmd_ctx, "IVA breakpoint: " TARGET_ADDR_FMT ", 0x%x, %i, 0x%s",
 					breakpoint->address,
 					breakpoint->length,
 					breakpoint->set, buf);
@@ -3526,13 +3667,13 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 							breakpoint->asid,
 							breakpoint->length, breakpoint->set);
 			else if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
-				command_print(cmd_ctx, "Hybrid breakpoint(IVA): 0x%8.8" PRIx32 ", 0x%x, %i",
+				command_print(cmd_ctx, "Hybrid breakpoint(IVA): " TARGET_ADDR_FMT ", 0x%x, %i",
 							breakpoint->address,
 							breakpoint->length, breakpoint->set);
 				command_print(cmd_ctx, "\t|--->linked with ContextID: 0x%8.8" PRIx32,
 							breakpoint->asid);
 			} else
-				command_print(cmd_ctx, "Breakpoint(IVA): 0x%8.8" PRIx32 ", 0x%x, %i",
+				command_print(cmd_ctx, "Breakpoint(IVA): " TARGET_ADDR_FMT ", 0x%x, %i",
 							breakpoint->address,
 							breakpoint->length, breakpoint->set);
 		}
@@ -3543,7 +3684,7 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 }
 
 static int handle_bp_command_set(struct command_context *cmd_ctx,
-		uint32_t addr, uint32_t asid, uint32_t length, int hw)
+		target_addr_t addr, uint32_t asid, uint32_t length, int hw)
 {
 	struct target *target = get_current_target(cmd_ctx);
 	int retval;
@@ -3551,7 +3692,7 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 	if (asid == 0) {
 		retval = breakpoint_add(target, addr, length, hw);
 		if (ERROR_OK == retval)
-			command_print(cmd_ctx, "breakpoint set at 0x%8.8" PRIx32 "", addr);
+			command_print(cmd_ctx, "breakpoint set at " TARGET_ADDR_FMT "", addr);
 		else {
 			LOG_ERROR("Failure setting breakpoint, the same address(IVA) is already used");
 			return retval;
@@ -3586,7 +3727,7 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 
 COMMAND_HANDLER(handle_bp_command)
 {
-	uint32_t addr;
+	target_addr_t addr;
 	uint32_t asid;
 	uint32_t length;
 	int hw = BKPT_SOFT;
@@ -3597,17 +3738,15 @@ COMMAND_HANDLER(handle_bp_command)
 
 		case 2:
 			asid = 0;
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+			COMMAND_PARSE_ADDRESS(CMD_ARGV[0], addr);
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
 			return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
 
 		case 3:
 			if (strcmp(CMD_ARGV[2], "hw") == 0) {
 				hw = BKPT_HARD;
-				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
-
+				COMMAND_PARSE_ADDRESS(CMD_ARGV[0], addr);
 				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
-
 				asid = 0;
 				return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
 			} else if (strcmp(CMD_ARGV[2], "hw_ctx") == 0) {
@@ -3617,10 +3756,10 @@ COMMAND_HANDLER(handle_bp_command)
 				addr = 0;
 				return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
 			}
-
+			/* fallthrough */
 		case 4:
 			hw = BKPT_HARD;
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+			COMMAND_PARSE_ADDRESS(CMD_ARGV[0], addr);
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], asid);
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], length);
 			return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
@@ -3635,8 +3774,8 @@ COMMAND_HANDLER(handle_rbp_command)
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t addr;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+	target_addr_t addr;
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], addr);
 
 	struct target *target = get_current_target(CMD_CTX);
 	breakpoint_remove(target, addr);
@@ -3652,7 +3791,7 @@ COMMAND_HANDLER(handle_wp_command)
 		struct watchpoint *watchpoint = target->watchpoints;
 
 		while (watchpoint) {
-			command_print(CMD_CTX, "address: 0x%8.8" PRIx32
+			command_print(CMD_CTX, "address: " TARGET_ADDR_FMT
 					", len: 0x%8.8" PRIx32
 					", r/w/a: %i, value: 0x%8.8" PRIx32
 					", mask: 0x%8.8" PRIx32,
@@ -3737,14 +3876,14 @@ COMMAND_HANDLER(handle_virt2phys_command)
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t va;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], va);
-	uint32_t pa;
+	target_addr_t va;
+	COMMAND_PARSE_ADDRESS(CMD_ARGV[0], va);
+	target_addr_t pa;
 
 	struct target *target = get_current_target(CMD_CTX);
 	int retval = target->type->virt2phys(target, va, &pa);
 	if (retval == ERROR_OK)
-		command_print(CMD_CTX, "Physical address 0x%08" PRIx32 "", pa);
+		command_print(CMD_CTX, "Physical address " TARGET_ADDR_FMT "", pa);
 
 	return retval;
 }
@@ -3993,6 +4132,8 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	uint32_t count;
 	uint32_t v;
 	const char *varname;
+	const char *phys;
+	bool is_phys;
 	int  n, e, retval;
 	uint32_t i;
 
@@ -4001,8 +4142,8 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	 * argv[3] = memory address
 	 * argv[4] = count of times to read
 	 */
-	if (argc != 4) {
-		Jim_WrongNumArgs(interp, 1, argv, "varname width addr nelems");
+	if (argc < 4 || argc > 5) {
+		Jim_WrongNumArgs(interp, 1, argv, "varname width addr nelems [phys]");
 		return JIM_ERR;
 	}
 	varname = Jim_GetString(argv[0], &len);
@@ -4021,6 +4162,14 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	len = l;
 	if (e != JIM_OK)
 		return e;
+	is_phys = false;
+	if (argc > 4) {
+		phys = Jim_GetString(argv[4], &n);
+		if (!strncmp(phys, "phys", n))
+			is_phys = true;
+		else
+			return JIM_ERR;
+	}
 	switch (width) {
 		case 8:
 			width = 1;
@@ -4063,7 +4212,7 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 		sprintf(buf, "mem2array address: 0x%08" PRIx32 " is not aligned for %" PRId32 " byte reads",
 				addr,
 				width);
-		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
+		Jim_AppendStrings(interp, Jim_GetResult(interp), buf, NULL);
 		return JIM_ERR;
 	}
 
@@ -4086,13 +4235,16 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 		if (count > (buffersize / width))
 			count = (buffersize / width);
 
-		retval = target_read_memory(target, addr, width, count, buffer);
+		if (is_phys)
+			retval = target_read_phys_memory(target, addr, width, count, buffer);
+		else
+			retval = target_read_memory(target, addr, width, count, buffer);
 		if (retval != ERROR_OK) {
 			/* BOO !*/
-			LOG_ERROR("mem2array: Read @ 0x%08x, w=%d, cnt=%d, failed",
-					  (unsigned int)addr,
-					  (int)width,
-					  (int)count);
+			LOG_ERROR("mem2array: Read @ 0x%08" PRIx32 ", w=%" PRId32 ", cnt=%" PRId32 ", failed",
+					  addr,
+					  width,
+					  count);
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 			Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: cannot read memory", NULL);
 			e = JIM_ERR;
@@ -4182,6 +4334,8 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	uint32_t count;
 	uint32_t v;
 	const char *varname;
+	const char *phys;
+	bool is_phys;
 	int  n, e, retval;
 	uint32_t i;
 
@@ -4190,8 +4344,8 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	 * argv[3] = memory address
 	 * argv[4] = count to write
 	 */
-	if (argc != 4) {
-		Jim_WrongNumArgs(interp, 0, argv, "varname width addr nelems");
+	if (argc < 4 || argc > 5) {
+		Jim_WrongNumArgs(interp, 0, argv, "varname width addr nelems [phys]");
 		return JIM_ERR;
 	}
 	varname = Jim_GetString(argv[0], &len);
@@ -4210,6 +4364,14 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	len = l;
 	if (e != JIM_OK)
 		return e;
+	is_phys = false;
+	if (argc > 4) {
+		phys = Jim_GetString(argv[4], &n);
+		if (!strncmp(phys, "phys", n))
+			is_phys = true;
+		else
+			return JIM_ERR;
+	}
 	switch (width) {
 		case 8:
 			width = 1;
@@ -4253,10 +4415,10 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	} else {
 		char buf[100];
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		sprintf(buf, "array2mem address: 0x%08x is not aligned for %d byte reads",
-				(unsigned int)addr,
-				(int)width);
-		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
+		sprintf(buf, "array2mem address: 0x%08" PRIx32 " is not aligned for %" PRId32 " byte reads",
+				addr,
+				width);
+		Jim_AppendStrings(interp, Jim_GetResult(interp), buf, NULL);
 		return JIM_ERR;
 	}
 
@@ -4296,13 +4458,16 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 		}
 		len -= count;
 
-		retval = target_write_memory(target, addr, width, count, buffer);
+		if (is_phys)
+			retval = target_write_phys_memory(target, addr, width, count, buffer);
+		else
+			retval = target_write_memory(target, addr, width, count, buffer);
 		if (retval != ERROR_OK) {
 			/* BOO !*/
-			LOG_ERROR("array2mem: Write @ 0x%08x, w=%d, cnt=%d, failed",
-					  (unsigned int)addr,
-					  (int)width,
-					  (int)count);
+			LOG_ERROR("array2mem: Write @ 0x%08" PRIx32 ", w=%" PRId32 ", cnt=%" PRId32 ", failed",
+					  addr,
+					  width,
+					  count);
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 			Jim_AppendStrings(interp, Jim_GetResult(interp), "array2mem: cannot read memory", NULL);
 			e = JIM_ERR;
@@ -4367,7 +4532,9 @@ enum target_cfg_param {
 	TCFG_COREID,
 	TCFG_CHAIN_POSITION,
 	TCFG_DBGBASE,
+	TCFG_CTIBASE,
 	TCFG_RTOS,
+	TCFG_DEFER_EXAMINE,
 	TCFG_MEMORYMAP,
 	TCFG_RTOS_WIPE,
 };
@@ -4383,7 +4550,9 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
 	{ .name = "-dbgbase",          .value = TCFG_DBGBASE },
+	{ .name = "-ctibase",          .value = TCFG_CTIBASE },
 	{ .name = "-rtos",             .value = TCFG_RTOS },
+	{ .name = "-defer-examine",    .value = TCFG_DEFER_EXAMINE },
 	{ .name = "-rtos-wipe",        .value = TCFG_RTOS_WIPE },
 	{ .name = "-memorymap",        .value = TCFG_MEMORYMAP },
 	{ .name = NULL, .value = -1 }
@@ -4650,7 +4819,20 @@ no_params:
 			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->dbgbase));
 			/* loop for more */
 			break;
-
+		case TCFG_CTIBASE:
+			if (goi->isconfigure) {
+				e = Jim_GetOpt_Wide(goi, &w);
+				if (e != JIM_OK)
+					return e;
+				target->ctibase = (uint32_t)w;
+				target->ctibase_set = true;
+			} else {
+				if (goi->argc != 0)
+					goto no_params;
+			}
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->ctibase));
+			/* loop for more */
+			break;
 		case TCFG_RTOS:
 			/* RTOS */
 			{
@@ -4661,6 +4843,12 @@ no_params:
 			/* loop for more */
 			break;
 
+		case TCFG_DEFER_EXAMINE:
+			/* DEFER_EXAMINE */
+			target->defer_examine = true;
+			/* loop for more */
+			break;
+
 		case TCFG_RTOS_WIPE:
 			/* RTOS wipe*/
 			{
@@ -4691,10 +4879,10 @@ no_params:
 
 static int add_memory_mapping(Jim_GetOptInfo *goi, struct target *target)
 {
-	char *type_str;
+	const char *type_str;
 	enum memory_map_access type;
-	char *short_name = NULL;
-	char *long_name = NULL;
+	const char *short_name = NULL;
+	const char *long_name = NULL;
 	int64_t start_addr;
 	int64_t size;
 	int retval;
@@ -4782,12 +4970,9 @@ static int jim_target_configure(Jim_Interp *interp, int argc, Jim_Obj * const *a
 
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 	goi.isconfigure = !strcmp(Jim_GetString(argv[0], NULL), "configure");
-	int need_args = 1 + goi.isconfigure;
-	if (goi.argc < need_args) {
+	if (goi.argc < 1) {
 		Jim_WrongNumArgs(goi.interp, goi.argc, goi.argv,
-			goi.isconfigure
-				? "missing: -option VALUE ..."
-				: "missing: -option ...");
+				 "missing: -option ...");
 		return JIM_ERR;
 	}
 	struct target *target = Jim_CmdPrivData(goi.interp);
@@ -4900,7 +5085,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 
 	int (*fn)(struct target *target,
-			uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+			target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	fn = target_read_memory;
 
 	int e;
@@ -5038,20 +5223,58 @@ static int jim_target_tap_disabled(Jim_Interp *interp)
 
 static int jim_target_examine(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	if (argc != 1) {
-		Jim_WrongNumArgs(interp, 1, argv, "[no parameters]");
+	bool allow_defer = false;
+
+	Jim_GetOptInfo goi;
+	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
+	if (goi.argc > 1) {
+		const char *cmd_name = Jim_GetString(argv[0], NULL);
+		Jim_SetResultFormatted(goi.interp,
+				"usage: %s ['allow-defer']", cmd_name);
 		return JIM_ERR;
 	}
+	if (goi.argc > 0 &&
+	    strcmp(Jim_GetString(argv[1], NULL), "allow-defer") == 0) {
+		/* consume it */
+		struct Jim_Obj *obj;
+		int e = Jim_GetOpt_Obj(&goi, &obj);
+		if (e != JIM_OK)
+			return e;
+		allow_defer = true;
+	}
+
 	struct target *target = Jim_CmdPrivData(interp);
 	if (!target->tap->enabled)
 		return jim_target_tap_disabled(interp);
 
+	if (allow_defer && target->defer_examine) {
+		LOG_INFO("Deferring arp_examine of %s", target_name(target));
+		LOG_INFO("Use arp_examine command to examine it manually!");
+		return JIM_OK;
+	}
+
 	int e = target->type->examine(target);
 	if (e != ERROR_OK)
 		return JIM_ERR;
 	return JIM_OK;
 }
 
+static int jim_target_was_examined(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
+{
+	struct target *target = Jim_CmdPrivData(interp);
+
+	Jim_SetResultBool(interp, target_was_examined(target));
+	return JIM_OK;
+}
+
+static int jim_target_examine_deferred(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
+{
+	struct target *target = Jim_CmdPrivData(interp);
+
+	Jim_SetResultBool(interp, target->defer_examine);
+	return JIM_OK;
+}
+
 static int jim_target_halt_gdb(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	if (argc != 1) {
@@ -5112,16 +5335,17 @@ static int jim_target_reset(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	struct target *target = Jim_CmdPrivData(goi.interp);
 	if (!target->tap->enabled)
 		return jim_target_tap_disabled(interp);
-	if (!(target_was_examined(target))) {
-		LOG_ERROR("Target not examined yet");
-		return ERROR_TARGET_NOT_EXAMINED;
-	}
+
 	if (!target->type->assert_reset || !target->type->deassert_reset) {
 		Jim_SetResultFormatted(interp,
 				"No target-specific reset for %s",
 				target_name(target));
 		return JIM_ERR;
 	}
+
+	if (target->defer_examine)
+		target_reset_examined(target);
+
 	/* determine if we should halt or not. */
 	target->reset_halt = !!a;
 	/* When this happens - all workareas are invalid. */
@@ -5332,6 +5556,21 @@ static const struct command_registration target_instance_command_handlers[] = {
 		.mode = COMMAND_EXEC,
 		.jim_handler = jim_target_examine,
 		.help = "used internally for reset processing",
+		.usage = "arp_examine ['allow-defer']",
+	},
+	{
+		.name = "was_examined",
+		.mode = COMMAND_EXEC,
+		.jim_handler = jim_target_was_examined,
+		.help = "used internally for reset processing",
+		.usage = "was_examined",
+	},
+	{
+		.name = "examine_deferred",
+		.mode = COMMAND_EXEC,
+		.jim_handler = jim_target_examine_deferred,
+		.help = "used internally for reset processing",
+		.usage = "examine_deferred",
 	},
 	{
 		.name = "arp_halt_gdb",
@@ -5378,7 +5617,6 @@ static int target_create(Jim_GetOptInfo *goi)
 	Jim_Obj *new_cmd;
 	Jim_Cmd *cmd;
 	const char *cp;
-	char *cp2;
 	int e;
 	int x;
 	struct target *target;
@@ -5403,10 +5641,9 @@ static int target_create(Jim_GetOptInfo *goi)
 	}
 
 	/* TYPE */
-	e = Jim_GetOpt_String(goi, &cp2, NULL);
+	e = Jim_GetOpt_String(goi, &cp, NULL);
 	if (e != JIM_OK)
 		return e;
-	cp = cp2;
 	struct transport *tr = get_current_transport();
 	if (tr->override_target) {
 		e = tr->override_target(&cp);
@@ -5485,14 +5722,7 @@ static int target_create(Jim_GetOptInfo *goi)
 	target->halt_issued			= false;
 
 	/* initialize trace information */
-	target->trace_info = malloc(sizeof(struct trace));
-	target->trace_info->num_trace_points         = 0;
-	target->trace_info->trace_points_size        = 0;
-	target->trace_info->trace_points             = NULL;
-	target->trace_info->trace_history_size       = 0;
-	target->trace_info->trace_history            = NULL;
-	target->trace_info->trace_history_pos        = 0;
-	target->trace_info->trace_history_overflowed = 0;
+	target->trace_info = calloc(1, sizeof(struct trace));
 
 	target->dbgmsg          = NULL;
 	target->dbg_msg_enabled = 0;
@@ -5728,7 +5958,7 @@ static const struct command_registration target_subcommand_handlers[] = {
 };
 
 struct FastLoad {
-	uint32_t address;
+	target_addr_t address;
 	uint8_t *data;
 	int length;
 
@@ -5755,8 +5985,8 @@ COMMAND_HANDLER(handle_fast_load_image_command)
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint32_t image_size;
-	uint32_t min_address = 0;
-	uint32_t max_address = 0xffffffff;
+	target_addr_t min_address = 0;
+	target_addr_t max_address = -1;
 	int i;
 
 	struct image image;
@@ -5862,7 +6092,7 @@ COMMAND_HANDLER(handle_fast_load_command)
 		return ERROR_FAIL;
 	}
 	int i;
-	int ms = timeval_ms();
+	int64_t ms = timeval_ms();
 	int size = 0;
 	int retval = ERROR_OK;
 	for (i = 0; i < fastload_num; i++) {
@@ -5876,7 +6106,7 @@ COMMAND_HANDLER(handle_fast_load_command)
 		size += fastload[i].length;
 	}
 	if (retval == ERROR_OK) {
-		int after = timeval_ms();
+		int64_t after = timeval_ms();
 		command_print(CMD_CTX, "Loaded image %f kBytes/s", (float)(size/1024.0)/((float)(after-ms)/1000.0));
 	}
 	return retval;
@@ -6226,6 +6456,13 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.help =	"step one instruction from current PC or address",
 		.usage = "[address]",
 	},
+	{
+		.name = "mdd",
+		.handler = handle_md_command,
+		.mode = COMMAND_EXEC,
+		.help = "display memory words",
+		.usage = "['phys'] address [count]",
+	},
 	{
 		.name = "mdw",
 		.handler = handle_md_command,
@@ -6247,6 +6484,13 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.help = "display memory bytes",
 		.usage = "['phys'] address [count]",
 	},
+	{
+		.name = "mwd",
+		.handler = handle_mw_command,
+		.mode = COMMAND_EXEC,
+		.help = "write memory word",
+		.usage = "['phys'] address value [count]",
+	},
 	{
 		.name = "mww",
 		.handler = handle_mw_command,
diff --git a/src/target/target.h b/src/target/target.h
index 7079d421..47daeefd 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -25,13 +25,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef TARGET_H
-#define TARGET_H
+#ifndef OPENOCD_TARGET_TARGET_H
+#define OPENOCD_TARGET_TARGET_H
 
 #include <helper/list.h>
 
@@ -95,7 +93,7 @@ enum target_endianness {
 };
 
 struct working_area {
-	uint32_t address;
+	target_addr_t address;
 	uint32_t size;
 	bool free;
 	uint8_t *backup;
@@ -144,11 +142,14 @@ enum target_register_class {
 /* target_type.h contains the full definition of struct target_type */
 struct target {
 	struct target_type *type;			/* target type definition (name, access functions) */
-	const char *cmd_name;				/* tcl Name of target */
+	char *cmd_name;				/* tcl Name of target */
 	int target_number;					/* DO NOT USE!  field to be removed in 2010 */
 	struct jtag_tap *tap;				/* where on the jtag chain is this */
 	int32_t coreid;						/* which device on the TAP? */
 
+	/** Should we defer examine to later */
+	bool defer_examine;
+
 	/**
 	 * Indicates whether this target has been examined.
 	 *
@@ -172,9 +173,9 @@ struct target {
 	uint32_t working_area;				/* working area (initialised RAM). Evaluated
 										 * upon first allocation from virtual/physical address. */
 	bool working_area_virt_spec;		/* virtual address specified? */
-	uint32_t working_area_virt;			/* virtual address */
-	bool working_area_phys_spec;		/* virtual address specified? */
-	uint32_t working_area_phys;			/* physical address */
+	target_addr_t working_area_virt;			/* virtual address */
+	bool working_area_phys_spec;		/* physical address specified? */
+	target_addr_t working_area_phys;			/* physical address */
 	uint32_t working_area_size;			/* size in bytes */
 	uint32_t backup_working_area;		/* whether the content of the working area has to be preserved */
 	struct working_area *working_areas;/* list of allocated working areas */
@@ -189,17 +190,23 @@ struct target {
 	struct debug_msg_receiver *dbgmsg;	/* list of debug message receivers */
 	uint32_t dbg_msg_enabled;			/* debug message status */
 	void *arch_info;					/* architecture specific information */
+	void *private_config;				/* pointer to target specific config data (for jim_configure hook) */
 	struct target *next;				/* next target in list */
 
 	int display;						/* display async info in telnet session. Do not display
 										 * lots of halted/resumed info when stepping in debugger. */
 	bool halt_issued;					/* did we transition to halted state? */
-	long long halt_issued_time;			/* Note time when halt was issued */
+	int64_t halt_issued_time;			/* Note time when halt was issued */
 
 	bool dbgbase_set;					/* By default the debug base is not set */
 	uint32_t dbgbase;					/* Really a Cortex-A specific option, but there is no
 										 * system in place to support target specific options
 										 * currently. */
+
+	 bool ctibase_set;					 /* By default the debug base is not set */
+	 uint32_t ctibase;					 /* Really a Cortex-A specific option, but there is no
+										  * system in place to support target specific options
+										  * currently. */
 	struct rtos *rtos;					/* Instance of Real Time Operating System support */
 	bool rtos_auto_detect;				/* A flag that indicates that the RTOS has been specified as "auto"
 										 * and must be detected when symbols are offered */
@@ -372,7 +379,7 @@ int target_unregister_trace_callback(
  * yet it is possible to detect error conditions.
  */
 int target_poll(struct target *target);
-int target_resume(struct target *target, int current, uint32_t address,
+int target_resume(struct target *target, int current, target_addr_t address,
 		int handle_breakpoints, int debug_execution);
 int target_halt(struct target *target);
 int target_call_event_callbacks(struct target *target, enum target_event event);
@@ -493,7 +500,7 @@ int target_get_gdb_reg_list(struct target *target,
  * This routine is a wrapper for target->type->step.
  */
 int target_step(struct target *target,
-		int current, uint32_t address, int handle_breakpoints);
+		int current, target_addr_t address, int handle_breakpoints);
 /**
  * Run an algorithm on the @a target given.
  *
@@ -546,9 +553,9 @@ int target_run_flash_async_algorithm(struct target *target,
  * This routine is a wrapper for target->type->read_memory.
  */
 int target_read_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int target_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
  * the @a address given. @a address must be aligned to @a size
@@ -567,9 +574,9 @@ int target_read_phys_memory(struct target *target,
  * This routine is wrapper for target->type->write_memory.
  */
 int target_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 int target_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
 
 /*
  * Write to target memory using the virtual address.
@@ -596,13 +603,13 @@ int target_write_phys_memory(struct target *target,
  * peripheral registers which do not support byte operations.
  */
 int target_write_buffer(struct target *target,
-		uint32_t address, uint32_t size, const uint8_t *buffer);
+		target_addr_t address, uint32_t size, const uint8_t *buffer);
 int target_read_buffer(struct target *target,
-		uint32_t address, uint32_t size, uint8_t *buffer);
+		target_addr_t address, uint32_t size, uint8_t *buffer);
 int target_checksum_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t *crc);
+		target_addr_t address, uint32_t size, uint32_t *crc);
 int target_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t *blank);
+		target_addr_t address, uint32_t size, uint32_t *blank, uint8_t erased_value);
 int target_wait_state(struct target *target, enum target_state state, int ms);
 
 /**
@@ -678,14 +685,19 @@ void target_buffer_set_u64_array(struct target *target, uint8_t *buffer, uint32_
 void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint32_t count, const uint32_t *srcbuf);
 void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint32_t count, const uint16_t *srcbuf);
 
-int target_read_u64(struct target *target, uint64_t address, uint64_t *value);
-int target_read_u32(struct target *target, uint32_t address, uint32_t *value);
-int target_read_u16(struct target *target, uint32_t address, uint16_t *value);
-int target_read_u8(struct target *target, uint32_t address, uint8_t *value);
-int target_write_u64(struct target *target, uint64_t address, uint64_t value);
-int target_write_u32(struct target *target, uint32_t address, uint32_t value);
-int target_write_u16(struct target *target, uint32_t address, uint16_t value);
-int target_write_u8(struct target *target, uint32_t address, uint8_t value);
+int target_read_u64(struct target *target, target_addr_t address, uint64_t *value);
+int target_read_u32(struct target *target, target_addr_t address, uint32_t *value);
+int target_read_u16(struct target *target, target_addr_t address, uint16_t *value);
+int target_read_u8(struct target *target, target_addr_t address, uint8_t *value);
+int target_write_u64(struct target *target, target_addr_t address, uint64_t value);
+int target_write_u32(struct target *target, target_addr_t address, uint32_t value);
+int target_write_u16(struct target *target, target_addr_t address, uint16_t value);
+int target_write_u8(struct target *target, target_addr_t address, uint8_t value);
+
+int target_write_phys_u64(struct target *target, target_addr_t address, uint64_t value);
+int target_write_phys_u32(struct target *target, target_addr_t address, uint32_t value);
+int target_write_phys_u16(struct target *target, target_addr_t address, uint16_t value);
+int target_write_phys_u8(struct target *target, target_addr_t address, uint8_t value);
 
 /* Issues USER() statements with target state information */
 int target_arch_state(struct target *target);
@@ -706,4 +718,4 @@ void target_handle_event(struct target *t, enum target_event e);
 
 extern bool get_target_reset_nag(void);
 
-#endif /* TARGET_H */
+#endif /* OPENOCD_TARGET_TARGET_H */
diff --git a/src/target/target_request.c b/src/target/target_request.c
index df2fc34e..6ca204b5 100644
--- a/src/target/target_request.c
+++ b/src/target/target_request.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/target_request.h b/src/target/target_request.h
index 55ac0e9b..1b131733 100644
--- a/src/target/target_request.h
+++ b/src/target/target_request.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef TARGET_REQUEST_H
-#define TARGET_REQUEST_H
+#ifndef OPENOCD_TARGET_TARGET_REQUEST_H
+#define OPENOCD_TARGET_TARGET_REQUEST_H
 
 struct target;
 struct command_context;
@@ -54,4 +52,4 @@ int target_request_register_commands(struct command_context *cmd_ctx);
  */
 bool target_got_message(void);
 
-#endif /* TARGET_REQUEST_H */
+#endif /* OPENOCD_TARGET_TARGET_REQUEST_H */
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 234cdfb0..0960e6d5 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -19,13 +19,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef TARGET_TYPE_H
-#define TARGET_TYPE_H
+#ifndef OPENOCD_TARGET_TARGET_TYPE_H
+#define OPENOCD_TARGET_TARGET_TYPE_H
 
 #include <jim-nvp.h>
 
@@ -55,11 +53,11 @@ struct target_type {
 
 	/* halt will log a warning, but return ERROR_OK if the target is already halted. */
 	int (*halt)(struct target *target);
-	int (*resume)(struct target *target, int current, uint32_t address,
+	/* See target.c target_resume() for documentation. */
+	int (*resume)(struct target *target, int current, target_addr_t address,
 			int handle_breakpoints, int debug_execution);
-	int (*step)(struct target *target, int current, uint32_t address,
+	int (*step)(struct target *target, int current, target_addr_t address,
 			int handle_breakpoints);
-
 	/* target reset control. assert reset can be invoked when OpenOCD and
 	 * the target is out of sync.
 	 *
@@ -113,27 +111,27 @@ struct target_type {
 	 * Target memory read callback.  Do @b not call this function
 	 * directly, use target_read_memory() instead.
 	 */
-	int (*read_memory)(struct target *target, uint32_t address,
+	int (*read_memory)(struct target *target, target_addr_t address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
 	 */
-	int (*write_memory)(struct target *target, uint32_t address,
+	int (*write_memory)(struct target *target, target_addr_t address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
-	int (*read_buffer)(struct target *target, uint32_t address,
+	int (*read_buffer)(struct target *target, target_addr_t address,
 			uint32_t size, uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
-	int (*write_buffer)(struct target *target, uint32_t address,
+	int (*write_buffer)(struct target *target, target_addr_t address,
 			uint32_t size, const uint8_t *buffer);
 
-	int (*checksum_memory)(struct target *target, uint32_t address,
+	int (*checksum_memory)(struct target *target, target_addr_t address,
 			uint32_t count, uint32_t *checksum);
-	int (*blank_check_memory)(struct target *target, uint32_t address,
-			uint32_t count, uint32_t *blank);
+	int (*blank_check_memory)(struct target *target, target_addr_t address,
+			uint32_t count, uint32_t *blank, uint8_t erased_value);
 
 	/*
 	 * target break-/watchpoint control
@@ -177,15 +175,15 @@ struct target_type {
 	 */
 	int (*run_algorithm)(struct target *target, int num_mem_params,
 			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, uint32_t entry_point,
-			uint32_t exit_point, int timeout_ms, void *arch_info);
+			struct reg_param *reg_param, target_addr_t entry_point,
+			target_addr_t exit_point, int timeout_ms, void *arch_info);
 	int (*start_algorithm)(struct target *target, int num_mem_params,
 			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, uint32_t entry_point,
-			uint32_t exit_point, void *arch_info);
+			struct reg_param *reg_param, target_addr_t entry_point,
+			target_addr_t exit_point, void *arch_info);
 	int (*wait_algorithm)(struct target *target, int num_mem_params,
 			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, uint32_t exit_point,
+			struct reg_param *reg_param, target_addr_t exit_point,
 			int timeout_ms, void *arch_info);
 
 	const struct command_registration *commands;
@@ -235,7 +233,7 @@ struct target_type {
 	/* translate from virtual to physical address. Default implementation is successful
 	 * no-op(i.e. virtual==physical).
 	 */
-	int (*virt2phys)(struct target *target, uint32_t address, uint32_t *physical);
+	int (*virt2phys)(struct target *target, target_addr_t address, target_addr_t *physical);
 
 	/* read directly from physical memory. caches are bypassed and untouched.
 	 *
@@ -245,13 +243,13 @@ struct target_type {
 	 *
 	 * Default implementation is to call read_memory.
 	 */
-	int (*read_phys_memory)(struct target *target, uint32_t phys_address,
+	int (*read_phys_memory)(struct target *target, target_addr_t phys_address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
 
 	/*
 	 * same as read_phys_memory, except that it writes...
 	 */
-	int (*write_phys_memory)(struct target *target, uint32_t phys_address,
+	int (*write_phys_memory)(struct target *target, target_addr_t phys_address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
 
 	int (*mmu)(struct target *target, int *enabled);
@@ -278,4 +276,4 @@ struct target_type {
 			uint32_t max_num_samples, uint32_t *num_samples, uint32_t seconds);
 };
 
-#endif /* TARGET_TYPE_H */
+#endif /* OPENOCD_TARGET_TARGET_TYPE_H */
diff --git a/src/target/testee.c b/src/target/testee.c
index b95cb82b..5b6ccedd 100644
--- a/src/target/testee.c
+++ b/src/target/testee.c
@@ -12,9 +12,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/trace.c b/src/target/trace.c
index 9add8d80..206fd020 100644
--- a/src/target/trace.c
+++ b/src/target/trace.c
@@ -13,9 +13,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/target/trace.h b/src/target/trace.h
index bb9c3363..2966bbd9 100644
--- a/src/target/trace.h
+++ b/src/target/trace.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef TRACE_H
-#define TRACE_H
+#ifndef OPENOCD_TARGET_TRACE_H
+#define OPENOCD_TARGET_TRACE_H
 
 struct target;
 struct command_context;
@@ -58,4 +56,4 @@ int trace_register_commands(struct command_context *cmd_ctx);
 #define ERROR_TRACE_IMAGE_UNAVAILABLE		(-1500)
 #define ERROR_TRACE_INSTRUCTION_UNAVAILABLE	(-1501)
 
-#endif /* TRACE_H */
+#endif /* OPENOCD_TARGET_TRACE_H */
diff --git a/src/target/x86_32_common.c b/src/target/x86_32_common.c
index 3a26f71d..34f92eac 100644
--- a/src/target/x86_32_common.c
+++ b/src/target/x86_32_common.c
@@ -18,8 +18,7 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * Contact Information:
  * Intel Corporation
@@ -49,8 +48,8 @@ static int read_mem(struct target *t, uint32_t size,
 			uint32_t addr, uint8_t *buf);
 static int write_mem(struct target *t, uint32_t size,
 			uint32_t addr, const uint8_t *buf);
-static int calcaddr_pyhsfromlin(struct target *t, uint32_t addr,
-			uint32_t *physaddr);
+static int calcaddr_physfromlin(struct target *t, target_addr_t addr,
+			target_addr_t *physaddr);
 static int read_phys_mem(struct target *t, uint32_t phys_address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
 static int write_phys_mem(struct target *t, uint32_t phys_address,
@@ -114,7 +113,7 @@ int x86_32_common_mmu(struct target *t, int *enabled)
 	return ERROR_OK;
 }
 
-int x86_32_common_virt2phys(struct target *t, uint32_t address, uint32_t *physical)
+int x86_32_common_virt2phys(struct target *t, target_addr_t address, target_addr_t *physical)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 
@@ -135,8 +134,8 @@ int x86_32_common_virt2phys(struct target *t, uint32_t address, uint32_t *physic
 
 	} else {
 		/* target halted in protected mode */
-		if (calcaddr_pyhsfromlin(t, address, physical) != ERROR_OK) {
-			LOG_ERROR("%s failed to calculate physical address from 0x%08" PRIx32,
+		if (calcaddr_physfromlin(t, address, physical) != ERROR_OK) {
+			LOG_ERROR("%s failed to calculate physical address from " TARGET_ADDR_FMT,
 					__func__, address);
 			return ERROR_FAIL;
 		}
@@ -144,7 +143,7 @@ int x86_32_common_virt2phys(struct target *t, uint32_t address, uint32_t *physic
 	return ERROR_OK;
 }
 
-int x86_32_common_read_phys_mem(struct target *t, uint32_t phys_address,
+int x86_32_common_read_phys_mem(struct target *t, target_addr_t phys_address,
 			uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
@@ -227,7 +226,7 @@ static int read_phys_mem(struct target *t, uint32_t phys_address,
 	return retval;
 }
 
-int x86_32_common_write_phys_mem(struct target *t, uint32_t phys_address,
+int x86_32_common_write_phys_mem(struct target *t, target_addr_t phys_address,
 			uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
@@ -236,7 +235,7 @@ int x86_32_common_write_phys_mem(struct target *t, uint32_t phys_address,
 
 	check_not_halted(t);
 	if (!count || !buffer || !phys_address) {
-		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=" TARGET_ADDR_FMT,
 				__func__, count, buffer, phys_address);
 		return ERROR_COMMAND_ARGUMENT_INVALID;
 	}
@@ -445,7 +444,7 @@ static int write_mem(struct target *t, uint32_t size,
 	return retval;
 }
 
-int calcaddr_pyhsfromlin(struct target *t, uint32_t addr, uint32_t *physaddr)
+int calcaddr_physfromlin(struct target *t, target_addr_t addr, target_addr_t *physaddr)
 {
 	uint8_t entry_buffer[8];
 
@@ -569,16 +568,16 @@ int calcaddr_pyhsfromlin(struct target *t, uint32_t addr, uint32_t *physaddr)
 	return ERROR_OK;
 }
 
-int x86_32_common_read_memory(struct target *t, uint32_t addr,
+int x86_32_common_read_memory(struct target *t, target_addr_t addr,
 			uint32_t size, uint32_t count, uint8_t *buf)
 {
 	int retval = ERROR_OK;
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
-	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+	LOG_DEBUG("addr=" TARGET_ADDR_FMT ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
 			addr, size, count, buf);
 	check_not_halted(t);
 	if (!count || !buf || !addr) {
-		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=" TARGET_ADDR_FMT,
 				__func__, count, buf, addr);
 		return ERROR_COMMAND_ARGUMENT_INVALID;
 	}
@@ -592,9 +591,10 @@ int x86_32_common_read_memory(struct target *t, uint32_t addr,
 			LOG_ERROR("%s could not disable paging", __func__);
 			return retval;
 		}
-		uint32_t physaddr = 0;
-		if (calcaddr_pyhsfromlin(t, addr, &physaddr) != ERROR_OK) {
-			LOG_ERROR("%s failed to calculate physical address from 0x%08" PRIx32, __func__, addr);
+		target_addr_t physaddr = 0;
+		if (calcaddr_physfromlin(t, addr, &physaddr) != ERROR_OK) {
+			LOG_ERROR("%s failed to calculate physical address from " TARGET_ADDR_FMT,
+					  __func__, addr);
 			retval = ERROR_FAIL;
 		}
 		/* TODO: !!! Watch out for page boundaries
@@ -604,7 +604,8 @@ int x86_32_common_read_memory(struct target *t, uint32_t addr,
 
 		if (retval == ERROR_OK
 			&& x86_32_common_read_phys_mem(t, physaddr, size, count, buf) != ERROR_OK) {
-			LOG_ERROR("%s failed to read memory from physical address 0x%08" PRIx32, __func__, physaddr);
+			LOG_ERROR("%s failed to read memory from physical address " TARGET_ADDR_FMT,
+					  __func__, physaddr);
 			retval = ERROR_FAIL;
 		}
 		/* restore PG bit if it was cleared prior (regardless of retval) */
@@ -616,7 +617,8 @@ int x86_32_common_read_memory(struct target *t, uint32_t addr,
 	} else {
 		/* paging is off - linear address is physical address */
 		if (x86_32_common_read_phys_mem(t, addr, size, count, buf) != ERROR_OK) {
-			LOG_ERROR("%s failed to read memory from address 0%08" PRIx32, __func__, addr);
+			LOG_ERROR("%s failed to read memory from address " TARGET_ADDR_FMT,
+					  __func__, addr);
 			retval = ERROR_FAIL;
 		}
 	}
@@ -624,16 +626,16 @@ int x86_32_common_read_memory(struct target *t, uint32_t addr,
 	return retval;
 }
 
-int x86_32_common_write_memory(struct target *t, uint32_t addr,
+int x86_32_common_write_memory(struct target *t, target_addr_t addr,
 			uint32_t size, uint32_t count, const uint8_t *buf)
 {
 	int retval = ERROR_OK;
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
-	LOG_DEBUG("addr=0x%08" PRIx32 ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
+	LOG_DEBUG("addr=" TARGET_ADDR_FMT ", size=%" PRIu32 ", count=0x%" PRIx32 ", buf=%p",
 			addr, size, count, buf);
 	check_not_halted(t);
 	if (!count || !buf || !addr) {
-		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=0x%08" PRIx32,
+		LOG_ERROR("%s invalid params count=0x%" PRIx32 ", buf=%p, addr=" TARGET_ADDR_FMT,
 					__func__, count, buf, addr);
 		return ERROR_COMMAND_ARGUMENT_INVALID;
 	}
@@ -646,9 +648,9 @@ int x86_32_common_write_memory(struct target *t, uint32_t addr,
 			LOG_ERROR("%s could not disable paging", __func__);
 			return retval;
 		}
-		uint32_t physaddr = 0;
-		if (calcaddr_pyhsfromlin(t, addr, &physaddr) != ERROR_OK) {
-			LOG_ERROR("%s failed to calculate physical address from 0x%08" PRIx32,
+		target_addr_t physaddr = 0;
+		if (calcaddr_physfromlin(t, addr, &physaddr) != ERROR_OK) {
+			LOG_ERROR("%s failed to calculate physical address from " TARGET_ADDR_FMT,
 					__func__, addr);
 			retval = ERROR_FAIL;
 		}
@@ -658,7 +660,7 @@ int x86_32_common_write_memory(struct target *t, uint32_t addr,
 		 */
 		if (retval == ERROR_OK
 			&& x86_32_common_write_phys_mem(t, physaddr, size, count, buf) != ERROR_OK) {
-			LOG_ERROR("%s failed to write memory to physical address 0x%08" PRIx32,
+			LOG_ERROR("%s failed to write memory to physical address " TARGET_ADDR_FMT,
 					__func__, physaddr);
 			retval = ERROR_FAIL;
 		}
@@ -672,7 +674,7 @@ int x86_32_common_write_memory(struct target *t, uint32_t addr,
 
 		/* paging is off - linear address is physical address */
 		if (x86_32_common_write_phys_mem(t, addr, size, count, buf) != ERROR_OK) {
-			LOG_ERROR("%s failed to write memory to address 0x%08" PRIx32,
+			LOG_ERROR("%s failed to write memory to address " TARGET_ADDR_FMT,
 					__func__, addr);
 			retval = ERROR_FAIL;
 		}
@@ -853,7 +855,7 @@ int x86_32_common_remove_watchpoint(struct target *t, struct watchpoint *wp)
 
 int x86_32_common_add_breakpoint(struct target *t, struct breakpoint *bp)
 {
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
 	if (check_not_halted(t))
 		return ERROR_TARGET_NOT_HALTED;
 	/* set_breakpoint() will return ERROR_TARGET_RESOURCE_NOT_AVAILABLE if all
@@ -864,7 +866,7 @@ int x86_32_common_add_breakpoint(struct target *t, struct breakpoint *bp)
 
 int x86_32_common_remove_breakpoint(struct target *t, struct breakpoint *bp)
 {
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
 	if (check_not_halted(t))
 		return ERROR_TARGET_NOT_HALTED;
 	if (bp->set)
@@ -1004,7 +1006,7 @@ static int unset_hwbp(struct target *t, struct breakpoint *bp)
 	debug_reg_list[hwbp_num].used = 0;
 	debug_reg_list[hwbp_num].bp_value = 0;
 
-	LOG_USER("%s hardware breakpoint %" PRIu32 " removed from 0x%08" PRIx32 " (hwreg=%d)",
+	LOG_USER("%s hardware breakpoint %" PRIu32 " removed from " TARGET_ADDR_FMT " (hwreg=%d)",
 			__func__, bp->unique_id, bp->address, hwbp_num);
 	return ERROR_OK;
 }
@@ -1013,11 +1015,11 @@ static int set_swbp(struct target *t, struct breakpoint *bp)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	LOG_DEBUG("id %" PRIx32, bp->unique_id);
-	uint32_t physaddr;
+	target_addr_t physaddr;
 	uint8_t opcode = SW_BP_OPCODE;
 	uint8_t readback;
 
-	if (calcaddr_pyhsfromlin(t, bp->address, &physaddr) != ERROR_OK)
+	if (calcaddr_physfromlin(t, bp->address, &physaddr) != ERROR_OK)
 		return ERROR_FAIL;
 	if (read_phys_mem(t, physaddr, 1, 1, bp->orig_instr))
 		return ERROR_FAIL;
@@ -1033,7 +1035,7 @@ static int set_swbp(struct target *t, struct breakpoint *bp)
 		return ERROR_FAIL;
 
 	if (readback != SW_BP_OPCODE) {
-		LOG_ERROR("%s software breakpoint error at 0x%08" PRIx32 ", check memory",
+		LOG_ERROR("%s software breakpoint error at " TARGET_ADDR_FMT ", check memory",
 				__func__, bp->address);
 		LOG_ERROR("%s readback=0x%02" PRIx8 " orig=0x%02" PRIx8 "",
 				__func__, readback, *bp->orig_instr);
@@ -1060,7 +1062,7 @@ static int set_swbp(struct target *t, struct breakpoint *bp)
 			addto = addto->next;
 		addto->next = new_patch;
 	}
-	LOG_USER("%s software breakpoint %" PRIu32 " set at 0x%08" PRIx32,
+	LOG_USER("%s software breakpoint %" PRIu32 " set at " TARGET_ADDR_FMT,
 			__func__, bp->unique_id, bp->address);
 	return ERROR_OK;
 }
@@ -1069,11 +1071,11 @@ static int unset_swbp(struct target *t, struct breakpoint *bp)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	LOG_DEBUG("id %" PRIx32, bp->unique_id);
-	uint32_t physaddr;
+	target_addr_t physaddr;
 	uint8_t current_instr;
 
 	/* check that user program has not modified breakpoint instruction */
-	if (calcaddr_pyhsfromlin(t, bp->address, &physaddr) != ERROR_OK)
+	if (calcaddr_physfromlin(t, bp->address, &physaddr) != ERROR_OK)
 		return ERROR_FAIL;
 	if (read_phys_mem(t, physaddr, 1, 1, &current_instr))
 		return ERROR_FAIL;
@@ -1082,7 +1084,7 @@ static int unset_swbp(struct target *t, struct breakpoint *bp)
 		if (write_phys_mem(t, physaddr, 1, 1, bp->orig_instr))
 			return ERROR_FAIL;
 	} else {
-		LOG_ERROR("%s software breakpoint remove error at 0x%08" PRIx32 ", check memory",
+		LOG_ERROR("%s software breakpoint remove error at " TARGET_ADDR_FMT ", check memory",
 				__func__, bp->address);
 		LOG_ERROR("%s current=0x%02" PRIx8 " orig=0x%02" PRIx8 "",
 				__func__, current_instr, *bp->orig_instr);
@@ -1108,7 +1110,7 @@ static int unset_swbp(struct target *t, struct breakpoint *bp)
 		}
 	}
 
-	LOG_USER("%s software breakpoint %" PRIu32 " removed from 0x%08" PRIx32,
+	LOG_USER("%s software breakpoint %" PRIu32 " removed from " TARGET_ADDR_FMT,
 			__func__, bp->unique_id, bp->address);
 	return ERROR_OK;
 }
@@ -1117,7 +1119,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 {
 	int error = ERROR_OK;
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
 	if (bp->set) {
 		LOG_ERROR("breakpoint already set");
 		return error;
@@ -1125,7 +1127,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 	if (bp->type == BKPT_HARD) {
 		error = set_hwbp(t, bp);
 		if (error != ERROR_OK) {
-			LOG_ERROR("%s error setting hardware breakpoint at 0x%08" PRIx32,
+			LOG_ERROR("%s error setting hardware breakpoint at " TARGET_ADDR_FMT,
 					__func__, bp->address);
 			return error;
 		}
@@ -1133,7 +1135,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 		if (x86_32->sw_bpts_supported(t)) {
 			error = set_swbp(t, bp);
 			if (error != ERROR_OK) {
-				LOG_ERROR("%s error setting software breakpoint at 0x%08" PRIx32,
+				LOG_ERROR("%s error setting software breakpoint at " TARGET_ADDR_FMT,
 						__func__, bp->address);
 				return error;
 			}
@@ -1148,7 +1150,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 
 static int unset_breakpoint(struct target *t, struct breakpoint *bp)
 {
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, bp->type, bp->address);
 	if (!bp->set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
@@ -1156,13 +1158,13 @@ static int unset_breakpoint(struct target *t, struct breakpoint *bp)
 
 	if (bp->type == BKPT_HARD) {
 		if (unset_hwbp(t, bp) != ERROR_OK) {
-			LOG_ERROR("%s error removing hardware breakpoint at 0x%08" PRIx32,
+			LOG_ERROR("%s error removing hardware breakpoint at " TARGET_ADDR_FMT,
 					__func__, bp->address);
 			return ERROR_FAIL;
 		}
 	} else {
 		if (unset_swbp(t, bp) != ERROR_OK) {
-			LOG_ERROR("%s error removing software breakpoint at 0x%08" PRIx32,
+			LOG_ERROR("%s error removing software breakpoint at " TARGET_ADDR_FMT,
 					__func__, bp->address);
 			return ERROR_FAIL;
 		}
@@ -1176,7 +1178,7 @@ static int set_watchpoint(struct target *t, struct watchpoint *wp)
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
 	int wp_num = 0;
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, wp->rw, wp->address);
+	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, wp->rw, wp->address);
 
 	if (wp->set) {
 		LOG_ERROR("%s watchpoint already set", __func__);
@@ -1221,7 +1223,7 @@ static int set_watchpoint(struct target *t, struct watchpoint *wp)
 	wp->set = wp_num + 1;
 	debug_reg_list[wp_num].used = 1;
 	debug_reg_list[wp_num].bp_value = wp->address;
-	LOG_USER("'%s' watchpoint %d set at 0x%08" PRIx32 " with length %" PRIu32 " (hwreg=%d)",
+	LOG_USER("'%s' watchpoint %d set at " TARGET_ADDR_FMT " with length %" PRIu32 " (hwreg=%d)",
 			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
 			"write" : wp->rw == WPT_ACCESS ? "access" : "?",
 			wp->unique_id, wp->address, wp->length, wp_num);
@@ -1232,7 +1234,7 @@ static int unset_watchpoint(struct target *t, struct watchpoint *wp)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, wp->rw, wp->address);
+	LOG_DEBUG("type=%d, addr=" TARGET_ADDR_FMT, wp->rw, wp->address);
 	if (!wp->set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
@@ -1250,7 +1252,7 @@ static int unset_watchpoint(struct target *t, struct watchpoint *wp)
 	debug_reg_list[wp_num].bp_value = 0;
 	wp->set = 0;
 
-	LOG_USER("'%s' watchpoint %d removed from 0x%08" PRIx32 " with length %" PRIu32 " (hwreg=%d)",
+	LOG_USER("'%s' watchpoint %d removed from " TARGET_ADDR_FMT " with length %" PRIu32 " (hwreg=%d)",
 			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
 			"write" : wp->rw == WPT_ACCESS ? "access" : "?",
 			wp->unique_id, wp->address, wp->length, wp_num);
diff --git a/src/target/x86_32_common.h b/src/target/x86_32_common.h
index af57a5f7..0aaa963d 100644
--- a/src/target/x86_32_common.h
+++ b/src/target/x86_32_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2013 Intel Corporation.
+ * Copyright(c) 2013-2016 Intel Corporation.
  *
  * Adrian Burns (adrian.burns@intel.com)
  * Thomas Faust (thomas.faust@intel.com)
@@ -18,8 +18,7 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  * Contact Information:
  * Intel Corporation
@@ -30,8 +29,8 @@
  * This is the interface to the x86 32 bit memory and breakpoint operations.
  */
 
-#ifndef X86_32_COMMON_H
-#define X86_32_COMMON_H
+#ifndef OPENOCD_TARGET_X86_32_COMMON_H
+#define OPENOCD_TARGET_X86_32_COMMON_H
 
 #include <jtag/jtag.h>
 #include <helper/command.h>
@@ -196,6 +195,11 @@ enum {
 	WBINVD,
 };
 
+enum x86_core_type {
+	LMT1,
+	LMT3_5
+};
+
 struct swbp_mem_patch {
 	uint8_t orig_byte;
 	uint32_t swbp_unique_id;
@@ -209,6 +213,7 @@ struct swbp_mem_patch {
 struct x86_32_common {
 	uint32_t common_magic;
 	void *arch_info;
+	enum x86_core_type core_type;
 	struct reg_cache *cache;
 	struct jtag_tap *curr_tap;
 	uint32_t stored_pc;
@@ -304,14 +309,14 @@ int x86_32_get_gdb_reg_list(struct target *t,
 int x86_32_common_init_arch_info(struct target *target,
 			struct x86_32_common *x86_32);
 int x86_32_common_mmu(struct target *t, int *enabled);
-int x86_32_common_virt2phys(struct target *t, uint32_t address, uint32_t *physical);
-int x86_32_common_read_phys_mem(struct target *t, uint32_t phys_address,
+int x86_32_common_virt2phys(struct target *t, target_addr_t address, target_addr_t *physical);
+int x86_32_common_read_phys_mem(struct target *t, target_addr_t phys_address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
-int x86_32_common_write_phys_mem(struct target *t, uint32_t phys_address,
+int x86_32_common_write_phys_mem(struct target *t, target_addr_t phys_address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
-int x86_32_common_read_memory(struct target *t, uint32_t addr,
+int x86_32_common_read_memory(struct target *t, target_addr_t addr,
 			uint32_t size, uint32_t count, uint8_t *buf);
-int x86_32_common_write_memory(struct target *t, uint32_t addr,
+int x86_32_common_write_memory(struct target *t, target_addr_t addr,
 			uint32_t size, uint32_t count, const uint8_t *buf);
 int x86_32_common_read_io(struct target *t, uint32_t addr,
 			uint32_t size, uint8_t *buf);
@@ -322,4 +327,4 @@ int x86_32_common_remove_breakpoint(struct target *t, struct breakpoint *bp);
 int x86_32_common_add_watchpoint(struct target *t, struct watchpoint *wp);
 int x86_32_common_remove_watchpoint(struct target *t, struct watchpoint *wp);
 
-#endif /* X86_32_COMMON_H */
+#endif /* OPENOCD_TARGET_X86_32_COMMON_H */
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 82e41600..8fe8a2cb 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -19,9 +19,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 #ifdef HAVE_CONFIG_H
@@ -61,7 +59,7 @@
 
 /* forward declarations */
 static int xscale_resume(struct target *, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution);
+	target_addr_t address, int handle_breakpoints, int debug_execution);
 static int xscale_debug_entry(struct target *);
 static int xscale_restore_banked(struct target *);
 static int xscale_get_reg(struct reg *reg);
@@ -75,7 +73,7 @@ static int xscale_read_trace(struct target *);
  * mini-ICache, which is 2K of code writable only via JTAG.
  */
 static const uint8_t xscale_debug_handler[] = {
-#include "xscale_debug.inc"
+#include "../../contrib/loaders/debug/xscale/debug_handler.inc"
 };
 
 static const char *const xscale_reg_list[] = {
@@ -1122,7 +1120,7 @@ static void xscale_free_trace_data(struct xscale_common *xscale)
 }
 
 static int xscale_resume(struct target *target, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution)
+	target_addr_t address, int handle_breakpoints, int debug_execution)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	struct arm *arm = &xscale->arm;
@@ -1167,7 +1165,8 @@ static int xscale_resume(struct target *target, int current,
 			enum trace_mode saved_trace_mode;
 
 			/* there's a breakpoint at the current PC, we have to step over it */
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("unset breakpoint at " TARGET_ADDR_FMT "",
+				breakpoint->address);
 			xscale_unset_breakpoint(target, breakpoint);
 
 			/* calculate PC of next instruction */
@@ -1224,7 +1223,8 @@ static int xscale_resume(struct target *target, int current,
 			LOG_DEBUG("disable single-step");
 			xscale_disable_single_step(target);
 
-			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("set breakpoint at " TARGET_ADDR_FMT "",
+				breakpoint->address);
 			xscale_set_breakpoint(target, breakpoint);
 		}
 	}
@@ -1386,7 +1386,7 @@ static int xscale_step_inner(struct target *target, int current,
 }
 
 static int xscale_step(struct target *target, int current,
-	uint32_t address, int handle_breakpoints)
+	target_addr_t address, int handle_breakpoints)
 {
 	struct arm *arm = target_to_arm(target);
 	struct breakpoint *breakpoint = NULL;
@@ -1446,6 +1446,13 @@ static int xscale_assert_reset(struct target *target)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 
+	/* TODO: apply hw reset signal in not examined state */
+	if (!(target_was_examined(target))) {
+		LOG_WARNING("Reset is not asserted because the target is not examined.");
+		LOG_WARNING("Use a reset button or power cycle the target.");
+		return ERROR_TARGET_NOT_EXAMINED;
+	}
+
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
 
@@ -1573,7 +1580,6 @@ static int xscale_deassert_reset(struct target *target)
 
 			address += buf_cnt;
 		}
-		;
 
 		retval = xscale_load_ic(target, 0x0,
 				xscale->low_vectors);
@@ -1774,7 +1780,7 @@ dirty:
 	return ERROR_OK;
 }
 
-static int xscale_read_memory(struct target *target, uint32_t address,
+static int xscale_read_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
@@ -1782,7 +1788,7 @@ static int xscale_read_memory(struct target *target, uint32_t address,
 	uint32_t i;
 	int retval;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32,
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32,
 		address,
 		size,
 		count);
@@ -1860,7 +1866,7 @@ static int xscale_read_memory(struct target *target, uint32_t address,
 	return ERROR_OK;
 }
 
-static int xscale_read_phys_memory(struct target *target, uint32_t address,
+static int xscale_read_phys_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
@@ -1875,13 +1881,13 @@ static int xscale_read_phys_memory(struct target *target, uint32_t address,
 	return ERROR_FAIL;
 }
 
-static int xscale_write_memory(struct target *target, uint32_t address,
+static int xscale_write_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	int retval;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32,
+	LOG_DEBUG("address: " TARGET_ADDR_FMT ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32,
 		address,
 		size,
 		count);
@@ -1959,7 +1965,7 @@ static int xscale_write_memory(struct target *target, uint32_t address,
 	return ERROR_OK;
 }
 
-static int xscale_write_phys_memory(struct target *target, uint32_t address,
+static int xscale_write_phys_memory(struct target *target, target_addr_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
@@ -2663,7 +2669,7 @@ static int xscale_analyze_trace(struct target *target, struct command_context *c
 	struct xscale_common *xscale = target_to_xscale(target);
 	struct xscale_trace_data *trace_data = xscale->trace.data;
 	int i, retval;
-	uint32_t breakpoint_pc;
+	uint32_t breakpoint_pc = 0;
 	struct arm_instruction instruction;
 	uint32_t current_pc = 0;/* initialized when address determined */
 
@@ -3089,7 +3095,7 @@ COMMAND_HANDLER(xscale_handle_cache_info_command)
 }
 
 static int xscale_virt2phys(struct target *target,
-	uint32_t virtual, uint32_t *physical)
+	target_addr_t virtual, target_addr_t *physical)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t cb;
@@ -3426,7 +3432,7 @@ COMMAND_HANDLER(xscale_handle_dump_trace_command)
 	struct target *target = get_current_target(CMD_CTX);
 	struct xscale_common *xscale = target_to_xscale(target);
 	struct xscale_trace_data *trace_data;
-	struct fileio file;
+	struct fileio *file;
 	int retval;
 
 	retval = xscale_verify_pointer(CMD_CTX, xscale);
@@ -3454,19 +3460,19 @@ COMMAND_HANDLER(xscale_handle_dump_trace_command)
 	while (trace_data) {
 		int i;
 
-		fileio_write_u32(&file, trace_data->chkpt0);
-		fileio_write_u32(&file, trace_data->chkpt1);
-		fileio_write_u32(&file, trace_data->last_instruction);
-		fileio_write_u32(&file, trace_data->depth);
+		fileio_write_u32(file, trace_data->chkpt0);
+		fileio_write_u32(file, trace_data->chkpt1);
+		fileio_write_u32(file, trace_data->last_instruction);
+		fileio_write_u32(file, trace_data->depth);
 
 		for (i = 0; i < trace_data->depth; i++)
-			fileio_write_u32(&file, trace_data->entries[i].data |
+			fileio_write_u32(file, trace_data->entries[i].data |
 				((trace_data->entries[i].type & 0xffff) << 16));
 
 		trace_data = trace_data->next;
 	}
 
-	fileio_close(&file);
+	fileio_close(file);
 
 	return ERROR_OK;
 }
diff --git a/src/target/xscale.h b/src/target/xscale.h
index a71ec351..a86edb2f 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -16,13 +16,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef XSCALE_H
-#define XSCALE_H
+#ifndef OPENOCD_TARGET_XSCALE_H
+#define OPENOCD_TARGET_XSCALE_H
 
 #include "arm.h"
 #include "armv4_5_mmu.h"
@@ -187,4 +185,4 @@ enum {
 #define DCSR_TRAP_MASK \
 	(DCSR_TF | DCSR_TI | DCSR_TD | DCSR_TA | DCSR_TS | DCSR_TU | DCSR_TR)
 
-#endif /* XSCALE_H */
+#endif /* OPENOCD_TARGET_XSCALE_H */
diff --git a/src/target/xscale/build.sh b/src/target/xscale/build.sh
deleted file mode 100755
index fc828b2c..00000000
--- a/src/target/xscale/build.sh
+++ /dev/null
@@ -1,7 +0,0 @@
-arm-none-eabi-gcc -c debug_handler.S -o debug_handler.o
-arm-none-eabi-ld -EL -n -Tdebug_handler.cmd debug_handler.o -o debug_handler.out
-arm-none-eabi-objcopy -O binary debug_handler.out debug_handler.bin
-
-#arm-none-eabi-gcc -mbig-endian -c debug_handler.S -o debug_handler_be.o
-#arm-none-eabi-ld -EB -n -Tdebug_handler.cmd debug_handler_be.o -o debug_handler_be.out
-#arm-none-eabi-objcopy -O binary debug_handler_be.out debug_handler_be.bin
diff --git a/src/target/xscale/debug_handler.bin b/src/target/xscale/debug_handler.bin
deleted file mode 100755
index 2dde18531648415e9ab588ea1bd3f743e3732e5e..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1592
zcmaKsO-NKx6vyv#)Ui?DyE>yeqvL2vL|=@3EP?{twsFkb3?U{F8WGaA7HZ2#p;i^x
zgNQa|<R&5z(ORl$gh*t*nIcj=jk_pw`k%vl`CQ~|e&?L~pZm@|=iZ~#_CLKCqk`FZ
z#!xC2n6<NdF+_T!p8n+Xm$g~4X;TRq%657UwNe0H1q0v}un@cq7J=PhF?b0Kf)_!h
zTAePJ4Qf0)uKKbGtuk7*W%;`a#1e>|RBHLW=u+9^N`(xS%BH~z@H$ut-UK7yEwB;1
z3+@6RfKA{dFbPJ$W^liuLM`AM_@}^CFa<sV+rX#b8JF!YJ3-#>0$7IscYzUbKA&Gc
z%K7DboWsms+etDzZRZd(WjhC$Ew;0dnY5j~%m&-p!_>CZ1iJN2Yl@P}bz~B})@wN`
z*XStJOlsrxV9?itVV^zXv&Ve)w9j7j+2~&a^$y@%+z)?`gYI`9;(Y7szqzFKVAQ)0
zX+7+-M|}2}&z|<#i#{9Y_Hy}G3zKWn<9NB;KrRcM3u-sdMC}YU_vQXjkY?Z;x-Ii7
zpO0OGj(yfmxw=s`x5T=)K3z9-?6Ypt)fK8cvfpc;t^+#uS@+7-z2tQ@AzJUdXQ6xH
z>Yls0XW*!skZ*gs)6n6r$$pPr9quUJ%)plYTA<TrjQD+MGejrg--FJmwX>sE5b?eY
z@A(^NK8Cew#EyVfU^D;MswBQUg}K(uLHOIh`pwlo$!RFlx7NR;Els=e29sbTsI3b0
ziTw(Si(g5#!Z1aJRkTxBO;y4;g@p;K0BfvzvcM=<F7bLQ1;g-nfDtgrakG|+gmr}b
z2|tcm!;DcLXK6={KR5Er=OkC#VP7>2W%}0!kh7vStR=x8ptcNJ72lv0@eAm?FhJjg
zMf6ozOj%($IYNs*gEf{(pTH>iQQ{^ofMNLaU<CZYakG@(3(II$SWYv-5KVzb9cC%c
z)r4HVzG<@#eZ>36`Rc(*pN=)_=<OI{sIkl#)L3Q=YAiDbHI^BJ8q179jb+B5#&W+<
nV|gd2@s=6GGv0W2TV^}Yn+?7%-h44j$jsT^JV<N2L-zjyAcLt>

diff --git a/src/transport/Makefile.am b/src/transport/Makefile.am
index 7c6224a4..9076d9b6 100644
--- a/src/transport/Makefile.am
+++ b/src/transport/Makefile.am
@@ -1,11 +1,4 @@
-include $(top_srcdir)/common.mk
-
-#METASOURCES = AUTO
-noinst_LTLIBRARIES = libtransport.la
-libtransport_la_SOURCES = \
-	transport.c
-
-noinst_HEADERS = \
-	transport.h
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+noinst_LTLIBRARIES += %D%/libtransport.la
+%C%_libtransport_la_SOURCES = \
+	%D%/transport.c \
+	%D%/transport.h
diff --git a/src/transport/transport.c b/src/transport/transport.c
index c973e1c3..70859471 100644
--- a/src/transport/transport.c
+++ b/src/transport/transport.c
@@ -12,8 +12,7 @@
  * GNU General Public License for more details.
 
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifdef HAVE_CONFIG_H
diff --git a/src/transport/transport.h b/src/transport/transport.h
index daf49604..6c57067a 100644
--- a/src/transport/transport.h
+++ b/src/transport/transport.h
@@ -13,12 +13,11 @@
  * GNU General Public License for more details.
 
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#ifndef TRANSPORT_H
-#define TRANSPORT_H
+#ifndef OPENOCD_TRANSPORT_TRANSPORT_H
+#define OPENOCD_TRANSPORT_TRANSPORT_H
 
 #include "helper/command.h"
 
@@ -91,4 +90,4 @@ int allow_transports(struct command_context *ctx, const char * const *vector);
 
 bool transports_are_declared(void);
 
-#endif
+#endif /* OPENOCD_TRANSPORT_TRANSPORT_H */
diff --git a/src/xsvf/Makefile.am b/src/xsvf/Makefile.am
index 1b9cfab0..61e6fb92 100644
--- a/src/xsvf/Makefile.am
+++ b/src/xsvf/Makefile.am
@@ -1,8 +1,2 @@
-include $(top_srcdir)/common.mk
-
-METASOURCES = AUTO
-noinst_LTLIBRARIES = libxsvf.la
-noinst_HEADERS = xsvf.h
-libxsvf_la_SOURCES = xsvf.c
-
-MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
+noinst_LTLIBRARIES += %D%/libxsvf.la
+%C%_libxsvf_la_SOURCES = %D%/xsvf.c %D%/xsvf.h
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index a6de8239..63c89151 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -22,9 +22,7 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
 /* The specification for SVF is available here:
diff --git a/src/xsvf/xsvf.h b/src/xsvf/xsvf.h
index 3f35aea5..aa0f4f04 100644
--- a/src/xsvf/xsvf.h
+++ b/src/xsvf/xsvf.h
@@ -13,13 +13,11 @@
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>. *
  ***************************************************************************/
 
-#ifndef XSVF_H
-#define XSVF_H
+#ifndef OPENOCD_XSVF_XSVF_H
+#define OPENOCD_XSVF_XSVF_H
 
 #include <helper/command.h>
 
@@ -28,4 +26,4 @@ int xsvf_register_commands(struct command_context *cmd_ctx);
 #define ERROR_XSVF_EOF  (-200)
 #define ERROR_XSVF_FAILED       (-201)
 
-#endif	/* XSVF_H */
+#endif /* OPENOCD_XSVF_XSVF_H */
diff --git a/tcl/board/atmel_same70_xplained.cfg b/tcl/board/atmel_same70_xplained.cfg
new file mode 100644
index 00000000..a22e801a
--- /dev/null
+++ b/tcl/board/atmel_same70_xplained.cfg
@@ -0,0 +1,12 @@
+#
+# Atmel SAME70 Xplained evaluation kit.
+# http://www.atmel.com/tools/ATSAME70-XPLD.aspx
+#
+# Connect using the EDBG chip on the dev kit over USB
+source [find interface/cmsis-dap.cfg]
+
+set CHIPNAME atsame70q21
+
+source [find target/atsamv.cfg]
+
+reset_config srst_only
diff --git a/tcl/board/atmel_samg55_xplained_pro.cfg b/tcl/board/atmel_samg55_xplained_pro.cfg
new file mode 100644
index 00000000..3797bf8b
--- /dev/null
+++ b/tcl/board/atmel_samg55_xplained_pro.cfg
@@ -0,0 +1,11 @@
+#
+# Atmel SAMG55 Xplained Pro evaluation kit.
+# http://www.atmel.com/tools/ATSAMG55-XPRO.aspx
+#
+
+source [find interface/cmsis-dap.cfg]
+
+# chip name
+set CHIPNAME ATSAMG55J19
+
+source [find target/at91samg5x.cfg]
diff --git a/tcl/board/efm32.cfg b/tcl/board/efm32.cfg
index 820b6c81..d2bc9a61 100644
--- a/tcl/board/efm32.cfg
+++ b/tcl/board/efm32.cfg
@@ -1,6 +1,6 @@
-# Configuration for EFM32 boards with Segger J-Link on board
+# Configuration for EFM32 boards with on-board SEGGER J-Link
 #
-# Tested with TINY GECKO and Zero Gecko demo board
+# Tested with Tiny, Giant and Zero Gecko Starter Kit.
 #
 
 source [find interface/jlink.cfg]
@@ -9,9 +9,3 @@ adapter_khz 1000
 
 set CHIPNAME efm32
 source [find target/efm32.cfg]
-
-# EFM32 SWD doesn't work with RST asserted
-# So don't use srst_nogate!
-# Attach to running target with "mon halt"
-reset_config srst_only
-
diff --git a/tcl/board/fsl_imx6q_sabresd.cfg b/tcl/board/fsl_imx6q_sabresd.cfg
new file mode 100644
index 00000000..797e2de5
--- /dev/null
+++ b/tcl/board/fsl_imx6q_sabresd.cfg
@@ -0,0 +1,149 @@
+#
+# Board configuration file for the Freescale IMX6Q Sabre SD EVM
+#
+# This board does not have an embedded JTAG adapter, you must source
+# a suitable adapter configuration before sourcing this file.
+
+# Sabre SD has a standard ARM-20 JTAG connector with
+# nTRST and nSRST available.
+reset_config trst_and_srst
+
+# the only possible transport is JTAG
+transport select jtag
+
+# iMX6Q POR gates JTAG and the chip is completely incommunicado
+# over JTAG for at least 10ms after nSRST is deasserted
+adapter_nsrst_delay 11
+
+# Source generic iMX6Q target configuration
+set CHIPNAME imx6q
+source [find target/imx6.cfg]
+
+# function to apply initial configuration after a reset. It
+# provides a basic pad configuration and also DDR memory and clocks
+# sufficient to load and execute a boot loader (e.g. barebox) from
+# DDR memory. This list is extracted from the barebox flash image
+# header.
+proc apply_dcd { } {
+	mww 0x020e05a8 0x00000030
+	mww 0x020e05b0 0x00000030
+	mww 0x020e0524 0x00000030
+	mww 0x020e051c 0x00000030
+	mww 0x020e0518 0x00000030
+	mww 0x020e050c 0x00000030
+	mww 0x020e05b8 0x00000030
+	mww 0x020e05c0 0x00000030
+	mww 0x020e05ac 0x00020030
+	mww 0x020e05b4 0x00020030
+	mww 0x020e0528 0x00020030
+	mww 0x020e0520 0x00020030
+	mww 0x020e0514 0x00020030
+	mww 0x020e0510 0x00020030
+	mww 0x020e05bc 0x00020030
+	mww 0x020e05c4 0x00020030
+	mww 0x020e056c 0x00020030
+	mww 0x020e0578 0x00020030
+	mww 0x020e0588 0x00020030
+	mww 0x020e0594 0x00020030
+	mww 0x020e057c 0x00020030
+	mww 0x020e0590 0x00003000
+	mww 0x020e0598 0x00003000
+	mww 0x020e058c 0x00000000
+	mww 0x020e059c 0x00003030
+	mww 0x020e05a0 0x00003030
+	mww 0x020e0784 0x00000030
+	mww 0x020e0788 0x00000030
+	mww 0x020e0794 0x00000030
+	mww 0x020e079c 0x00000030
+	mww 0x020e07a0 0x00000030
+	mww 0x020e07a4 0x00000030
+	mww 0x020e07a8 0x00000030
+	mww 0x020e0748 0x00000030
+	mww 0x020e074c 0x00000030
+	mww 0x020e0750 0x00020000
+	mww 0x020e0758 0x00000000
+	mww 0x020e0774 0x00020000
+	mww 0x020e078c 0x00000030
+	mww 0x020e0798 0x000c0000
+	mww 0x021b081c 0x33333333
+	mww 0x021b0820 0x33333333
+	mww 0x021b0824 0x33333333
+	mww 0x021b0828 0x33333333
+	mww 0x021b481c 0x33333333
+	mww 0x021b4820 0x33333333
+	mww 0x021b4824 0x33333333
+	mww 0x021b4828 0x33333333
+	mww 0x021b0018 0x00081740
+	mww 0x021b001c 0x00008000
+	mww 0x021b000c 0x555a7975
+	mww 0x021b0010 0xff538e64
+	mww 0x021b0014 0x01ff00db
+	mww 0x021b002c 0x000026d2
+	mww 0x021b0030 0x005b0e21
+	mww 0x021b0008 0x09444040
+	mww 0x021b0004 0x00025576
+	mww 0x021b0040 0x00000027
+	mww 0x021b0000 0x831a0000
+	mww 0x021b001c 0x04088032
+	mww 0x021b001c 0x0408803a
+	mww 0x021b001c 0x00008033
+	mww 0x021b001c 0x0000803b
+	mww 0x021b001c 0x00428031
+	mww 0x021b001c 0x00428039
+	mww 0x021b001c 0x09408030
+	mww 0x021b001c 0x09408038
+	mww 0x021b001c 0x04008040
+	mww 0x021b001c 0x04008048
+	mww 0x021b0800 0xa1380003
+	mww 0x021b4800 0xa1380003
+	mww 0x021b0020 0x00005800
+	mww 0x021b0818 0x00022227
+	mww 0x021b4818 0x00022227
+	mww 0x021b083c 0x434b0350
+	mww 0x021b0840 0x034c0359
+	mww 0x021b483c 0x434b0350
+	mww 0x021b4840 0x03650348
+	mww 0x021b0848 0x4436383b
+	mww 0x021b4848 0x39393341
+	mww 0x021b0850 0x35373933
+	mww 0x021b4850 0x48254A36
+	mww 0x021b080c 0x001f001f
+	mww 0x021b0810 0x001f001f
+	mww 0x021b480c 0x00440044
+	mww 0x021b4810 0x00440044
+	mww 0x021b08b8 0x00000800
+	mww 0x021b48b8 0x00000800
+	mww 0x021b001c 0x00000000
+	mww 0x021b0404 0x00011006
+	mww 0x020c4068 0x00c03f3f
+	mww 0x020c406c 0x0030fc03
+	mww 0x020c4070 0x0fffc000
+	mww 0x020c4074 0x3ff00000
+	mww 0x020c4078 0x00fff300
+	mww 0x020c407c 0x0f0000c3
+	mww 0x020c4080 0x000003ff
+	mww 0x020e0010 0xf00000cf
+	mww 0x020e0018 0x007f007f
+	mww 0x020e001c 0x007f007f
+}
+
+# disable watchdog
+proc disable_wdog { } {
+	mwh 0x020bc000 0x30
+}
+
+# This function applies the initial configuration after a "reset init"
+# command
+proc imx6q_sabresd_init { } {
+	disable_wdog
+	apply_dcd
+}
+
+# prevent cortex-a code from asserting SRST again
+$_TARGETNAME.0 configure -event reset-assert { }
+# hook the init function into the reset-init event
+$_TARGETNAME.0 configure -event reset-init { imx6q_sabresd_init }
+# make sure target is halted when gdb attaches
+$_TARGETNAME.0 configure -event gdb-attach { halt }
+# set a slow default JTAG clock, can be overridden later
+adapter_khz 1000
diff --git a/tcl/board/lemaker_hikey.cfg b/tcl/board/lemaker_hikey.cfg
new file mode 100644
index 00000000..d7244404
--- /dev/null
+++ b/tcl/board/lemaker_hikey.cfg
@@ -0,0 +1,26 @@
+#
+# board configuration for LeMaker Hikey
+#
+
+# board does not feature anything but JTAG
+transport select jtag
+
+# SRST-only reset configuration
+reset_config srst_only srst_push_pull
+
+source [find target/hi6220.cfg]
+
+# halt the cores when gdb attaches
+${_TARGETNAME}0 configure -event gdb-attach "halt"
+
+# make sure the default target is the boot core
+targets ${_TARGETNAME}0
+
+proc core_up { args } {
+	global _TARGETNAME
+
+	# examine remaining cores
+	foreach _core [set args] {
+		${_TARGETNAME}$_core arp_examine
+	}
+}
diff --git a/tcl/board/linksys-wag200g.cfg b/tcl/board/linksys-wag200g.cfg
new file mode 100644
index 00000000..aa4887f9
--- /dev/null
+++ b/tcl/board/linksys-wag200g.cfg
@@ -0,0 +1,27 @@
+#
+# Linksys WAG200G Router
+#
+# The stock firmware Flash layout is organized as follow:
+#
+#   Start       End         Device
+#   0x90000000  0x90020000  /dev/mtdblock/2
+#   0x90020000  0x900d0000  /dev/mtdblock/1
+#   0x900d0000  0x903a0000  /dev/mtdblock/0
+#   0x903a0000  0x903e0000  /dev/mtdblock/5
+#   0x903e0000  0x903f0000  /dev/mtdblock/3
+#   0x903f0000  0x90400000  /dev/mtdblock/4
+
+set partition_list {
+    adam2	{ "Adam2 bootloader"		0x90000000 0x00020000 }
+    kernel	{ "Kernel"			0x90020000 0x000b0000 }
+    rootfs	{ "Root FS"			0x900d0000 0x002d0000 }
+    lang	{ "Minix language part"		0x903a0000 0x00040000 }
+    config	{ "Firmware config"		0x903e0000 0x00010000 }
+    adam2env	{ "Adam2 environment"		0x903f0000 0x00010000 }
+}
+
+source [find target/ti-ar7.cfg]
+
+# External 4MB MXIC 29LV320MBTC Flash (Manufacturer/Device: 0x00c2 0x227e)
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME cfi 0x90000000 0x00400000 2 2 $_TARGETNAME
diff --git a/tcl/board/marsohod.cfg b/tcl/board/marsohod.cfg
new file mode 100644
index 00000000..681f575c
--- /dev/null
+++ b/tcl/board/marsohod.cfg
@@ -0,0 +1,13 @@
+#
+# Marsohod CPLD Development and Education board
+#
+# http://marsohod.org/howtostart/plata
+#
+
+# Recommended MBFTDI programmer
+source [find interface/ftdi/mbftdi.cfg]
+adapter_khz 2000
+transport select jtag
+
+# Altera MAXII EPM240T100C CPLD
+source [find cpld/altera-epm240.cfg]
diff --git a/tcl/board/marsohod2.cfg b/tcl/board/marsohod2.cfg
new file mode 100644
index 00000000..d4897c3c
--- /dev/null
+++ b/tcl/board/marsohod2.cfg
@@ -0,0 +1,13 @@
+#
+# Marsohod2 FPGA Development and Education board
+#
+# http://www.marsohod.org/prodmarsohod2
+#
+
+# Built-in MBFTDI programmer
+source [find interface/ftdi/mbftdi.cfg]
+adapter_khz 2000
+transport select jtag
+
+# Cyclone III EP3C10E144 FPGA
+source [find fpga/altera-ep3c10.cfg]
diff --git a/tcl/board/marsohod3.cfg b/tcl/board/marsohod3.cfg
new file mode 100644
index 00000000..bb3c74f2
--- /dev/null
+++ b/tcl/board/marsohod3.cfg
@@ -0,0 +1,13 @@
+#
+# Marsohod3 FPGA Development and Education board
+#
+# http://www.marsohod.org/plata-marsokhod3
+#
+
+# Built-in MBFTDI programmer
+source [find interface/ftdi/mbftdi.cfg]
+adapter_khz 2000
+transport select jtag
+
+# MAX10 10M50SAE144C8GES FPGA
+source [find fpga/altera-10m50.cfg]
diff --git a/tcl/board/minispartan6.cfg b/tcl/board/minispartan6.cfg
new file mode 100644
index 00000000..3de9e99d
--- /dev/null
+++ b/tcl/board/minispartan6.cfg
@@ -0,0 +1,24 @@
+# https://www.scarabhardware.com/minispartan6/
+
+source [find interface/ftdi/minispartan6.cfg]
+source [find cpld/xilinx-xc6s.cfg]
+source [find cpld/jtagspi.cfg]
+
+# example command to read the device dna of the FPGA on the board;
+# openocd -f board/minispartan6.cfg -c "init;xc6s_print_dna xc6s.tap;shutdown"
+
+# example command to write bitstream
+# openocd -f board/minispartan6.cfg -c "init;\
+# jtagspi_init 0 bscan_spi_xc6slx??.bit;\
+# jtagspi_program bitstream.bin 0;\
+# xc6s_program xc6s.tap;\
+# shutdown"
+#
+# jtagspi flash procies can be found in the contrib/loaders/flash/fpga/
+# directory, with prebuilt versions available at
+# https://github.com/jordens/bscan_spi_bitstreams
+#
+# For the SLX25 variant, use
+#  - https://github.com/jordens/bscan_spi_bitstreams/raw/master/bscan_spi_xc6slx25.bit
+# For the SLX9 variant, use
+#  - https://github.com/jordens/bscan_spi_bitstreams/raw/master/bscan_spi_xc6slx9.bit
diff --git a/tcl/board/nordic_nrf51_dk.cfg b/tcl/board/nordic_nrf51_dk.cfg
new file mode 100644
index 00000000..96f5471a
--- /dev/null
+++ b/tcl/board/nordic_nrf51_dk.cfg
@@ -0,0 +1,9 @@
+#
+# Nordic Semiconductor NRF51 Development Kit (nRF6824)
+#
+
+source [find interface/jlink.cfg]
+
+transport select swd
+
+source [find target/nrf51.cfg]
diff --git a/tcl/board/nordic_nrf52_dk.cfg b/tcl/board/nordic_nrf52_dk.cfg
new file mode 100644
index 00000000..9f528669
--- /dev/null
+++ b/tcl/board/nordic_nrf52_dk.cfg
@@ -0,0 +1,9 @@
+#
+# Nordic Semiconductor NRF52 Development Kit (nRF52832)
+#
+
+source [find interface/jlink.cfg]
+
+transport select swd
+
+source [find target/nrf52.cfg]
diff --git a/tcl/board/novena-internal-fpga.cfg b/tcl/board/novena-internal-fpga.cfg
new file mode 100644
index 00000000..8d2f6a4f
--- /dev/null
+++ b/tcl/board/novena-internal-fpga.cfg
@@ -0,0 +1,24 @@
+#
+# Novena open hardware and F/OSS-friendly computing platform
+#
+# Design documentation:
+# http://www.kosagi.com/w/index.php?title=Novena_PVT_Design_Source
+#
+# +-------------+--------------+------+-------+---------+
+# | Pad name    | Schematic    | GPIO | sysfs | JTAG    |
+# +-------------+--------------+------+-------+---------+
+# | DISP0_DAT13 | FPGA_RESET_N | 5-07 |  135  | RESET_N |
+# | DISP0_DAT14 | FPGA_TCK     | 5-08 |  136  | TCK     |
+# | DISP0_DAT15 | FPGA_TDI     | 5-09 |  137  | TDI     |
+# | DISP0_DAT16 | FPGA_TDO     | 5-10 |  138  | TDO     |
+# | DISP0_DAT17 | FPGA_TMS     | 5-11 |  139  | TMS     |
+# +-------------+--------------+------+-------+---------+
+
+interface sysfsgpio
+
+transport select jtag
+
+# TCK TMS TDI TDO
+sysfsgpio_jtag_nums 136 139 137 138
+
+source [find cpld/xilinx-xc6s.cfg]
diff --git a/tcl/board/openrd.cfg b/tcl/board/openrd.cfg
index 1051c25d..db3cb032 100644
--- a/tcl/board/openrd.cfg
+++ b/tcl/board/openrd.cfg
@@ -3,6 +3,8 @@
 source [find interface/ftdi/openrd.cfg]
 source [find target/feroceon.cfg]
 
+adapter_khz 2000
+
 $_TARGETNAME configure \
 	-work-area-phys 0x10000000 \
 	-work-area-size 65536 \
diff --git a/tcl/board/quark_d2000_refboard.cfg b/tcl/board/quark_d2000_refboard.cfg
new file mode 100644
index 00000000..d1388bba
--- /dev/null
+++ b/tcl/board/quark_d2000_refboard.cfg
@@ -0,0 +1,15 @@
+# Intel Quark microcontroller D2000 Reference Board (web search for doc num 333582)
+
+# the board has an onboard FTDI FT232H chip
+interface ftdi
+ftdi_vid_pid 0x0403 0x6014
+ftdi_channel 0
+
+ftdi_layout_init 0x0000 0x030b
+ftdi_layout_signal nTRST -data 0x0100 -noe 0x0100
+
+source [find target/quark_d20xx.cfg]
+
+adapter_khz 1000
+
+reset_config trst_only
diff --git a/tcl/board/spansion_sk-fm4-176l-s6e2cc.cfg b/tcl/board/spansion_sk-fm4-176l-s6e2cc.cfg
index 4b23146f..2855c5d4 100644
--- a/tcl/board/spansion_sk-fm4-176l-s6e2cc.cfg
+++ b/tcl/board/spansion_sk-fm4-176l-s6e2cc.cfg
@@ -13,6 +13,7 @@ source [find interface/cmsis-dap.cfg]
 # FM4 S6E2CCAJ0A w/ 192 KB SRAM0
 #
 set CHIPNAME s6e2cc
+set CHIPSERIES S6E2CCAJ0A
 set WORKAREASIZE 0x30000
 source [find target/fm4_s6e2cc.cfg]
 
diff --git a/tcl/board/spansion_sk-fm4-u120-9b560.cfg b/tcl/board/spansion_sk-fm4-u120-9b560.cfg
index 64cbade3..38ad4a88 100644
--- a/tcl/board/spansion_sk-fm4-u120-9b560.cfg
+++ b/tcl/board/spansion_sk-fm4-u120-9b560.cfg
@@ -11,6 +11,7 @@
 # FM4 MB9BF568R w/ 64 KB SRAM0
 #
 set CHIPNAME mb9bf568
+set CHIPSERIES MB9BF568R
 set WORKAREASIZE 0x10000
 source [find target/fm4_mb9bf.cfg]
 
diff --git a/tcl/board/st_nucleo_f7.cfg b/tcl/board/st_nucleo_f7.cfg
new file mode 100644
index 00000000..88a8a308
--- /dev/null
+++ b/tcl/board/st_nucleo_f7.cfg
@@ -0,0 +1,10 @@
+# STMicroelectronics STM32F7 Nucleo development board
+# Known boards: NUCLEO-F746ZG and NUCLEO-F767ZI
+
+source [find interface/stlink-v2-1.cfg]
+
+transport select hla_swd
+
+source [find target/stm32f7x.cfg]
+
+reset_config srst_only
diff --git a/tcl/board/st_nucleo_l073rz.cfg b/tcl/board/st_nucleo_l073rz.cfg
new file mode 100644
index 00000000..fa9dc87c
--- /dev/null
+++ b/tcl/board/st_nucleo_l073rz.cfg
@@ -0,0 +1,12 @@
+# This is an ST NUCLEO-L073RZ board with single STM32L073RZ chip.
+# http://www.st.com/en/evaluation-tools/nucleo-l073rz.html
+source [find interface/stlink-v2-1.cfg]
+
+transport select hla_swd
+
+set WORKAREASIZE 0x2000
+
+source [find target/stm32l0_dual_bank.cfg]
+
+# There is only system reset line and JTAG/SWD command can be issued when SRST
+reset_config srst_only
diff --git a/tcl/board/st_nucleo_l476rg.cfg b/tcl/board/st_nucleo_l476rg.cfg
new file mode 100644
index 00000000..19525f5e
--- /dev/null
+++ b/tcl/board/st_nucleo_l476rg.cfg
@@ -0,0 +1,11 @@
+# This is a ST NUCLEO L476RG board with a single STM32L476RGT6 chip.
+# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF261636
+
+source [find interface/stlink-v2-1.cfg]
+
+transport select hla_swd
+
+source [find target/stm32l4x.cfg]
+
+# use hardware reset
+reset_config srst_only srst_nogate
diff --git a/tcl/board/stm32f429disc1.cfg b/tcl/board/stm32f429disc1.cfg
new file mode 100644
index 00000000..9d3cdd75
--- /dev/null
+++ b/tcl/board/stm32f429disc1.cfg
@@ -0,0 +1,12 @@
+#
+# This is an STM32F429 discovery board with a single STM32F429ZI chip.
+# http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/PF259090
+#
+
+source [find interface/stlink-v2-1.cfg]
+
+transport select hla_swd
+
+source [find target/stm32f4x.cfg]
+
+reset_config srst_only
diff --git a/tcl/board/stm32f429discovery.cfg b/tcl/board/stm32f429discovery.cfg
index eddaa9f6..e06d2a51 100644
--- a/tcl/board/stm32f429discovery.cfg
+++ b/tcl/board/stm32f429discovery.cfg
@@ -7,6 +7,9 @@ source [find interface/stlink-v2.cfg]
 
 transport select hla_swd
 
+# increase working area to 128KB
+set WORKAREASIZE 0x20000
+
 source [find target/stm32f4x.cfg]
 
 reset_config srst_only
diff --git a/tcl/board/stm32f469discovery.cfg b/tcl/board/stm32f469discovery.cfg
index eecfe339..63b13638 100644
--- a/tcl/board/stm32f469discovery.cfg
+++ b/tcl/board/stm32f469discovery.cfg
@@ -7,6 +7,9 @@ source [find interface/stlink-v2-1.cfg]
 
 transport select hla_swd
 
+# increase working area to 128KB
+set WORKAREASIZE 0x20000
+
 source [find target/stm32f4x.cfg]
 
 reset_config srst_only
diff --git a/tcl/board/stm32f4discovery.cfg b/tcl/board/stm32f4discovery.cfg
index f5b52920..963e0f95 100644
--- a/tcl/board/stm32f4discovery.cfg
+++ b/tcl/board/stm32f4discovery.cfg
@@ -5,6 +5,9 @@ source [find interface/stlink-v2.cfg]
 
 transport select hla_swd
 
+# increase working area to 64KB
+set WORKAREASIZE 0x10000
+
 source [find target/stm32f4x.cfg]
 
 reset_config srst_only
diff --git a/tcl/board/telo.cfg b/tcl/board/telo.cfg
index 126f388f..1d3afdf0 100644
--- a/tcl/board/telo.cfg
+++ b/tcl/board/telo.cfg
@@ -8,9 +8,6 @@ source [find target/c100helper.tcl]
 
 
 # Telo board & C100 support trst and srst
-# Note that libftd2xx.so tries to assert srst
-# which break this script
-# use libftdi.so library instead with this script
 # make the reset asserted to
 # allow RC circuit to discharge for: [ms]
 adapter_nsrst_assert_width 100
diff --git a/tcl/board/ti_am437x_idk.cfg b/tcl/board/ti_am437x_idk.cfg
index ce9c9a73..65e2094e 100644
--- a/tcl/board/ti_am437x_idk.cfg
+++ b/tcl/board/ti_am437x_idk.cfg
@@ -4,13 +4,9 @@
 source [find interface/ftdi/xds100v2.cfg]
 
 transport select jtag
-adapter_khz 1000
+adapter_khz 30000
 
 source [find target/am437x.cfg]
 $_TARGETNAME configure -event reset-init { init_platform 0x61a11b32 }
 
 reset_config trst_and_srst
-
-init
-ftdi_set_signal PWR_RST 1
-jtag arp_init
diff --git a/tcl/board/ti_beaglebone-base.cfg b/tcl/board/ti_beaglebone-base.cfg
new file mode 100644
index 00000000..82d3c312
--- /dev/null
+++ b/tcl/board/ti_beaglebone-base.cfg
@@ -0,0 +1,4 @@
+# AM335x Beaglebone family base configuration
+#  http://beagleboard.org/bone
+
+source [find target/am335x.cfg]
diff --git a/tcl/board/ti_beaglebone.cfg b/tcl/board/ti_beaglebone.cfg
index 5d31d1d9..c19bb577 100644
--- a/tcl/board/ti_beaglebone.cfg
+++ b/tcl/board/ti_beaglebone.cfg
@@ -6,8 +6,7 @@ source [find interface/ftdi/xds100v2.cfg]
 
 adapter_khz 16000
 
-source [find target/am335x.cfg]
-
 reset_config trst_and_srst
 
+source [find board/ti_beaglebone-base.cfg]
 
diff --git a/tcl/board/ti_beaglebone_black.cfg b/tcl/board/ti_beaglebone_black.cfg
new file mode 100644
index 00000000..79fc1e8a
--- /dev/null
+++ b/tcl/board/ti_beaglebone_black.cfg
@@ -0,0 +1,8 @@
+# AM335x Beaglebone Black
+#  http://beagleboard.org/bone
+
+adapter_khz 1000
+
+reset_config trst_and_srst
+
+source [find board/ti_beaglebone-base.cfg]
diff --git a/tcl/board/tocoding_poplar.cfg b/tcl/board/tocoding_poplar.cfg
new file mode 100644
index 00000000..fd661560
--- /dev/null
+++ b/tcl/board/tocoding_poplar.cfg
@@ -0,0 +1,28 @@
+#
+# board configuration for Tocoding Poplar
+#
+
+# board does not feature anything but JTAG
+transport select jtag
+
+adapter_khz 10000
+
+# SRST-only reset configuration
+reset_config srst_only srst_push_pull
+
+source [find tcl/target/hi3798.cfg]
+
+# halt the cores when gdb attaches
+${_TARGETNAME}0 configure -event gdb-attach "halt"
+
+# make sure the default target is the boot core
+targets ${_TARGETNAME}0
+
+proc core_up { args } {
+	global _TARGETNAME
+
+	# examine remaining cores
+	foreach _core [set args] {
+		${_TARGETNAME}$_core arp_examine
+	}
+}
diff --git a/tcl/board/tp-link_tl-mr3020.cfg b/tcl/board/tp-link_tl-mr3020.cfg
index b7d8d5b6..7e040b32 100644
--- a/tcl/board/tp-link_tl-mr3020.cfg
+++ b/tcl/board/tp-link_tl-mr3020.cfg
@@ -42,3 +42,5 @@ $_TARGETNAME configure -event reset-init {
 
 set ram_boot_address 0xa0000000
 $_TARGETNAME configure -work-area-phys 0xa1FFE000 -work-area-size 0x1000
+
+flash bank flash0 ath79 0 0 0 0 $_TARGETNAME cs0
diff --git a/tcl/board/tp-link_wdr4300.cfg b/tcl/board/tp-link_wdr4300.cfg
new file mode 100644
index 00000000..c3179162
--- /dev/null
+++ b/tcl/board/tp-link_wdr4300.cfg
@@ -0,0 +1,160 @@
+source [find target/atheros_ar9344.cfg]
+
+reset_config trst_only separate
+
+proc ar9344_40mhz_pll_init {} {
+	# QCA_PLL_SRIF_CPU_DPLL2_REG
+	mww 0xb81161C4 0x13210f00
+	# QCA_PLL_SRIF_CPU_DPLL3_REG
+	mww 0xb81161C8 0x03000000
+	# QCA_PLL_SRIF_DDR_DPLL2_REG
+	mww 0xb8116244 0x13210f00
+	# QCA_PLL_SRIF_DDR_DPLL3_REG
+	mww 0xb8116248 0x03000000
+	# QCA_PLL_SRIF_BB_DPLL_BASE_REG
+	mww 0xb8116188 0x03000000
+
+	# QCA_PLL_CPU_DDR_CLK_CTRL_REG
+	mww 0xb8050008 0x0130001C
+	mww 0xb8050008 0x0130001C
+	mww 0xb8050008 0x0130001C
+
+	# QCA_PLL_CPU_PLL_CFG_REG
+	mww 0xb8050000 0x40021380
+	# QCA_PLL_DDR_PLL_CFG_REG
+	mww 0xb8050004 0x40815800
+	# QCA_PLL_CPU_DDR_CLK_CTRL_REG
+	mww 0xb8050008 0x0130801C
+
+	# QCA_PLL_SRIF_CPU_DPLL2_REG
+	mww 0xb81161C4 0x10810F00
+	mww 0xb81161C0 0x41C00000
+	# QCA_PLL_SRIF_CPU_DPLL2_REG
+	mww 0xb81161C4 0xD0810F00
+	# QCA_PLL_SRIF_CPU_DPLL3_REG
+	mww 0xb81161C8 0x03000000
+	# QCA_PLL_SRIF_CPU_DPLL2_REG
+	mww 0xb81161C4 0xD0800F00
+
+	# QCA_PLL_SRIF_CPU_DPLL3_REG
+	mww 0xb81161C8 0x03000000
+	# QCA_PLL_SRIF_CPU_DPLL3_REG
+	mww 0xb81161C8 0x43000000
+	# QCA_PLL_SRIF_CPU_DPLL3_REG
+	mww 0xb81161C8 0x030003E8
+
+	# QCA_PLL_SRIF_DDR_DPLL2_REG
+	mww 0xb8116244 0x10810F00
+	mww 0xb8116240 0x41680000
+	# QCA_PLL_SRIF_DDR_DPLL2_REG
+	mww 0xb8116244 0xD0810F00
+	# QCA_PLL_SRIF_DDR_DPLL3_REG
+	mww 0xb8116248 0x03000000
+	# QCA_PLL_SRIF_DDR_DPLL2_REG
+	mww 0xb8116244 0xD0800F00
+
+	# QCA_PLL_SRIF_DDR_DPLL3_REG
+	mww 0xb8116248 0x03000000
+	# QCA_PLL_SRIF_DDR_DPLL3_REG
+	mww 0xb8116248 0x43000000
+	# QCA_PLL_SRIF_DDR_DPLL3_REG
+	mww 0xb8116248 0x03000718
+
+	# QCA_PLL_CPU_DDR_CLK_CTRL_REG
+	mww 0xb8050008 0x01308018
+	mww 0xb8050008 0x01308010
+	mww 0xb8050008 0x01308000
+
+	# QCA_PLL_DDR_PLL_DITHER_REG
+	mww 0xb8050044 0x78180200
+	# QCA_PLL_CPU_PLL_DITHER_REG
+	mww 0xb8050048 0x41C00000
+
+}
+
+proc ar9344_ddr_init {} {
+	# QCA_DDR_CTRL_CFG_REG
+	mww 0xb8000108 0x40
+	# QCA_DDR_RD_DATA_THIS_CYCLE_REG
+	mww 0xb8000018 0xFF
+	# QCA_DDR_BURST_REG
+	mww 0xb80000C4 0x74444444
+	# QCA_DDR_BURST2_REG
+	mww 0xb80000C8 0x0222
+	# QCA_AHB_MASTER_TOUT_MAX_REG
+	mww 0xb80000CC 0xFFFFF
+
+	# QCA_DDR_CFG_REG
+	mww 0xb8000000 0xC7D48CD0
+	# QCA_DDR_CFG2_REG
+	mww 0xb8000004 0x9DD0E6A8
+
+	# QCA_DDR_DDR2_CFG_REG
+	mww 0xb80000B8 0x0E59
+	# QCA_DDR_CFG2_REG
+	mww 0xb8000004 0x9DD0E6A8
+
+	# QCA_DDR_CTRL_REG
+	mww 0xb8000010 0x08
+	mww 0xb8000010 0x08
+	mww 0xb8000010 0x10
+	mww 0xb8000010 0x20
+	# QCA_DDR_EMR_REG
+	mww 0xb800000C 0x02
+	# QCA_DDR_CTRL_REG
+	mww 0xb8000010 0x02
+
+	# QCA_DDR_MR_REG
+	mww 0xb8000008 0x0133
+	# QCA_DDR_CTRL_REG
+	mww 0xb8000010 0x1
+	mww 0xb8000010 0x8
+	mww 0xb8000010 0x8
+	mww 0xb8000010 0x4
+	mww 0xb8000010 0x4
+
+	# QCA_DDR_MR_REG
+	mww 0xb8000008 0x33
+	# QCA_DDR_CTRL_REG
+	mww 0xb8000010 0x1
+
+	# QCA_DDR_EMR_REG
+	mww 0xb800000C 0x0382
+	# QCA_DDR_CTRL_REG
+	mww 0xb8000010 0x2
+	# QCA_DDR_EMR_REG
+	mww 0xb800000C 0x0402
+	# QCA_DDR_CTRL_REG
+	mww 0xb8000010 0x2
+
+	# QCA_DDR_REFRESH_REG
+	mww 0xb8000014 0x4270
+
+	# QCA_DDR_TAP_CTRL_0_REG
+	mww 0xb800001C 0x0e
+	# QCA_DDR_TAP_CTRL_1_REG
+	mww 0xb8000020 0x0e
+	# QCA_DDR_TAP_CTRL_2_REG
+	mww 0xb8000024 0x0e
+	# QCA_DDR_TAP_CTRL_3_REG
+	mww 0xb8000028 0x0e
+}
+
+$_TARGETNAME configure -event reset-init {
+
+	# mww 0xb806001c 0x1000000
+	ar9344_40mhz_pll_init
+	sleep 100
+
+	# flash remap
+	# SPI_CONTROL_ADDR
+	mww 0xbF000004 0x43
+
+	ar9344_ddr_init
+	sleep 100
+}
+
+set ram_boot_address 0xa0000000
+$_TARGETNAME configure -work-area-phys 0x1d000000 -work-area-size 0x1000
+
+flash bank flash0 ath79 0 0 0 0 $_TARGETNAME cs0
diff --git a/tcl/board/twr-vf65gs10.cfg b/tcl/board/twr-vf65gs10.cfg
new file mode 100644
index 00000000..a80407f3
--- /dev/null
+++ b/tcl/board/twr-vf65gs10.cfg
@@ -0,0 +1,201 @@
+#
+# Board configuration file for the Freescale VF65GS10 tower board
+#
+# Board has a 20 pin Cortex+ETM debug connector with only nSRST available
+reset_config srst_only
+
+# This configuration file only deals with the hardware JTAG.
+# There is has also an embedded Kinetis K20 with OpenSDA
+# where a CMSIS-DAP application can be installed.
+
+# Source generic VF6xx target configuration
+source [find target/vybrid_vf6xx.cfg]
+
+# basic DDR memory init, setting up pad configuration
+# for DDR first then configuring the DDRMC for the
+# board
+proc ddr_init { } {
+	# iomux ddr
+	mww phys 0x40048220 0x00000180
+	mww phys 0x40048224 0x00000180
+	mww phys 0x40048228 0x00000180
+	mww phys 0x4004822c 0x00000180
+	mww phys 0x40048230 0x00000180
+	mww phys 0x40048234 0x00000180
+	mww phys 0x40048238 0x00000180
+	mww phys 0x4004823c 0x00000180
+	mww phys 0x40048240 0x00000180
+	mww phys 0x40048244 0x00000180
+	mww phys 0x40048248 0x00000180
+	mww phys 0x4004824c 0x00000180
+	mww phys 0x40048250 0x00000180
+	mww phys 0x40048254 0x00000180
+	mww phys 0x40048258 0x00000180
+	mww phys 0x4004825c 0x00000180
+	mww phys 0x40048260 0x00000180
+	mww phys 0x40048264 0x00000180
+	mww phys 0x40048268 0x00000180
+	mww phys 0x4004826c 0x00000180
+	mww phys 0x40048270 0x00000180
+	mww phys 0x40048274 0x00000180
+	mww phys 0x40048278 0x00000180
+	mww phys 0x4004827c 0x00010180
+	mww phys 0x40048280 0x00010180
+	mww phys 0x40048284 0x00010180
+	mww phys 0x40048288 0x00010180
+	mww phys 0x4004828c 0x00010180
+	mww phys 0x40048290 0x00010180
+	mww phys 0x40048294 0x00010180
+	mww phys 0x40048298 0x00010180
+	mww phys 0x4004829c 0x00010180
+	mww phys 0x400482a0 0x00010180
+	mww phys 0x400482a4 0x00010180
+	mww phys 0x400482a8 0x00010180
+	mww phys 0x400482ac 0x00010180
+	mww phys 0x400482b0 0x00010180
+	mww phys 0x400482b4 0x00010180
+	mww phys 0x400482b8 0x00010180
+	mww phys 0x400482bc 0x00010180
+	mww phys 0x400482c0 0x00010180
+	mww phys 0x400482c4 0x00010180
+	mww phys 0x400482c8 0x00010180
+	mww phys 0x400482cc 0x00000180
+	mww phys 0x400482d0 0x00000180
+	mww phys 0x400482d4 0x00000180
+	mww phys 0x400482d8 0x00000180
+	mww phys 0x4004821c 0x000001a0
+	# ddr_ctrl_init
+	mww phys 0x400ae000 0x00000600
+	mww phys 0x400ae008 0x00000020
+	mww phys 0x400ae028 0x00013880
+	mww phys 0x400ae02c 0x00030d40
+	mww phys 0x400ae030 0x0000050c
+	mww phys 0x400ae034 0x15040400
+	mww phys 0x400ae038 0x1406040f
+	mww phys 0x400ae040 0x04040000
+	mww phys 0x400ae044 0x006db00c
+	mww phys 0x400ae048 0x00000403
+	mww phys 0x400ae050 0x01000000
+	mww phys 0x400ae054 0x00060001
+	mww phys 0x400ae058 0x000c0000
+	mww phys 0x400ae05c 0x03000200
+	mww phys 0x400ae060 0x00000006
+	mww phys 0x400ae064 0x00010000
+	mww phys 0x400ae068 0x0c30002c
+	mww phys 0x400ae070 0x00000000
+	mww phys 0x400ae074 0x00000003
+	mww phys 0x400ae078 0x0000000a
+	mww phys 0x400ae07c 0x003001d4
+	mww phys 0x400ae084 0x00010000
+	mww phys 0x400ae088 0x00050500
+	mww phys 0x400ae098 0x00000000
+	mww phys 0x400ae09c 0x04001002
+	mww phys 0x400ae0a4 0x00000001
+	mww phys 0x400ae0c0 0x00460420
+	mww phys 0x400ae108 0x01000200
+	mww phys 0x400ae10c 0x00000040
+	mww phys 0x400ae114 0x00000200
+	mww phys 0x400ae118 0x00000040
+	mww phys 0x400ae120 0x00000000
+	mww phys 0x400ae124 0x0a010300
+	mww phys 0x400ae128 0x01014040
+	mww phys 0x400ae12c 0x01010101
+	mww phys 0x400ae130 0x03030100
+	mww phys 0x400ae134 0x01000101
+	mww phys 0x400ae138 0x0700000c
+	mww phys 0x400ae13c 0x00000000
+	mww phys 0x400ae148 0x10000000
+	mww phys 0x400ae15c 0x01000000
+	mww phys 0x400ae160 0x00040000
+	mww phys 0x400ae164 0x00000002
+	mww phys 0x400ae16c 0x00020000
+	mww phys 0x400ae180 0x00002819
+	mww phys 0x400ae184 0x01000000
+	mww phys 0x400ae188 0x00000000
+	mww phys 0x400ae18c 0x00000000
+	mww phys 0x400ae198 0x00000000
+	mww phys 0x400ae1a4 0x00000c00
+	mww phys 0x400ae1a8 0x00000000
+	mww phys 0x400ae1b8 0x0000000c
+	mww phys 0x400ae1c8 0x00000000
+	mww phys 0x400ae1cc 0x00000000
+	mww phys 0x400ae1d4 0x00000000
+	mww phys 0x400ae1d8 0x01010000
+	mww phys 0x400ae1e0 0x02020000
+	mww phys 0x400ae1e4 0x00000202
+	mww phys 0x400ae1e8 0x01010064
+	mww phys 0x400ae1ec 0x00010101
+	mww phys 0x400ae1f0 0x00000064
+	mww phys 0x400ae1f8 0x00000800
+	mww phys 0x400ae210 0x00000506
+	mww phys 0x400ae224 0x00020000
+	mww phys 0x400ae228 0x01000000
+	mww phys 0x400ae22c 0x04070303
+	mww phys 0x400ae230 0x00000040
+	mww phys 0x400ae23c 0x06000080
+	mww phys 0x400ae240 0x04070303
+	mww phys 0x400ae244 0x00000040
+	mww phys 0x400ae248 0x00000040
+	mww phys 0x400ae24c 0x000f0000
+	mww phys 0x400ae250 0x000f0000
+	mww phys 0x400ae25c 0x00000101
+	mww phys 0x400ae268 0x682c4000
+	mww phys 0x400ae26c 0x00000012
+	mww phys 0x400ae278 0x00000006
+	mww phys 0x400ae284 0x00010202
+	mww phys 0x400ae400 0x00002613
+	mww phys 0x400ae440 0x00002613
+	mww phys 0x400ae404 0x00002615
+	mww phys 0x400ae444 0x00002615
+	mww phys 0x400ae408 0x00210000
+	mww phys 0x400ae448 0x00210000
+	mww phys 0x400ae488 0x00210000
+	mww phys 0x400ae40c 0x0001012a
+	mww phys 0x400ae44c 0x0001012a
+	mww phys 0x400ae48c 0x0001012a
+	mww phys 0x400ae410 0x00002400
+	mww phys 0x400ae450 0x00002400
+	mww phys 0x400ae490 0x00002400
+	mww phys 0x400ae4c4 0x00000000
+	mww phys 0x400ae4c8 0x00001100
+	mww phys 0x400ae4d0 0x00010101
+	mww phys 0x400ae000 0x00000601
+}
+
+# clock control init, setting up basic
+# clocks
+proc clock_init { } {
+	# captured from u-boot
+	mww phys 0x4006b040 0xffffffff
+	mww phys 0x4006b044 0xffffffff
+	mww phys 0x4006b048 0xffffffff
+	mww phys 0x4006b04c 0xffffffff
+	mww phys 0x4006b050 0xffffffff
+	mww phys 0x4006b058 0xffffffff
+	mww phys 0x4006b05c 0xffffffff
+	mww phys 0x4006b060 0xffffffff
+	mww phys 0x4006b064 0xffffffff
+	mww phys 0x4006b068 0xffffffff
+	mww phys 0x40050030 0x00002001
+	mww phys 0x40050270 0x80002001
+	mww phys 0x4006b000 0x00011005
+	mww phys 0x4006b008 0x0001ff24
+	mww phys 0x4006b00c 0x00000810
+	mww phys 0x4006b010 0x00cc0000
+	mww phys 0x4006b014 0x01000000
+	mww phys 0x4006b018 0x20000000
+	mww phys 0x4006b01c 0x0000001f
+	mww phys 0x4006b020 0x00000000
+}
+
+# This function applies the initial configuration after a "reset init"
+# command
+proc board_init { } {
+	clock_init
+	ddr_init
+}
+
+# hook the init function into the reset-init event
+${_TARGETNAME}0 configure -event reset-init { board_init }
+# set a slow default JTAG clock, can be overridden later
+adapter_khz 1000
diff --git a/tcl/board/twr-vf65gs10_cmsisdap.cfg b/tcl/board/twr-vf65gs10_cmsisdap.cfg
new file mode 100644
index 00000000..e8db7549
--- /dev/null
+++ b/tcl/board/twr-vf65gs10_cmsisdap.cfg
@@ -0,0 +1,15 @@
+#
+# Board configuration file for the Freescale VF65GS10 tower board
+#
+# CMSIS-DAP via USB-OTG connector
+#
+source [find interface/cmsis-dap.cfg]
+
+# only SWD is supported by the CMSIS-DAP on this board
+transport select swd
+
+# Source generic part of twr-vf65gs10 configuration
+source [find board/twr-vf65gs10.cfg]
+
+# override reset configuration
+reset_config srst_only
\ No newline at end of file
diff --git a/tcl/board/xmc-2go.cfg b/tcl/board/xmc-2go.cfg
index 66442630..90dbf436 100644
--- a/tcl/board/xmc-2go.cfg
+++ b/tcl/board/xmc-2go.cfg
@@ -9,6 +9,7 @@ source [find interface/jlink.cfg]
 transport select swd
 
 set CHIPNAME xmc1100
+set WORKAREASIZE 0x4000
 source [find target/xmc1xxx.cfg]
 
 reset_config srst_only srst_nogate
diff --git a/tcl/board/xmc1100-boot-kit.cfg b/tcl/board/xmc1100-boot-kit.cfg
index 4c83fd3a..5e7c6073 100644
--- a/tcl/board/xmc1100-boot-kit.cfg
+++ b/tcl/board/xmc1100-boot-kit.cfg
@@ -9,6 +9,7 @@ source [find interface/jlink.cfg]
 transport select swd
 
 set CHIPNAME xmc1100
+set WORKAREASIZE 0x4000
 source [find target/xmc1xxx.cfg]
 
 reset_config srst_only srst_nogate
diff --git a/tcl/board/xmc4300-relax.cfg b/tcl/board/xmc4300-relax.cfg
new file mode 100644
index 00000000..bb46ccfd
--- /dev/null
+++ b/tcl/board/xmc4300-relax.cfg
@@ -0,0 +1,12 @@
+#
+# Infineon XMC4300 Relax EtherCAT Kit
+#
+
+#
+# Segger J-Link Lite XMC4200 on-board
+#
+source [find interface/jlink.cfg]
+transport select swd
+
+set CHIPNAME xmc4300
+source [find target/xmc4xxx.cfg]
diff --git a/tcl/board/xmc4500-application-kit-sdram.cfg b/tcl/board/xmc4500-application-kit-sdram.cfg
index f3d88259..fe44d01a 100644
--- a/tcl/board/xmc4500-application-kit-sdram.cfg
+++ b/tcl/board/xmc4500-application-kit-sdram.cfg
@@ -8,5 +8,3 @@
 
 set CHIPNAME xmc4500
 source [find target/xmc4xxx.cfg]
-
-reset_config srst_only
diff --git a/tcl/cpld/altera-5m570z-cpld.cfg b/tcl/cpld/altera-5m570z-cpld.cfg
new file mode 100644
index 00000000..22a422c4
--- /dev/null
+++ b/tcl/cpld/altera-5m570z-cpld.cfg
@@ -0,0 +1,6 @@
+# Altera MAXV 5M24OZ/5M570Z CPLD
+# see MAX V Device Handbook
+# Table 6-3: 32-Bit MAX V Device IDCODE
+# Version     Part Number             Manuf. ID        LSB
+# 0000        0010 0000 1010 0111     000 0110 1110    1
+jtag newtap 5m570z tap -expected-id 0x020a60dd -irlen 10
diff --git a/tcl/cpld/altera-epm240.cfg b/tcl/cpld/altera-epm240.cfg
new file mode 100644
index 00000000..62f2b73b
--- /dev/null
+++ b/tcl/cpld/altera-epm240.cfg
@@ -0,0 +1,6 @@
+# Altera MAXII EPM240T100C CPLD
+# see MAX II Device Handbook
+# Table 3-3: 32-Bit MAX II Device IDCODE
+# Version     Part Number             Manuf. ID        LSB
+# 0000        0010 0000 1010 0001     000 0110 1110    1
+jtag newtap epm240 tap -expected-id 0x020a10dd -irlen 10
diff --git a/tcl/cpld/xilinx-xc7.cfg b/tcl/cpld/xilinx-xc7.cfg
index 5c5b0232..d5824f8a 100644
--- a/tcl/cpld/xilinx-xc7.cfg
+++ b/tcl/cpld/xilinx-xc7.cfg
@@ -9,7 +9,7 @@ if { [info exists CHIPNAME] } {
 
 # the 4 top bits (28:31) are the die stepping/revisions. ignore it.
 jtag newtap $_CHIPNAME tap -irlen 6 -ignore-version \
-	-expected-id 0x0362D093 \
+	-expected-id 0x0362E093 \
 	-expected-id 0x0362D093 \
 	-expected-id 0x0362C093 \
 	-expected-id 0x03632093 \
diff --git a/tcl/fpga/altera-10m50.cfg b/tcl/fpga/altera-10m50.cfg
new file mode 100644
index 00000000..9d00daa8
--- /dev/null
+++ b/tcl/fpga/altera-10m50.cfg
@@ -0,0 +1,6 @@
+# Altera MAX10 10M50SAE144C8GES FPGA
+# see MAX 10 FPGA Device Architecture
+# Table 3-1: IDCODE Information for MAX 10 Devices
+# Version     Part Number             Manuf. ID        LSB
+# 0000        0011 0001 1000 0101     000 0110 1110    1
+jtag newtap 10m50 tap -expected-id 0x031850dd -irlen 10
diff --git a/tcl/interface/axm0432.cfg b/tcl/interface/axm0432.cfg
deleted file mode 100644
index d2a2aaa8..00000000
--- a/tcl/interface/axm0432.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Axiom axm0432
-#
-# http://www.axman.com
-#
-
-interface ft2232
-ft2232_device_desc "Symphony SoundBite"
-ft2232_layout "axm0432_jtag"
-ft2232_vid_pid 0x0403 0x6010
-
diff --git a/tcl/interface/busblaster.cfg b/tcl/interface/busblaster.cfg
deleted file mode 100644
index f87a482e..00000000
--- a/tcl/interface/busblaster.cfg
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-# Dangerous Prototypes - Bus Blaster
-#
-# The Bus Blaster has a configurable buffer between the FTDI FT2232H and the
-# JTAG header which allows it to emulate various debugger types. It comes
-# configured as a JTAGkey device.
-#
-# http://dangerousprototypes.com/docs/Bus_Blaster
-#
-
-interface ft2232
-ft2232_device_desc "Dual RS232-HS"
-ft2232_layout jtagkey
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/calao-usb-a9260-c01.cfg b/tcl/interface/calao-usb-a9260-c01.cfg
deleted file mode 100644
index c6606710..00000000
--- a/tcl/interface/calao-usb-a9260-c01.cfg
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# CALAO Systems USB-A9260-C01
-#
-# http://www.calao-systems.com/
-#
-
-interface ft2232
-ft2232_layout jtagkey
-ft2232_device_desc "USB-A9260"
-ft2232_vid_pid 0x0403 0x6010
-script interface/calao-usb-a9260.cfg
-script target/at91sam9260minimal.cfg
-
diff --git a/tcl/interface/calao-usb-a9260-c02.cfg b/tcl/interface/calao-usb-a9260-c02.cfg
deleted file mode 100644
index 2461b70d..00000000
--- a/tcl/interface/calao-usb-a9260-c02.cfg
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# CALAO Systems USB-A9260-C02
-#
-# http://www.calao-systems.com/
-#
-
-interface ft2232
-ft2232_layout jtagkey
-ft2232_device_desc "USB-A9260"
-ft2232_vid_pid 0x0403 0x6001
-script interface/calao-usb-a9260.cfg
-script target/at91sam9260minimal.cfg
-
diff --git a/tcl/interface/cortino.cfg b/tcl/interface/cortino.cfg
deleted file mode 100644
index e2b23011..00000000
--- a/tcl/interface/cortino.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hitex Cortino
-#
-# http://www.hitex.com/index.php?id=cortino
-#
-
-interface ft2232
-ft2232_device_desc "Cortino"
-ft2232_layout cortino
-ft2232_vid_pid 0x0640 0x0032
-
diff --git a/tcl/interface/digilent-hs1.cfg b/tcl/interface/digilent-hs1.cfg
deleted file mode 100644
index e35f0cfc..00000000
--- a/tcl/interface/digilent-hs1.cfg
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# Digilent HS1
-#
-# The Digilent HS1 is a high-speed FT2232H-based adapter, compliant with the
-# Xilinx JTAG 14-pin pinout.
-# It does not support ARM reset signals (SRST and TRST) but can still be used for
-# hardware debugging, with some limitations.
-#
-# http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,395,922&Prod=JTAG-HS1
-#
-
-interface ft2232
-ft2232_device_desc "Digilent Adept USB Device"
-ft2232_layout digilent-hs1
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/dlp-usb1232h.cfg b/tcl/interface/dlp-usb1232h.cfg
deleted file mode 100644
index 74324138..00000000
--- a/tcl/interface/dlp-usb1232h.cfg
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-# DLP Design DLP-USB1232H USB-to-UART/FIFO interface module
-#
-# http://www.dlpdesign.com/usb/usb1232h.shtml
-#
-# Schematics for OpenOCD usage:
-# http://randomprojects.org/wiki/DLP-USB1232H_and_OpenOCD_based_JTAG_adapter
-#
-
-interface ft2232
-ft2232_device_desc "Dual RS232-HS"
-ft2232_layout usbjtag
-ft2232_vid_pid 0x0403 0x6010
-
diff --git a/tcl/interface/flossjtag-noeeprom.cfg b/tcl/interface/flossjtag-noeeprom.cfg
deleted file mode 100644
index 66c010bc..00000000
--- a/tcl/interface/flossjtag-noeeprom.cfg
+++ /dev/null
@@ -1,19 +0,0 @@
-#
-# FlossJTAG
-#
-# http://github.com/esden/floss-jtag
-#
-# This is the pre v0.3 Floss-JTAG compatible config file. It can also be used
-# for newer versions of Floss-JTAG with empty or not populated EEPROM. If you
-# have several Floss-JTAG connected you have to use the USB ID to select a
-# specific one.
-#
-# If you have a Floss-JTAG WITH EEPROM that is programmed, use the
-# flossjtag.cfg file.
-#
-
-interface ft2232
-ft2232_vid_pid 0x0403 0x6010
-ft2232_device_desc "Dual RS232-HS"
-ft2232_layout "usbjtag"
-ft2232_latency 2
diff --git a/tcl/interface/flossjtag.cfg b/tcl/interface/flossjtag.cfg
deleted file mode 100644
index fbbabc10..00000000
--- a/tcl/interface/flossjtag.cfg
+++ /dev/null
@@ -1,20 +0,0 @@
-#
-# FlossJTAG
-#
-# http://github.com/esden/floss-jtag
-#
-# This is the v0.3 and v1.0 Floss-JTAG compatible config file. It relies on the
-# existence of an EEPROM on Floss-JTAG containing a name. If you have several
-# Floss-JTAG adapters connected you can use the serial number to select a
-# specific device.
-#
-# If your Floss-JTAG does not have an EEPROM, or the EEPROM is empty, use the
-# flossjtag-noeeprom.cfg file.
-#
-
-interface ft2232
-ft2232_vid_pid 0x0403 0x6010
-ft2232_device_desc "FLOSS-JTAG"
-#ft2232_serial "FJ000001"
-ft2232_layout "flossjtag"
-ft2232_latency 2
diff --git a/tcl/interface/flyswatter.cfg b/tcl/interface/flyswatter.cfg
deleted file mode 100644
index 5bac05b6..00000000
--- a/tcl/interface/flyswatter.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# TinCanTools Flyswatter
-#
-# http://www.tincantools.com/product.php?productid=16134
-#
-
-interface ft2232
-ft2232_device_desc "Flyswatter"
-ft2232_layout "flyswatter"
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/flyswatter2.cfg b/tcl/interface/flyswatter2.cfg
deleted file mode 100644
index 21e7fedc..00000000
--- a/tcl/interface/flyswatter2.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# TinCanTools Flyswatter 2
-#
-# http://www.tincantools.com/product.php?productid=16153
-#
-
-interface ft2232
-ft2232_device_desc "Flyswatter2"
-ft2232_layout "flyswatter2"
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/ftdi/digilent-hs2.cfg b/tcl/interface/ftdi/digilent-hs2.cfg
new file mode 100644
index 00000000..2005b66a
--- /dev/null
+++ b/tcl/interface/ftdi/digilent-hs2.cfg
@@ -0,0 +1,10 @@
+# this supports JTAG-HS2 (and apparently Nexys4 as well)
+
+interface ftdi
+ftdi_device_desc "Digilent Adept USB Device"
+ftdi_vid_pid 0x0403 0x6014
+
+ftdi_channel 0
+ftdi_layout_init 0x00e8 0x60eb
+
+reset_config none
diff --git a/tcl/interface/ftdi/incircuit-icprog.cfg b/tcl/interface/ftdi/incircuit-icprog.cfg
new file mode 100644
index 00000000..5e90a703
--- /dev/null
+++ b/tcl/interface/ftdi/incircuit-icprog.cfg
@@ -0,0 +1,14 @@
+#
+# In-Circuit's ICprog OpenOCD JTAG Adapter
+# https://shop.in-circuit.de/product_info.php?products_id=112
+#
+# Schematics available at
+# http://wiki.in-circuit.de/images/0/06/610000158A_openocd.pdf
+#
+
+interface ftdi
+ftdi_vid_pid 0x0403 0x6010
+
+ftdi_layout_init 0x0508 0x0f1b
+ftdi_layout_signal nSRST -noe 0x0400 -data 0x0800
+ftdi_layout_signal nTRST -noe 0x0100 -data 0x0200
diff --git a/tcl/interface/ftdi/mbftdi.cfg b/tcl/interface/ftdi/mbftdi.cfg
new file mode 100644
index 00000000..d051cccb
--- /dev/null
+++ b/tcl/interface/ftdi/mbftdi.cfg
@@ -0,0 +1,16 @@
+#
+# MBFTDI
+#
+# http://www.marsohod.org/prodmbftdi
+#
+# Also the Marsohod2 and the Marsohod3 boards
+# include a built-in MBFTDI for FPGA programming.
+# See http://www.marsohod.org/prodmarsohod2
+# and http://www.marsohod.org/plata-marsokhod3 for details.
+#
+
+interface ftdi
+ftdi_device_desc "Dual RS232-HS"
+ftdi_vid_pid 0x0403 0x6010
+
+ftdi_layout_init 0x0008 0x000b
diff --git a/tcl/interface/ftdi/minimodule.cfg b/tcl/interface/ftdi/minimodule.cfg
index 57249dfc..7df096d9 100644
--- a/tcl/interface/ftdi/minimodule.cfg
+++ b/tcl/interface/ftdi/minimodule.cfg
@@ -4,14 +4,13 @@
 # http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf
 #
 
-echo "WARNING!"
-echo "This file was not tested with real interface, it is based on code in ft2232.c."
-echo "Please report your experience with this file to openocd-devel mailing list,"
-echo "so it could be marked as working or fixed."
-
 interface ftdi
 ftdi_device_desc "FT2232H MiniModule"
 ftdi_vid_pid 0x0403 0x6010
 
-ftdi_layout_init 0x0018 0x05fb
-ftdi_layout_signal nSRST -data 0x0020
+# Every pin set as high impedance except TCK, TDI, TDO and TMS
+ftdi_layout_init 0x0008 0x000b
+
+# nSRST defined on pin CN2-13 of the MiniModule (pin ADBUS5 [AD5] on the FT2232H chip)
+# This choice is arbitrary. Use other GPIO pin if desired.
+ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020
diff --git a/tcl/interface/ftdi/minispartan6.cfg b/tcl/interface/ftdi/minispartan6.cfg
new file mode 100644
index 00000000..8f160119
--- /dev/null
+++ b/tcl/interface/ftdi/minispartan6.cfg
@@ -0,0 +1,15 @@
+# https://www.scarabhardware.com/minispartan6/
+# https://github.com/scarabhardware/miniSpartan6-plus/raw/master/miniSpartan6%2B_Rev_B.pdf
+interface ftdi
+# The miniSpartan6+ sadly doesn't have a custom device description, so we just
+# have to hope you got it right.
+#ftdi_device_desc "Dual RS232-HS"
+ftdi_vid_pid 0x0403 0x6010
+# interface 1 is the uart
+ftdi_channel 0
+# just TCK TDI TDO TMS, no reset
+ftdi_layout_init 0x0008 0x000b
+reset_config none
+# this generally works fast: the fpga can handle 30MHz, the spi flash can handle
+# 54MHz with simple read, no dummy cycles, and wait-for-write-completion
+adapter_khz 30000
diff --git a/tcl/interface/ftdi/openrd.cfg b/tcl/interface/ftdi/openrd.cfg
index 8c1a8059..9ec5b5f6 100644
--- a/tcl/interface/ftdi/openrd.cfg
+++ b/tcl/interface/ftdi/openrd.cfg
@@ -4,15 +4,10 @@
 # http://www.marvell.com/products/embedded_processors/developer/kirkwood/openrd.jsp
 #
 
-echo "WARNING!"
-echo "This file was not tested with real interface, it is based on code in ft2232.c."
-echo "Please report your experience with this file to openocd-devel mailing list,"
-echo "so it could be marked as working or fixed."
-
 interface ftdi
-ftdi_device_desc "OpenRD JTAGKey FT2232D"
+ftdi_device_desc "OpenRD JTAGKey FT2232D B"
 ftdi_vid_pid 0x0403 0x9e90
-ftdi_channel 1
+ftdi_channel 0
 
 ftdi_layout_init 0x0608 0x0f1b
 ftdi_layout_signal nTRST -data 0x0200
diff --git a/tcl/interface/ftdi/sheevaplug.cfg b/tcl/interface/ftdi/sheevaplug.cfg
index f299f27a..625aad39 100644
--- a/tcl/interface/ftdi/sheevaplug.cfg
+++ b/tcl/interface/ftdi/sheevaplug.cfg
@@ -7,7 +7,7 @@
 interface ftdi
 ftdi_device_desc "SheevaPlug JTAGKey FT2232D B"
 ftdi_vid_pid 0x9e88 0x9e8f
-ftdi_channel 1
+ftdi_channel 0
 
 ftdi_layout_init 0x0608 0x0f1b
 ftdi_layout_signal nTRST -data 0x0200
diff --git a/tcl/interface/ftdi/xds100v3.cfg b/tcl/interface/ftdi/xds100v3.cfg
new file mode 100644
index 00000000..6c705823
--- /dev/null
+++ b/tcl/interface/ftdi/xds100v3.cfg
@@ -0,0 +1,11 @@
+#
+# Texas Instruments XDS100 ver 3.0
+#
+# http://processors.wiki.ti.com/index.php/XDS100
+#
+
+# Version 3.0 is the same as 2.0 as far as OpenOCD is concerned
+source [find interface/ftdi/xds100v2.cfg]
+
+# The USB ids are different.
+ftdi_vid_pid 0x0403 0xa6d1
diff --git a/tcl/interface/hilscher_nxhx10_etm.cfg b/tcl/interface/hilscher_nxhx10_etm.cfg
deleted file mode 100644
index b16ed1a5..00000000
--- a/tcl/interface/hilscher_nxhx10_etm.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hilscher NXHX 10-ETM
-#
-# http://de.hilscher.com/products_details_hardware.html?p_id=P_4ce145a5983e6
-#
-
-interface ft2232
-ft2232_device_desc "NXHX 10-ETM"
-ft2232_layout comstick
-ft2232_vid_pid 0x0640 0x0028
-adapter_khz 6000
diff --git a/tcl/interface/hilscher_nxhx500_etm.cfg b/tcl/interface/hilscher_nxhx500_etm.cfg
deleted file mode 100644
index 840ffaf6..00000000
--- a/tcl/interface/hilscher_nxhx500_etm.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hilscher NXHX 500-ETM
-#
-# http://de.hilscher.com/files_design/8/NXHX500-ETM_description_Rev01_EN.pdf
-#
-
-interface ft2232
-ft2232_device_desc "NXHX 500-ETM"
-ft2232_layout comstick
-ft2232_vid_pid 0x0640 0x0028
-adapter_khz 6000
diff --git a/tcl/interface/hilscher_nxhx500_re.cfg b/tcl/interface/hilscher_nxhx500_re.cfg
deleted file mode 100644
index 1d1b7542..00000000
--- a/tcl/interface/hilscher_nxhx500_re.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hilscher NXHX 500-RE
-#
-# http://de.hilscher.com/products_details_hardware.html?p_id=P_461ff2053bad1&bs=20
-#
-
-interface ft2232
-ft2232_device_desc "NXHX 500-RE"
-ft2232_layout comstick
-ft2232_vid_pid 0x0640 0x0028
-adapter_khz 6000
diff --git a/tcl/interface/hilscher_nxhx50_etm.cfg b/tcl/interface/hilscher_nxhx50_etm.cfg
deleted file mode 100644
index ff98c280..00000000
--- a/tcl/interface/hilscher_nxhx50_etm.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hilscher NXHX 50-ETM
-#
-# http://de.hilscher.com/files_design/8/NXHX50-ETM_description_Rev01_EN.pdf
-#
-
-interface ft2232
-ft2232_device_desc "NXHX 50-ETM"
-ft2232_layout comstick
-ft2232_vid_pid 0x0640 0x0028
-adapter_khz 6000
diff --git a/tcl/interface/hilscher_nxhx50_re.cfg b/tcl/interface/hilscher_nxhx50_re.cfg
deleted file mode 100644
index 0573e031..00000000
--- a/tcl/interface/hilscher_nxhx50_re.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hilscher NXHX 50-RE
-#
-# http://de.hilscher.com/products_details_hardware.html?p_id=P_483c0f582ad36&bs=20
-#
-
-interface ft2232
-ft2232_device_desc "NXHX50-RE"
-ft2232_layout comstick
-ft2232_vid_pid 0x0640 0x0028
-adapter_khz 6000
diff --git a/tcl/interface/hitex_str9-comstick.cfg b/tcl/interface/hitex_str9-comstick.cfg
deleted file mode 100644
index a38be78a..00000000
--- a/tcl/interface/hitex_str9-comstick.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hitex STR9-comStick
-#
-# http://www.hitex.com/index.php?id=383
-#
-
-interface ft2232
-ft2232_device_desc "STR9-comStick"
-ft2232_layout comstick
-ft2232_vid_pid 0x0640 0x002c
-
diff --git a/tcl/interface/icebear.cfg b/tcl/interface/icebear.cfg
deleted file mode 100644
index 88b5e36a..00000000
--- a/tcl/interface/icebear.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Section5 ICEBear
-#
-# http://section5.ch/icebear
-#
-
-interface ft2232
-ft2232_device_desc "ICEbear JTAG adapter"
-ft2232_layout icebear
-ft2232_vid_pid 0x0403 0xc140
-
diff --git a/tcl/interface/imx-native.cfg b/tcl/interface/imx-native.cfg
new file mode 100644
index 00000000..c2f80eb5
--- /dev/null
+++ b/tcl/interface/imx-native.cfg
@@ -0,0 +1,35 @@
+#
+# Config for using NXP IMX CPU
+#
+# This is best used with a fast enough buffer but also
+# is suitable for direct connection if the target voltage
+# matches to host voltage and the cable is short enough.
+#
+#
+
+interface imx_gpio
+
+# For most IMX processors 0x0209c000
+imx_gpio_peripheral_base 0x0209c000
+
+# Transition delay calculation: SPEED_COEFF/khz - SPEED_OFFSET
+# These depend on system clock, calibrated for IMX6UL@528MHz
+# imx_gpio_speed SPEED_COEFF SPEED_OFFSET
+imx_gpio_speed_coeffs 50000 50
+
+# Each of the JTAG lines need a gpio number set: tck tms tdi tdo.
+# Example configuration:
+# imx_gpio_jtag_nums 6 7 8 9
+
+# SWD interface pins: swclk swdio
+# Example configuration:
+imx_gpio_swd_nums 1 6
+
+# imx_gpio_trst_num 10
+# reset_config trst_only
+
+# imx_gpio_srst_num 11
+# reset_config srst_only srst_push_pull
+
+# or if you have both connected,
+# reset_config trst_and_srst srst_push_pull
\ No newline at end of file
diff --git a/tcl/interface/jlink.cfg b/tcl/interface/jlink.cfg
index 3d83362a..a4f9dddd 100644
--- a/tcl/interface/jlink.cfg
+++ b/tcl/interface/jlink.cfg
@@ -1,19 +1,14 @@
 #
-# Segger J-Link
+# SEGGER J-Link
 #
 # http://www.segger.com/jlink.html
 #
 
 interface jlink
 
-
-# The serial number can be used to select a specific interface in case more than one
-# is connected to the host.
-#
-# Segger software omits leading zeros in serial number displays,
-# OpenOCD requires them.
+# The serial number can be used to select a specific device in case more than
+# one is connected to the host.
 #
-# Example: Select J-Link with serial 123456789
+# Example: Select J-Link with serial number 123456789
 #
-# jlink serial 000123456789
-
+# jlink serial 123456789
diff --git a/tcl/interface/jtag-lock-pick_tiny_2.cfg b/tcl/interface/jtag-lock-pick_tiny_2.cfg
deleted file mode 100644
index 539f0f99..00000000
--- a/tcl/interface/jtag-lock-pick_tiny_2.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# DISTORTEC JTAG-lock-pick Tiny 2
-#
-# http://www.distortec.com
-#
-
-interface ft2232
-ft2232_device_desc "JTAG-lock-pick Tiny 2"
-ft2232_layout ktlink
-ft2232_vid_pid 0x0403 0x8220
diff --git a/tcl/interface/jtagkey-tiny.cfg b/tcl/interface/jtagkey-tiny.cfg
deleted file mode 100644
index 633fdda8..00000000
--- a/tcl/interface/jtagkey-tiny.cfg
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# Amontec JTAGkey-tiny
-#
-# http://www.amontec.com/jtagkey-tiny.shtml
-#
-
-# The JTAGkey-tiny uses exactly the same config as the JTAGkey.
-source [find interface/jtagkey.cfg]
-
diff --git a/tcl/interface/jtagkey.cfg b/tcl/interface/jtagkey.cfg
deleted file mode 100644
index ca45dfcf..00000000
--- a/tcl/interface/jtagkey.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Amontec JTAGkey
-#
-# http://www.amontec.com/jtagkey.shtml
-#
-
-interface ft2232
-ft2232_device_desc "Amontec JTAGkey"
-ft2232_layout jtagkey
-ft2232_vid_pid 0x0403 0xcff8
-
diff --git a/tcl/interface/jtagkey2.cfg b/tcl/interface/jtagkey2.cfg
deleted file mode 100644
index 40a0b0db..00000000
--- a/tcl/interface/jtagkey2.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Amontec JTAGkey2
-#
-# http://www.amontec.com/jtagkey2.shtml
-#
-
-interface ft2232
-ft2232_device_desc "Amontec JTAGkey-2"
-ft2232_layout jtagkey
-ft2232_vid_pid 0x0403 0xCFF8
-
diff --git a/tcl/interface/jtagkey2p.cfg b/tcl/interface/jtagkey2p.cfg
deleted file mode 100644
index 98a94171..00000000
--- a/tcl/interface/jtagkey2p.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Amontec JTAGkey2P
-#
-# http://www.amontec.com/jtagkey2p.shtml
-#
-
-interface ft2232
-ft2232_device_desc "Amontec JTAGkey-2P"
-ft2232_layout jtagkey
-ft2232_vid_pid 0x0403 0xCFF8
-
diff --git a/tcl/interface/kitprog.cfg b/tcl/interface/kitprog.cfg
new file mode 100644
index 00000000..94497147
--- /dev/null
+++ b/tcl/interface/kitprog.cfg
@@ -0,0 +1,12 @@
+#
+# Cypress Semiconductor KitProg
+#
+# Note: This is the driver for the proprietary KitPtog protocol. If the
+# KitProg is in CMSIS-DAP mode, you should either use the cmsis-dap
+# interface driver or switch the KitProg to KitProg mode.
+#
+
+interface kitprog
+
+# Optionally specify the serial number of the KitProg you want to use.
+#kitprog_serial 1926402735485200
diff --git a/tcl/interface/kt-link.cfg b/tcl/interface/kt-link.cfg
deleted file mode 100644
index 93af8e44..00000000
--- a/tcl/interface/kt-link.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Kristech KT-Link
-#
-# http://www.kristech.eu
-#
-
-interface ft2232
-ft2232_device_desc "KT-LINK"
-ft2232_layout ktlink
-ft2232_vid_pid 0x0403 0xBBE2
diff --git a/tcl/interface/lisa-l.cfg b/tcl/interface/lisa-l.cfg
deleted file mode 100644
index cc7d6ccd..00000000
--- a/tcl/interface/lisa-l.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Lisa/L
-#
-# http://paparazzi.enac.fr/wiki/Lisa
-#
-
-interface ft2232
-ft2232_vid_pid 0x0403 0x6010
-ft2232_device_desc "Lisa/L"
-ft2232_layout "lisa-l"
-ft2232_latency 2
diff --git a/tcl/interface/luminary-icdi.cfg b/tcl/interface/luminary-icdi.cfg
deleted file mode 100644
index 94e00aee..00000000
--- a/tcl/interface/luminary-icdi.cfg
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# Luminary Micro Stellaris LM3S9B9x Evaluation Kits
-# In-Circuit Debug Interface (ICDI) Board
-#
-# Essentially all Luminary debug hardware is the same, (with both
-# JTAG and SWD support compatible with ICDI boards.  This ICDI adapter
-# configuration is JTAG-only, but the same hardware handles SWD too.
-#
-# This is a discrete FT2232 based debug board which supports ARM's
-# JTAG/SWD connectors in both backwards-compatible 20-pin format and
-# in the new-style compact 10-pin.  There's also an 8-pin connector
-# with serial port support.  It's included with LM3S9B9x eval boards.
-#
-# http://www.luminarymicro.com/products/ek-lm3s9b90.html
-# http://www.luminarymicro.com/products/ek-lm3s9b92.html
-#
-
-interface ft2232
-ft2232_device_desc "Luminary Micro ICDI Board"
-ft2232_layout luminary_icdi
-ft2232_vid_pid 0x0403 0xbcda
diff --git a/tcl/interface/luminary-lm3s811.cfg b/tcl/interface/luminary-lm3s811.cfg
deleted file mode 100644
index fd747c09..00000000
--- a/tcl/interface/luminary-lm3s811.cfg
+++ /dev/null
@@ -1,18 +0,0 @@
-#
-# Luminary Micro Stellaris LM3S811 Evaluation Kit
-#
-# http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
-#
-# NOTE:  this is only for boards *before* Rev C, which adds support
-# for SWO tracing with ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN signals.
-# The "evb_lm3s811" layout doesn't set up those signals.
-#
-# Rev C boards work more like the other Stellaris eval boards.  They
-# need to use the "luminary_icdi" layout to work correctly.
-#
-
-interface ft2232
-ft2232_device_desc "LM3S811 Evaluation Board"
-ft2232_layout evb_lm3s811
-ft2232_vid_pid 0x0403 0xbcd9
-
diff --git a/tcl/interface/luminary.cfg b/tcl/interface/luminary.cfg
deleted file mode 100644
index e94e5149..00000000
--- a/tcl/interface/luminary.cfg
+++ /dev/null
@@ -1,31 +0,0 @@
-#
-# Luminary Micro Stellaris Evaluation Kits
-#
-# http://www.luminarymicro.com/products/evaluation_kits.html
-#
-# There are a number of evaluation kits for Stellaris Cortex-M3 chips.
-# Currently they all bundle FT2232 based debug support.  When that is
-# used (instead of an external adapter), use this config file in one
-# of these two modes:
-#
-# - Eval board debug ... debug of the Stellaris chip via port A.
-#
-# - Other board debug ... same thing, but the board acts as a debug
-#   adapter for another board (using a standard ARM JTAG connector).
-#   The Stellaris chip stays in reset.
-#
-# Those support both JTAG and SWD.  SWD is an ARM-only two-wire debug
-# protocol; in 2009, OpenOCD does not support SWD.
-#
-# Port B of the FT2232 chip is normally used as a serial link to the
-# Stellaris chip.  On most boards (but not older LM3S811 eval boards),
-# when SWD is used Port B may instead be used to read low-bandwidth
-# "SWO trace" data, including so-called "printf style" output from
-# firmware via the ITM module as well as profile data.
-#
-
-interface ft2232
-ft2232_device_desc "Stellaris Evaluation Board"
-ft2232_layout luminary_icdi
-ft2232_vid_pid 0x0403 0xbcd9
-
diff --git a/tcl/interface/minimodule.cfg b/tcl/interface/minimodule.cfg
deleted file mode 100644
index c8f9ba10..00000000
--- a/tcl/interface/minimodule.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# FTDI MiniModule
-#
-# http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf
-#
-
-interface ft2232
-ft2232_device_desc "FT2232H MiniModule"
-ft2232_layout "minimodule"
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/neodb.cfg b/tcl/interface/neodb.cfg
deleted file mode 100644
index 8e2f5267..00000000
--- a/tcl/interface/neodb.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Openmoko USB JTAG/RS232 adapter
-#
-# http://wiki.openmoko.org/wiki/Debug_Board_v3
-#
-
-interface ft2232
-ft2232_device_desc "Debug Board for Neo1973"
-ft2232_layout jtagkey
-ft2232_vid_pid 0x1457 0x5118
diff --git a/tcl/interface/ngxtech.cfg b/tcl/interface/ngxtech.cfg
deleted file mode 100644
index 9dfe01c3..00000000
--- a/tcl/interface/ngxtech.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# NGX ARM USB JTAG
-#
-# http://shop.ngxtechnologies.com/product_info.php?cPath=26&products_id=30
-#
-
-interface ft2232
-ft2232_device_desc "NGX JTAG A"
-ft2232_vid_pid 0x0403 0x6010
-ft2232_layout "oocdlink"
diff --git a/tcl/interface/olimex-arm-usb-ocd-h.cfg b/tcl/interface/olimex-arm-usb-ocd-h.cfg
deleted file mode 100644
index 47daa928..00000000
--- a/tcl/interface/olimex-arm-usb-ocd-h.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Olimex ARM-USB-OCD-H
-#
-# http://www.olimex.com/dev/arm-usb-ocd.html
-#
-
-interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG ARM-USB-OCD-H"
-ft2232_layout olimex-jtag
-ft2232_vid_pid 0x15ba 0x002b
-
diff --git a/tcl/interface/olimex-arm-usb-ocd.cfg b/tcl/interface/olimex-arm-usb-ocd.cfg
deleted file mode 100644
index 569dcef5..00000000
--- a/tcl/interface/olimex-arm-usb-ocd.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Olimex ARM-USB-OCD
-#
-# http://www.olimex.com/dev/arm-usb-ocd.html
-#
-
-interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG"
-ft2232_layout olimex-jtag
-ft2232_vid_pid 0x15ba 0x0003
-
diff --git a/tcl/interface/olimex-arm-usb-tiny-h.cfg b/tcl/interface/olimex-arm-usb-tiny-h.cfg
deleted file mode 100644
index b6aa952f..00000000
--- a/tcl/interface/olimex-arm-usb-tiny-h.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Olimex ARM-USB-TINY-H
-#
-# http://www.olimex.com/dev/arm-usb-tiny-h.html
-#
-
-interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG ARM-USB-TINY-H"
-ft2232_layout olimex-jtag
-ft2232_vid_pid 0x15ba 0x002a
-
diff --git a/tcl/interface/olimex-jtag-tiny.cfg b/tcl/interface/olimex-jtag-tiny.cfg
deleted file mode 100644
index f28ed9da..00000000
--- a/tcl/interface/olimex-jtag-tiny.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Olimex ARM-USB-TINY
-#
-# http://www.olimex.com/dev/arm-usb-tiny.html
-#
-
-interface ft2232
-ft2232_device_desc "Olimex OpenOCD JTAG TINY"
-ft2232_layout olimex-jtag
-ft2232_vid_pid 0x15ba 0x0004
-
diff --git a/tcl/interface/oocdlink.cfg b/tcl/interface/oocdlink.cfg
deleted file mode 100644
index 4e962f52..00000000
--- a/tcl/interface/oocdlink.cfg
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# Joern Kaipf's OOCDLink
-#
-# http://www.joernonline.de/contrexx2/cms/index.php?page=126
-#
-
-interface ft2232
-ft2232_device_desc "OOCDLink"
-ft2232_layout oocdlink
-ft2232_vid_pid 0x0403 0xbaf8
-adapter_khz 5
-
diff --git a/tcl/interface/opendous_ftdi.cfg b/tcl/interface/opendous_ftdi.cfg
deleted file mode 100644
index e0e05c4a..00000000
--- a/tcl/interface/opendous_ftdi.cfg
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# Opendous
-#
-# http://code.google.com/p/opendous/wiki/JTAG
-#
-# According to the website, it is similar to jtagkey, but it uses channel B
-# (and it has a different pid number).
-#
-
-interface ft2232
-ft2232_device_desc "Dual RS232-HS"
-ft2232_layout jtagkey
-ft2232_vid_pid 0x0403 0x6010
-ft2232_channel 2
-
diff --git a/tcl/interface/openocd-usb-hs.cfg b/tcl/interface/openocd-usb-hs.cfg
deleted file mode 100644
index ddf3dce0..00000000
--- a/tcl/interface/openocd-usb-hs.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# embedded projects openocd usb adapter v3
-#
-# http://shop.embedded-projects.net/index.php?module=artikel&action=artikel&id=14
-#
-
-interface ft2232
-ft2232_vid_pid 0x0403 0x6010
-ft2232_device_desc "Dual RS232-HS"
-ft2232_layout "oocdlink"
-ft2232_latency 2
diff --git a/tcl/interface/openocd-usb.cfg b/tcl/interface/openocd-usb.cfg
deleted file mode 100644
index 4000b23f..00000000
--- a/tcl/interface/openocd-usb.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hubert Hoegl's USB to JTAG
-#
-# http://www.hs-augsburg.de/~hhoegl/proj/usbjtag/usbjtag.html
-#
-
-interface ft2232
-ft2232_vid_pid 0x0403 0x6010
-ft2232_device_desc "Dual RS232"
-ft2232_layout "oocdlink"
-ft2232_latency 2
diff --git a/tcl/interface/openrd.cfg b/tcl/interface/openrd.cfg
deleted file mode 100644
index 322b508b..00000000
--- a/tcl/interface/openrd.cfg
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# Marvell OpenRD
-#
-# http://www.marvell.com/products/embedded_processors/developer/kirkwood/openrd.jsp
-#
-
-interface ft2232
-ft2232_layout sheevaplug
-ft2232_vid_pid 0x0403 0x9e90
-ft2232_device_desc "OpenRD JTAGKey FT2232D B"
-adapter_khz 3000
-
diff --git a/tcl/interface/redbee-econotag.cfg b/tcl/interface/redbee-econotag.cfg
deleted file mode 100644
index 7e17a05c..00000000
--- a/tcl/interface/redbee-econotag.cfg
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# Redwire Redbee-Econotag
-#
-# http://www.redwirellc.com/store/node/1
-#
-# The Redbee-Econotag has an onboard FT2232H with:
-#  - FT2232H channel A wired to mc13224v JTAG
-#  - FT2232H channel B wired to mc13224v UART1
-#
-
-interface ft2232
-ft2232_layout redbee-econotag
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/redbee-usb.cfg b/tcl/interface/redbee-usb.cfg
deleted file mode 100644
index 5e7e4f7d..00000000
--- a/tcl/interface/redbee-usb.cfg
+++ /dev/null
@@ -1,13 +0,0 @@
-#
-# Redwire Redbee-USB
-#
-# http://www.redwirellc.com
-#
-# The Redbee-USB has an onboard FT2232H with:
-#  - FT2232H channel B wired to mc13224v JTAG
-#  - FT2232H channel A wired to mc13224v UART1
-#
-
-interface ft2232
-ft2232_layout redbee-usb
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/sheevaplug.cfg b/tcl/interface/sheevaplug.cfg
deleted file mode 100644
index d46d71e2..00000000
--- a/tcl/interface/sheevaplug.cfg
+++ /dev/null
@@ -1,12 +0,0 @@
-#
-# Marvel SheevaPlug Development Kit
-#
-# http://www.marvell.com/products/embedded_processors/developer/kirkwood/sheevaplug.jsp
-#
-
-interface ft2232
-ft2232_layout sheevaplug
-ft2232_vid_pid 0x9e88 0x9e8f
-ft2232_device_desc "SheevaPlug JTAGKey FT2232D B"
-adapter_khz 2000
-
diff --git a/tcl/interface/signalyzer-h2.cfg b/tcl/interface/signalyzer-h2.cfg
deleted file mode 100644
index 24288acb..00000000
--- a/tcl/interface/signalyzer-h2.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Xverve Signalyzer H2 (DT-USB-SH2)
-#
-# http://www.signalyzer.com
-#
-
-interface ft2232
-ft2232_device_desc "Signalyzer H2"
-ft2232_layout signalyzer-h
-ft2232_vid_pid 0x0403 0xbca2
-
diff --git a/tcl/interface/signalyzer-h4.cfg b/tcl/interface/signalyzer-h4.cfg
deleted file mode 100644
index d2b260b8..00000000
--- a/tcl/interface/signalyzer-h4.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Xverve Signalyzer H4 (DT-USB-SH4)
-#
-# http://www.signalyzer.com
-#
-
-interface ft2232
-ft2232_device_desc "Signalyzer H4"
-ft2232_layout signalyzer-h
-ft2232_vid_pid 0x0403 0xbca4
-
diff --git a/tcl/interface/signalyzer-lite.cfg b/tcl/interface/signalyzer-lite.cfg
deleted file mode 100644
index 834bc0c5..00000000
--- a/tcl/interface/signalyzer-lite.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Xverve Signalyzer LITE (DT-USB-SLITE)
-#
-# http://www.signalyzer.com
-#
-
-interface ft2232
-ft2232_device_desc "Signalyzer LITE"
-ft2232_layout signalyzer
-ft2232_vid_pid 0x0403 0xbca1
-
diff --git a/tcl/interface/signalyzer.cfg b/tcl/interface/signalyzer.cfg
deleted file mode 100644
index b0581c5c..00000000
--- a/tcl/interface/signalyzer.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Xverve Signalyzer Tool (DT-USB-ST)
-#
-# http://www.signalyzer.com
-#
-
-interface ft2232
-ft2232_device_desc "Signalyzer"
-ft2232_layout signalyzer
-ft2232_vid_pid 0x0403 0xbca0
-
diff --git a/tcl/interface/stm32-stick.cfg b/tcl/interface/stm32-stick.cfg
deleted file mode 100644
index 9dcf8162..00000000
--- a/tcl/interface/stm32-stick.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-#
-# Hitex STM32-PerformanceStick
-#
-# http://www.hitex.com/index.php?id=340
-#
-
-interface ft2232
-ft2232_device_desc "STM32-PerformanceStick"
-ft2232_layout stm32stick
-ft2232_vid_pid 0x0640 0x002d
-
diff --git a/tcl/interface/turtelizer2.cfg b/tcl/interface/turtelizer2.cfg
deleted file mode 100644
index c5e10c08..00000000
--- a/tcl/interface/turtelizer2.cfg
+++ /dev/null
@@ -1,15 +0,0 @@
-#
-# egnite Turtelizer 2
-#
-# http://www.ethernut.de/en/hardware/turtelizer/index.html
-#
-# Deprecated, if possible use tcl/interface/ftdi/turtelizer...
-# To run, one of following configure option needed
-#  --enable-legacy-ft2232_libftdi
-#  --enable-legacy-ft2232_ftd2xx
-
-interface ft2232
-ft2232_device_desc "Turtelizer JTAG/RS232 Adapter"
-ft2232_layout turtelizer2
-ft2232_vid_pid 0x0403 0xbdc8
-
diff --git a/tcl/interface/usb-jtag.cfg b/tcl/interface/usb-jtag.cfg
index 15274d52..cb4d29bb 100644
--- a/tcl/interface/usb-jtag.cfg
+++ b/tcl/interface/usb-jtag.cfg
@@ -27,11 +27,11 @@
 #
 # TODO: Refactor the usb_blaster driver to allow loading firmware using any low
 # level driver. Loading firmware is currently only supported on the ublast2
-# driver but ixo-usb-jtag requires the ftdi or ftd2xx driver.
+# driver but ixo-usb-jtag requires the ftdi driver.
 
 interface usb_blaster
 usb_blaster_vid_pid 0x16C0 0x06AD
 usb_blaster_device_desc "Van Ooijen Technische Informatica"
 # ixo-usb-jtag is only compatible with the ublast1 protocol implemented via the
-# ftdi or ftd2xx modes, using ublast2 will cause openocd to hang.
+# ftdi modes, using ublast2 will cause openocd to hang.
 usb_blaster_lowlevel_driver ftdi
diff --git a/tcl/interface/vpaclink.cfg b/tcl/interface/vpaclink.cfg
deleted file mode 100644
index a4795d30..00000000
--- a/tcl/interface/vpaclink.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Voipac VPACLink
-#
-# http://voipac.com/27M-JTG-000
-#
-
-interface ft2232
-ft2232_device_desc "VPACLink A"
-ft2232_layout oocdlink
-ft2232_vid_pid 0x0403 0x6010
diff --git a/tcl/interface/xds100v2.cfg b/tcl/interface/xds100v2.cfg
deleted file mode 100644
index f14f1d8d..00000000
--- a/tcl/interface/xds100v2.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Texas Instruments XDS100v2
-#
-# http://processors.wiki.ti.com/index.php/XDS100#XDS100v2_Features
-#
-
-interface ft2232
-ft2232_device_desc "Texas Instruments Inc.XDS100 Ver 2.0"
-ft2232_layout xds100v2
-ft2232_vid_pid 0x0403 0xa6d0
diff --git a/tcl/mem_helper.tcl b/tcl/mem_helper.tcl
index a3d92cb8..86ad00f7 100644
--- a/tcl/mem_helper.tcl
+++ b/tcl/mem_helper.tcl
@@ -10,6 +10,15 @@ proc mrw {reg} {
 add_usage_text mrw "address"
 add_help_text mrw "Returns value of word in memory."
 
+proc mrb {reg} {
+	set value ""
+	mem2array value 8 $reg 1
+	return $value(0)
+}
+
+add_usage_text mrb "address"
+add_help_text mrb "Returns value of byte in memory."
+
 # mmw: "memory modify word", updates value of $reg
 #       $reg <== ((value & ~$clearbits) | $setbits)
 proc mmw {reg setbits clearbits} {
diff --git a/tcl/memory.tcl b/tcl/memory.tcl
index 2719d3fe..83c96d6c 100644
--- a/tcl/memory.tcl
+++ b/tcl/memory.tcl
@@ -131,3 +131,57 @@ proc memwrite8 {ADDR DATA} {
 	error "memwrite8: $msg"
     }
 }
+
+proc memread32_phys {ADDR} {
+    set foo(0) 0
+    if ![ catch { mem2array foo 32 $ADDR 1 phys } msg ] {
+	return $foo(0)
+    } else {
+	error "memread32: $msg"
+    }
+}
+
+proc memread16_phys {ADDR} {
+    set foo(0) 0
+    if ![ catch { mem2array foo 16 $ADDR 1 phys } msg ] {
+	return $foo(0)
+    } else {
+	error "memread16: $msg"
+    }
+}
+
+proc memread8_phys {ADDR} {
+    set foo(0) 0
+    if ![ catch { mem2array foo 8 $ADDR 1 phys } msg ] {
+	return $foo(0)
+    } else {
+	error "memread8: $msg"
+    }
+}
+
+proc memwrite32_phys {ADDR DATA} {
+    set foo(0) $DATA
+    if ![ catch { array2mem foo 32 $ADDR 1 phys } msg ] {
+	return $foo(0)
+    } else {
+	error "memwrite32: $msg"
+    }
+}
+
+proc memwrite16_phys {ADDR DATA} {
+    set foo(0) $DATA
+    if ![ catch { array2mem foo 16 $ADDR 1 phys } msg ] {
+	return $foo(0)
+    } else {
+	error "memwrite16: $msg"
+    }
+}
+
+proc memwrite8_phys {ADDR DATA} {
+    set foo(0) $DATA
+    if ![ catch { array2mem foo 8 $ADDR 1 phys } msg ] {
+	return $foo(0)
+    } else {
+	error "memwrite8: $msg"
+    }
+}
diff --git a/tcl/target/adsp-sc58x.cfg b/tcl/target/adsp-sc58x.cfg
new file mode 100644
index 00000000..0a76518c
--- /dev/null
+++ b/tcl/target/adsp-sc58x.cfg
@@ -0,0 +1,44 @@
+# Analog Devices ADSP-SC58x (ARM Cortex-A5 plus one or two SHARC+ DSPs)
+
+# evaluation boards by Analog Devices (and designs derived from them) use a non-standard 10-pin 0.05" ARM Cortex Debug Connector
+# pin 9 (GND or GNDDetect) has been usurped with JTAG /TRST
+# as a result, a standards-compliant debug pod will only force the processor's debug interface into reset, preventing usage
+# so, a connector adapter must be employed on these boards to isolate or otherwise prevent /TRST from being asserted
+
+transport select swd
+source [find target/swj-dp.tcl]
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME ADSP-SC58x
+}
+
+if { [info exists ENDIAN] } {
+	set _ENDIAN $ENDIAN
+} else {
+	set _ENDIAN little
+}
+
+if { [info exists CPUTAPID] } {
+	set _CPUTAPID $CPUTAPID
+} else {
+	set _CPUTAPID 0x3BA02477
+}
+
+swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_a -endian $_ENDIAN -chain-position $_TARGETNAME
+
+$_TARGETNAME configure -event examine-end {
+   global _TARGETNAME
+   sc58x_enabledebug $_TARGETNAME
+}
+
+proc sc58x_enabledebug {target} {
+   # Enable debugging functionality by setting relevant bits in the TAPC_DBGCTL register
+   # the "phys" option is critical; the OpenOCD Cortex-A target code prevents normal mww when the target is not halted
+   # however, it is not possible to halt the target unless these register bits have been set
+   $target mww phys 0x31131000 0xFFFF
+}
diff --git a/tcl/target/altera_fpgasoc.cfg b/tcl/target/altera_fpgasoc.cfg
index fccf8c51..25fe1f49 100644
--- a/tcl/target/altera_fpgasoc.cfg
+++ b/tcl/target/altera_fpgasoc.cfg
@@ -27,7 +27,7 @@ jtag newtap $_CHIPNAME.fpga tap -irlen 10 -ircapture 0x01 -irmask 0x3 -expected-
 
 
 #
-# Cortex A9 target
+# Cortex-A9 target
 #
 
 # GDB target: Cortex-A9, using DAP, configuring only one core
@@ -59,6 +59,6 @@ $_TARGETNAME1 configure -event gdb-attach { halt }
 #$_TARGETNAME2 configure -event gdb-attach { halt }
 
 proc cycv_dbginit {target} {
-        # General Cortex A8/A9 debug initialisation
+        # General Cortex-A8/A9 debug initialisation
         cortex_a dbginit
 }
diff --git a/tcl/target/am335x.cfg b/tcl/target/am335x.cfg
index ce7cfb6d..3ca196b1 100644
--- a/tcl/target/am335x.cfg
+++ b/tcl/target/am335x.cfg
@@ -63,16 +63,48 @@ proc enable_default_taps { taps } {
 }
 
 #
-# Cortex M3 target
+# Cortex-M3 target
 #
 set _TARGETNAME_2 $_CHIPNAME.m3
 target create $_TARGETNAME_2 cortex_m -chain-position $_CHIPNAME.m3_dap
 
 #
-# Cortex A8 target
+# Cortex-A8 target
 #
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_a -chain-position $_CHIPNAME.dap -dbgbase 0x80001000
 
 # SRAM: 64K at 0x4030.0000; use the first 16K
 $_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x4000
+
+
+# when putting the target into 'reset halt', we need to disable the watchdog as
+# it would otherwise trigger while we're in JTAG
+# FIXME: unify with target/am437x.cfg
+source [find mem_helper.tcl]
+set  WDT1_BASE_ADDR                  0x44e35000
+set  WDT1_W_PEND_WSPR                [expr       $WDT1_BASE_ADDR     +  0x0034]
+set  WDT1_WSPR                       [expr       $WDT1_BASE_ADDR     +  0x0048]
+proc disable_watchdog { } {
+	global WDT1_WSPR
+	global WDT1_W_PEND_WSPR
+	global _TARGETNAME
+
+	set curstate [$_TARGETNAME curstate]
+
+	if { [string compare $curstate halted] == 0 } {
+		set WDT_DISABLE_SEQ1	0xaaaa
+		set WDT_DISABLE_SEQ2	0x5555
+
+		mww phys $WDT1_WSPR $WDT_DISABLE_SEQ1
+
+		# Empty body to make sure this executes as fast as possible.
+		# We don't want any delays here otherwise romcode might start
+		# executing and end up changing state of certain IPs.
+		while { [expr [mrw $WDT1_W_PEND_WSPR] & 0x10] } { }
+
+		mww phys $WDT1_WSPR $WDT_DISABLE_SEQ2
+		while { [expr [mrw $WDT1_W_PEND_WSPR] & 0x10] } { }
+	}
+}
+$_TARGETNAME configure -event reset-end { disable_watchdog }
diff --git a/tcl/target/am437x.cfg b/tcl/target/am437x.cfg
index 507d51e2..fe0ffff2 100644
--- a/tcl/target/am437x.cfg
+++ b/tcl/target/am437x.cfg
@@ -484,7 +484,7 @@ jtag configure $JRC_NAME -event setup "jtag tapenable $DEBUGSS_NAME"
 jtag configure $JRC_NAME -event post-reset "runtest 100"
 
 #
-# Cortex A9 target
+# Cortex-A9 target
 #
 target create $_TARGETNAME cortex_a -chain-position $DEBUGSS_NAME -coreid 0 -dbgbase 0x80000000
 
@@ -993,11 +993,7 @@ proc config_ddr3 { SDRAM_CONFIG } {
 proc init_platform { SDRAM_CONFIG } {
 	config_opp100
 	config_ddr3 $SDRAM_CONFIG
-
-	# now that PLLs are configured, we can run JTAG at full speed
-	adapter_khz 16000
 }
 
-$_TARGETNAME configure -event reset-start { adapter_khz 1000 }
 $_TARGETNAME configure -event reset-init { init_platform 0x61a013b2 }
 $_TARGETNAME configure -event reset-end { disable_watchdog }
diff --git a/tcl/target/amdm37x.cfg b/tcl/target/amdm37x.cfg
index 59fbbf01..c00dae92 100644
--- a/tcl/target/amdm37x.cfg
+++ b/tcl/target/amdm37x.cfg
@@ -199,7 +199,7 @@ $_TARGETNAME configure -event gdb-attach {
 # Run this to enable invasive debugging.  This is run automatically in the
 # reset sequence.
 proc amdm37x_dbginit {target} {
-   # General Cortex A8 debug initialisation
+   # General Cortex-A8 debug initialisation
    cortex_a dbginit
 
    # Enable DBGEN signal.  This signal is described in the ARM v7 TRM, but
diff --git a/tcl/target/at91sam3XXX.cfg b/tcl/target/at91sam3XXX.cfg
index 6af1f5cc..fca655d2 100644
--- a/tcl/target/at91sam3XXX.cfg
+++ b/tcl/target/at91sam3XXX.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam3, a CORTEX-M3 chip
+# script for ATMEL sam3, a Cortex-M3 chip
 #
 # at91sam3u4e
 # at91sam3u2e
diff --git a/tcl/target/at91sam3ax_xx.cfg b/tcl/target/at91sam3ax_xx.cfg
index 8e6bc337..e5617712 100644
--- a/tcl/target/at91sam3ax_xx.cfg
+++ b/tcl/target/at91sam3ax_xx.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam3, a CORTEX-M3 chip
+# script for ATMEL sam3, a Cortex-M3 chip
 #
 # at91sam3A4C
 # at91sam3A8C
diff --git a/tcl/target/at91sam3sXX.cfg b/tcl/target/at91sam3sXX.cfg
index ca7092b7..09146bd0 100644
--- a/tcl/target/at91sam3sXX.cfg
+++ b/tcl/target/at91sam3sXX.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam3, a CORTEX-M3 chip
+# script for ATMEL sam3, a Cortex-M3 chip
 #
 # at91sam3s4c
 # at91sam3s4b
diff --git a/tcl/target/at91sam3uxx.cfg b/tcl/target/at91sam3uxx.cfg
index a11afc0b..b42ae19c 100644
--- a/tcl/target/at91sam3uxx.cfg
+++ b/tcl/target/at91sam3uxx.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam3, a CORTEX-M3 chip
+# script for ATMEL sam3, a Cortex-M3 chip
 #
 # at91sam3u4e
 # at91sam3u2e
diff --git a/tcl/target/at91sam4XXX.cfg b/tcl/target/at91sam4XXX.cfg
index 8f32ca0b..ca801431 100644
--- a/tcl/target/at91sam4XXX.cfg
+++ b/tcl/target/at91sam4XXX.cfg
@@ -1,5 +1,5 @@
 #
-# script for ATMEL sam4, a CORTEX-M4 chip
+# script for ATMEL sam4, a Cortex-M4 chip
 #
 
 #
diff --git a/tcl/target/at91sam4c32x.cfg b/tcl/target/at91sam4c32x.cfg
new file mode 100644
index 00000000..5344e0c5
--- /dev/null
+++ b/tcl/target/at91sam4c32x.cfg
@@ -0,0 +1,9 @@
+# script for ATMEL sam4c32, a Cortex-M4 chip
+#
+
+source [find target/at91sam4XXX.cfg]
+
+set _FLASHNAME $_CHIPNAME.flash0
+flash bank $_FLASHNAME at91sam4 0x01000000 0 1 1 $_TARGETNAME
+set _FLASHNAME $_CHIPNAME.flash1
+flash bank $_FLASHNAME at91sam4 0x01100000 0 1 1 $_TARGETNAME
diff --git a/tcl/target/at91sam4cXXX.cfg b/tcl/target/at91sam4cXXX.cfg
new file mode 100644
index 00000000..3f10c61d
--- /dev/null
+++ b/tcl/target/at91sam4cXXX.cfg
@@ -0,0 +1,7 @@
+# script for ATMEL sam4c, a Cortex-M4 chip
+#
+
+source [find target/at91sam4XXX.cfg]
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME at91sam4 0x01000000 0 1 1 $_TARGETNAME
diff --git a/tcl/target/at91sam4lXX.cfg b/tcl/target/at91sam4lXX.cfg
index 46c38aef..4aee7d08 100644
--- a/tcl/target/at91sam4lXX.cfg
+++ b/tcl/target/at91sam4lXX.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam4l, a CORTEX-M4 chip
+# script for ATMEL sam4l, a Cortex-M4 chip
 #
 
 source [find target/at91sam4XXX.cfg]
diff --git a/tcl/target/at91sam4sXX.cfg b/tcl/target/at91sam4sXX.cfg
index 3de4aa85..8883e23c 100644
--- a/tcl/target/at91sam4sXX.cfg
+++ b/tcl/target/at91sam4sXX.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam4, a CORTEX-M4 chip
+# script for ATMEL sam4, a Cortex-M4 chip
 #
 
 source [find target/at91sam4XXX.cfg]
diff --git a/tcl/target/at91sam4sd32x.cfg b/tcl/target/at91sam4sd32x.cfg
index e44db66e..077b1f51 100644
--- a/tcl/target/at91sam4sd32x.cfg
+++ b/tcl/target/at91sam4sd32x.cfg
@@ -1,4 +1,4 @@
-# script for ATMEL sam4sd32, a CORTEX-M4 chip
+# script for ATMEL sam4sd32, a Cortex-M4 chip
 #
 
 source [find target/at91sam4XXX.cfg]
diff --git a/tcl/target/at91samdXX.cfg b/tcl/target/at91samdXX.cfg
index 50d93f59..93a95c8e 100644
--- a/tcl/target/at91samdXX.cfg
+++ b/tcl/target/at91samdXX.cfg
@@ -1,5 +1,5 @@
 #
-# script for Atmel SAMD, SAMR, SAML or SAMC, a CORTEX-M0 chip
+# script for Atmel SAMD, SAMR, SAML or SAMC, a Cortex-M0 chip
 #
 
 #
@@ -53,11 +53,6 @@ $_TARGETNAME configure -event reset-deassert-post {
 # srst_pulls_trst is not configured here to avoid an error raised in reset halt
 reset_config srst_gates_jtag
 
-# Atmel's EDBG (on-board cmsis-dap adapter of Xplained kits) cannot
-# stop the MCU before it starts executing code if hardware RESETN
-# line is configured by command "reset_config srst_only"
-# Use "reset_config none" (default) before flash programming.
-
 # Do not use a reset button with other SWD adapter than Atmel's EDBG.
 # DSU usually locks MCU in reset state until you issue a reset command
 # in OpenOCD.
diff --git a/tcl/target/at91samg5x.cfg b/tcl/target/at91samg5x.cfg
index d26455b0..57274c0c 100644
--- a/tcl/target/at91samg5x.cfg
+++ b/tcl/target/at91samg5x.cfg
@@ -1,4 +1,4 @@
-# script for the ATMEL samg5x CORTEX-M4F chip family
+# script for the ATMEL samg5x Cortex-M4F chip family
 #
 
 source [find target/at91sam4XXX.cfg]
diff --git a/tcl/target/atheros_ar9344.cfg b/tcl/target/atheros_ar9344.cfg
new file mode 100644
index 00000000..b698f250
--- /dev/null
+++ b/tcl/target/atheros_ar9344.cfg
@@ -0,0 +1,39 @@
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $_CHIPNAME
+} else {
+	set _CHIPNAME ar9344
+}
+
+if { [info exists CPUTAPID] } {
+	set _CPUTAPID $CPUTAPID
+} else {
+	set _CPUTAPID 0x00000001
+}
+
+jtag newtap $_CHIPNAME cpu -irlen 5 -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME mips_m4k -endian big -chain-position $_TARGETNAME
+
+proc test_ar9344_uart0_tx {} {
+	echo "configuring uart0.."
+	mww 0xb802000c 0x87
+	mww 0xb8020000 0x15
+	mww 0xb8020004 0
+	mww 0xb802000c 7
+	mww 0xb8020004 0
+
+	echo "send message: hallo world"
+	mww 0xb8020000 0x68
+	mww 0xb8020000 0x65
+	mww 0xb8020000 0x6c
+	mww 0xb8020000 0x6c
+	mww 0xb8020000 0x6f
+	mww 0xb8020000 0x20
+	mww 0xb8020000 0x77
+	mww 0xb8020000 0x6f
+	mww 0xb8020000 0x72
+	mww 0xb8020000 0x6c
+	mww 0xb8020000 0x64
+	mww 0xb8020000 0x0a
+}
diff --git a/tcl/target/atmega128rfa1.cfg b/tcl/target/atmega128rfa1.cfg
new file mode 100644
index 00000000..2c12a610
--- /dev/null
+++ b/tcl/target/atmega128rfa1.cfg
@@ -0,0 +1,22 @@
+set _CHIPNAME avr
+set _ENDIAN little
+
+# jtag speed
+adapter_khz 4500
+
+# avr jtag docs never connect RSTN
+reset_config none
+
+#jtag scan chain
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x0a70103f
+}
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME avr -endian $_ENDIAN -chain-position $_TARGETNAME
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME avr 0 0 0 0 $_TARGETNAME
diff --git a/tcl/target/bcm281xx.cfg b/tcl/target/bcm281xx.cfg
index c05682f8..224af793 100644
--- a/tcl/target/bcm281xx.cfg
+++ b/tcl/target/bcm281xx.cfg
@@ -17,7 +17,7 @@ if { [info exists DAP_TAPID] } {
 jtag newtap $_CHIPNAME dap -expected-id $_DAP_TAPID -irlen 4
 
 
-# Dual Cortex A9s
+# Dual Cortex-A9
 set _TARGETNAME0 $_CHIPNAME.cpu0
 set _TARGETNAME1 $_CHIPNAME.cpu1
 
diff --git a/tcl/target/cc26xx.cfg b/tcl/target/cc26xx.cfg
index 0fa46003..1492e6a2 100755
--- a/tcl/target/cc26xx.cfg
+++ b/tcl/target/cc26xx.cfg
@@ -37,7 +37,7 @@ jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.dap"
 jtag configure $_CHIPNAME.jrc -event post-reset "ti_cjtag_to_4pin_jtag $_CHIPNAME.jrc"
 
 #
-# Cortex M3 target
+# Cortex-M3 target
 #
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m -chain-position $_CHIPNAME.dap
diff --git a/tcl/target/cc32xx.cfg b/tcl/target/cc32xx.cfg
index ff654502..154bf910 100755
--- a/tcl/target/cc32xx.cfg
+++ b/tcl/target/cc32xx.cfg
@@ -47,7 +47,7 @@ if {[using_jtag]} {
 }
 
 #
-# Cortex M3 target
+# Cortex-M3 target
 #
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m -chain-position $_CHIPNAME.dap
diff --git a/tcl/target/fm3.cfg b/tcl/target/fm3.cfg
index e2d78d1e..78bbc945 100644
--- a/tcl/target/fm3.cfg
+++ b/tcl/target/fm3.cfg
@@ -27,7 +27,7 @@ if {[using_jtag]} {
    jtag_ntrst_delay 100
 }
 
-# Fujitsu cortex-M3 reset configuration
+# Fujitsu Cortex-M3 reset configuration
 reset_config trst_only
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
diff --git a/tcl/target/fm4_mb9bf.cfg b/tcl/target/fm4_mb9bf.cfg
index 12a6aee7..e53fdc87 100644
--- a/tcl/target/fm4_mb9bf.cfg
+++ b/tcl/target/fm4_mb9bf.cfg
@@ -13,3 +13,6 @@ if { [info exists WORKAREASIZE] } {
 
 $_TARGETNAME configure -work-area-phys [expr 0x20000000 - $_WORKAREASIZE] \
                        -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME fm4 0x00000000 0 0 0 $_TARGETNAME $CHIPSERIES
diff --git a/tcl/target/fm4_s6e2cc.cfg b/tcl/target/fm4_s6e2cc.cfg
index 18cc630b..60b73b97 100644
--- a/tcl/target/fm4_s6e2cc.cfg
+++ b/tcl/target/fm4_s6e2cc.cfg
@@ -13,3 +13,7 @@ if { [info exists WORKAREASIZE] } {
 
 $_TARGETNAME configure -work-area-phys [expr 0x20000000 - $_WORKAREASIZE] \
                        -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank ${_FLASHNAME}0 fm4 0x00000000 0 0 0 $_TARGETNAME $CHIPSERIES
+flash bank ${_FLASHNAME}1 fm4 0x00100000 0 0 0 $_TARGETNAME $CHIPSERIES
diff --git a/tcl/target/hi3798.cfg b/tcl/target/hi3798.cfg
new file mode 100644
index 00000000..9eda1503
--- /dev/null
+++ b/tcl/target/hi3798.cfg
@@ -0,0 +1,49 @@
+# Hisilicon Hi3798 Target
+
+if { [info exists CHIPNAME] } {
+  set _CHIPNAME $CHIPNAME
+} else {
+  set _CHIPNAME hi3798
+}
+
+#
+# Main DAP
+#
+if { [info exists DAP_TAPID] } {
+   set _DAP_TAPID $DAP_TAPID
+} else {
+   set _DAP_TAPID 0x5ba00477
+}
+
+# declare the one JTAG tap to access the DAP
+jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -ignore-version -enable
+
+# declare the 4 main application cores
+set _TARGETNAME $_CHIPNAME.cpu
+set _smp_command ""
+
+set $_TARGETNAME.cti(0) 0x80020000
+set $_TARGETNAME.cti(1) 0x80120000
+set $_TARGETNAME.cti(2) 0x80220000
+set $_TARGETNAME.cti(3) 0x80320000
+
+set _cores 4
+for { set _core 0 } { $_core < $_cores } { incr _core 1 } {
+
+    set _command "target create ${_TARGETNAME}$_core aarch64 \
+                         -chain-position $_CHIPNAME.dap -coreid $_core -ctibase [set $_TARGETNAME.cti($_core)]"
+
+    if { $_core != 0 } {
+        # non-boot core examination may fail
+        #set _command "$_command -defer-examine"
+        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
+    } else {
+        # uncomment when "hawt" rtos is merged
+        # set _command "$_command -rtos hawt"
+        set _smp_command "target smp ${_TARGETNAME}$_core"
+    }
+
+    eval $_command
+}
+
+eval $_smp_command
diff --git a/tcl/target/hi6220.cfg b/tcl/target/hi6220.cfg
new file mode 100644
index 00000000..7daa3c11
--- /dev/null
+++ b/tcl/target/hi6220.cfg
@@ -0,0 +1,56 @@
+# Hisilicon Hi6220 Target
+
+if { [info exists CHIPNAME] } {
+  set _CHIPNAME $CHIPNAME
+} else {
+  set _CHIPNAME hi6220
+}
+
+#
+# Main DAP
+#
+if { [info exists DAP_TAPID] } {
+   set _DAP_TAPID $DAP_TAPID
+} else {
+   set _DAP_TAPID 0x4ba00477
+}
+
+# declare the one JTAG tap to access the DAP
+jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_DAP_TAPID -ignore-version -enable
+
+# declare the 8 main application cores
+set _TARGETNAME $_CHIPNAME.cpu
+set _smp_command ""
+
+set $_TARGETNAME.cti(0) 0x80198000
+set $_TARGETNAME.cti(1) 0x80199000
+set $_TARGETNAME.cti(2) 0x8019A000
+set $_TARGETNAME.cti(3) 0x8019B000
+set $_TARGETNAME.cti(4) 0x801D8000
+set $_TARGETNAME.cti(5) 0x801D9000
+set $_TARGETNAME.cti(6) 0x801DA000
+set $_TARGETNAME.cti(7) 0x801DB000
+
+set _cores 8
+for { set _core 0 } { $_core < $_cores } { incr _core 1 } {
+
+    set _command "target create ${_TARGETNAME}$_core aarch64 \
+                         -chain-position $_CHIPNAME.dap -coreid $_core -ctibase [set $_TARGETNAME.cti($_core)]"
+
+    if { $_core != 0 } {
+        # non-boot core examination may fail
+        set _command "$_command -defer-examine"
+        set _smp_command "$_smp_command ${_TARGETNAME}$_core"
+    } else {
+        # uncomment when "hawt" rtos is merged
+        # set _command "$_command -rtos hawt"
+        set _smp_command "target smp ${_TARGETNAME}$_core"
+    }
+
+    eval $_command
+}
+
+eval $_smp_command
+
+# declare the auxiliary Cortex-M3 core on AP #2 (runs mcuimage.bin)
+target create ${_TARGETNAME}.m3 cortex_m -chain-position $_CHIPNAME.dap -ap-num 2 -defer-examine
diff --git a/tcl/target/imx51.cfg b/tcl/target/imx51.cfg
index 15d5c048..d10cf9f5 100644
--- a/tcl/target/imx51.cfg
+++ b/tcl/target/imx51.cfg
@@ -36,11 +36,8 @@ target create $_TARGETNAME cortex_a -chain-position $_CHIPNAME.DAP
 # some TCK tycles are required to activate the DEBUG power domain
 jtag configure $_CHIPNAME.SJC -event post-reset "runtest 100"
 
-# have the DAP "always" be active
-jtag configure $_CHIPNAME.SJC -event setup "jtag tapenable $_CHIPNAME.DAP"
-
 proc imx51_dbginit {target} {
-     # General Cortex A8 debug initialisation
+     # General Cortex-A8 debug initialisation
      cortex_a dbginit
 }
 
diff --git a/tcl/target/imx53.cfg b/tcl/target/imx53.cfg
index e77bc340..5ad6473a 100644
--- a/tcl/target/imx53.cfg
+++ b/tcl/target/imx53.cfg
@@ -36,11 +36,8 @@ target create $_TARGETNAME cortex_a -chain-position $_CHIPNAME.DAP
 # some TCK tycles are required to activate the DEBUG power domain
 jtag configure $_CHIPNAME.SJC -event post-reset "runtest 100"
 
-# have the DAP "always" be active
-jtag configure $_CHIPNAME.SJC -event setup "jtag tapenable $_CHIPNAME.DAP"
-
 proc imx53_dbginit {target} {
-     # General Cortex A8 debug initialisation
+     # General Cortex-A8 debug initialisation
      cortex_a dbginit
 }
 
diff --git a/tcl/target/imx6.cfg b/tcl/target/imx6.cfg
index 11c2134c..4f7e98af 100644
--- a/tcl/target/imx6.cfg
+++ b/tcl/target/imx6.cfg
@@ -47,7 +47,7 @@ target create $_TARGETNAME cortex_a -chain-position $_CHIPNAME.dap \
 jtag configure $_CHIPNAME.sjc -event post-reset "runtest 100"
 
 proc imx6_dbginit {target} {
-        # General Cortex A8/A9 debug initialisation
+        # General Cortex-A8/A9 debug initialisation
         cortex_a dbginit
 }
 
diff --git a/tcl/target/k1921vk01t.cfg b/tcl/target/k1921vk01t.cfg
index 131bdadc..61b193e3 100755
--- a/tcl/target/k1921vk01t.cfg
+++ b/tcl/target/k1921vk01t.cfg
@@ -24,7 +24,7 @@ if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
 } else {
    if { [using_jtag] } {
-      set _CPUTAPID 0x410fc241
+      set _CPUTAPID 0x4ba00477
    } {
       # SWD IDCODE
       set _CPUTAPID 0x2ba01477
diff --git a/tcl/target/ke0x.cfg b/tcl/target/ke0x.cfg
new file mode 100644
index 00000000..7927e0ae
--- /dev/null
+++ b/tcl/target/ke0x.cfg
@@ -0,0 +1,54 @@
+#
+# Freescale Kinetis KE0x series devices
+#
+
+source [find target/swj-dp.tcl]
+
+if { [info exists CHIPNAME] } {
+    set _CHIPNAME $CHIPNAME
+} else {
+    set _CHIPNAME ke
+}
+
+# Work-area is a space in RAM used for flash programming
+# By default use 1kB
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x400
+}
+
+if { [info exists CPUTAPID] } {
+    set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x0bc11477
+}
+
+swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -chain-position $_CHIPNAME.cpu
+
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME kinetis_ke 0 0 0 0 $_TARGETNAME
+
+adapter_khz 1000
+
+reset_config srst_nogate
+
+if {![using_hla]} {
+
+   # It is important that "kinetis_ke mdm check_security" is called for
+   # 'examine-end' event and not 'eximine-start'. Calling it in 'examine-start'
+   # causes "kinetis_ke mdm check_security" to fail the first time openocd
+   # calls it when it tries to connect after the CPU has been power-cycled.
+   $_CHIPNAME.cpu configure -event examine-end {
+      kinetis_ke mdm check_security
+   }
+
+   # if srst is not fitted use SYSRESETREQ to
+   # perform a soft reset
+   cortex_m reset_config sysresetreq
+}
diff --git a/tcl/target/ke1xf.cfg b/tcl/target/ke1xf.cfg
new file mode 100644
index 00000000..b1200cec
--- /dev/null
+++ b/tcl/target/ke1xf.cfg
@@ -0,0 +1,7 @@
+#
+# NXP (Freescale) Kinetis KE1xF devices
+#
+
+set CHIPNAME ke
+
+source [find target/kx.cfg]
diff --git a/tcl/target/ke1xz.cfg b/tcl/target/ke1xz.cfg
new file mode 100644
index 00000000..6a3f509e
--- /dev/null
+++ b/tcl/target/ke1xz.cfg
@@ -0,0 +1,7 @@
+#
+# NXP (Freescale) Kinetis KE1xZ devices
+#
+
+set CHIPNAME ke
+
+source [find target/klx.cfg]
diff --git a/tcl/target/klx.cfg b/tcl/target/klx.cfg
index d2d2c284..7dd0404f 100644
--- a/tcl/target/klx.cfg
+++ b/tcl/target/klx.cfg
@@ -1,5 +1,6 @@
 #
-# Freescale Kinetis KL series devices
+# NXP (former Freescale) Kinetis KL series devices
+# Also used for Cortex-M0+ equipped members of KVx and KE1xZ series
 #
 
 source [find target/swj-dp.tcl]
@@ -29,34 +30,33 @@ swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m -chain-position $_CHIPNAME.cpu
 
-# It is important that "kinetis mdm check_security" is called for
-# 'examine-end' event and not 'eximine-start'. Calling it in 'examine-start'
-# causes "kinetis mdm check_security" to fail the first time openocd
-# calls it when it tries to connect after the CPU has been power-cycled.
-$_CHIPNAME.cpu configure -event examine-end {
-	kinetis mdm check_security
-}
-
 $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.pflash
 flash bank $_FLASHNAME kinetis 0 0 0 0 $_TARGETNAME
+kinetis create_banks
 
 # Table 5-1. Clock Summary of KL25 Sub-Family Reference Manual
-# specifies up to 1MHz for VLPR mode.
+# specifies up to 1MHz for VLPR mode and up to 24MHz for run mode;
+# Table 17 of Sub-Family Data Sheet rev4 lists 25MHz as the maximum frequency.
 adapter_khz 1000
 
 reset_config srst_nogate
 
 if {![using_hla]} {
+   # Detect secured MCU or boot lock-up in RESET/WDOG loop
+   $_CHIPNAME.cpu configure -event examine-start {
+      kinetis mdm check_security
+   }
+
    # if srst is not fitted use SYSRESETREQ to
    # perform a soft reset
    cortex_m reset_config sysresetreq
 }
 
+# Disable watchdog not to disturb OpenOCD algorithms running on MCU
+# (e.g. armv7m_checksum_memory() in verify_image)
+# Flash driver also disables watchdog before FTFA flash programming.
 $_TARGETNAME configure -event reset-init {
-    # Table 5-1. Clock Summary of KL25 Sub-Family Reference Manual
-    # specifies up to 24MHz for run mode; Table 17 of Sub-Family Data
-    # Sheet rev4 lists 25MHz as the maximum frequency.
-    adapter_khz 24000
+   kinetis disable_wdog
 }
diff --git a/tcl/target/kx.cfg b/tcl/target/kx.cfg
index ad76ac66..d3219ca6 100644
--- a/tcl/target/kx.cfg
+++ b/tcl/target/kx.cfg
@@ -1,5 +1,6 @@
 #
-# Freescale Kinetis Kx series devices
+# NXP (former Freescale) Kinetis Kx series devices
+# Also used for Cortex-M4 equipped members of KVx and KE1xF series
 #
 
 source [find target/swj-dp.tcl]
@@ -33,25 +34,30 @@ swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPU
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m -chain-position $_CHIPNAME.cpu
 
-# It is important that "kinetis mdm check_security" is called for
-# 'examine-end' event and not 'eximine-start'. Calling it in 'examine-start'
-# causes "kinetis mdm check_security" to fail the first time openocd
-# calls it when it tries to connect after the CPU has been power-cycled.
-$_CHIPNAME.cpu configure -event examine-end {
-	kinetis mdm check_security
-}
-
 $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.pflash
 flash bank $_FLASHNAME kinetis 0 0 0 0 $_TARGETNAME
+kinetis create_banks
 
 adapter_khz 1000
 
 reset_config srst_nogate
 
 if {![using_hla]} {
+   # Detect secured MCU or boot lock-up in RESET/WDOG loop
+   $_CHIPNAME.cpu configure -event examine-start {
+      kinetis mdm check_security
+   }
+
    # if srst is not fitted use SYSRESETREQ to
    # perform a soft reset
    cortex_m reset_config sysresetreq
 }
+
+# Disable watchdog not to disturb OpenOCD algorithms running on MCU
+# (e.g. armv7m_checksum_memory() in verify_image)
+# Flash driver also disables watchdog before FTFA flash programming.
+$_TARGETNAME configure -event reset-init {
+   kinetis disable_wdog
+}
diff --git a/tcl/target/lpc1xxx.cfg b/tcl/target/lpc1xxx.cfg
index 226425d4..9c10e9f9 100644
--- a/tcl/target/lpc1xxx.cfg
+++ b/tcl/target/lpc1xxx.cfg
@@ -56,7 +56,7 @@ if { [info exists CPUTAPID] } {
 	# Allow user override
 	set _CPUTAPID $CPUTAPID
 } else {
-	# LPC8xx/LPC11xx/LPC12xx use a Cortex M0/M0+ core, LPC13xx/LPC17xx use a Cortex M3 core,LPC40xx use a Cortex-M4F core.
+	# LPC8xx/LPC11xx/LPC12xx use a Cortex-M0/M0+ core, LPC13xx/LPC17xx use a Cortex-M3 core, LPC40xx use a Cortex-M4F core.
 	if { $_CHIPSERIES == "lpc800" || $_CHIPSERIES == "lpc1100" || $_CHIPSERIES == "lpc1200" } {
 		set _CPUTAPID 0x0bb11477
 	} elseif { $_CHIPSERIES == "lpc1300" || $_CHIPSERIES == "lpc1700" || $_CHIPSERIES == "lpc4000" } {
@@ -148,10 +148,10 @@ if {[using_jtag]} {
  jtag_ntrst_delay 200
 }
 
-# LPC8xx (Cortex M0+ core) support SYSRESETREQ
-# LPC11xx/LPC12xx (Cortex M0 core) support SYSRESETREQ
-# LPC13xx/LPC17xx (Cortex M3 core) support SYSRESETREQ
-# LPC40xx (Cortex M4F core) support SYSRESETREQ
+# LPC8xx (Cortex-M0+ core) support SYSRESETREQ
+# LPC11xx/LPC12xx (Cortex-M0 core) support SYSRESETREQ
+# LPC13xx/LPC17xx (Cortex-M3 core) support SYSRESETREQ
+# LPC40xx (Cortex-M4F core) support SYSRESETREQ
 if {![using_hla]} {
     # if srst is not fitted use SYSRESETREQ to
     # perform a soft reset
diff --git a/tcl/target/nrf51.cfg b/tcl/target/nrf51.cfg
index 07681206..280dd4ff 100644
--- a/tcl/target/nrf51.cfg
+++ b/tcl/target/nrf51.cfg
@@ -1,5 +1,5 @@
 #
-# script for Nordic nRF51 series, a CORTEX-M0 chip
+# script for Nordic nRF51 series, a Cortex-M0 chip
 #
 
 source [find target/swj-dp.tcl]
diff --git a/tcl/target/nrf52.cfg b/tcl/target/nrf52.cfg
index c1cbf1a2..e7301750 100644
--- a/tcl/target/nrf52.cfg
+++ b/tcl/target/nrf52.cfg
@@ -10,6 +10,14 @@ if { [info exists CHIPNAME] } {
 	set _CHIPNAME nrf52
 }
 
+# Work-area is a space in RAM used for flash programming
+# By default use 16kB
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x4000
+}
+
 if { [info exists CPUTAPID] } {
 	set _CPUTAPID $CPUTAPID
 } else {
@@ -21,8 +29,13 @@ swj_newdap $_CHIPNAME cpu -expected-id $_CPUTAPID
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m -chain-position $_TARGETNAME
 
-adapter_khz 10000
+adapter_khz 1000
+
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
 if { ![using_hla] } {
 	cortex_m reset_config sysresetreq
 }
+
+flash bank $_CHIPNAME.flash nrf5 0x00000000 0 1 1 $_TARGETNAME
+flash bank $_CHIPNAME.uicr nrf5 0x10001000 0 1 1 $_TARGETNAME
diff --git a/tcl/target/omap3530.cfg b/tcl/target/omap3530.cfg
index f9dcf7cb..c2929d1c 100644
--- a/tcl/target/omap3530.cfg
+++ b/tcl/target/omap3530.cfg
@@ -53,7 +53,7 @@ jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"
 jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.dap"
 
 proc omap3_dbginit {target} {
-     # General Cortex A8 debug initialisation
+     # General Cortex-A8 debug initialisation
      cortex_a dbginit
      # Enable DBGU signal for OMAP353x
      $target mww phys 0x5401d030 0x00002000
diff --git a/tcl/target/psoc4.cfg b/tcl/target/psoc4.cfg
index 2416dbe9..d443b014 100644
--- a/tcl/target/psoc4.cfg
+++ b/tcl/target/psoc4.cfg
@@ -127,7 +127,7 @@ proc ocd_process_reset_inner { MODE } {
 		set pc [ocd_reg pc]
 		regsub {pc[^:]*: } $pc "" pc
 		if { $pc < 0x10000000 || $pc > 0x1000ffff } {
-			return -code error [format "TARGET: %s - Not halted is system ROM" $t]
+			return -code error [format "TARGET: %s - Not halted in system ROM, use 'reset_config none'" $t]
 		}
 
 		# Set registers to reset vector values
diff --git a/tcl/target/psoc5lp.cfg b/tcl/target/psoc5lp.cfg
new file mode 100644
index 00000000..1cdde471
--- /dev/null
+++ b/tcl/target/psoc5lp.cfg
@@ -0,0 +1,32 @@
+#
+# Cypress PSoC 5LP
+#
+
+source [find target/swj-dp.tcl]
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME psoc5lp
+}
+
+if { [info exists CPUTAPID] } {
+	set _CPU_TAPID $CPUTAPID
+} else {
+	set _CPU_TAPID 0x4BA00477
+}
+
+if { [using_jtag] } {
+	set _CPU_DAP_ID $_CPU_TAPID
+} else {
+	set _CPU_DAP_ID 0x2ba01477
+}
+
+swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_DAP_ID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -chain-position $_TARGETNAME
+
+if {![using_hla]} {
+	cortex_m reset_config sysresetreq
+}
diff --git a/tcl/target/quark_d20xx.cfg b/tcl/target/quark_d20xx.cfg
new file mode 100644
index 00000000..419f9dc4
--- /dev/null
+++ b/tcl/target/quark_d20xx.cfg
@@ -0,0 +1,50 @@
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x38289013
+}
+
+jtag newtap quark_d20xx quark -irlen 8 -irmask 0xff -expected-id $_CPUTAPID -disable
+jtag newtap quark_d20xx cltap -irlen 8 -irmask 0xff -expected-id 0x0e786013 -enable
+
+proc quark_d20xx_tapenable {} {
+	echo "enabling quark core tap"
+	irscan quark_d20xx.cltap 0x11
+	drscan quark_d20xx.cltap 12 1
+	runtest 10
+}
+
+proc quark_d20xx_tapdisable {} {
+	echo "disabling quark core tap"
+	irscan quark_d20xx.cltap 0x11
+	drscan quark_d20xx.cltap 12 0
+	runtest 10
+}
+
+proc quark_d20xx_setup {} {
+	jtag tapenable quark_d20xx.quark
+}
+
+jtag configure quark_d20xx.quark -event tap-enable \
+   "quark_d20xx_tapenable"
+
+jtag configure quark_d20xx.quark -event tap-disable \
+   "quark_d20xx_tapdisable"
+
+target create quark_d20xx.quark quark_d20xx -endian little -chain-position quark_d20xx.quark
+
+quark_d20xx.quark configure -event gdb-attach { halt }
+
+quark_d20xx.quark configure -event reset-start {
+	# need to halt the target to write to memory
+	if {[quark_d20xx.quark curstate] ne "halted"} { halt }
+	# set resetbreak via the core tap
+	irscan quark_d20xx.quark 0x35 ; drscan quark_d20xx.quark 1 0x1
+	# trigger a warm reset
+	mww 0xb0800570 0x2
+	# clear resetbreak
+	irscan quark_d20xx.quark 0x35 ; drscan quark_d20xx.quark 1 0x0
+}
+
+jtag configure quark_d20xx.quark -event setup \
+   "quark_d20xx_setup"
diff --git a/tcl/target/stm32f1x.cfg b/tcl/target/stm32f1x.cfg
index bd02e95b..5a4c2fa7 100644
--- a/tcl/target/stm32f1x.cfg
+++ b/tcl/target/stm32f1x.cfg
@@ -37,37 +37,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   # FIXME this never gets used to override defaults...
-   set _BSTAPID $BSTAPID
-} else {
-  # See STM Document RM0008
-  # Section 29.6.2
-  # Low density devices, Rev A
-  set _BSTAPID1 0x06412041
-  # Medium density devices, Rev A
-  set _BSTAPID2 0x06410041
-  # Medium density devices, Rev B and Rev Z
-  set _BSTAPID3 0x16410041
-  set _BSTAPID4 0x06420041
-  # High density devices, Rev A
-  set _BSTAPID5 0x06414041
-  # Connectivity line devices, Rev A and Rev Z
-  set _BSTAPID6 0x06418041
-  # XL line devices, Rev A
-  set _BSTAPID7 0x06430041
-  # VL line devices, Rev A and Z In medium-density and high-density value line devices
-  set _BSTAPID8 0x06420041
-  # VL line devices, Rev A
-  set _BSTAPID9 0x06428041
-}
-
 if {[using_jtag]} {
- swj_newdap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1 \
-	-expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
-	-expected-id $_BSTAPID4 -expected-id $_BSTAPID5 \
-	-expected-id $_BSTAPID6 -expected-id $_BSTAPID7 \
-	-expected-id $_BSTAPID8 -expected-id $_BSTAPID9
+   jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/stm32f2x.cfg b/tcl/target/stm32f2x.cfg
index 0e734deb..44955d45 100644
--- a/tcl/target/stm32f2x.cfg
+++ b/tcl/target/stm32f2x.cfg
@@ -50,17 +50,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   set _BSTAPID $BSTAPID
-} else {
-  # See STM Document RM0033
-  # Section 32.6.2
-  # 
-  set _BSTAPID 0x06411041
-}
-
 if {[using_jtag]} {
- swj_newdap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID
+	jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/stm32f3x.cfg b/tcl/target/stm32f3x.cfg
index f3ea40ba..0c8919f1 100644
--- a/tcl/target/stm32f3x.cfg
+++ b/tcl/target/stm32f3x.cfg
@@ -50,27 +50,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   set _BSTAPID $BSTAPID
-} else {
-  # STM Document RM0316 rev 5 for STM32F302/303 B/C size
-  set _BSTAPID1 0x06422041
-  # STM Document RM0313 rev 3 for STM32F37x
-  set _BSTAPID2 0x06432041
-  #  STM Document RM364 rev 1 for STM32F334
-  set _BSTAPID3 0x06438041
-  #  STM Document RM316 rev 5 for STM32F303 6/8 size
-  #  STM Document RM365 rev 3 for STM32F302 6/8 size
-  #  STM Document RM366 rev 2 for STM32F301 6/8 size
-  set _BSTAPID4 0x06439041
-  #  STM Document RM016 rev 5 for STM32F303 D/E size
-  set _BSTAPID5 0x06446041
-}
-
 if {[using_jtag]} {
- swj_newdap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1 \
- -expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
- -expected-id $_BSTAPID4 -expected-id $_BSTAPID5
+   jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/stm32f4x.cfg b/tcl/target/stm32f4x.cfg
index c7f6ee81..7a0af9fb 100644
--- a/tcl/target/stm32f4x.cfg
+++ b/tcl/target/stm32f4x.cfg
@@ -15,11 +15,11 @@ if { [info exists CHIPNAME] } {
 set _ENDIAN little
 
 # Work-area is a space in RAM used for flash programming
-# By default use 64kB
+# By default use 32kB (Available RAM in smallest device STM32F410)
 if { [info exists WORKAREASIZE] } {
    set _WORKAREASIZE $WORKAREASIZE
 } else {
-   set _WORKAREASIZE 0x10000
+   set _WORKAREASIZE 0x8000
 }
 
 #jtag scan chain
@@ -37,29 +37,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   set _BSTAPID $BSTAPID
-} else {
-  # See STM Document RM0090
-  # Section 38.6.2
-  # STM32F405xx/07xx and STM32F415xx/17xx
-  set _BSTAPID1 0x06413041
-  # STM32F42xxx and STM32F43xxx
-  set _BSTAPID2 0x06419041
-  # See STM Document RM0368 (Rev. 3)
-  # STM32F401B/C
-  set _BSTAPID3 0x06423041
-  # STM32F401D/E
-  set _BSTAPID4 0x06433041
-  # See STM Document RM0383 (Rev 2)
-  # STM32F411
-  set _BSTAPID5 0x06431041
-}
-
 if {[using_jtag]} {
- swj_newdap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1 \
-     -expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
-     -expected-id $_BSTAPID4 -expected-id $_BSTAPID5
+   jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
@@ -120,3 +99,8 @@ $_TARGETNAME configure -event reset-init {
 	# Boost JTAG frequency
 	adapter_khz 8000
 }
+
+$_TARGETNAME configure -event reset-start {
+	# Reduce speed since CPU speed will slow down to 16MHz with the reset
+	adapter_khz 2000
+}
diff --git a/tcl/target/stm32f7x.cfg b/tcl/target/stm32f7x.cfg
index 16624670..4065e2a0 100755
--- a/tcl/target/stm32f7x.cfg
+++ b/tcl/target/stm32f7x.cfg
@@ -37,17 +37,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   set _BSTAPID $BSTAPID
-} else {
-  # See STM Document RM0385
-  # Section 40.6.1
-  # STM32F75xxG
-  set _BSTAPID1 0x06449071
-}
-
 if {[using_jtag]} {
- swj_newdap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1
+   jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/stm32l0.cfg b/tcl/target/stm32l0.cfg
index fd8f951b..245213b4 100644
--- a/tcl/target/stm32l0.cfg
+++ b/tcl/target/stm32l0.cfg
@@ -4,6 +4,7 @@
 #
 
 source [find target/swj-dp.tcl]
+source [find mem_helper.tcl]
 
 if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
@@ -75,3 +76,12 @@ $_TARGETNAME configure -event reset-init {
 $_TARGETNAME configure -event reset-start {
 	adapter_khz 300
 }
+
+$_TARGETNAME configure -event examine-end {
+	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
+	mmw 0x40015804 0x00000007 0
+
+	# Stop watchdog counters during halt
+	# DBGMCU_APB1_FZ |= DBG_IWDG_STOP | DBG_WWDG_STOP
+	mmw 0x40015808 0x00001800 0
+}
diff --git a/tcl/target/stm32l0_dual_bank.cfg b/tcl/target/stm32l0_dual_bank.cfg
new file mode 100644
index 00000000..f9f1a4e7
--- /dev/null
+++ b/tcl/target/stm32l0_dual_bank.cfg
@@ -0,0 +1,5 @@
+source [find target/stm32l0.cfg]
+
+# Add the second flash bank.
+set _FLASHNAME $_CHIPNAME.flash1
+flash bank $_FLASHNAME stm32lx 0 0 0 0 $_TARGETNAME
diff --git a/tcl/target/stm32l1.cfg b/tcl/target/stm32l1.cfg
index 790c495b..a8d6fdf2 100644
--- a/tcl/target/stm32l1.cfg
+++ b/tcl/target/stm32l1.cfg
@@ -46,28 +46,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   # FIXME this never gets used to override defaults...
-   set _BSTAPID $BSTAPID
-} else {
-   # See STM Document RM0038 Section 30.6.1 Rev. 12
-
-   # Low and medium density
-   set _BSTAPID1 0x06416041
-   # Cat.2 device (medium+ density)
-   set _BSTAPID2 0x06429041
-   # Cat.3 device (medium+ density)
-   set _BSTAPID3 0x06427041
-   # Cat.4 device, STM32L15/6xxD or Cat.3 device, some STM32L15/6xxC-A models
-   set _BSTAPID4 0x06436041
-   # Cat.5 device (high density), STM32L15/6xxE
-   set _BSTAPID5 0x06437041
-}
-
 if {[using_jtag]} {
-   swj_newdap $_CHIPNAME bs -irlen 5 \
-   -expected-id $_BSTAPID1 -expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
-   -expected-id $_BSTAPID4 -expected-id $_BSTAPID5
+   jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/stm32l4x.cfg b/tcl/target/stm32l4x.cfg
index 8b827adc..ccee48e9 100644
--- a/tcl/target/stm32l4x.cfg
+++ b/tcl/target/stm32l4x.cfg
@@ -37,17 +37,8 @@ if { [info exists CPUTAPID] } {
 
 swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-if { [info exists BSTAPID] } {
-   set _BSTAPID $BSTAPID
-} else {
-  # See STM Document RM0351
-  # Section 44.6.3
-  # STM32L4X6
-  set _BSTAPID1 0x06415041
-}
-
 if {[using_jtag]} {
- swj_newdap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1
+   jtag newtap $_CHIPNAME bs -irlen 5
 }
 
 set _TARGETNAME $_CHIPNAME.cpu
@@ -58,12 +49,12 @@ $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME stm32l4x 0 0 0 0 $_TARGETNAME
 
-# JTAG speed should be <= F_CPU/6. F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz
+# Common knowledges tells JTAG speed should be <= F_CPU/6.
+# F_CPU after reset is MSI 4MHz, so use F_JTAG = 500 kHz to stay on
+# the safe side.
 #
-# Since we may be running of an RC oscilator, we crank down the speed a
-# bit more to be on the safe side. Perhaps superstition, but if are
-# running off a crystal, we can run closer to the limit. Note
-# that there can be a pretty wide band where things are more or less stable.
+# Note that there is a pretty wide band where things are
+# more or less stable, see http://openocd.zylin.com/#/c/3366/
 adapter_khz 500
 
 adapter_nsrst_delay 100
@@ -81,14 +72,19 @@ if {![using_hla]} {
 
 $_TARGETNAME configure -event reset-init {
 	# CPU comes out of reset with MSI_ON | MSI_RDY | MSI Range 6 (4 MHz).
-	# Configure system to use MSI 24 MHz clock, compliant with VOS default (2).
-	# 3 WS compliant with VOS=2 and 24 MHz.
-	mww 0x40022000 0x00000102   ;# FLASH_ACR = PRFTBE | 3(Latency)
-	mww 0x4002100C 0x00000099   ;# RCC_CR = MSI_ON | MSIRGSEL| MSI Range 10
+	# Use MSI 24 MHz clock, compliant even with VOS == 2.
+	# 3 WS compliant with VOS == 2 and 24 MHz.
+	mww 0x40022000 0x00000103   ;# FLASH_ACR = PRFTBE | 3(Latency)
+	mww 0x40021000 0x00000099   ;# RCC_CR = MSI_ON | MSIRGSEL | MSI Range 9
 	# Boost JTAG frequency
 	adapter_khz 4000
 }
 
+$_TARGETNAME configure -event reset-start {
+	# Reset clock is MSI (4 MHz)
+	adapter_khz 500
+}
+
 $_TARGETNAME configure -event examine-end {
 	# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
 	mmw 0xE0042004 0x00000007 0
diff --git a/tcl/target/stm32w108xx.cfg b/tcl/target/stm32w108xx.cfg
index 1a191354..d07afc41 100644
--- a/tcl/target/stm32w108xx.cfg
+++ b/tcl/target/stm32w108xx.cfg
@@ -1,7 +1,7 @@
 #
 # Target configuration for the ST STM32W108xx chips
 #
-# Processor: ARM Cortex M3
+# Processor: ARM Cortex-M3
 # Date:      2013-06-09
 # Author:    Giuseppe Barba <giuseppe.barba@gmail.com>
 
diff --git a/tcl/target/ti_msp432p4xx.cfg b/tcl/target/ti_msp432p4xx.cfg
new file mode 100644
index 00000000..86008670
--- /dev/null
+++ b/tcl/target/ti_msp432p4xx.cfg
@@ -0,0 +1,52 @@
+#
+# Texas Instruments MSP432P4xx - ARM Cortex-M4F @ up to 48 MHz
+#
+# http://www.ti.com/MSP432
+#
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME msp432p4xx
+}
+
+if { [info exists CPUTAPID] } {
+	set _DAP_TAPID $CPUTAPID
+} else {
+	set _DAP_TAPID 0x4ba00477
+}
+
+if { [info exists DAP_SWD_ID] } {
+	set _DAP_SWD_ID $DAP_SWD_ID
+} else {
+	set _DAP_SWD_ID 0x2ba01477
+}
+
+source [find target/swj-dp.tcl]
+
+if { [using_jtag] } {
+	set _DAP_ID $_DAP_TAPID
+} else {
+	set _DAP_ID $_DAP_SWD_ID
+}
+
+swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_ID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -chain-position $_TARGETNAME
+
+if { [info exists WORKAREASIZE] } {
+	set _WORKAREASIZE $WORKAREASIZE
+} else {
+	# On MSP432P401x Bank0 (8k) is always powered
+	set _WORKAREASIZE 0x2000
+}
+
+$_TARGETNAME configure -work-area-phys 0x20000000 \
+                       -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+if { ![using_hla] } {
+	cortex_m reset_config sysresetreq
+}
+
+adapter_khz 500
diff --git a/tcl/target/ti_tms570.cfg b/tcl/target/ti_tms570.cfg
index 582a4bfa..21da6c01 100644
--- a/tcl/target/ti_tms570.cfg
+++ b/tcl/target/ti_tms570.cfg
@@ -53,7 +53,7 @@ jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
 jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.dap"
 jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"
 
-# Cortex R4 target
+# Cortex-R4 target
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_r4 -endian $_ENDIAN \
 	-chain-position $_CHIPNAME.dap -coreid 0 -dbgbase 0x00001003
diff --git a/tcl/target/xmc1xxx.cfg b/tcl/target/xmc1xxx.cfg
index 0a0e47ee..d3123c43 100644
--- a/tcl/target/xmc1xxx.cfg
+++ b/tcl/target/xmc1xxx.cfg
@@ -24,4 +24,17 @@ swj_newdap $_CHIPNAME cpu -irlen 4 -expected-id $_CPU_SWD_TAPID
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m -endian little -chain-position $_TARGETNAME
 
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x4000
+}
+
+$_TARGETNAME configure -work-area-phys 0x20000000 \
+                       -work-area-size $_WORKAREASIZE \
+                       -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME xmc1xxx 0x10000000 0 0 0 $_TARGETNAME
+
 adapter_khz 1000
diff --git a/tcl/target/zynq_7000.cfg b/tcl/target/zynq_7000.cfg
index b11de328..70a86162 100644
--- a/tcl/target/zynq_7000.cfg
+++ b/tcl/target/zynq_7000.cfg
@@ -10,7 +10,8 @@ set _TARGETNAME $_CHIPNAME.cpu
 jtag newtap zynq_pl bs -irlen 6 -ircapture 0x1 -irmask 0x03 \
     -expected-id 0x23727093 \
     -expected-id 0x13722093 \
-    -expected-id 0x03727093
+    -expected-id 0x03727093 \
+    -expected-id 0x03736093
 
 jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id 0x4ba00477
 
diff --git a/tcl/tools/firmware-recovery.tcl b/tcl/tools/firmware-recovery.tcl
index 6e23540f..8e017ce5 100644
--- a/tcl/tools/firmware-recovery.tcl
+++ b/tcl/tools/firmware-recovery.tcl
@@ -4,6 +4,7 @@ echo "Use -c firmware_help to get help\n"
 set known_boards {
     "asus-rt-n16		ASUS RT-N16"
     "asus-rt-n66u		ASUS RT-N66U"
+    "linksys-wag200g		Linksys WAG200G"
     "linksys-wrt54gl		Linksys WRT54GL v1.1"
     "netgear-dg834v3		Netgear DG834G v3"
     "tp-link_tl-mr3020		TP-LINK TL-MR3020"
diff --git a/tools/scripts/checkpatch.pl b/tools/scripts/checkpatch.pl
index 4eb50c3c..b977d361 100755
--- a/tools/scripts/checkpatch.pl
+++ b/tools/scripts/checkpatch.pl
@@ -2224,8 +2224,8 @@ sub process {
 
 # function brace can't be on same line, except for #defines of do while,
 # or if closed on same line
-		if (($line=~/$Type\s*$Ident\(.*\).*\s{/) and
-		    !($line=~/\#\s*define.*do\s{/) and !($line=~/}/)) {
+		if (($line=~/$Type\s*$Ident\(.*\).*\s\{/) and
+		    !($line=~/\#\s*define.*do\s\{/) and !($line=~/}/)) {
 			ERROR("OPEN_BRACE",
 			      "open brace '{' following function declarations go on the next line\n" . $herecurr);
 		}
@@ -2493,8 +2493,8 @@ sub process {
 ## 		}
 
 #need space before brace following if, while, etc
-		if (($line =~ /\(.*\){/ && $line !~ /\($Type\){/) ||
-		    $line =~ /do{/) {
+		if (($line =~ /\(.*\)\{/ && $line !~ /\($Type\){/) ||
+		    $line =~ /do\{/) {
 			ERROR("SPACING",
 			      "space required before the open brace '{'\n" . $herecurr);
 		}
-- 
2.14.2

